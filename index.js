var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __require = (id) => {
  return import.meta.require(id);
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);

// node_modules/node-cmd/cmd.js
var require_cmd = __commonJS((exports, module) => {
  var runCommand = function(command, callback) {
    return exec(command, function() {
      return function(err, data, stderr) {
        if (!callback)
          return;
        callback(err, data, stderr);
      };
    }(callback));
  };
  var runSync = function(command) {
    try {
      return {
        data: execSync(command).toString(),
        err: null,
        stderr: null
      };
    } catch (error) {
      return {
        data: null,
        err: error.stderr.toString(),
        stderr: error.stderr.toString()
      };
    }
  };
  var { exec, execSync } = __require("child_process");
  var commandline = {
    run: runCommand,
    runSync
  };
  module.exports = commandline;
});

// node_modules/webidl-conversions/lib/index.js
var require_lib = __commonJS((exports, module) => {
  var sign = function(x) {
    return x < 0 ? -1 : 1;
  };
  var evenRound = function(x) {
    if (x % 1 === 0.5 && (x & 1) === 0) {
      return Math.floor(x);
    } else {
      return Math.round(x);
    }
  };
  var createNumberConversion = function(bitLength, typeOpts) {
    if (!typeOpts.unsigned) {
      --bitLength;
    }
    const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
    const upperBound = Math.pow(2, bitLength) - 1;
    const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
    const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
    return function(V, opts) {
      if (!opts)
        opts = {};
      let x = +V;
      if (opts.enforceRange) {
        if (!Number.isFinite(x)) {
          throw new TypeError("Argument is not a finite number");
        }
        x = sign(x) * Math.floor(Math.abs(x));
        if (x < lowerBound || x > upperBound) {
          throw new TypeError("Argument is not in byte range");
        }
        return x;
      }
      if (!isNaN(x) && opts.clamp) {
        x = evenRound(x);
        if (x < lowerBound)
          x = lowerBound;
        if (x > upperBound)
          x = upperBound;
        return x;
      }
      if (!Number.isFinite(x) || x === 0) {
        return 0;
      }
      x = sign(x) * Math.floor(Math.abs(x));
      x = x % moduloVal;
      if (!typeOpts.unsigned && x >= moduloBound) {
        return x - moduloVal;
      } else if (typeOpts.unsigned) {
        if (x < 0) {
          x += moduloVal;
        } else if (x === -0) {
          return 0;
        }
      }
      return x;
    };
  };
  var conversions = {};
  module.exports = conversions;
  conversions["void"] = function() {
    return;
  };
  conversions["boolean"] = function(val) {
    return !!val;
  };
  conversions["byte"] = createNumberConversion(8, { unsigned: false });
  conversions["octet"] = createNumberConversion(8, { unsigned: true });
  conversions["short"] = createNumberConversion(16, { unsigned: false });
  conversions["unsigned short"] = createNumberConversion(16, { unsigned: true });
  conversions["long"] = createNumberConversion(32, { unsigned: false });
  conversions["unsigned long"] = createNumberConversion(32, { unsigned: true });
  conversions["long long"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });
  conversions["unsigned long long"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });
  conversions["double"] = function(V) {
    const x = +V;
    if (!Number.isFinite(x)) {
      throw new TypeError("Argument is not a finite floating-point value");
    }
    return x;
  };
  conversions["unrestricted double"] = function(V) {
    const x = +V;
    if (isNaN(x)) {
      throw new TypeError("Argument is NaN");
    }
    return x;
  };
  conversions["float"] = conversions["double"];
  conversions["unrestricted float"] = conversions["unrestricted double"];
  conversions["DOMString"] = function(V, opts) {
    if (!opts)
      opts = {};
    if (opts.treatNullAsEmptyString && V === null) {
      return "";
    }
    return String(V);
  };
  conversions["ByteString"] = function(V, opts) {
    const x = String(V);
    let c = undefined;
    for (let i = 0;(c = x.codePointAt(i)) !== undefined; ++i) {
      if (c > 255) {
        throw new TypeError("Argument is not a valid bytestring");
      }
    }
    return x;
  };
  conversions["USVString"] = function(V) {
    const S = String(V);
    const n = S.length;
    const U = [];
    for (let i = 0;i < n; ++i) {
      const c = S.charCodeAt(i);
      if (c < 55296 || c > 57343) {
        U.push(String.fromCodePoint(c));
      } else if (56320 <= c && c <= 57343) {
        U.push(String.fromCodePoint(65533));
      } else {
        if (i === n - 1) {
          U.push(String.fromCodePoint(65533));
        } else {
          const d = S.charCodeAt(i + 1);
          if (56320 <= d && d <= 57343) {
            const a = c & 1023;
            const b = d & 1023;
            U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
            ++i;
          } else {
            U.push(String.fromCodePoint(65533));
          }
        }
      }
    }
    return U.join("");
  };
  conversions["Date"] = function(V, opts) {
    if (!(V instanceof Date)) {
      throw new TypeError("Argument is not a Date object");
    }
    if (isNaN(V)) {
      return;
    }
    return V;
  };
  conversions["RegExp"] = function(V, opts) {
    if (!(V instanceof RegExp)) {
      V = new RegExp(V);
    }
    return V;
  };
});

// node_modules/whatwg-url/lib/utils.js
var require_utils = __commonJS((exports, module) => {
  exports.mixin = function mixin(target, source) {
    const keys = Object.getOwnPropertyNames(source);
    for (let i = 0;i < keys.length; ++i) {
      Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));
    }
  };
  exports.wrapperSymbol = Symbol("wrapper");
  exports.implSymbol = Symbol("impl");
  exports.wrapperForImpl = function(impl) {
    return impl[exports.wrapperSymbol];
  };
  exports.implForWrapper = function(wrapper) {
    return wrapper[exports.implSymbol];
  };
});

// node_modules/tr46/lib/mappingTable.json
var require_mappingTable = __commonJS((exports, module) => {
  module.exports = [[[0, 44], "disallowed_STD3_valid"], [[45, 46], "valid"], [[47, 47], "disallowed_STD3_valid"], [[48, 57], "valid"], [[58, 64], "disallowed_STD3_valid"], [[65, 65], "mapped", [97]], [[66, 66], "mapped", [98]], [[67, 67], "mapped", [99]], [[68, 68], "mapped", [100]], [[69, 69], "mapped", [101]], [[70, 70], "mapped", [102]], [[71, 71], "mapped", [103]], [[72, 72], "mapped", [104]], [[73, 73], "mapped", [105]], [[74, 74], "mapped", [106]], [[75, 75], "mapped", [107]], [[76, 76], "mapped", [108]], [[77, 77], "mapped", [109]], [[78, 78], "mapped", [110]], [[79, 79], "mapped", [111]], [[80, 80], "mapped", [112]], [[81, 81], "mapped", [113]], [[82, 82], "mapped", [114]], [[83, 83], "mapped", [115]], [[84, 84], "mapped", [116]], [[85, 85], "mapped", [117]], [[86, 86], "mapped", [118]], [[87, 87], "mapped", [119]], [[88, 88], "mapped", [120]], [[89, 89], "mapped", [121]], [[90, 90], "mapped", [122]], [[91, 96], "disallowed_STD3_valid"], [[97, 122], "valid"], [[123, 127], "disallowed_STD3_valid"], [[128, 159], "disallowed"], [[160, 160], "disallowed_STD3_mapped", [32]], [[161, 167], "valid", [], "NV8"], [[168, 168], "disallowed_STD3_mapped", [32, 776]], [[169, 169], "valid", [], "NV8"], [[170, 170], "mapped", [97]], [[171, 172], "valid", [], "NV8"], [[173, 173], "ignored"], [[174, 174], "valid", [], "NV8"], [[175, 175], "disallowed_STD3_mapped", [32, 772]], [[176, 177], "valid", [], "NV8"], [[178, 178], "mapped", [50]], [[179, 179], "mapped", [51]], [[180, 180], "disallowed_STD3_mapped", [32, 769]], [[181, 181], "mapped", [956]], [[182, 182], "valid", [], "NV8"], [[183, 183], "valid"], [[184, 184], "disallowed_STD3_mapped", [32, 807]], [[185, 185], "mapped", [49]], [[186, 186], "mapped", [111]], [[187, 187], "valid", [], "NV8"], [[188, 188], "mapped", [49, 8260, 52]], [[189, 189], "mapped", [49, 8260, 50]], [[190, 190], "mapped", [51, 8260, 52]], [[191, 191], "valid", [], "NV8"], [[192, 192], "mapped", [224]], [[193, 193], "mapped", [225]], [[194, 194], "mapped", [226]], [[195, 195], "mapped", [227]], [[196, 196], "mapped", [228]], [[197, 197], "mapped", [229]], [[198, 198], "mapped", [230]], [[199, 199], "mapped", [231]], [[200, 200], "mapped", [232]], [[201, 201], "mapped", [233]], [[202, 202], "mapped", [234]], [[203, 203], "mapped", [235]], [[204, 204], "mapped", [236]], [[205, 205], "mapped", [237]], [[206, 206], "mapped", [238]], [[207, 207], "mapped", [239]], [[208, 208], "mapped", [240]], [[209, 209], "mapped", [241]], [[210, 210], "mapped", [242]], [[211, 211], "mapped", [243]], [[212, 212], "mapped", [244]], [[213, 213], "mapped", [245]], [[214, 214], "mapped", [246]], [[215, 215], "valid", [], "NV8"], [[216, 216], "mapped", [248]], [[217, 217], "mapped", [249]], [[218, 218], "mapped", [250]], [[219, 219], "mapped", [251]], [[220, 220], "mapped", [252]], [[221, 221], "mapped", [253]], [[222, 222], "mapped", [254]], [[223, 223], "deviation", [115, 115]], [[224, 246], "valid"], [[247, 247], "valid", [], "NV8"], [[248, 255], "valid"], [[256, 256], "mapped", [257]], [[257, 257], "valid"], [[258, 258], "mapped", [259]], [[259, 259], "valid"], [[260, 260], "mapped", [261]], [[261, 261], "valid"], [[262, 262], "mapped", [263]], [[263, 263], "valid"], [[264, 264], "mapped", [265]], [[265, 265], "valid"], [[266, 266], "mapped", [267]], [[267, 267], "valid"], [[268, 268], "mapped", [269]], [[269, 269], "valid"], [[270, 270], "mapped", [271]], [[271, 271], "valid"], [[272, 272], "mapped", [273]], [[273, 273], "valid"], [[274, 274], "mapped", [275]], [[275, 275], "valid"], [[276, 276], "mapped", [277]], [[277, 277], "valid"], [[278, 278], "mapped", [279]], [[279, 279], "valid"], [[280, 280], "mapped", [281]], [[281, 281], "valid"], [[282, 282], "mapped", [283]], [[283, 283], "valid"], [[284, 284], "mapped", [285]], [[285, 285], "valid"], [[286, 286], "mapped", [287]], [[287, 287], "valid"], [[288, 288], "mapped", [289]], [[289, 289], "valid"], [[290, 290], "mapped", [291]], [[291, 291], "valid"], [[292, 292], "mapped", [293]], [[293, 293], "valid"], [[294, 294], "mapped", [295]], [[295, 295], "valid"], [[296, 296], "mapped", [297]], [[297, 297], "valid"], [[298, 298], "mapped", [299]], [[299, 299], "valid"], [[300, 300], "mapped", [301]], [[301, 301], "valid"], [[302, 302], "mapped", [303]], [[303, 303], "valid"], [[304, 304], "mapped", [105, 775]], [[305, 305], "valid"], [[306, 307], "mapped", [105, 106]], [[308, 308], "mapped", [309]], [[309, 309], "valid"], [[310, 310], "mapped", [311]], [[311, 312], "valid"], [[313, 313], "mapped", [314]], [[314, 314], "valid"], [[315, 315], "mapped", [316]], [[316, 316], "valid"], [[317, 317], "mapped", [318]], [[318, 318], "valid"], [[319, 320], "mapped", [108, 183]], [[321, 321], "mapped", [322]], [[322, 322], "valid"], [[323, 323], "mapped", [324]], [[324, 324], "valid"], [[325, 325], "mapped", [326]], [[326, 326], "valid"], [[327, 327], "mapped", [328]], [[328, 328], "valid"], [[329, 329], "mapped", [700, 110]], [[330, 330], "mapped", [331]], [[331, 331], "valid"], [[332, 332], "mapped", [333]], [[333, 333], "valid"], [[334, 334], "mapped", [335]], [[335, 335], "valid"], [[336, 336], "mapped", [337]], [[337, 337], "valid"], [[338, 338], "mapped", [339]], [[339, 339], "valid"], [[340, 340], "mapped", [341]], [[341, 341], "valid"], [[342, 342], "mapped", [343]], [[343, 343], "valid"], [[344, 344], "mapped", [345]], [[345, 345], "valid"], [[346, 346], "mapped", [347]], [[347, 347], "valid"], [[348, 348], "mapped", [349]], [[349, 349], "valid"], [[350, 350], "mapped", [351]], [[351, 351], "valid"], [[352, 352], "mapped", [353]], [[353, 353], "valid"], [[354, 354], "mapped", [355]], [[355, 355], "valid"], [[356, 356], "mapped", [357]], [[357, 357], "valid"], [[358, 358], "mapped", [359]], [[359, 359], "valid"], [[360, 360], "mapped", [361]], [[361, 361], "valid"], [[362, 362], "mapped", [363]], [[363, 363], "valid"], [[364, 364], "mapped", [365]], [[365, 365], "valid"], [[366, 366], "mapped", [367]], [[367, 367], "valid"], [[368, 368], "mapped", [369]], [[369, 369], "valid"], [[370, 370], "mapped", [371]], [[371, 371], "valid"], [[372, 372], "mapped", [373]], [[373, 373], "valid"], [[374, 374], "mapped", [375]], [[375, 375], "valid"], [[376, 376], "mapped", [255]], [[377, 377], "mapped", [378]], [[378, 378], "valid"], [[379, 379], "mapped", [380]], [[380, 380], "valid"], [[381, 381], "mapped", [382]], [[382, 382], "valid"], [[383, 383], "mapped", [115]], [[384, 384], "valid"], [[385, 385], "mapped", [595]], [[386, 386], "mapped", [387]], [[387, 387], "valid"], [[388, 388], "mapped", [389]], [[389, 389], "valid"], [[390, 390], "mapped", [596]], [[391, 391], "mapped", [392]], [[392, 392], "valid"], [[393, 393], "mapped", [598]], [[394, 394], "mapped", [599]], [[395, 395], "mapped", [396]], [[396, 397], "valid"], [[398, 398], "mapped", [477]], [[399, 399], "mapped", [601]], [[400, 400], "mapped", [603]], [[401, 401], "mapped", [402]], [[402, 402], "valid"], [[403, 403], "mapped", [608]], [[404, 404], "mapped", [611]], [[405, 405], "valid"], [[406, 406], "mapped", [617]], [[407, 407], "mapped", [616]], [[408, 408], "mapped", [409]], [[409, 411], "valid"], [[412, 412], "mapped", [623]], [[413, 413], "mapped", [626]], [[414, 414], "valid"], [[415, 415], "mapped", [629]], [[416, 416], "mapped", [417]], [[417, 417], "valid"], [[418, 418], "mapped", [419]], [[419, 419], "valid"], [[420, 420], "mapped", [421]], [[421, 421], "valid"], [[422, 422], "mapped", [640]], [[423, 423], "mapped", [424]], [[424, 424], "valid"], [[425, 425], "mapped", [643]], [[426, 427], "valid"], [[428, 428], "mapped", [429]], [[429, 429], "valid"], [[430, 430], "mapped", [648]], [[431, 431], "mapped", [432]], [[432, 432], "valid"], [[433, 433], "mapped", [650]], [[434, 434], "mapped", [651]], [[435, 435], "mapped", [436]], [[436, 436], "valid"], [[437, 437], "mapped", [438]], [[438, 438], "valid"], [[439, 439], "mapped", [658]], [[440, 440], "mapped", [441]], [[441, 443], "valid"], [[444, 444], "mapped", [445]], [[445, 451], "valid"], [[452, 454], "mapped", [100, 382]], [[455, 457], "mapped", [108, 106]], [[458, 460], "mapped", [110, 106]], [[461, 461], "mapped", [462]], [[462, 462], "valid"], [[463, 463], "mapped", [464]], [[464, 464], "valid"], [[465, 465], "mapped", [466]], [[466, 466], "valid"], [[467, 467], "mapped", [468]], [[468, 468], "valid"], [[469, 469], "mapped", [470]], [[470, 470], "valid"], [[471, 471], "mapped", [472]], [[472, 472], "valid"], [[473, 473], "mapped", [474]], [[474, 474], "valid"], [[475, 475], "mapped", [476]], [[476, 477], "valid"], [[478, 478], "mapped", [479]], [[479, 479], "valid"], [[480, 480], "mapped", [481]], [[481, 481], "valid"], [[482, 482], "mapped", [483]], [[483, 483], "valid"], [[484, 484], "mapped", [485]], [[485, 485], "valid"], [[486, 486], "mapped", [487]], [[487, 487], "valid"], [[488, 488], "mapped", [489]], [[489, 489], "valid"], [[490, 490], "mapped", [491]], [[491, 491], "valid"], [[492, 492], "mapped", [493]], [[493, 493], "valid"], [[494, 494], "mapped", [495]], [[495, 496], "valid"], [[497, 499], "mapped", [100, 122]], [[500, 500], "mapped", [501]], [[501, 501], "valid"], [[502, 502], "mapped", [405]], [[503, 503], "mapped", [447]], [[504, 504], "mapped", [505]], [[505, 505], "valid"], [[506, 506], "mapped", [507]], [[507, 507], "valid"], [[508, 508], "mapped", [509]], [[509, 509], "valid"], [[510, 510], "mapped", [511]], [[511, 511], "valid"], [[512, 512], "mapped", [513]], [[513, 513], "valid"], [[514, 514], "mapped", [515]], [[515, 515], "valid"], [[516, 516], "mapped", [517]], [[517, 517], "valid"], [[518, 518], "mapped", [519]], [[519, 519], "valid"], [[520, 520], "mapped", [521]], [[521, 521], "valid"], [[522, 522], "mapped", [523]], [[523, 523], "valid"], [[524, 524], "mapped", [525]], [[525, 525], "valid"], [[526, 526], "mapped", [527]], [[527, 527], "valid"], [[528, 528], "mapped", [529]], [[529, 529], "valid"], [[530, 530], "mapped", [531]], [[531, 531], "valid"], [[532, 532], "mapped", [533]], [[533, 533], "valid"], [[534, 534], "mapped", [535]], [[535, 535], "valid"], [[536, 536], "mapped", [537]], [[537, 537], "valid"], [[538, 538], "mapped", [539]], [[539, 539], "valid"], [[540, 540], "mapped", [541]], [[541, 541], "valid"], [[542, 542], "mapped", [543]], [[543, 543], "valid"], [[544, 544], "mapped", [414]], [[545, 545], "valid"], [[546, 546], "mapped", [547]], [[547, 547], "valid"], [[548, 548], "mapped", [549]], [[549, 549], "valid"], [[550, 550], "mapped", [551]], [[551, 551], "valid"], [[552, 552], "mapped", [553]], [[553, 553], "valid"], [[554, 554], "mapped", [555]], [[555, 555], "valid"], [[556, 556], "mapped", [557]], [[557, 557], "valid"], [[558, 558], "mapped", [559]], [[559, 559], "valid"], [[560, 560], "mapped", [561]], [[561, 561], "valid"], [[562, 562], "mapped", [563]], [[563, 563], "valid"], [[564, 566], "valid"], [[567, 569], "valid"], [[570, 570], "mapped", [11365]], [[571, 571], "mapped", [572]], [[572, 572], "valid"], [[573, 573], "mapped", [410]], [[574, 574], "mapped", [11366]], [[575, 576], "valid"], [[577, 577], "mapped", [578]], [[578, 578], "valid"], [[579, 579], "mapped", [384]], [[580, 580], "mapped", [649]], [[581, 581], "mapped", [652]], [[582, 582], "mapped", [583]], [[583, 583], "valid"], [[584, 584], "mapped", [585]], [[585, 585], "valid"], [[586, 586], "mapped", [587]], [[587, 587], "valid"], [[588, 588], "mapped", [589]], [[589, 589], "valid"], [[590, 590], "mapped", [591]], [[591, 591], "valid"], [[592, 680], "valid"], [[681, 685], "valid"], [[686, 687], "valid"], [[688, 688], "mapped", [104]], [[689, 689], "mapped", [614]], [[690, 690], "mapped", [106]], [[691, 691], "mapped", [114]], [[692, 692], "mapped", [633]], [[693, 693], "mapped", [635]], [[694, 694], "mapped", [641]], [[695, 695], "mapped", [119]], [[696, 696], "mapped", [121]], [[697, 705], "valid"], [[706, 709], "valid", [], "NV8"], [[710, 721], "valid"], [[722, 727], "valid", [], "NV8"], [[728, 728], "disallowed_STD3_mapped", [32, 774]], [[729, 729], "disallowed_STD3_mapped", [32, 775]], [[730, 730], "disallowed_STD3_mapped", [32, 778]], [[731, 731], "disallowed_STD3_mapped", [32, 808]], [[732, 732], "disallowed_STD3_mapped", [32, 771]], [[733, 733], "disallowed_STD3_mapped", [32, 779]], [[734, 734], "valid", [], "NV8"], [[735, 735], "valid", [], "NV8"], [[736, 736], "mapped", [611]], [[737, 737], "mapped", [108]], [[738, 738], "mapped", [115]], [[739, 739], "mapped", [120]], [[740, 740], "mapped", [661]], [[741, 745], "valid", [], "NV8"], [[746, 747], "valid", [], "NV8"], [[748, 748], "valid"], [[749, 749], "valid", [], "NV8"], [[750, 750], "valid"], [[751, 767], "valid", [], "NV8"], [[768, 831], "valid"], [[832, 832], "mapped", [768]], [[833, 833], "mapped", [769]], [[834, 834], "valid"], [[835, 835], "mapped", [787]], [[836, 836], "mapped", [776, 769]], [[837, 837], "mapped", [953]], [[838, 846], "valid"], [[847, 847], "ignored"], [[848, 855], "valid"], [[856, 860], "valid"], [[861, 863], "valid"], [[864, 865], "valid"], [[866, 866], "valid"], [[867, 879], "valid"], [[880, 880], "mapped", [881]], [[881, 881], "valid"], [[882, 882], "mapped", [883]], [[883, 883], "valid"], [[884, 884], "mapped", [697]], [[885, 885], "valid"], [[886, 886], "mapped", [887]], [[887, 887], "valid"], [[888, 889], "disallowed"], [[890, 890], "disallowed_STD3_mapped", [32, 953]], [[891, 893], "valid"], [[894, 894], "disallowed_STD3_mapped", [59]], [[895, 895], "mapped", [1011]], [[896, 899], "disallowed"], [[900, 900], "disallowed_STD3_mapped", [32, 769]], [[901, 901], "disallowed_STD3_mapped", [32, 776, 769]], [[902, 902], "mapped", [940]], [[903, 903], "mapped", [183]], [[904, 904], "mapped", [941]], [[905, 905], "mapped", [942]], [[906, 906], "mapped", [943]], [[907, 907], "disallowed"], [[908, 908], "mapped", [972]], [[909, 909], "disallowed"], [[910, 910], "mapped", [973]], [[911, 911], "mapped", [974]], [[912, 912], "valid"], [[913, 913], "mapped", [945]], [[914, 914], "mapped", [946]], [[915, 915], "mapped", [947]], [[916, 916], "mapped", [948]], [[917, 917], "mapped", [949]], [[918, 918], "mapped", [950]], [[919, 919], "mapped", [951]], [[920, 920], "mapped", [952]], [[921, 921], "mapped", [953]], [[922, 922], "mapped", [954]], [[923, 923], "mapped", [955]], [[924, 924], "mapped", [956]], [[925, 925], "mapped", [957]], [[926, 926], "mapped", [958]], [[927, 927], "mapped", [959]], [[928, 928], "mapped", [960]], [[929, 929], "mapped", [961]], [[930, 930], "disallowed"], [[931, 931], "mapped", [963]], [[932, 932], "mapped", [964]], [[933, 933], "mapped", [965]], [[934, 934], "mapped", [966]], [[935, 935], "mapped", [967]], [[936, 936], "mapped", [968]], [[937, 937], "mapped", [969]], [[938, 938], "mapped", [970]], [[939, 939], "mapped", [971]], [[940, 961], "valid"], [[962, 962], "deviation", [963]], [[963, 974], "valid"], [[975, 975], "mapped", [983]], [[976, 976], "mapped", [946]], [[977, 977], "mapped", [952]], [[978, 978], "mapped", [965]], [[979, 979], "mapped", [973]], [[980, 980], "mapped", [971]], [[981, 981], "mapped", [966]], [[982, 982], "mapped", [960]], [[983, 983], "valid"], [[984, 984], "mapped", [985]], [[985, 985], "valid"], [[986, 986], "mapped", [987]], [[987, 987], "valid"], [[988, 988], "mapped", [989]], [[989, 989], "valid"], [[990, 990], "mapped", [991]], [[991, 991], "valid"], [[992, 992], "mapped", [993]], [[993, 993], "valid"], [[994, 994], "mapped", [995]], [[995, 995], "valid"], [[996, 996], "mapped", [997]], [[997, 997], "valid"], [[998, 998], "mapped", [999]], [[999, 999], "valid"], [[1000, 1000], "mapped", [1001]], [[1001, 1001], "valid"], [[1002, 1002], "mapped", [1003]], [[1003, 1003], "valid"], [[1004, 1004], "mapped", [1005]], [[1005, 1005], "valid"], [[1006, 1006], "mapped", [1007]], [[1007, 1007], "valid"], [[1008, 1008], "mapped", [954]], [[1009, 1009], "mapped", [961]], [[1010, 1010], "mapped", [963]], [[1011, 1011], "valid"], [[1012, 1012], "mapped", [952]], [[1013, 1013], "mapped", [949]], [[1014, 1014], "valid", [], "NV8"], [[1015, 1015], "mapped", [1016]], [[1016, 1016], "valid"], [[1017, 1017], "mapped", [963]], [[1018, 1018], "mapped", [1019]], [[1019, 1019], "valid"], [[1020, 1020], "valid"], [[1021, 1021], "mapped", [891]], [[1022, 1022], "mapped", [892]], [[1023, 1023], "mapped", [893]], [[1024, 1024], "mapped", [1104]], [[1025, 1025], "mapped", [1105]], [[1026, 1026], "mapped", [1106]], [[1027, 1027], "mapped", [1107]], [[1028, 1028], "mapped", [1108]], [[1029, 1029], "mapped", [1109]], [[1030, 1030], "mapped", [1110]], [[1031, 1031], "mapped", [1111]], [[1032, 1032], "mapped", [1112]], [[1033, 1033], "mapped", [1113]], [[1034, 1034], "mapped", [1114]], [[1035, 1035], "mapped", [1115]], [[1036, 1036], "mapped", [1116]], [[1037, 1037], "mapped", [1117]], [[1038, 1038], "mapped", [1118]], [[1039, 1039], "mapped", [1119]], [[1040, 1040], "mapped", [1072]], [[1041, 1041], "mapped", [1073]], [[1042, 1042], "mapped", [1074]], [[1043, 1043], "mapped", [1075]], [[1044, 1044], "mapped", [1076]], [[1045, 1045], "mapped", [1077]], [[1046, 1046], "mapped", [1078]], [[1047, 1047], "mapped", [1079]], [[1048, 1048], "mapped", [1080]], [[1049, 1049], "mapped", [1081]], [[1050, 1050], "mapped", [1082]], [[1051, 1051], "mapped", [1083]], [[1052, 1052], "mapped", [1084]], [[1053, 1053], "mapped", [1085]], [[1054, 1054], "mapped", [1086]], [[1055, 1055], "mapped", [1087]], [[1056, 1056], "mapped", [1088]], [[1057, 1057], "mapped", [1089]], [[1058, 1058], "mapped", [1090]], [[1059, 1059], "mapped", [1091]], [[1060, 1060], "mapped", [1092]], [[1061, 1061], "mapped", [1093]], [[1062, 1062], "mapped", [1094]], [[1063, 1063], "mapped", [1095]], [[1064, 1064], "mapped", [1096]], [[1065, 1065], "mapped", [1097]], [[1066, 1066], "mapped", [1098]], [[1067, 1067], "mapped", [1099]], [[1068, 1068], "mapped", [1100]], [[1069, 1069], "mapped", [1101]], [[1070, 1070], "mapped", [1102]], [[1071, 1071], "mapped", [1103]], [[1072, 1103], "valid"], [[1104, 1104], "valid"], [[1105, 1116], "valid"], [[1117, 1117], "valid"], [[1118, 1119], "valid"], [[1120, 1120], "mapped", [1121]], [[1121, 1121], "valid"], [[1122, 1122], "mapped", [1123]], [[1123, 1123], "valid"], [[1124, 1124], "mapped", [1125]], [[1125, 1125], "valid"], [[1126, 1126], "mapped", [1127]], [[1127, 1127], "valid"], [[1128, 1128], "mapped", [1129]], [[1129, 1129], "valid"], [[1130, 1130], "mapped", [1131]], [[1131, 1131], "valid"], [[1132, 1132], "mapped", [1133]], [[1133, 1133], "valid"], [[1134, 1134], "mapped", [1135]], [[1135, 1135], "valid"], [[1136, 1136], "mapped", [1137]], [[1137, 1137], "valid"], [[1138, 1138], "mapped", [1139]], [[1139, 1139], "valid"], [[1140, 1140], "mapped", [1141]], [[1141, 1141], "valid"], [[1142, 1142], "mapped", [1143]], [[1143, 1143], "valid"], [[1144, 1144], "mapped", [1145]], [[1145, 1145], "valid"], [[1146, 1146], "mapped", [1147]], [[1147, 1147], "valid"], [[1148, 1148], "mapped", [1149]], [[1149, 1149], "valid"], [[1150, 1150], "mapped", [1151]], [[1151, 1151], "valid"], [[1152, 1152], "mapped", [1153]], [[1153, 1153], "valid"], [[1154, 1154], "valid", [], "NV8"], [[1155, 1158], "valid"], [[1159, 1159], "valid"], [[1160, 1161], "valid", [], "NV8"], [[1162, 1162], "mapped", [1163]], [[1163, 1163], "valid"], [[1164, 1164], "mapped", [1165]], [[1165, 1165], "valid"], [[1166, 1166], "mapped", [1167]], [[1167, 1167], "valid"], [[1168, 1168], "mapped", [1169]], [[1169, 1169], "valid"], [[1170, 1170], "mapped", [1171]], [[1171, 1171], "valid"], [[1172, 1172], "mapped", [1173]], [[1173, 1173], "valid"], [[1174, 1174], "mapped", [1175]], [[1175, 1175], "valid"], [[1176, 1176], "mapped", [1177]], [[1177, 1177], "valid"], [[1178, 1178], "mapped", [1179]], [[1179, 1179], "valid"], [[1180, 1180], "mapped", [1181]], [[1181, 1181], "valid"], [[1182, 1182], "mapped", [1183]], [[1183, 1183], "valid"], [[1184, 1184], "mapped", [1185]], [[1185, 1185], "valid"], [[1186, 1186], "mapped", [1187]], [[1187, 1187], "valid"], [[1188, 1188], "mapped", [1189]], [[1189, 1189], "valid"], [[1190, 1190], "mapped", [1191]], [[1191, 1191], "valid"], [[1192, 1192], "mapped", [1193]], [[1193, 1193], "valid"], [[1194, 1194], "mapped", [1195]], [[1195, 1195], "valid"], [[1196, 1196], "mapped", [1197]], [[1197, 1197], "valid"], [[1198, 1198], "mapped", [1199]], [[1199, 1199], "valid"], [[1200, 1200], "mapped", [1201]], [[1201, 1201], "valid"], [[1202, 1202], "mapped", [1203]], [[1203, 1203], "valid"], [[1204, 1204], "mapped", [1205]], [[1205, 1205], "valid"], [[1206, 1206], "mapped", [1207]], [[1207, 1207], "valid"], [[1208, 1208], "mapped", [1209]], [[1209, 1209], "valid"], [[1210, 1210], "mapped", [1211]], [[1211, 1211], "valid"], [[1212, 1212], "mapped", [1213]], [[1213, 1213], "valid"], [[1214, 1214], "mapped", [1215]], [[1215, 1215], "valid"], [[1216, 1216], "disallowed"], [[1217, 1217], "mapped", [1218]], [[1218, 1218], "valid"], [[1219, 1219], "mapped", [1220]], [[1220, 1220], "valid"], [[1221, 1221], "mapped", [1222]], [[1222, 1222], "valid"], [[1223, 1223], "mapped", [1224]], [[1224, 1224], "valid"], [[1225, 1225], "mapped", [1226]], [[1226, 1226], "valid"], [[1227, 1227], "mapped", [1228]], [[1228, 1228], "valid"], [[1229, 1229], "mapped", [1230]], [[1230, 1230], "valid"], [[1231, 1231], "valid"], [[1232, 1232], "mapped", [1233]], [[1233, 1233], "valid"], [[1234, 1234], "mapped", [1235]], [[1235, 1235], "valid"], [[1236, 1236], "mapped", [1237]], [[1237, 1237], "valid"], [[1238, 1238], "mapped", [1239]], [[1239, 1239], "valid"], [[1240, 1240], "mapped", [1241]], [[1241, 1241], "valid"], [[1242, 1242], "mapped", [1243]], [[1243, 1243], "valid"], [[1244, 1244], "mapped", [1245]], [[1245, 1245], "valid"], [[1246, 1246], "mapped", [1247]], [[1247, 1247], "valid"], [[1248, 1248], "mapped", [1249]], [[1249, 1249], "valid"], [[1250, 1250], "mapped", [1251]], [[1251, 1251], "valid"], [[1252, 1252], "mapped", [1253]], [[1253, 1253], "valid"], [[1254, 1254], "mapped", [1255]], [[1255, 1255], "valid"], [[1256, 1256], "mapped", [1257]], [[1257, 1257], "valid"], [[1258, 1258], "mapped", [1259]], [[1259, 1259], "valid"], [[1260, 1260], "mapped", [1261]], [[1261, 1261], "valid"], [[1262, 1262], "mapped", [1263]], [[1263, 1263], "valid"], [[1264, 1264], "mapped", [1265]], [[1265, 1265], "valid"], [[1266, 1266], "mapped", [1267]], [[1267, 1267], "valid"], [[1268, 1268], "mapped", [1269]], [[1269, 1269], "valid"], [[1270, 1270], "mapped", [1271]], [[1271, 1271], "valid"], [[1272, 1272], "mapped", [1273]], [[1273, 1273], "valid"], [[1274, 1274], "mapped", [1275]], [[1275, 1275], "valid"], [[1276, 1276], "mapped", [1277]], [[1277, 1277], "valid"], [[1278, 1278], "mapped", [1279]], [[1279, 1279], "valid"], [[1280, 1280], "mapped", [1281]], [[1281, 1281], "valid"], [[1282, 1282], "mapped", [1283]], [[1283, 1283], "valid"], [[1284, 1284], "mapped", [1285]], [[1285, 1285], "valid"], [[1286, 1286], "mapped", [1287]], [[1287, 1287], "valid"], [[1288, 1288], "mapped", [1289]], [[1289, 1289], "valid"], [[1290, 1290], "mapped", [1291]], [[1291, 1291], "valid"], [[1292, 1292], "mapped", [1293]], [[1293, 1293], "valid"], [[1294, 1294], "mapped", [1295]], [[1295, 1295], "valid"], [[1296, 1296], "mapped", [1297]], [[1297, 1297], "valid"], [[1298, 1298], "mapped", [1299]], [[1299, 1299], "valid"], [[1300, 1300], "mapped", [1301]], [[1301, 1301], "valid"], [[1302, 1302], "mapped", [1303]], [[1303, 1303], "valid"], [[1304, 1304], "mapped", [1305]], [[1305, 1305], "valid"], [[1306, 1306], "mapped", [1307]], [[1307, 1307], "valid"], [[1308, 1308], "mapped", [1309]], [[1309, 1309], "valid"], [[1310, 1310], "mapped", [1311]], [[1311, 1311], "valid"], [[1312, 1312], "mapped", [1313]], [[1313, 1313], "valid"], [[1314, 1314], "mapped", [1315]], [[1315, 1315], "valid"], [[1316, 1316], "mapped", [1317]], [[1317, 1317], "valid"], [[1318, 1318], "mapped", [1319]], [[1319, 1319], "valid"], [[1320, 1320], "mapped", [1321]], [[1321, 1321], "valid"], [[1322, 1322], "mapped", [1323]], [[1323, 1323], "valid"], [[1324, 1324], "mapped", [1325]], [[1325, 1325], "valid"], [[1326, 1326], "mapped", [1327]], [[1327, 1327], "valid"], [[1328, 1328], "disallowed"], [[1329, 1329], "mapped", [1377]], [[1330, 1330], "mapped", [1378]], [[1331, 1331], "mapped", [1379]], [[1332, 1332], "mapped", [1380]], [[1333, 1333], "mapped", [1381]], [[1334, 1334], "mapped", [1382]], [[1335, 1335], "mapped", [1383]], [[1336, 1336], "mapped", [1384]], [[1337, 1337], "mapped", [1385]], [[1338, 1338], "mapped", [1386]], [[1339, 1339], "mapped", [1387]], [[1340, 1340], "mapped", [1388]], [[1341, 1341], "mapped", [1389]], [[1342, 1342], "mapped", [1390]], [[1343, 1343], "mapped", [1391]], [[1344, 1344], "mapped", [1392]], [[1345, 1345], "mapped", [1393]], [[1346, 1346], "mapped", [1394]], [[1347, 1347], "mapped", [1395]], [[1348, 1348], "mapped", [1396]], [[1349, 1349], "mapped", [1397]], [[1350, 1350], "mapped", [1398]], [[1351, 1351], "mapped", [1399]], [[1352, 1352], "mapped", [1400]], [[1353, 1353], "mapped", [1401]], [[1354, 1354], "mapped", [1402]], [[1355, 1355], "mapped", [1403]], [[1356, 1356], "mapped", [1404]], [[1357, 1357], "mapped", [1405]], [[1358, 1358], "mapped", [1406]], [[1359, 1359], "mapped", [1407]], [[1360, 1360], "mapped", [1408]], [[1361, 1361], "mapped", [1409]], [[1362, 1362], "mapped", [1410]], [[1363, 1363], "mapped", [1411]], [[1364, 1364], "mapped", [1412]], [[1365, 1365], "mapped", [1413]], [[1366, 1366], "mapped", [1414]], [[1367, 1368], "disallowed"], [[1369, 1369], "valid"], [[1370, 1375], "valid", [], "NV8"], [[1376, 1376], "disallowed"], [[1377, 1414], "valid"], [[1415, 1415], "mapped", [1381, 1410]], [[1416, 1416], "disallowed"], [[1417, 1417], "valid", [], "NV8"], [[1418, 1418], "valid", [], "NV8"], [[1419, 1420], "disallowed"], [[1421, 1422], "valid", [], "NV8"], [[1423, 1423], "valid", [], "NV8"], [[1424, 1424], "disallowed"], [[1425, 1441], "valid"], [[1442, 1442], "valid"], [[1443, 1455], "valid"], [[1456, 1465], "valid"], [[1466, 1466], "valid"], [[1467, 1469], "valid"], [[1470, 1470], "valid", [], "NV8"], [[1471, 1471], "valid"], [[1472, 1472], "valid", [], "NV8"], [[1473, 1474], "valid"], [[1475, 1475], "valid", [], "NV8"], [[1476, 1476], "valid"], [[1477, 1477], "valid"], [[1478, 1478], "valid", [], "NV8"], [[1479, 1479], "valid"], [[1480, 1487], "disallowed"], [[1488, 1514], "valid"], [[1515, 1519], "disallowed"], [[1520, 1524], "valid"], [[1525, 1535], "disallowed"], [[1536, 1539], "disallowed"], [[1540, 1540], "disallowed"], [[1541, 1541], "disallowed"], [[1542, 1546], "valid", [], "NV8"], [[1547, 1547], "valid", [], "NV8"], [[1548, 1548], "valid", [], "NV8"], [[1549, 1551], "valid", [], "NV8"], [[1552, 1557], "valid"], [[1558, 1562], "valid"], [[1563, 1563], "valid", [], "NV8"], [[1564, 1564], "disallowed"], [[1565, 1565], "disallowed"], [[1566, 1566], "valid", [], "NV8"], [[1567, 1567], "valid", [], "NV8"], [[1568, 1568], "valid"], [[1569, 1594], "valid"], [[1595, 1599], "valid"], [[1600, 1600], "valid", [], "NV8"], [[1601, 1618], "valid"], [[1619, 1621], "valid"], [[1622, 1624], "valid"], [[1625, 1630], "valid"], [[1631, 1631], "valid"], [[1632, 1641], "valid"], [[1642, 1645], "valid", [], "NV8"], [[1646, 1647], "valid"], [[1648, 1652], "valid"], [[1653, 1653], "mapped", [1575, 1652]], [[1654, 1654], "mapped", [1608, 1652]], [[1655, 1655], "mapped", [1735, 1652]], [[1656, 1656], "mapped", [1610, 1652]], [[1657, 1719], "valid"], [[1720, 1721], "valid"], [[1722, 1726], "valid"], [[1727, 1727], "valid"], [[1728, 1742], "valid"], [[1743, 1743], "valid"], [[1744, 1747], "valid"], [[1748, 1748], "valid", [], "NV8"], [[1749, 1756], "valid"], [[1757, 1757], "disallowed"], [[1758, 1758], "valid", [], "NV8"], [[1759, 1768], "valid"], [[1769, 1769], "valid", [], "NV8"], [[1770, 1773], "valid"], [[1774, 1775], "valid"], [[1776, 1785], "valid"], [[1786, 1790], "valid"], [[1791, 1791], "valid"], [[1792, 1805], "valid", [], "NV8"], [[1806, 1806], "disallowed"], [[1807, 1807], "disallowed"], [[1808, 1836], "valid"], [[1837, 1839], "valid"], [[1840, 1866], "valid"], [[1867, 1868], "disallowed"], [[1869, 1871], "valid"], [[1872, 1901], "valid"], [[1902, 1919], "valid"], [[1920, 1968], "valid"], [[1969, 1969], "valid"], [[1970, 1983], "disallowed"], [[1984, 2037], "valid"], [[2038, 2042], "valid", [], "NV8"], [[2043, 2047], "disallowed"], [[2048, 2093], "valid"], [[2094, 2095], "disallowed"], [[2096, 2110], "valid", [], "NV8"], [[2111, 2111], "disallowed"], [[2112, 2139], "valid"], [[2140, 2141], "disallowed"], [[2142, 2142], "valid", [], "NV8"], [[2143, 2207], "disallowed"], [[2208, 2208], "valid"], [[2209, 2209], "valid"], [[2210, 2220], "valid"], [[2221, 2226], "valid"], [[2227, 2228], "valid"], [[2229, 2274], "disallowed"], [[2275, 2275], "valid"], [[2276, 2302], "valid"], [[2303, 2303], "valid"], [[2304, 2304], "valid"], [[2305, 2307], "valid"], [[2308, 2308], "valid"], [[2309, 2361], "valid"], [[2362, 2363], "valid"], [[2364, 2381], "valid"], [[2382, 2382], "valid"], [[2383, 2383], "valid"], [[2384, 2388], "valid"], [[2389, 2389], "valid"], [[2390, 2391], "valid"], [[2392, 2392], "mapped", [2325, 2364]], [[2393, 2393], "mapped", [2326, 2364]], [[2394, 2394], "mapped", [2327, 2364]], [[2395, 2395], "mapped", [2332, 2364]], [[2396, 2396], "mapped", [2337, 2364]], [[2397, 2397], "mapped", [2338, 2364]], [[2398, 2398], "mapped", [2347, 2364]], [[2399, 2399], "mapped", [2351, 2364]], [[2400, 2403], "valid"], [[2404, 2405], "valid", [], "NV8"], [[2406, 2415], "valid"], [[2416, 2416], "valid", [], "NV8"], [[2417, 2418], "valid"], [[2419, 2423], "valid"], [[2424, 2424], "valid"], [[2425, 2426], "valid"], [[2427, 2428], "valid"], [[2429, 2429], "valid"], [[2430, 2431], "valid"], [[2432, 2432], "valid"], [[2433, 2435], "valid"], [[2436, 2436], "disallowed"], [[2437, 2444], "valid"], [[2445, 2446], "disallowed"], [[2447, 2448], "valid"], [[2449, 2450], "disallowed"], [[2451, 2472], "valid"], [[2473, 2473], "disallowed"], [[2474, 2480], "valid"], [[2481, 2481], "disallowed"], [[2482, 2482], "valid"], [[2483, 2485], "disallowed"], [[2486, 2489], "valid"], [[2490, 2491], "disallowed"], [[2492, 2492], "valid"], [[2493, 2493], "valid"], [[2494, 2500], "valid"], [[2501, 2502], "disallowed"], [[2503, 2504], "valid"], [[2505, 2506], "disallowed"], [[2507, 2509], "valid"], [[2510, 2510], "valid"], [[2511, 2518], "disallowed"], [[2519, 2519], "valid"], [[2520, 2523], "disallowed"], [[2524, 2524], "mapped", [2465, 2492]], [[2525, 2525], "mapped", [2466, 2492]], [[2526, 2526], "disallowed"], [[2527, 2527], "mapped", [2479, 2492]], [[2528, 2531], "valid"], [[2532, 2533], "disallowed"], [[2534, 2545], "valid"], [[2546, 2554], "valid", [], "NV8"], [[2555, 2555], "valid", [], "NV8"], [[2556, 2560], "disallowed"], [[2561, 2561], "valid"], [[2562, 2562], "valid"], [[2563, 2563], "valid"], [[2564, 2564], "disallowed"], [[2565, 2570], "valid"], [[2571, 2574], "disallowed"], [[2575, 2576], "valid"], [[2577, 2578], "disallowed"], [[2579, 2600], "valid"], [[2601, 2601], "disallowed"], [[2602, 2608], "valid"], [[2609, 2609], "disallowed"], [[2610, 2610], "valid"], [[2611, 2611], "mapped", [2610, 2620]], [[2612, 2612], "disallowed"], [[2613, 2613], "valid"], [[2614, 2614], "mapped", [2616, 2620]], [[2615, 2615], "disallowed"], [[2616, 2617], "valid"], [[2618, 2619], "disallowed"], [[2620, 2620], "valid"], [[2621, 2621], "disallowed"], [[2622, 2626], "valid"], [[2627, 2630], "disallowed"], [[2631, 2632], "valid"], [[2633, 2634], "disallowed"], [[2635, 2637], "valid"], [[2638, 2640], "disallowed"], [[2641, 2641], "valid"], [[2642, 2648], "disallowed"], [[2649, 2649], "mapped", [2582, 2620]], [[2650, 2650], "mapped", [2583, 2620]], [[2651, 2651], "mapped", [2588, 2620]], [[2652, 2652], "valid"], [[2653, 2653], "disallowed"], [[2654, 2654], "mapped", [2603, 2620]], [[2655, 2661], "disallowed"], [[2662, 2676], "valid"], [[2677, 2677], "valid"], [[2678, 2688], "disallowed"], [[2689, 2691], "valid"], [[2692, 2692], "disallowed"], [[2693, 2699], "valid"], [[2700, 2700], "valid"], [[2701, 2701], "valid"], [[2702, 2702], "disallowed"], [[2703, 2705], "valid"], [[2706, 2706], "disallowed"], [[2707, 2728], "valid"], [[2729, 2729], "disallowed"], [[2730, 2736], "valid"], [[2737, 2737], "disallowed"], [[2738, 2739], "valid"], [[2740, 2740], "disallowed"], [[2741, 2745], "valid"], [[2746, 2747], "disallowed"], [[2748, 2757], "valid"], [[2758, 2758], "disallowed"], [[2759, 2761], "valid"], [[2762, 2762], "disallowed"], [[2763, 2765], "valid"], [[2766, 2767], "disallowed"], [[2768, 2768], "valid"], [[2769, 2783], "disallowed"], [[2784, 2784], "valid"], [[2785, 2787], "valid"], [[2788, 2789], "disallowed"], [[2790, 2799], "valid"], [[2800, 2800], "valid", [], "NV8"], [[2801, 2801], "valid", [], "NV8"], [[2802, 2808], "disallowed"], [[2809, 2809], "valid"], [[2810, 2816], "disallowed"], [[2817, 2819], "valid"], [[2820, 2820], "disallowed"], [[2821, 2828], "valid"], [[2829, 2830], "disallowed"], [[2831, 2832], "valid"], [[2833, 2834], "disallowed"], [[2835, 2856], "valid"], [[2857, 2857], "disallowed"], [[2858, 2864], "valid"], [[2865, 2865], "disallowed"], [[2866, 2867], "valid"], [[2868, 2868], "disallowed"], [[2869, 2869], "valid"], [[2870, 2873], "valid"], [[2874, 2875], "disallowed"], [[2876, 2883], "valid"], [[2884, 2884], "valid"], [[2885, 2886], "disallowed"], [[2887, 2888], "valid"], [[2889, 2890], "disallowed"], [[2891, 2893], "valid"], [[2894, 2901], "disallowed"], [[2902, 2903], "valid"], [[2904, 2907], "disallowed"], [[2908, 2908], "mapped", [2849, 2876]], [[2909, 2909], "mapped", [2850, 2876]], [[2910, 2910], "disallowed"], [[2911, 2913], "valid"], [[2914, 2915], "valid"], [[2916, 2917], "disallowed"], [[2918, 2927], "valid"], [[2928, 2928], "valid", [], "NV8"], [[2929, 2929], "valid"], [[2930, 2935], "valid", [], "NV8"], [[2936, 2945], "disallowed"], [[2946, 2947], "valid"], [[2948, 2948], "disallowed"], [[2949, 2954], "valid"], [[2955, 2957], "disallowed"], [[2958, 2960], "valid"], [[2961, 2961], "disallowed"], [[2962, 2965], "valid"], [[2966, 2968], "disallowed"], [[2969, 2970], "valid"], [[2971, 2971], "disallowed"], [[2972, 2972], "valid"], [[2973, 2973], "disallowed"], [[2974, 2975], "valid"], [[2976, 2978], "disallowed"], [[2979, 2980], "valid"], [[2981, 2983], "disallowed"], [[2984, 2986], "valid"], [[2987, 2989], "disallowed"], [[2990, 2997], "valid"], [[2998, 2998], "valid"], [[2999, 3001], "valid"], [[3002, 3005], "disallowed"], [[3006, 3010], "valid"], [[3011, 3013], "disallowed"], [[3014, 3016], "valid"], [[3017, 3017], "disallowed"], [[3018, 3021], "valid"], [[3022, 3023], "disallowed"], [[3024, 3024], "valid"], [[3025, 3030], "disallowed"], [[3031, 3031], "valid"], [[3032, 3045], "disallowed"], [[3046, 3046], "valid"], [[3047, 3055], "valid"], [[3056, 3058], "valid", [], "NV8"], [[3059, 3066], "valid", [], "NV8"], [[3067, 3071], "disallowed"], [[3072, 3072], "valid"], [[3073, 3075], "valid"], [[3076, 3076], "disallowed"], [[3077, 3084], "valid"], [[3085, 3085], "disallowed"], [[3086, 3088], "valid"], [[3089, 3089], "disallowed"], [[3090, 3112], "valid"], [[3113, 3113], "disallowed"], [[3114, 3123], "valid"], [[3124, 3124], "valid"], [[3125, 3129], "valid"], [[3130, 3132], "disallowed"], [[3133, 3133], "valid"], [[3134, 3140], "valid"], [[3141, 3141], "disallowed"], [[3142, 3144], "valid"], [[3145, 3145], "disallowed"], [[3146, 3149], "valid"], [[3150, 3156], "disallowed"], [[3157, 3158], "valid"], [[3159, 3159], "disallowed"], [[3160, 3161], "valid"], [[3162, 3162], "valid"], [[3163, 3167], "disallowed"], [[3168, 3169], "valid"], [[3170, 3171], "valid"], [[3172, 3173], "disallowed"], [[3174, 3183], "valid"], [[3184, 3191], "disallowed"], [[3192, 3199], "valid", [], "NV8"], [[3200, 3200], "disallowed"], [[3201, 3201], "valid"], [[3202, 3203], "valid"], [[3204, 3204], "disallowed"], [[3205, 3212], "valid"], [[3213, 3213], "disallowed"], [[3214, 3216], "valid"], [[3217, 3217], "disallowed"], [[3218, 3240], "valid"], [[3241, 3241], "disallowed"], [[3242, 3251], "valid"], [[3252, 3252], "disallowed"], [[3253, 3257], "valid"], [[3258, 3259], "disallowed"], [[3260, 3261], "valid"], [[3262, 3268], "valid"], [[3269, 3269], "disallowed"], [[3270, 3272], "valid"], [[3273, 3273], "disallowed"], [[3274, 3277], "valid"], [[3278, 3284], "disallowed"], [[3285, 3286], "valid"], [[3287, 3293], "disallowed"], [[3294, 3294], "valid"], [[3295, 3295], "disallowed"], [[3296, 3297], "valid"], [[3298, 3299], "valid"], [[3300, 3301], "disallowed"], [[3302, 3311], "valid"], [[3312, 3312], "disallowed"], [[3313, 3314], "valid"], [[3315, 3328], "disallowed"], [[3329, 3329], "valid"], [[3330, 3331], "valid"], [[3332, 3332], "disallowed"], [[3333, 3340], "valid"], [[3341, 3341], "disallowed"], [[3342, 3344], "valid"], [[3345, 3345], "disallowed"], [[3346, 3368], "valid"], [[3369, 3369], "valid"], [[3370, 3385], "valid"], [[3386, 3386], "valid"], [[3387, 3388], "disallowed"], [[3389, 3389], "valid"], [[3390, 3395], "valid"], [[3396, 3396], "valid"], [[3397, 3397], "disallowed"], [[3398, 3400], "valid"], [[3401, 3401], "disallowed"], [[3402, 3405], "valid"], [[3406, 3406], "valid"], [[3407, 3414], "disallowed"], [[3415, 3415], "valid"], [[3416, 3422], "disallowed"], [[3423, 3423], "valid"], [[3424, 3425], "valid"], [[3426, 3427], "valid"], [[3428, 3429], "disallowed"], [[3430, 3439], "valid"], [[3440, 3445], "valid", [], "NV8"], [[3446, 3448], "disallowed"], [[3449, 3449], "valid", [], "NV8"], [[3450, 3455], "valid"], [[3456, 3457], "disallowed"], [[3458, 3459], "valid"], [[3460, 3460], "disallowed"], [[3461, 3478], "valid"], [[3479, 3481], "disallowed"], [[3482, 3505], "valid"], [[3506, 3506], "disallowed"], [[3507, 3515], "valid"], [[3516, 3516], "disallowed"], [[3517, 3517], "valid"], [[3518, 3519], "disallowed"], [[3520, 3526], "valid"], [[3527, 3529], "disallowed"], [[3530, 3530], "valid"], [[3531, 3534], "disallowed"], [[3535, 3540], "valid"], [[3541, 3541], "disallowed"], [[3542, 3542], "valid"], [[3543, 3543], "disallowed"], [[3544, 3551], "valid"], [[3552, 3557], "disallowed"], [[3558, 3567], "valid"], [[3568, 3569], "disallowed"], [[3570, 3571], "valid"], [[3572, 3572], "valid", [], "NV8"], [[3573, 3584], "disallowed"], [[3585, 3634], "valid"], [[3635, 3635], "mapped", [3661, 3634]], [[3636, 3642], "valid"], [[3643, 3646], "disallowed"], [[3647, 3647], "valid", [], "NV8"], [[3648, 3662], "valid"], [[3663, 3663], "valid", [], "NV8"], [[3664, 3673], "valid"], [[3674, 3675], "valid", [], "NV8"], [[3676, 3712], "disallowed"], [[3713, 3714], "valid"], [[3715, 3715], "disallowed"], [[3716, 3716], "valid"], [[3717, 3718], "disallowed"], [[3719, 3720], "valid"], [[3721, 3721], "disallowed"], [[3722, 3722], "valid"], [[3723, 3724], "disallowed"], [[3725, 3725], "valid"], [[3726, 3731], "disallowed"], [[3732, 3735], "valid"], [[3736, 3736], "disallowed"], [[3737, 3743], "valid"], [[3744, 3744], "disallowed"], [[3745, 3747], "valid"], [[3748, 3748], "disallowed"], [[3749, 3749], "valid"], [[3750, 3750], "disallowed"], [[3751, 3751], "valid"], [[3752, 3753], "disallowed"], [[3754, 3755], "valid"], [[3756, 3756], "disallowed"], [[3757, 3762], "valid"], [[3763, 3763], "mapped", [3789, 3762]], [[3764, 3769], "valid"], [[3770, 3770], "disallowed"], [[3771, 3773], "valid"], [[3774, 3775], "disallowed"], [[3776, 3780], "valid"], [[3781, 3781], "disallowed"], [[3782, 3782], "valid"], [[3783, 3783], "disallowed"], [[3784, 3789], "valid"], [[3790, 3791], "disallowed"], [[3792, 3801], "valid"], [[3802, 3803], "disallowed"], [[3804, 3804], "mapped", [3755, 3737]], [[3805, 3805], "mapped", [3755, 3745]], [[3806, 3807], "valid"], [[3808, 3839], "disallowed"], [[3840, 3840], "valid"], [[3841, 3850], "valid", [], "NV8"], [[3851, 3851], "valid"], [[3852, 3852], "mapped", [3851]], [[3853, 3863], "valid", [], "NV8"], [[3864, 3865], "valid"], [[3866, 3871], "valid", [], "NV8"], [[3872, 3881], "valid"], [[3882, 3892], "valid", [], "NV8"], [[3893, 3893], "valid"], [[3894, 3894], "valid", [], "NV8"], [[3895, 3895], "valid"], [[3896, 3896], "valid", [], "NV8"], [[3897, 3897], "valid"], [[3898, 3901], "valid", [], "NV8"], [[3902, 3906], "valid"], [[3907, 3907], "mapped", [3906, 4023]], [[3908, 3911], "valid"], [[3912, 3912], "disallowed"], [[3913, 3916], "valid"], [[3917, 3917], "mapped", [3916, 4023]], [[3918, 3921], "valid"], [[3922, 3922], "mapped", [3921, 4023]], [[3923, 3926], "valid"], [[3927, 3927], "mapped", [3926, 4023]], [[3928, 3931], "valid"], [[3932, 3932], "mapped", [3931, 4023]], [[3933, 3944], "valid"], [[3945, 3945], "mapped", [3904, 4021]], [[3946, 3946], "valid"], [[3947, 3948], "valid"], [[3949, 3952], "disallowed"], [[3953, 3954], "valid"], [[3955, 3955], "mapped", [3953, 3954]], [[3956, 3956], "valid"], [[3957, 3957], "mapped", [3953, 3956]], [[3958, 3958], "mapped", [4018, 3968]], [[3959, 3959], "mapped", [4018, 3953, 3968]], [[3960, 3960], "mapped", [4019, 3968]], [[3961, 3961], "mapped", [4019, 3953, 3968]], [[3962, 3968], "valid"], [[3969, 3969], "mapped", [3953, 3968]], [[3970, 3972], "valid"], [[3973, 3973], "valid", [], "NV8"], [[3974, 3979], "valid"], [[3980, 3983], "valid"], [[3984, 3986], "valid"], [[3987, 3987], "mapped", [3986, 4023]], [[3988, 3989], "valid"], [[3990, 3990], "valid"], [[3991, 3991], "valid"], [[3992, 3992], "disallowed"], [[3993, 3996], "valid"], [[3997, 3997], "mapped", [3996, 4023]], [[3998, 4001], "valid"], [[4002, 4002], "mapped", [4001, 4023]], [[4003, 4006], "valid"], [[4007, 4007], "mapped", [4006, 4023]], [[4008, 4011], "valid"], [[4012, 4012], "mapped", [4011, 4023]], [[4013, 4013], "valid"], [[4014, 4016], "valid"], [[4017, 4023], "valid"], [[4024, 4024], "valid"], [[4025, 4025], "mapped", [3984, 4021]], [[4026, 4028], "valid"], [[4029, 4029], "disallowed"], [[4030, 4037], "valid", [], "NV8"], [[4038, 4038], "valid"], [[4039, 4044], "valid", [], "NV8"], [[4045, 4045], "disallowed"], [[4046, 4046], "valid", [], "NV8"], [[4047, 4047], "valid", [], "NV8"], [[4048, 4049], "valid", [], "NV8"], [[4050, 4052], "valid", [], "NV8"], [[4053, 4056], "valid", [], "NV8"], [[4057, 4058], "valid", [], "NV8"], [[4059, 4095], "disallowed"], [[4096, 4129], "valid"], [[4130, 4130], "valid"], [[4131, 4135], "valid"], [[4136, 4136], "valid"], [[4137, 4138], "valid"], [[4139, 4139], "valid"], [[4140, 4146], "valid"], [[4147, 4149], "valid"], [[4150, 4153], "valid"], [[4154, 4159], "valid"], [[4160, 4169], "valid"], [[4170, 4175], "valid", [], "NV8"], [[4176, 4185], "valid"], [[4186, 4249], "valid"], [[4250, 4253], "valid"], [[4254, 4255], "valid", [], "NV8"], [[4256, 4293], "disallowed"], [[4294, 4294], "disallowed"], [[4295, 4295], "mapped", [11559]], [[4296, 4300], "disallowed"], [[4301, 4301], "mapped", [11565]], [[4302, 4303], "disallowed"], [[4304, 4342], "valid"], [[4343, 4344], "valid"], [[4345, 4346], "valid"], [[4347, 4347], "valid", [], "NV8"], [[4348, 4348], "mapped", [4316]], [[4349, 4351], "valid"], [[4352, 4441], "valid", [], "NV8"], [[4442, 4446], "valid", [], "NV8"], [[4447, 4448], "disallowed"], [[4449, 4514], "valid", [], "NV8"], [[4515, 4519], "valid", [], "NV8"], [[4520, 4601], "valid", [], "NV8"], [[4602, 4607], "valid", [], "NV8"], [[4608, 4614], "valid"], [[4615, 4615], "valid"], [[4616, 4678], "valid"], [[4679, 4679], "valid"], [[4680, 4680], "valid"], [[4681, 4681], "disallowed"], [[4682, 4685], "valid"], [[4686, 4687], "disallowed"], [[4688, 4694], "valid"], [[4695, 4695], "disallowed"], [[4696, 4696], "valid"], [[4697, 4697], "disallowed"], [[4698, 4701], "valid"], [[4702, 4703], "disallowed"], [[4704, 4742], "valid"], [[4743, 4743], "valid"], [[4744, 4744], "valid"], [[4745, 4745], "disallowed"], [[4746, 4749], "valid"], [[4750, 4751], "disallowed"], [[4752, 4782], "valid"], [[4783, 4783], "valid"], [[4784, 4784], "valid"], [[4785, 4785], "disallowed"], [[4786, 4789], "valid"], [[4790, 4791], "disallowed"], [[4792, 4798], "valid"], [[4799, 4799], "disallowed"], [[4800, 4800], "valid"], [[4801, 4801], "disallowed"], [[4802, 4805], "valid"], [[4806, 4807], "disallowed"], [[4808, 4814], "valid"], [[4815, 4815], "valid"], [[4816, 4822], "valid"], [[4823, 4823], "disallowed"], [[4824, 4846], "valid"], [[4847, 4847], "valid"], [[4848, 4878], "valid"], [[4879, 4879], "valid"], [[4880, 4880], "valid"], [[4881, 4881], "disallowed"], [[4882, 4885], "valid"], [[4886, 4887], "disallowed"], [[4888, 4894], "valid"], [[4895, 4895], "valid"], [[4896, 4934], "valid"], [[4935, 4935], "valid"], [[4936, 4954], "valid"], [[4955, 4956], "disallowed"], [[4957, 4958], "valid"], [[4959, 4959], "valid"], [[4960, 4960], "valid", [], "NV8"], [[4961, 4988], "valid", [], "NV8"], [[4989, 4991], "disallowed"], [[4992, 5007], "valid"], [[5008, 5017], "valid", [], "NV8"], [[5018, 5023], "disallowed"], [[5024, 5108], "valid"], [[5109, 5109], "valid"], [[5110, 5111], "disallowed"], [[5112, 5112], "mapped", [5104]], [[5113, 5113], "mapped", [5105]], [[5114, 5114], "mapped", [5106]], [[5115, 5115], "mapped", [5107]], [[5116, 5116], "mapped", [5108]], [[5117, 5117], "mapped", [5109]], [[5118, 5119], "disallowed"], [[5120, 5120], "valid", [], "NV8"], [[5121, 5740], "valid"], [[5741, 5742], "valid", [], "NV8"], [[5743, 5750], "valid"], [[5751, 5759], "valid"], [[5760, 5760], "disallowed"], [[5761, 5786], "valid"], [[5787, 5788], "valid", [], "NV8"], [[5789, 5791], "disallowed"], [[5792, 5866], "valid"], [[5867, 5872], "valid", [], "NV8"], [[5873, 5880], "valid"], [[5881, 5887], "disallowed"], [[5888, 5900], "valid"], [[5901, 5901], "disallowed"], [[5902, 5908], "valid"], [[5909, 5919], "disallowed"], [[5920, 5940], "valid"], [[5941, 5942], "valid", [], "NV8"], [[5943, 5951], "disallowed"], [[5952, 5971], "valid"], [[5972, 5983], "disallowed"], [[5984, 5996], "valid"], [[5997, 5997], "disallowed"], [[5998, 6000], "valid"], [[6001, 6001], "disallowed"], [[6002, 6003], "valid"], [[6004, 6015], "disallowed"], [[6016, 6067], "valid"], [[6068, 6069], "disallowed"], [[6070, 6099], "valid"], [[6100, 6102], "valid", [], "NV8"], [[6103, 6103], "valid"], [[6104, 6107], "valid", [], "NV8"], [[6108, 6108], "valid"], [[6109, 6109], "valid"], [[6110, 6111], "disallowed"], [[6112, 6121], "valid"], [[6122, 6127], "disallowed"], [[6128, 6137], "valid", [], "NV8"], [[6138, 6143], "disallowed"], [[6144, 6149], "valid", [], "NV8"], [[6150, 6150], "disallowed"], [[6151, 6154], "valid", [], "NV8"], [[6155, 6157], "ignored"], [[6158, 6158], "disallowed"], [[6159, 6159], "disallowed"], [[6160, 6169], "valid"], [[6170, 6175], "disallowed"], [[6176, 6263], "valid"], [[6264, 6271], "disallowed"], [[6272, 6313], "valid"], [[6314, 6314], "valid"], [[6315, 6319], "disallowed"], [[6320, 6389], "valid"], [[6390, 6399], "disallowed"], [[6400, 6428], "valid"], [[6429, 6430], "valid"], [[6431, 6431], "disallowed"], [[6432, 6443], "valid"], [[6444, 6447], "disallowed"], [[6448, 6459], "valid"], [[6460, 6463], "disallowed"], [[6464, 6464], "valid", [], "NV8"], [[6465, 6467], "disallowed"], [[6468, 6469], "valid", [], "NV8"], [[6470, 6509], "valid"], [[6510, 6511], "disallowed"], [[6512, 6516], "valid"], [[6517, 6527], "disallowed"], [[6528, 6569], "valid"], [[6570, 6571], "valid"], [[6572, 6575], "disallowed"], [[6576, 6601], "valid"], [[6602, 6607], "disallowed"], [[6608, 6617], "valid"], [[6618, 6618], "valid", [], "XV8"], [[6619, 6621], "disallowed"], [[6622, 6623], "valid", [], "NV8"], [[6624, 6655], "valid", [], "NV8"], [[6656, 6683], "valid"], [[6684, 6685], "disallowed"], [[6686, 6687], "valid", [], "NV8"], [[6688, 6750], "valid"], [[6751, 6751], "disallowed"], [[6752, 6780], "valid"], [[6781, 6782], "disallowed"], [[6783, 6793], "valid"], [[6794, 6799], "disallowed"], [[6800, 6809], "valid"], [[6810, 6815], "disallowed"], [[6816, 6822], "valid", [], "NV8"], [[6823, 6823], "valid"], [[6824, 6829], "valid", [], "NV8"], [[6830, 6831], "disallowed"], [[6832, 6845], "valid"], [[6846, 6846], "valid", [], "NV8"], [[6847, 6911], "disallowed"], [[6912, 6987], "valid"], [[6988, 6991], "disallowed"], [[6992, 7001], "valid"], [[7002, 7018], "valid", [], "NV8"], [[7019, 7027], "valid"], [[7028, 7036], "valid", [], "NV8"], [[7037, 7039], "disallowed"], [[7040, 7082], "valid"], [[7083, 7085], "valid"], [[7086, 7097], "valid"], [[7098, 7103], "valid"], [[7104, 7155], "valid"], [[7156, 7163], "disallowed"], [[7164, 7167], "valid", [], "NV8"], [[7168, 7223], "valid"], [[7224, 7226], "disallowed"], [[7227, 7231], "valid", [], "NV8"], [[7232, 7241], "valid"], [[7242, 7244], "disallowed"], [[7245, 7293], "valid"], [[7294, 7295], "valid", [], "NV8"], [[7296, 7359], "disallowed"], [[7360, 7367], "valid", [], "NV8"], [[7368, 7375], "disallowed"], [[7376, 7378], "valid"], [[7379, 7379], "valid", [], "NV8"], [[7380, 7410], "valid"], [[7411, 7414], "valid"], [[7415, 7415], "disallowed"], [[7416, 7417], "valid"], [[7418, 7423], "disallowed"], [[7424, 7467], "valid"], [[7468, 7468], "mapped", [97]], [[7469, 7469], "mapped", [230]], [[7470, 7470], "mapped", [98]], [[7471, 7471], "valid"], [[7472, 7472], "mapped", [100]], [[7473, 7473], "mapped", [101]], [[7474, 7474], "mapped", [477]], [[7475, 7475], "mapped", [103]], [[7476, 7476], "mapped", [104]], [[7477, 7477], "mapped", [105]], [[7478, 7478], "mapped", [106]], [[7479, 7479], "mapped", [107]], [[7480, 7480], "mapped", [108]], [[7481, 7481], "mapped", [109]], [[7482, 7482], "mapped", [110]], [[7483, 7483], "valid"], [[7484, 7484], "mapped", [111]], [[7485, 7485], "mapped", [547]], [[7486, 7486], "mapped", [112]], [[7487, 7487], "mapped", [114]], [[7488, 7488], "mapped", [116]], [[7489, 7489], "mapped", [117]], [[7490, 7490], "mapped", [119]], [[7491, 7491], "mapped", [97]], [[7492, 7492], "mapped", [592]], [[7493, 7493], "mapped", [593]], [[7494, 7494], "mapped", [7426]], [[7495, 7495], "mapped", [98]], [[7496, 7496], "mapped", [100]], [[7497, 7497], "mapped", [101]], [[7498, 7498], "mapped", [601]], [[7499, 7499], "mapped", [603]], [[7500, 7500], "mapped", [604]], [[7501, 7501], "mapped", [103]], [[7502, 7502], "valid"], [[7503, 7503], "mapped", [107]], [[7504, 7504], "mapped", [109]], [[7505, 7505], "mapped", [331]], [[7506, 7506], "mapped", [111]], [[7507, 7507], "mapped", [596]], [[7508, 7508], "mapped", [7446]], [[7509, 7509], "mapped", [7447]], [[7510, 7510], "mapped", [112]], [[7511, 7511], "mapped", [116]], [[7512, 7512], "mapped", [117]], [[7513, 7513], "mapped", [7453]], [[7514, 7514], "mapped", [623]], [[7515, 7515], "mapped", [118]], [[7516, 7516], "mapped", [7461]], [[7517, 7517], "mapped", [946]], [[7518, 7518], "mapped", [947]], [[7519, 7519], "mapped", [948]], [[7520, 7520], "mapped", [966]], [[7521, 7521], "mapped", [967]], [[7522, 7522], "mapped", [105]], [[7523, 7523], "mapped", [114]], [[7524, 7524], "mapped", [117]], [[7525, 7525], "mapped", [118]], [[7526, 7526], "mapped", [946]], [[7527, 7527], "mapped", [947]], [[7528, 7528], "mapped", [961]], [[7529, 7529], "mapped", [966]], [[7530, 7530], "mapped", [967]], [[7531, 7531], "valid"], [[7532, 7543], "valid"], [[7544, 7544], "mapped", [1085]], [[7545, 7578], "valid"], [[7579, 7579], "mapped", [594]], [[7580, 7580], "mapped", [99]], [[7581, 7581], "mapped", [597]], [[7582, 7582], "mapped", [240]], [[7583, 7583], "mapped", [604]], [[7584, 7584], "mapped", [102]], [[7585, 7585], "mapped", [607]], [[7586, 7586], "mapped", [609]], [[7587, 7587], "mapped", [613]], [[7588, 7588], "mapped", [616]], [[7589, 7589], "mapped", [617]], [[7590, 7590], "mapped", [618]], [[7591, 7591], "mapped", [7547]], [[7592, 7592], "mapped", [669]], [[7593, 7593], "mapped", [621]], [[7594, 7594], "mapped", [7557]], [[7595, 7595], "mapped", [671]], [[7596, 7596], "mapped", [625]], [[7597, 7597], "mapped", [624]], [[7598, 7598], "mapped", [626]], [[7599, 7599], "mapped", [627]], [[7600, 7600], "mapped", [628]], [[7601, 7601], "mapped", [629]], [[7602, 7602], "mapped", [632]], [[7603, 7603], "mapped", [642]], [[7604, 7604], "mapped", [643]], [[7605, 7605], "mapped", [427]], [[7606, 7606], "mapped", [649]], [[7607, 7607], "mapped", [650]], [[7608, 7608], "mapped", [7452]], [[7609, 7609], "mapped", [651]], [[7610, 7610], "mapped", [652]], [[7611, 7611], "mapped", [122]], [[7612, 7612], "mapped", [656]], [[7613, 7613], "mapped", [657]], [[7614, 7614], "mapped", [658]], [[7615, 7615], "mapped", [952]], [[7616, 7619], "valid"], [[7620, 7626], "valid"], [[7627, 7654], "valid"], [[7655, 7669], "valid"], [[7670, 7675], "disallowed"], [[7676, 7676], "valid"], [[7677, 7677], "valid"], [[7678, 7679], "valid"], [[7680, 7680], "mapped", [7681]], [[7681, 7681], "valid"], [[7682, 7682], "mapped", [7683]], [[7683, 7683], "valid"], [[7684, 7684], "mapped", [7685]], [[7685, 7685], "valid"], [[7686, 7686], "mapped", [7687]], [[7687, 7687], "valid"], [[7688, 7688], "mapped", [7689]], [[7689, 7689], "valid"], [[7690, 7690], "mapped", [7691]], [[7691, 7691], "valid"], [[7692, 7692], "mapped", [7693]], [[7693, 7693], "valid"], [[7694, 7694], "mapped", [7695]], [[7695, 7695], "valid"], [[7696, 7696], "mapped", [7697]], [[7697, 7697], "valid"], [[7698, 7698], "mapped", [7699]], [[7699, 7699], "valid"], [[7700, 7700], "mapped", [7701]], [[7701, 7701], "valid"], [[7702, 7702], "mapped", [7703]], [[7703, 7703], "valid"], [[7704, 7704], "mapped", [7705]], [[7705, 7705], "valid"], [[7706, 7706], "mapped", [7707]], [[7707, 7707], "valid"], [[7708, 7708], "mapped", [7709]], [[7709, 7709], "valid"], [[7710, 7710], "mapped", [7711]], [[7711, 7711], "valid"], [[7712, 7712], "mapped", [7713]], [[7713, 7713], "valid"], [[7714, 7714], "mapped", [7715]], [[7715, 7715], "valid"], [[7716, 7716], "mapped", [7717]], [[7717, 7717], "valid"], [[7718, 7718], "mapped", [7719]], [[7719, 7719], "valid"], [[7720, 7720], "mapped", [7721]], [[7721, 7721], "valid"], [[7722, 7722], "mapped", [7723]], [[7723, 7723], "valid"], [[7724, 7724], "mapped", [7725]], [[7725, 7725], "valid"], [[7726, 7726], "mapped", [7727]], [[7727, 7727], "valid"], [[7728, 7728], "mapped", [7729]], [[7729, 7729], "valid"], [[7730, 7730], "mapped", [7731]], [[7731, 7731], "valid"], [[7732, 7732], "mapped", [7733]], [[7733, 7733], "valid"], [[7734, 7734], "mapped", [7735]], [[7735, 7735], "valid"], [[7736, 7736], "mapped", [7737]], [[7737, 7737], "valid"], [[7738, 7738], "mapped", [7739]], [[7739, 7739], "valid"], [[7740, 7740], "mapped", [7741]], [[7741, 7741], "valid"], [[7742, 7742], "mapped", [7743]], [[7743, 7743], "valid"], [[7744, 7744], "mapped", [7745]], [[7745, 7745], "valid"], [[7746, 7746], "mapped", [7747]], [[7747, 7747], "valid"], [[7748, 7748], "mapped", [7749]], [[7749, 7749], "valid"], [[7750, 7750], "mapped", [7751]], [[7751, 7751], "valid"], [[7752, 7752], "mapped", [7753]], [[7753, 7753], "valid"], [[7754, 7754], "mapped", [7755]], [[7755, 7755], "valid"], [[7756, 7756], "mapped", [7757]], [[7757, 7757], "valid"], [[7758, 7758], "mapped", [7759]], [[7759, 7759], "valid"], [[7760, 7760], "mapped", [7761]], [[7761, 7761], "valid"], [[7762, 7762], "mapped", [7763]], [[7763, 7763], "valid"], [[7764, 7764], "mapped", [7765]], [[7765, 7765], "valid"], [[7766, 7766], "mapped", [7767]], [[7767, 7767], "valid"], [[7768, 7768], "mapped", [7769]], [[7769, 7769], "valid"], [[7770, 7770], "mapped", [7771]], [[7771, 7771], "valid"], [[7772, 7772], "mapped", [7773]], [[7773, 7773], "valid"], [[7774, 7774], "mapped", [7775]], [[7775, 7775], "valid"], [[7776, 7776], "mapped", [7777]], [[7777, 7777], "valid"], [[7778, 7778], "mapped", [7779]], [[7779, 7779], "valid"], [[7780, 7780], "mapped", [7781]], [[7781, 7781], "valid"], [[7782, 7782], "mapped", [7783]], [[7783, 7783], "valid"], [[7784, 7784], "mapped", [7785]], [[7785, 7785], "valid"], [[7786, 7786], "mapped", [7787]], [[7787, 7787], "valid"], [[7788, 7788], "mapped", [7789]], [[7789, 7789], "valid"], [[7790, 7790], "mapped", [7791]], [[7791, 7791], "valid"], [[7792, 7792], "mapped", [7793]], [[7793, 7793], "valid"], [[7794, 7794], "mapped", [7795]], [[7795, 7795], "valid"], [[7796, 7796], "mapped", [7797]], [[7797, 7797], "valid"], [[7798, 7798], "mapped", [7799]], [[7799, 7799], "valid"], [[7800, 7800], "mapped", [7801]], [[7801, 7801], "valid"], [[7802, 7802], "mapped", [7803]], [[7803, 7803], "valid"], [[7804, 7804], "mapped", [7805]], [[7805, 7805], "valid"], [[7806, 7806], "mapped", [7807]], [[7807, 7807], "valid"], [[7808, 7808], "mapped", [7809]], [[7809, 7809], "valid"], [[7810, 7810], "mapped", [7811]], [[7811, 7811], "valid"], [[7812, 7812], "mapped", [7813]], [[7813, 7813], "valid"], [[7814, 7814], "mapped", [7815]], [[7815, 7815], "valid"], [[7816, 7816], "mapped", [7817]], [[7817, 7817], "valid"], [[7818, 7818], "mapped", [7819]], [[7819, 7819], "valid"], [[7820, 7820], "mapped", [7821]], [[7821, 7821], "valid"], [[7822, 7822], "mapped", [7823]], [[7823, 7823], "valid"], [[7824, 7824], "mapped", [7825]], [[7825, 7825], "valid"], [[7826, 7826], "mapped", [7827]], [[7827, 7827], "valid"], [[7828, 7828], "mapped", [7829]], [[7829, 7833], "valid"], [[7834, 7834], "mapped", [97, 702]], [[7835, 7835], "mapped", [7777]], [[7836, 7837], "valid"], [[7838, 7838], "mapped", [115, 115]], [[7839, 7839], "valid"], [[7840, 7840], "mapped", [7841]], [[7841, 7841], "valid"], [[7842, 7842], "mapped", [7843]], [[7843, 7843], "valid"], [[7844, 7844], "mapped", [7845]], [[7845, 7845], "valid"], [[7846, 7846], "mapped", [7847]], [[7847, 7847], "valid"], [[7848, 7848], "mapped", [7849]], [[7849, 7849], "valid"], [[7850, 7850], "mapped", [7851]], [[7851, 7851], "valid"], [[7852, 7852], "mapped", [7853]], [[7853, 7853], "valid"], [[7854, 7854], "mapped", [7855]], [[7855, 7855], "valid"], [[7856, 7856], "mapped", [7857]], [[7857, 7857], "valid"], [[7858, 7858], "mapped", [7859]], [[7859, 7859], "valid"], [[7860, 7860], "mapped", [7861]], [[7861, 7861], "valid"], [[7862, 7862], "mapped", [7863]], [[7863, 7863], "valid"], [[7864, 7864], "mapped", [7865]], [[7865, 7865], "valid"], [[7866, 7866], "mapped", [7867]], [[7867, 7867], "valid"], [[7868, 7868], "mapped", [7869]], [[7869, 7869], "valid"], [[7870, 7870], "mapped", [7871]], [[7871, 7871], "valid"], [[7872, 7872], "mapped", [7873]], [[7873, 7873], "valid"], [[7874, 7874], "mapped", [7875]], [[7875, 7875], "valid"], [[7876, 7876], "mapped", [7877]], [[7877, 7877], "valid"], [[7878, 7878], "mapped", [7879]], [[7879, 7879], "valid"], [[7880, 7880], "mapped", [7881]], [[7881, 7881], "valid"], [[7882, 7882], "mapped", [7883]], [[7883, 7883], "valid"], [[7884, 7884], "mapped", [7885]], [[7885, 7885], "valid"], [[7886, 7886], "mapped", [7887]], [[7887, 7887], "valid"], [[7888, 7888], "mapped", [7889]], [[7889, 7889], "valid"], [[7890, 7890], "mapped", [7891]], [[7891, 7891], "valid"], [[7892, 7892], "mapped", [7893]], [[7893, 7893], "valid"], [[7894, 7894], "mapped", [7895]], [[7895, 7895], "valid"], [[7896, 7896], "mapped", [7897]], [[7897, 7897], "valid"], [[7898, 7898], "mapped", [7899]], [[7899, 7899], "valid"], [[7900, 7900], "mapped", [7901]], [[7901, 7901], "valid"], [[7902, 7902], "mapped", [7903]], [[7903, 7903], "valid"], [[7904, 7904], "mapped", [7905]], [[7905, 7905], "valid"], [[7906, 7906], "mapped", [7907]], [[7907, 7907], "valid"], [[7908, 7908], "mapped", [7909]], [[7909, 7909], "valid"], [[7910, 7910], "mapped", [7911]], [[7911, 7911], "valid"], [[7912, 7912], "mapped", [7913]], [[7913, 7913], "valid"], [[7914, 7914], "mapped", [7915]], [[7915, 7915], "valid"], [[7916, 7916], "mapped", [7917]], [[7917, 7917], "valid"], [[7918, 7918], "mapped", [7919]], [[7919, 7919], "valid"], [[7920, 7920], "mapped", [7921]], [[7921, 7921], "valid"], [[7922, 7922], "mapped", [7923]], [[7923, 7923], "valid"], [[7924, 7924], "mapped", [7925]], [[7925, 7925], "valid"], [[7926, 7926], "mapped", [7927]], [[7927, 7927], "valid"], [[7928, 7928], "mapped", [7929]], [[7929, 7929], "valid"], [[7930, 7930], "mapped", [7931]], [[7931, 7931], "valid"], [[7932, 7932], "mapped", [7933]], [[7933, 7933], "valid"], [[7934, 7934], "mapped", [7935]], [[7935, 7935], "valid"], [[7936, 7943], "valid"], [[7944, 7944], "mapped", [7936]], [[7945, 7945], "mapped", [7937]], [[7946, 7946], "mapped", [7938]], [[7947, 7947], "mapped", [7939]], [[7948, 7948], "mapped", [7940]], [[7949, 7949], "mapped", [7941]], [[7950, 7950], "mapped", [7942]], [[7951, 7951], "mapped", [7943]], [[7952, 7957], "valid"], [[7958, 7959], "disallowed"], [[7960, 7960], "mapped", [7952]], [[7961, 7961], "mapped", [7953]], [[7962, 7962], "mapped", [7954]], [[7963, 7963], "mapped", [7955]], [[7964, 7964], "mapped", [7956]], [[7965, 7965], "mapped", [7957]], [[7966, 7967], "disallowed"], [[7968, 7975], "valid"], [[7976, 7976], "mapped", [7968]], [[7977, 7977], "mapped", [7969]], [[7978, 7978], "mapped", [7970]], [[7979, 7979], "mapped", [7971]], [[7980, 7980], "mapped", [7972]], [[7981, 7981], "mapped", [7973]], [[7982, 7982], "mapped", [7974]], [[7983, 7983], "mapped", [7975]], [[7984, 7991], "valid"], [[7992, 7992], "mapped", [7984]], [[7993, 7993], "mapped", [7985]], [[7994, 7994], "mapped", [7986]], [[7995, 7995], "mapped", [7987]], [[7996, 7996], "mapped", [7988]], [[7997, 7997], "mapped", [7989]], [[7998, 7998], "mapped", [7990]], [[7999, 7999], "mapped", [7991]], [[8000, 8005], "valid"], [[8006, 8007], "disallowed"], [[8008, 8008], "mapped", [8000]], [[8009, 8009], "mapped", [8001]], [[8010, 8010], "mapped", [8002]], [[8011, 8011], "mapped", [8003]], [[8012, 8012], "mapped", [8004]], [[8013, 8013], "mapped", [8005]], [[8014, 8015], "disallowed"], [[8016, 8023], "valid"], [[8024, 8024], "disallowed"], [[8025, 8025], "mapped", [8017]], [[8026, 8026], "disallowed"], [[8027, 8027], "mapped", [8019]], [[8028, 8028], "disallowed"], [[8029, 8029], "mapped", [8021]], [[8030, 8030], "disallowed"], [[8031, 8031], "mapped", [8023]], [[8032, 8039], "valid"], [[8040, 8040], "mapped", [8032]], [[8041, 8041], "mapped", [8033]], [[8042, 8042], "mapped", [8034]], [[8043, 8043], "mapped", [8035]], [[8044, 8044], "mapped", [8036]], [[8045, 8045], "mapped", [8037]], [[8046, 8046], "mapped", [8038]], [[8047, 8047], "mapped", [8039]], [[8048, 8048], "valid"], [[8049, 8049], "mapped", [940]], [[8050, 8050], "valid"], [[8051, 8051], "mapped", [941]], [[8052, 8052], "valid"], [[8053, 8053], "mapped", [942]], [[8054, 8054], "valid"], [[8055, 8055], "mapped", [943]], [[8056, 8056], "valid"], [[8057, 8057], "mapped", [972]], [[8058, 8058], "valid"], [[8059, 8059], "mapped", [973]], [[8060, 8060], "valid"], [[8061, 8061], "mapped", [974]], [[8062, 8063], "disallowed"], [[8064, 8064], "mapped", [7936, 953]], [[8065, 8065], "mapped", [7937, 953]], [[8066, 8066], "mapped", [7938, 953]], [[8067, 8067], "mapped", [7939, 953]], [[8068, 8068], "mapped", [7940, 953]], [[8069, 8069], "mapped", [7941, 953]], [[8070, 8070], "mapped", [7942, 953]], [[8071, 8071], "mapped", [7943, 953]], [[8072, 8072], "mapped", [7936, 953]], [[8073, 8073], "mapped", [7937, 953]], [[8074, 8074], "mapped", [7938, 953]], [[8075, 8075], "mapped", [7939, 953]], [[8076, 8076], "mapped", [7940, 953]], [[8077, 8077], "mapped", [7941, 953]], [[8078, 8078], "mapped", [7942, 953]], [[8079, 8079], "mapped", [7943, 953]], [[8080, 8080], "mapped", [7968, 953]], [[8081, 8081], "mapped", [7969, 953]], [[8082, 8082], "mapped", [7970, 953]], [[8083, 8083], "mapped", [7971, 953]], [[8084, 8084], "mapped", [7972, 953]], [[8085, 8085], "mapped", [7973, 953]], [[8086, 8086], "mapped", [7974, 953]], [[8087, 8087], "mapped", [7975, 953]], [[8088, 8088], "mapped", [7968, 953]], [[8089, 8089], "mapped", [7969, 953]], [[8090, 8090], "mapped", [7970, 953]], [[8091, 8091], "mapped", [7971, 953]], [[8092, 8092], "mapped", [7972, 953]], [[8093, 8093], "mapped", [7973, 953]], [[8094, 8094], "mapped", [7974, 953]], [[8095, 8095], "mapped", [7975, 953]], [[8096, 8096], "mapped", [8032, 953]], [[8097, 8097], "mapped", [8033, 953]], [[8098, 8098], "mapped", [8034, 953]], [[8099, 8099], "mapped", [8035, 953]], [[8100, 8100], "mapped", [8036, 953]], [[8101, 8101], "mapped", [8037, 953]], [[8102, 8102], "mapped", [8038, 953]], [[8103, 8103], "mapped", [8039, 953]], [[8104, 8104], "mapped", [8032, 953]], [[8105, 8105], "mapped", [8033, 953]], [[8106, 8106], "mapped", [8034, 953]], [[8107, 8107], "mapped", [8035, 953]], [[8108, 8108], "mapped", [8036, 953]], [[8109, 8109], "mapped", [8037, 953]], [[8110, 8110], "mapped", [8038, 953]], [[8111, 8111], "mapped", [8039, 953]], [[8112, 8113], "valid"], [[8114, 8114], "mapped", [8048, 953]], [[8115, 8115], "mapped", [945, 953]], [[8116, 8116], "mapped", [940, 953]], [[8117, 8117], "disallowed"], [[8118, 8118], "valid"], [[8119, 8119], "mapped", [8118, 953]], [[8120, 8120], "mapped", [8112]], [[8121, 8121], "mapped", [8113]], [[8122, 8122], "mapped", [8048]], [[8123, 8123], "mapped", [940]], [[8124, 8124], "mapped", [945, 953]], [[8125, 8125], "disallowed_STD3_mapped", [32, 787]], [[8126, 8126], "mapped", [953]], [[8127, 8127], "disallowed_STD3_mapped", [32, 787]], [[8128, 8128], "disallowed_STD3_mapped", [32, 834]], [[8129, 8129], "disallowed_STD3_mapped", [32, 776, 834]], [[8130, 8130], "mapped", [8052, 953]], [[8131, 8131], "mapped", [951, 953]], [[8132, 8132], "mapped", [942, 953]], [[8133, 8133], "disallowed"], [[8134, 8134], "valid"], [[8135, 8135], "mapped", [8134, 953]], [[8136, 8136], "mapped", [8050]], [[8137, 8137], "mapped", [941]], [[8138, 8138], "mapped", [8052]], [[8139, 8139], "mapped", [942]], [[8140, 8140], "mapped", [951, 953]], [[8141, 8141], "disallowed_STD3_mapped", [32, 787, 768]], [[8142, 8142], "disallowed_STD3_mapped", [32, 787, 769]], [[8143, 8143], "disallowed_STD3_mapped", [32, 787, 834]], [[8144, 8146], "valid"], [[8147, 8147], "mapped", [912]], [[8148, 8149], "disallowed"], [[8150, 8151], "valid"], [[8152, 8152], "mapped", [8144]], [[8153, 8153], "mapped", [8145]], [[8154, 8154], "mapped", [8054]], [[8155, 8155], "mapped", [943]], [[8156, 8156], "disallowed"], [[8157, 8157], "disallowed_STD3_mapped", [32, 788, 768]], [[8158, 8158], "disallowed_STD3_mapped", [32, 788, 769]], [[8159, 8159], "disallowed_STD3_mapped", [32, 788, 834]], [[8160, 8162], "valid"], [[8163, 8163], "mapped", [944]], [[8164, 8167], "valid"], [[8168, 8168], "mapped", [8160]], [[8169, 8169], "mapped", [8161]], [[8170, 8170], "mapped", [8058]], [[8171, 8171], "mapped", [973]], [[8172, 8172], "mapped", [8165]], [[8173, 8173], "disallowed_STD3_mapped", [32, 776, 768]], [[8174, 8174], "disallowed_STD3_mapped", [32, 776, 769]], [[8175, 8175], "disallowed_STD3_mapped", [96]], [[8176, 8177], "disallowed"], [[8178, 8178], "mapped", [8060, 953]], [[8179, 8179], "mapped", [969, 953]], [[8180, 8180], "mapped", [974, 953]], [[8181, 8181], "disallowed"], [[8182, 8182], "valid"], [[8183, 8183], "mapped", [8182, 953]], [[8184, 8184], "mapped", [8056]], [[8185, 8185], "mapped", [972]], [[8186, 8186], "mapped", [8060]], [[8187, 8187], "mapped", [974]], [[8188, 8188], "mapped", [969, 953]], [[8189, 8189], "disallowed_STD3_mapped", [32, 769]], [[8190, 8190], "disallowed_STD3_mapped", [32, 788]], [[8191, 8191], "disallowed"], [[8192, 8202], "disallowed_STD3_mapped", [32]], [[8203, 8203], "ignored"], [[8204, 8205], "deviation", []], [[8206, 8207], "disallowed"], [[8208, 8208], "valid", [], "NV8"], [[8209, 8209], "mapped", [8208]], [[8210, 8214], "valid", [], "NV8"], [[8215, 8215], "disallowed_STD3_mapped", [32, 819]], [[8216, 8227], "valid", [], "NV8"], [[8228, 8230], "disallowed"], [[8231, 8231], "valid", [], "NV8"], [[8232, 8238], "disallowed"], [[8239, 8239], "disallowed_STD3_mapped", [32]], [[8240, 8242], "valid", [], "NV8"], [[8243, 8243], "mapped", [8242, 8242]], [[8244, 8244], "mapped", [8242, 8242, 8242]], [[8245, 8245], "valid", [], "NV8"], [[8246, 8246], "mapped", [8245, 8245]], [[8247, 8247], "mapped", [8245, 8245, 8245]], [[8248, 8251], "valid", [], "NV8"], [[8252, 8252], "disallowed_STD3_mapped", [33, 33]], [[8253, 8253], "valid", [], "NV8"], [[8254, 8254], "disallowed_STD3_mapped", [32, 773]], [[8255, 8262], "valid", [], "NV8"], [[8263, 8263], "disallowed_STD3_mapped", [63, 63]], [[8264, 8264], "disallowed_STD3_mapped", [63, 33]], [[8265, 8265], "disallowed_STD3_mapped", [33, 63]], [[8266, 8269], "valid", [], "NV8"], [[8270, 8274], "valid", [], "NV8"], [[8275, 8276], "valid", [], "NV8"], [[8277, 8278], "valid", [], "NV8"], [[8279, 8279], "mapped", [8242, 8242, 8242, 8242]], [[8280, 8286], "valid", [], "NV8"], [[8287, 8287], "disallowed_STD3_mapped", [32]], [[8288, 8288], "ignored"], [[8289, 8291], "disallowed"], [[8292, 8292], "ignored"], [[8293, 8293], "disallowed"], [[8294, 8297], "disallowed"], [[8298, 8303], "disallowed"], [[8304, 8304], "mapped", [48]], [[8305, 8305], "mapped", [105]], [[8306, 8307], "disallowed"], [[8308, 8308], "mapped", [52]], [[8309, 8309], "mapped", [53]], [[8310, 8310], "mapped", [54]], [[8311, 8311], "mapped", [55]], [[8312, 8312], "mapped", [56]], [[8313, 8313], "mapped", [57]], [[8314, 8314], "disallowed_STD3_mapped", [43]], [[8315, 8315], "mapped", [8722]], [[8316, 8316], "disallowed_STD3_mapped", [61]], [[8317, 8317], "disallowed_STD3_mapped", [40]], [[8318, 8318], "disallowed_STD3_mapped", [41]], [[8319, 8319], "mapped", [110]], [[8320, 8320], "mapped", [48]], [[8321, 8321], "mapped", [49]], [[8322, 8322], "mapped", [50]], [[8323, 8323], "mapped", [51]], [[8324, 8324], "mapped", [52]], [[8325, 8325], "mapped", [53]], [[8326, 8326], "mapped", [54]], [[8327, 8327], "mapped", [55]], [[8328, 8328], "mapped", [56]], [[8329, 8329], "mapped", [57]], [[8330, 8330], "disallowed_STD3_mapped", [43]], [[8331, 8331], "mapped", [8722]], [[8332, 8332], "disallowed_STD3_mapped", [61]], [[8333, 8333], "disallowed_STD3_mapped", [40]], [[8334, 8334], "disallowed_STD3_mapped", [41]], [[8335, 8335], "disallowed"], [[8336, 8336], "mapped", [97]], [[8337, 8337], "mapped", [101]], [[8338, 8338], "mapped", [111]], [[8339, 8339], "mapped", [120]], [[8340, 8340], "mapped", [601]], [[8341, 8341], "mapped", [104]], [[8342, 8342], "mapped", [107]], [[8343, 8343], "mapped", [108]], [[8344, 8344], "mapped", [109]], [[8345, 8345], "mapped", [110]], [[8346, 8346], "mapped", [112]], [[8347, 8347], "mapped", [115]], [[8348, 8348], "mapped", [116]], [[8349, 8351], "disallowed"], [[8352, 8359], "valid", [], "NV8"], [[8360, 8360], "mapped", [114, 115]], [[8361, 8362], "valid", [], "NV8"], [[8363, 8363], "valid", [], "NV8"], [[8364, 8364], "valid", [], "NV8"], [[8365, 8367], "valid", [], "NV8"], [[8368, 8369], "valid", [], "NV8"], [[8370, 8373], "valid", [], "NV8"], [[8374, 8376], "valid", [], "NV8"], [[8377, 8377], "valid", [], "NV8"], [[8378, 8378], "valid", [], "NV8"], [[8379, 8381], "valid", [], "NV8"], [[8382, 8382], "valid", [], "NV8"], [[8383, 8399], "disallowed"], [[8400, 8417], "valid", [], "NV8"], [[8418, 8419], "valid", [], "NV8"], [[8420, 8426], "valid", [], "NV8"], [[8427, 8427], "valid", [], "NV8"], [[8428, 8431], "valid", [], "NV8"], [[8432, 8432], "valid", [], "NV8"], [[8433, 8447], "disallowed"], [[8448, 8448], "disallowed_STD3_mapped", [97, 47, 99]], [[8449, 8449], "disallowed_STD3_mapped", [97, 47, 115]], [[8450, 8450], "mapped", [99]], [[8451, 8451], "mapped", [176, 99]], [[8452, 8452], "valid", [], "NV8"], [[8453, 8453], "disallowed_STD3_mapped", [99, 47, 111]], [[8454, 8454], "disallowed_STD3_mapped", [99, 47, 117]], [[8455, 8455], "mapped", [603]], [[8456, 8456], "valid", [], "NV8"], [[8457, 8457], "mapped", [176, 102]], [[8458, 8458], "mapped", [103]], [[8459, 8462], "mapped", [104]], [[8463, 8463], "mapped", [295]], [[8464, 8465], "mapped", [105]], [[8466, 8467], "mapped", [108]], [[8468, 8468], "valid", [], "NV8"], [[8469, 8469], "mapped", [110]], [[8470, 8470], "mapped", [110, 111]], [[8471, 8472], "valid", [], "NV8"], [[8473, 8473], "mapped", [112]], [[8474, 8474], "mapped", [113]], [[8475, 8477], "mapped", [114]], [[8478, 8479], "valid", [], "NV8"], [[8480, 8480], "mapped", [115, 109]], [[8481, 8481], "mapped", [116, 101, 108]], [[8482, 8482], "mapped", [116, 109]], [[8483, 8483], "valid", [], "NV8"], [[8484, 8484], "mapped", [122]], [[8485, 8485], "valid", [], "NV8"], [[8486, 8486], "mapped", [969]], [[8487, 8487], "valid", [], "NV8"], [[8488, 8488], "mapped", [122]], [[8489, 8489], "valid", [], "NV8"], [[8490, 8490], "mapped", [107]], [[8491, 8491], "mapped", [229]], [[8492, 8492], "mapped", [98]], [[8493, 8493], "mapped", [99]], [[8494, 8494], "valid", [], "NV8"], [[8495, 8496], "mapped", [101]], [[8497, 8497], "mapped", [102]], [[8498, 8498], "disallowed"], [[8499, 8499], "mapped", [109]], [[8500, 8500], "mapped", [111]], [[8501, 8501], "mapped", [1488]], [[8502, 8502], "mapped", [1489]], [[8503, 8503], "mapped", [1490]], [[8504, 8504], "mapped", [1491]], [[8505, 8505], "mapped", [105]], [[8506, 8506], "valid", [], "NV8"], [[8507, 8507], "mapped", [102, 97, 120]], [[8508, 8508], "mapped", [960]], [[8509, 8510], "mapped", [947]], [[8511, 8511], "mapped", [960]], [[8512, 8512], "mapped", [8721]], [[8513, 8516], "valid", [], "NV8"], [[8517, 8518], "mapped", [100]], [[8519, 8519], "mapped", [101]], [[8520, 8520], "mapped", [105]], [[8521, 8521], "mapped", [106]], [[8522, 8523], "valid", [], "NV8"], [[8524, 8524], "valid", [], "NV8"], [[8525, 8525], "valid", [], "NV8"], [[8526, 8526], "valid"], [[8527, 8527], "valid", [], "NV8"], [[8528, 8528], "mapped", [49, 8260, 55]], [[8529, 8529], "mapped", [49, 8260, 57]], [[8530, 8530], "mapped", [49, 8260, 49, 48]], [[8531, 8531], "mapped", [49, 8260, 51]], [[8532, 8532], "mapped", [50, 8260, 51]], [[8533, 8533], "mapped", [49, 8260, 53]], [[8534, 8534], "mapped", [50, 8260, 53]], [[8535, 8535], "mapped", [51, 8260, 53]], [[8536, 8536], "mapped", [52, 8260, 53]], [[8537, 8537], "mapped", [49, 8260, 54]], [[8538, 8538], "mapped", [53, 8260, 54]], [[8539, 8539], "mapped", [49, 8260, 56]], [[8540, 8540], "mapped", [51, 8260, 56]], [[8541, 8541], "mapped", [53, 8260, 56]], [[8542, 8542], "mapped", [55, 8260, 56]], [[8543, 8543], "mapped", [49, 8260]], [[8544, 8544], "mapped", [105]], [[8545, 8545], "mapped", [105, 105]], [[8546, 8546], "mapped", [105, 105, 105]], [[8547, 8547], "mapped", [105, 118]], [[8548, 8548], "mapped", [118]], [[8549, 8549], "mapped", [118, 105]], [[8550, 8550], "mapped", [118, 105, 105]], [[8551, 8551], "mapped", [118, 105, 105, 105]], [[8552, 8552], "mapped", [105, 120]], [[8553, 8553], "mapped", [120]], [[8554, 8554], "mapped", [120, 105]], [[8555, 8555], "mapped", [120, 105, 105]], [[8556, 8556], "mapped", [108]], [[8557, 8557], "mapped", [99]], [[8558, 8558], "mapped", [100]], [[8559, 8559], "mapped", [109]], [[8560, 8560], "mapped", [105]], [[8561, 8561], "mapped", [105, 105]], [[8562, 8562], "mapped", [105, 105, 105]], [[8563, 8563], "mapped", [105, 118]], [[8564, 8564], "mapped", [118]], [[8565, 8565], "mapped", [118, 105]], [[8566, 8566], "mapped", [118, 105, 105]], [[8567, 8567], "mapped", [118, 105, 105, 105]], [[8568, 8568], "mapped", [105, 120]], [[8569, 8569], "mapped", [120]], [[8570, 8570], "mapped", [120, 105]], [[8571, 8571], "mapped", [120, 105, 105]], [[8572, 8572], "mapped", [108]], [[8573, 8573], "mapped", [99]], [[8574, 8574], "mapped", [100]], [[8575, 8575], "mapped", [109]], [[8576, 8578], "valid", [], "NV8"], [[8579, 8579], "disallowed"], [[8580, 8580], "valid"], [[8581, 8584], "valid", [], "NV8"], [[8585, 8585], "mapped", [48, 8260, 51]], [[8586, 8587], "valid", [], "NV8"], [[8588, 8591], "disallowed"], [[8592, 8682], "valid", [], "NV8"], [[8683, 8691], "valid", [], "NV8"], [[8692, 8703], "valid", [], "NV8"], [[8704, 8747], "valid", [], "NV8"], [[8748, 8748], "mapped", [8747, 8747]], [[8749, 8749], "mapped", [8747, 8747, 8747]], [[8750, 8750], "valid", [], "NV8"], [[8751, 8751], "mapped", [8750, 8750]], [[8752, 8752], "mapped", [8750, 8750, 8750]], [[8753, 8799], "valid", [], "NV8"], [[8800, 8800], "disallowed_STD3_valid"], [[8801, 8813], "valid", [], "NV8"], [[8814, 8815], "disallowed_STD3_valid"], [[8816, 8945], "valid", [], "NV8"], [[8946, 8959], "valid", [], "NV8"], [[8960, 8960], "valid", [], "NV8"], [[8961, 8961], "valid", [], "NV8"], [[8962, 9000], "valid", [], "NV8"], [[9001, 9001], "mapped", [12296]], [[9002, 9002], "mapped", [12297]], [[9003, 9082], "valid", [], "NV8"], [[9083, 9083], "valid", [], "NV8"], [[9084, 9084], "valid", [], "NV8"], [[9085, 9114], "valid", [], "NV8"], [[9115, 9166], "valid", [], "NV8"], [[9167, 9168], "valid", [], "NV8"], [[9169, 9179], "valid", [], "NV8"], [[9180, 9191], "valid", [], "NV8"], [[9192, 9192], "valid", [], "NV8"], [[9193, 9203], "valid", [], "NV8"], [[9204, 9210], "valid", [], "NV8"], [[9211, 9215], "disallowed"], [[9216, 9252], "valid", [], "NV8"], [[9253, 9254], "valid", [], "NV8"], [[9255, 9279], "disallowed"], [[9280, 9290], "valid", [], "NV8"], [[9291, 9311], "disallowed"], [[9312, 9312], "mapped", [49]], [[9313, 9313], "mapped", [50]], [[9314, 9314], "mapped", [51]], [[9315, 9315], "mapped", [52]], [[9316, 9316], "mapped", [53]], [[9317, 9317], "mapped", [54]], [[9318, 9318], "mapped", [55]], [[9319, 9319], "mapped", [56]], [[9320, 9320], "mapped", [57]], [[9321, 9321], "mapped", [49, 48]], [[9322, 9322], "mapped", [49, 49]], [[9323, 9323], "mapped", [49, 50]], [[9324, 9324], "mapped", [49, 51]], [[9325, 9325], "mapped", [49, 52]], [[9326, 9326], "mapped", [49, 53]], [[9327, 9327], "mapped", [49, 54]], [[9328, 9328], "mapped", [49, 55]], [[9329, 9329], "mapped", [49, 56]], [[9330, 9330], "mapped", [49, 57]], [[9331, 9331], "mapped", [50, 48]], [[9332, 9332], "disallowed_STD3_mapped", [40, 49, 41]], [[9333, 9333], "disallowed_STD3_mapped", [40, 50, 41]], [[9334, 9334], "disallowed_STD3_mapped", [40, 51, 41]], [[9335, 9335], "disallowed_STD3_mapped", [40, 52, 41]], [[9336, 9336], "disallowed_STD3_mapped", [40, 53, 41]], [[9337, 9337], "disallowed_STD3_mapped", [40, 54, 41]], [[9338, 9338], "disallowed_STD3_mapped", [40, 55, 41]], [[9339, 9339], "disallowed_STD3_mapped", [40, 56, 41]], [[9340, 9340], "disallowed_STD3_mapped", [40, 57, 41]], [[9341, 9341], "disallowed_STD3_mapped", [40, 49, 48, 41]], [[9342, 9342], "disallowed_STD3_mapped", [40, 49, 49, 41]], [[9343, 9343], "disallowed_STD3_mapped", [40, 49, 50, 41]], [[9344, 9344], "disallowed_STD3_mapped", [40, 49, 51, 41]], [[9345, 9345], "disallowed_STD3_mapped", [40, 49, 52, 41]], [[9346, 9346], "disallowed_STD3_mapped", [40, 49, 53, 41]], [[9347, 9347], "disallowed_STD3_mapped", [40, 49, 54, 41]], [[9348, 9348], "disallowed_STD3_mapped", [40, 49, 55, 41]], [[9349, 9349], "disallowed_STD3_mapped", [40, 49, 56, 41]], [[9350, 9350], "disallowed_STD3_mapped", [40, 49, 57, 41]], [[9351, 9351], "disallowed_STD3_mapped", [40, 50, 48, 41]], [[9352, 9371], "disallowed"], [[9372, 9372], "disallowed_STD3_mapped", [40, 97, 41]], [[9373, 9373], "disallowed_STD3_mapped", [40, 98, 41]], [[9374, 9374], "disallowed_STD3_mapped", [40, 99, 41]], [[9375, 9375], "disallowed_STD3_mapped", [40, 100, 41]], [[9376, 9376], "disallowed_STD3_mapped", [40, 101, 41]], [[9377, 9377], "disallowed_STD3_mapped", [40, 102, 41]], [[9378, 9378], "disallowed_STD3_mapped", [40, 103, 41]], [[9379, 9379], "disallowed_STD3_mapped", [40, 104, 41]], [[9380, 9380], "disallowed_STD3_mapped", [40, 105, 41]], [[9381, 9381], "disallowed_STD3_mapped", [40, 106, 41]], [[9382, 9382], "disallowed_STD3_mapped", [40, 107, 41]], [[9383, 9383], "disallowed_STD3_mapped", [40, 108, 41]], [[9384, 9384], "disallowed_STD3_mapped", [40, 109, 41]], [[9385, 9385], "disallowed_STD3_mapped", [40, 110, 41]], [[9386, 9386], "disallowed_STD3_mapped", [40, 111, 41]], [[9387, 9387], "disallowed_STD3_mapped", [40, 112, 41]], [[9388, 9388], "disallowed_STD3_mapped", [40, 113, 41]], [[9389, 9389], "disallowed_STD3_mapped", [40, 114, 41]], [[9390, 9390], "disallowed_STD3_mapped", [40, 115, 41]], [[9391, 9391], "disallowed_STD3_mapped", [40, 116, 41]], [[9392, 9392], "disallowed_STD3_mapped", [40, 117, 41]], [[9393, 9393], "disallowed_STD3_mapped", [40, 118, 41]], [[9394, 9394], "disallowed_STD3_mapped", [40, 119, 41]], [[9395, 9395], "disallowed_STD3_mapped", [40, 120, 41]], [[9396, 9396], "disallowed_STD3_mapped", [40, 121, 41]], [[9397, 9397], "disallowed_STD3_mapped", [40, 122, 41]], [[9398, 9398], "mapped", [97]], [[9399, 9399], "mapped", [98]], [[9400, 9400], "mapped", [99]], [[9401, 9401], "mapped", [100]], [[9402, 9402], "mapped", [101]], [[9403, 9403], "mapped", [102]], [[9404, 9404], "mapped", [103]], [[9405, 9405], "mapped", [104]], [[9406, 9406], "mapped", [105]], [[9407, 9407], "mapped", [106]], [[9408, 9408], "mapped", [107]], [[9409, 9409], "mapped", [108]], [[9410, 9410], "mapped", [109]], [[9411, 9411], "mapped", [110]], [[9412, 9412], "mapped", [111]], [[9413, 9413], "mapped", [112]], [[9414, 9414], "mapped", [113]], [[9415, 9415], "mapped", [114]], [[9416, 9416], "mapped", [115]], [[9417, 9417], "mapped", [116]], [[9418, 9418], "mapped", [117]], [[9419, 9419], "mapped", [118]], [[9420, 9420], "mapped", [119]], [[9421, 9421], "mapped", [120]], [[9422, 9422], "mapped", [121]], [[9423, 9423], "mapped", [122]], [[9424, 9424], "mapped", [97]], [[9425, 9425], "mapped", [98]], [[9426, 9426], "mapped", [99]], [[9427, 9427], "mapped", [100]], [[9428, 9428], "mapped", [101]], [[9429, 9429], "mapped", [102]], [[9430, 9430], "mapped", [103]], [[9431, 9431], "mapped", [104]], [[9432, 9432], "mapped", [105]], [[9433, 9433], "mapped", [106]], [[9434, 9434], "mapped", [107]], [[9435, 9435], "mapped", [108]], [[9436, 9436], "mapped", [109]], [[9437, 9437], "mapped", [110]], [[9438, 9438], "mapped", [111]], [[9439, 9439], "mapped", [112]], [[9440, 9440], "mapped", [113]], [[9441, 9441], "mapped", [114]], [[9442, 9442], "mapped", [115]], [[9443, 9443], "mapped", [116]], [[9444, 9444], "mapped", [117]], [[9445, 9445], "mapped", [118]], [[9446, 9446], "mapped", [119]], [[9447, 9447], "mapped", [120]], [[9448, 9448], "mapped", [121]], [[9449, 9449], "mapped", [122]], [[9450, 9450], "mapped", [48]], [[9451, 9470], "valid", [], "NV8"], [[9471, 9471], "valid", [], "NV8"], [[9472, 9621], "valid", [], "NV8"], [[9622, 9631], "valid", [], "NV8"], [[9632, 9711], "valid", [], "NV8"], [[9712, 9719], "valid", [], "NV8"], [[9720, 9727], "valid", [], "NV8"], [[9728, 9747], "valid", [], "NV8"], [[9748, 9749], "valid", [], "NV8"], [[9750, 9751], "valid", [], "NV8"], [[9752, 9752], "valid", [], "NV8"], [[9753, 9753], "valid", [], "NV8"], [[9754, 9839], "valid", [], "NV8"], [[9840, 9841], "valid", [], "NV8"], [[9842, 9853], "valid", [], "NV8"], [[9854, 9855], "valid", [], "NV8"], [[9856, 9865], "valid", [], "NV8"], [[9866, 9873], "valid", [], "NV8"], [[9874, 9884], "valid", [], "NV8"], [[9885, 9885], "valid", [], "NV8"], [[9886, 9887], "valid", [], "NV8"], [[9888, 9889], "valid", [], "NV8"], [[9890, 9905], "valid", [], "NV8"], [[9906, 9906], "valid", [], "NV8"], [[9907, 9916], "valid", [], "NV8"], [[9917, 9919], "valid", [], "NV8"], [[9920, 9923], "valid", [], "NV8"], [[9924, 9933], "valid", [], "NV8"], [[9934, 9934], "valid", [], "NV8"], [[9935, 9953], "valid", [], "NV8"], [[9954, 9954], "valid", [], "NV8"], [[9955, 9955], "valid", [], "NV8"], [[9956, 9959], "valid", [], "NV8"], [[9960, 9983], "valid", [], "NV8"], [[9984, 9984], "valid", [], "NV8"], [[9985, 9988], "valid", [], "NV8"], [[9989, 9989], "valid", [], "NV8"], [[9990, 9993], "valid", [], "NV8"], [[9994, 9995], "valid", [], "NV8"], [[9996, 10023], "valid", [], "NV8"], [[10024, 10024], "valid", [], "NV8"], [[10025, 10059], "valid", [], "NV8"], [[10060, 10060], "valid", [], "NV8"], [[10061, 10061], "valid", [], "NV8"], [[10062, 10062], "valid", [], "NV8"], [[10063, 10066], "valid", [], "NV8"], [[10067, 10069], "valid", [], "NV8"], [[10070, 10070], "valid", [], "NV8"], [[10071, 10071], "valid", [], "NV8"], [[10072, 10078], "valid", [], "NV8"], [[10079, 10080], "valid", [], "NV8"], [[10081, 10087], "valid", [], "NV8"], [[10088, 10101], "valid", [], "NV8"], [[10102, 10132], "valid", [], "NV8"], [[10133, 10135], "valid", [], "NV8"], [[10136, 10159], "valid", [], "NV8"], [[10160, 10160], "valid", [], "NV8"], [[10161, 10174], "valid", [], "NV8"], [[10175, 10175], "valid", [], "NV8"], [[10176, 10182], "valid", [], "NV8"], [[10183, 10186], "valid", [], "NV8"], [[10187, 10187], "valid", [], "NV8"], [[10188, 10188], "valid", [], "NV8"], [[10189, 10189], "valid", [], "NV8"], [[10190, 10191], "valid", [], "NV8"], [[10192, 10219], "valid", [], "NV8"], [[10220, 10223], "valid", [], "NV8"], [[10224, 10239], "valid", [], "NV8"], [[10240, 10495], "valid", [], "NV8"], [[10496, 10763], "valid", [], "NV8"], [[10764, 10764], "mapped", [8747, 8747, 8747, 8747]], [[10765, 10867], "valid", [], "NV8"], [[10868, 10868], "disallowed_STD3_mapped", [58, 58, 61]], [[10869, 10869], "disallowed_STD3_mapped", [61, 61]], [[10870, 10870], "disallowed_STD3_mapped", [61, 61, 61]], [[10871, 10971], "valid", [], "NV8"], [[10972, 10972], "mapped", [10973, 824]], [[10973, 11007], "valid", [], "NV8"], [[11008, 11021], "valid", [], "NV8"], [[11022, 11027], "valid", [], "NV8"], [[11028, 11034], "valid", [], "NV8"], [[11035, 11039], "valid", [], "NV8"], [[11040, 11043], "valid", [], "NV8"], [[11044, 11084], "valid", [], "NV8"], [[11085, 11087], "valid", [], "NV8"], [[11088, 11092], "valid", [], "NV8"], [[11093, 11097], "valid", [], "NV8"], [[11098, 11123], "valid", [], "NV8"], [[11124, 11125], "disallowed"], [[11126, 11157], "valid", [], "NV8"], [[11158, 11159], "disallowed"], [[11160, 11193], "valid", [], "NV8"], [[11194, 11196], "disallowed"], [[11197, 11208], "valid", [], "NV8"], [[11209, 11209], "disallowed"], [[11210, 11217], "valid", [], "NV8"], [[11218, 11243], "disallowed"], [[11244, 11247], "valid", [], "NV8"], [[11248, 11263], "disallowed"], [[11264, 11264], "mapped", [11312]], [[11265, 11265], "mapped", [11313]], [[11266, 11266], "mapped", [11314]], [[11267, 11267], "mapped", [11315]], [[11268, 11268], "mapped", [11316]], [[11269, 11269], "mapped", [11317]], [[11270, 11270], "mapped", [11318]], [[11271, 11271], "mapped", [11319]], [[11272, 11272], "mapped", [11320]], [[11273, 11273], "mapped", [11321]], [[11274, 11274], "mapped", [11322]], [[11275, 11275], "mapped", [11323]], [[11276, 11276], "mapped", [11324]], [[11277, 11277], "mapped", [11325]], [[11278, 11278], "mapped", [11326]], [[11279, 11279], "mapped", [11327]], [[11280, 11280], "mapped", [11328]], [[11281, 11281], "mapped", [11329]], [[11282, 11282], "mapped", [11330]], [[11283, 11283], "mapped", [11331]], [[11284, 11284], "mapped", [11332]], [[11285, 11285], "mapped", [11333]], [[11286, 11286], "mapped", [11334]], [[11287, 11287], "mapped", [11335]], [[11288, 11288], "mapped", [11336]], [[11289, 11289], "mapped", [11337]], [[11290, 11290], "mapped", [11338]], [[11291, 11291], "mapped", [11339]], [[11292, 11292], "mapped", [11340]], [[11293, 11293], "mapped", [11341]], [[11294, 11294], "mapped", [11342]], [[11295, 11295], "mapped", [11343]], [[11296, 11296], "mapped", [11344]], [[11297, 11297], "mapped", [11345]], [[11298, 11298], "mapped", [11346]], [[11299, 11299], "mapped", [11347]], [[11300, 11300], "mapped", [11348]], [[11301, 11301], "mapped", [11349]], [[11302, 11302], "mapped", [11350]], [[11303, 11303], "mapped", [11351]], [[11304, 11304], "mapped", [11352]], [[11305, 11305], "mapped", [11353]], [[11306, 11306], "mapped", [11354]], [[11307, 11307], "mapped", [11355]], [[11308, 11308], "mapped", [11356]], [[11309, 11309], "mapped", [11357]], [[11310, 11310], "mapped", [11358]], [[11311, 11311], "disallowed"], [[11312, 11358], "valid"], [[11359, 11359], "disallowed"], [[11360, 11360], "mapped", [11361]], [[11361, 11361], "valid"], [[11362, 11362], "mapped", [619]], [[11363, 11363], "mapped", [7549]], [[11364, 11364], "mapped", [637]], [[11365, 11366], "valid"], [[11367, 11367], "mapped", [11368]], [[11368, 11368], "valid"], [[11369, 11369], "mapped", [11370]], [[11370, 11370], "valid"], [[11371, 11371], "mapped", [11372]], [[11372, 11372], "valid"], [[11373, 11373], "mapped", [593]], [[11374, 11374], "mapped", [625]], [[11375, 11375], "mapped", [592]], [[11376, 11376], "mapped", [594]], [[11377, 11377], "valid"], [[11378, 11378], "mapped", [11379]], [[11379, 11379], "valid"], [[11380, 11380], "valid"], [[11381, 11381], "mapped", [11382]], [[11382, 11383], "valid"], [[11384, 11387], "valid"], [[11388, 11388], "mapped", [106]], [[11389, 11389], "mapped", [118]], [[11390, 11390], "mapped", [575]], [[11391, 11391], "mapped", [576]], [[11392, 11392], "mapped", [11393]], [[11393, 11393], "valid"], [[11394, 11394], "mapped", [11395]], [[11395, 11395], "valid"], [[11396, 11396], "mapped", [11397]], [[11397, 11397], "valid"], [[11398, 11398], "mapped", [11399]], [[11399, 11399], "valid"], [[11400, 11400], "mapped", [11401]], [[11401, 11401], "valid"], [[11402, 11402], "mapped", [11403]], [[11403, 11403], "valid"], [[11404, 11404], "mapped", [11405]], [[11405, 11405], "valid"], [[11406, 11406], "mapped", [11407]], [[11407, 11407], "valid"], [[11408, 11408], "mapped", [11409]], [[11409, 11409], "valid"], [[11410, 11410], "mapped", [11411]], [[11411, 11411], "valid"], [[11412, 11412], "mapped", [11413]], [[11413, 11413], "valid"], [[11414, 11414], "mapped", [11415]], [[11415, 11415], "valid"], [[11416, 11416], "mapped", [11417]], [[11417, 11417], "valid"], [[11418, 11418], "mapped", [11419]], [[11419, 11419], "valid"], [[11420, 11420], "mapped", [11421]], [[11421, 11421], "valid"], [[11422, 11422], "mapped", [11423]], [[11423, 11423], "valid"], [[11424, 11424], "mapped", [11425]], [[11425, 11425], "valid"], [[11426, 11426], "mapped", [11427]], [[11427, 11427], "valid"], [[11428, 11428], "mapped", [11429]], [[11429, 11429], "valid"], [[11430, 11430], "mapped", [11431]], [[11431, 11431], "valid"], [[11432, 11432], "mapped", [11433]], [[11433, 11433], "valid"], [[11434, 11434], "mapped", [11435]], [[11435, 11435], "valid"], [[11436, 11436], "mapped", [11437]], [[11437, 11437], "valid"], [[11438, 11438], "mapped", [11439]], [[11439, 11439], "valid"], [[11440, 11440], "mapped", [11441]], [[11441, 11441], "valid"], [[11442, 11442], "mapped", [11443]], [[11443, 11443], "valid"], [[11444, 11444], "mapped", [11445]], [[11445, 11445], "valid"], [[11446, 11446], "mapped", [11447]], [[11447, 11447], "valid"], [[11448, 11448], "mapped", [11449]], [[11449, 11449], "valid"], [[11450, 11450], "mapped", [11451]], [[11451, 11451], "valid"], [[11452, 11452], "mapped", [11453]], [[11453, 11453], "valid"], [[11454, 11454], "mapped", [11455]], [[11455, 11455], "valid"], [[11456, 11456], "mapped", [11457]], [[11457, 11457], "valid"], [[11458, 11458], "mapped", [11459]], [[11459, 11459], "valid"], [[11460, 11460], "mapped", [11461]], [[11461, 11461], "valid"], [[11462, 11462], "mapped", [11463]], [[11463, 11463], "valid"], [[11464, 11464], "mapped", [11465]], [[11465, 11465], "valid"], [[11466, 11466], "mapped", [11467]], [[11467, 11467], "valid"], [[11468, 11468], "mapped", [11469]], [[11469, 11469], "valid"], [[11470, 11470], "mapped", [11471]], [[11471, 11471], "valid"], [[11472, 11472], "mapped", [11473]], [[11473, 11473], "valid"], [[11474, 11474], "mapped", [11475]], [[11475, 11475], "valid"], [[11476, 11476], "mapped", [11477]], [[11477, 11477], "valid"], [[11478, 11478], "mapped", [11479]], [[11479, 11479], "valid"], [[11480, 11480], "mapped", [11481]], [[11481, 11481], "valid"], [[11482, 11482], "mapped", [11483]], [[11483, 11483], "valid"], [[11484, 11484], "mapped", [11485]], [[11485, 11485], "valid"], [[11486, 11486], "mapped", [11487]], [[11487, 11487], "valid"], [[11488, 11488], "mapped", [11489]], [[11489, 11489], "valid"], [[11490, 11490], "mapped", [11491]], [[11491, 11492], "valid"], [[11493, 11498], "valid", [], "NV8"], [[11499, 11499], "mapped", [11500]], [[11500, 11500], "valid"], [[11501, 11501], "mapped", [11502]], [[11502, 11505], "valid"], [[11506, 11506], "mapped", [11507]], [[11507, 11507], "valid"], [[11508, 11512], "disallowed"], [[11513, 11519], "valid", [], "NV8"], [[11520, 11557], "valid"], [[11558, 11558], "disallowed"], [[11559, 11559], "valid"], [[11560, 11564], "disallowed"], [[11565, 11565], "valid"], [[11566, 11567], "disallowed"], [[11568, 11621], "valid"], [[11622, 11623], "valid"], [[11624, 11630], "disallowed"], [[11631, 11631], "mapped", [11617]], [[11632, 11632], "valid", [], "NV8"], [[11633, 11646], "disallowed"], [[11647, 11647], "valid"], [[11648, 11670], "valid"], [[11671, 11679], "disallowed"], [[11680, 11686], "valid"], [[11687, 11687], "disallowed"], [[11688, 11694], "valid"], [[11695, 11695], "disallowed"], [[11696, 11702], "valid"], [[11703, 11703], "disallowed"], [[11704, 11710], "valid"], [[11711, 11711], "disallowed"], [[11712, 11718], "valid"], [[11719, 11719], "disallowed"], [[11720, 11726], "valid"], [[11727, 11727], "disallowed"], [[11728, 11734], "valid"], [[11735, 11735], "disallowed"], [[11736, 11742], "valid"], [[11743, 11743], "disallowed"], [[11744, 11775], "valid"], [[11776, 11799], "valid", [], "NV8"], [[11800, 11803], "valid", [], "NV8"], [[11804, 11805], "valid", [], "NV8"], [[11806, 11822], "valid", [], "NV8"], [[11823, 11823], "valid"], [[11824, 11824], "valid", [], "NV8"], [[11825, 11825], "valid", [], "NV8"], [[11826, 11835], "valid", [], "NV8"], [[11836, 11842], "valid", [], "NV8"], [[11843, 11903], "disallowed"], [[11904, 11929], "valid", [], "NV8"], [[11930, 11930], "disallowed"], [[11931, 11934], "valid", [], "NV8"], [[11935, 11935], "mapped", [27597]], [[11936, 12018], "valid", [], "NV8"], [[12019, 12019], "mapped", [40863]], [[12020, 12031], "disallowed"], [[12032, 12032], "mapped", [19968]], [[12033, 12033], "mapped", [20008]], [[12034, 12034], "mapped", [20022]], [[12035, 12035], "mapped", [20031]], [[12036, 12036], "mapped", [20057]], [[12037, 12037], "mapped", [20101]], [[12038, 12038], "mapped", [20108]], [[12039, 12039], "mapped", [20128]], [[12040, 12040], "mapped", [20154]], [[12041, 12041], "mapped", [20799]], [[12042, 12042], "mapped", [20837]], [[12043, 12043], "mapped", [20843]], [[12044, 12044], "mapped", [20866]], [[12045, 12045], "mapped", [20886]], [[12046, 12046], "mapped", [20907]], [[12047, 12047], "mapped", [20960]], [[12048, 12048], "mapped", [20981]], [[12049, 12049], "mapped", [20992]], [[12050, 12050], "mapped", [21147]], [[12051, 12051], "mapped", [21241]], [[12052, 12052], "mapped", [21269]], [[12053, 12053], "mapped", [21274]], [[12054, 12054], "mapped", [21304]], [[12055, 12055], "mapped", [21313]], [[12056, 12056], "mapped", [21340]], [[12057, 12057], "mapped", [21353]], [[12058, 12058], "mapped", [21378]], [[12059, 12059], "mapped", [21430]], [[12060, 12060], "mapped", [21448]], [[12061, 12061], "mapped", [21475]], [[12062, 12062], "mapped", [22231]], [[12063, 12063], "mapped", [22303]], [[12064, 12064], "mapped", [22763]], [[12065, 12065], "mapped", [22786]], [[12066, 12066], "mapped", [22794]], [[12067, 12067], "mapped", [22805]], [[12068, 12068], "mapped", [22823]], [[12069, 12069], "mapped", [22899]], [[12070, 12070], "mapped", [23376]], [[12071, 12071], "mapped", [23424]], [[12072, 12072], "mapped", [23544]], [[12073, 12073], "mapped", [23567]], [[12074, 12074], "mapped", [23586]], [[12075, 12075], "mapped", [23608]], [[12076, 12076], "mapped", [23662]], [[12077, 12077], "mapped", [23665]], [[12078, 12078], "mapped", [24027]], [[12079, 12079], "mapped", [24037]], [[12080, 12080], "mapped", [24049]], [[12081, 12081], "mapped", [24062]], [[12082, 12082], "mapped", [24178]], [[12083, 12083], "mapped", [24186]], [[12084, 12084], "mapped", [24191]], [[12085, 12085], "mapped", [24308]], [[12086, 12086], "mapped", [24318]], [[12087, 12087], "mapped", [24331]], [[12088, 12088], "mapped", [24339]], [[12089, 12089], "mapped", [24400]], [[12090, 12090], "mapped", [24417]], [[12091, 12091], "mapped", [24435]], [[12092, 12092], "mapped", [24515]], [[12093, 12093], "mapped", [25096]], [[12094, 12094], "mapped", [25142]], [[12095, 12095], "mapped", [25163]], [[12096, 12096], "mapped", [25903]], [[12097, 12097], "mapped", [25908]], [[12098, 12098], "mapped", [25991]], [[12099, 12099], "mapped", [26007]], [[12100, 12100], "mapped", [26020]], [[12101, 12101], "mapped", [26041]], [[12102, 12102], "mapped", [26080]], [[12103, 12103], "mapped", [26085]], [[12104, 12104], "mapped", [26352]], [[12105, 12105], "mapped", [26376]], [[12106, 12106], "mapped", [26408]], [[12107, 12107], "mapped", [27424]], [[12108, 12108], "mapped", [27490]], [[12109, 12109], "mapped", [27513]], [[12110, 12110], "mapped", [27571]], [[12111, 12111], "mapped", [27595]], [[12112, 12112], "mapped", [27604]], [[12113, 12113], "mapped", [27611]], [[12114, 12114], "mapped", [27663]], [[12115, 12115], "mapped", [27668]], [[12116, 12116], "mapped", [27700]], [[12117, 12117], "mapped", [28779]], [[12118, 12118], "mapped", [29226]], [[12119, 12119], "mapped", [29238]], [[12120, 12120], "mapped", [29243]], [[12121, 12121], "mapped", [29247]], [[12122, 12122], "mapped", [29255]], [[12123, 12123], "mapped", [29273]], [[12124, 12124], "mapped", [29275]], [[12125, 12125], "mapped", [29356]], [[12126, 12126], "mapped", [29572]], [[12127, 12127], "mapped", [29577]], [[12128, 12128], "mapped", [29916]], [[12129, 12129], "mapped", [29926]], [[12130, 12130], "mapped", [29976]], [[12131, 12131], "mapped", [29983]], [[12132, 12132], "mapped", [29992]], [[12133, 12133], "mapped", [30000]], [[12134, 12134], "mapped", [30091]], [[12135, 12135], "mapped", [30098]], [[12136, 12136], "mapped", [30326]], [[12137, 12137], "mapped", [30333]], [[12138, 12138], "mapped", [30382]], [[12139, 12139], "mapped", [30399]], [[12140, 12140], "mapped", [30446]], [[12141, 12141], "mapped", [30683]], [[12142, 12142], "mapped", [30690]], [[12143, 12143], "mapped", [30707]], [[12144, 12144], "mapped", [31034]], [[12145, 12145], "mapped", [31160]], [[12146, 12146], "mapped", [31166]], [[12147, 12147], "mapped", [31348]], [[12148, 12148], "mapped", [31435]], [[12149, 12149], "mapped", [31481]], [[12150, 12150], "mapped", [31859]], [[12151, 12151], "mapped", [31992]], [[12152, 12152], "mapped", [32566]], [[12153, 12153], "mapped", [32593]], [[12154, 12154], "mapped", [32650]], [[12155, 12155], "mapped", [32701]], [[12156, 12156], "mapped", [32769]], [[12157, 12157], "mapped", [32780]], [[12158, 12158], "mapped", [32786]], [[12159, 12159], "mapped", [32819]], [[12160, 12160], "mapped", [32895]], [[12161, 12161], "mapped", [32905]], [[12162, 12162], "mapped", [33251]], [[12163, 12163], "mapped", [33258]], [[12164, 12164], "mapped", [33267]], [[12165, 12165], "mapped", [33276]], [[12166, 12166], "mapped", [33292]], [[12167, 12167], "mapped", [33307]], [[12168, 12168], "mapped", [33311]], [[12169, 12169], "mapped", [33390]], [[12170, 12170], "mapped", [33394]], [[12171, 12171], "mapped", [33400]], [[12172, 12172], "mapped", [34381]], [[12173, 12173], "mapped", [34411]], [[12174, 12174], "mapped", [34880]], [[12175, 12175], "mapped", [34892]], [[12176, 12176], "mapped", [34915]], [[12177, 12177], "mapped", [35198]], [[12178, 12178], "mapped", [35211]], [[12179, 12179], "mapped", [35282]], [[12180, 12180], "mapped", [35328]], [[12181, 12181], "mapped", [35895]], [[12182, 12182], "mapped", [35910]], [[12183, 12183], "mapped", [35925]], [[12184, 12184], "mapped", [35960]], [[12185, 12185], "mapped", [35997]], [[12186, 12186], "mapped", [36196]], [[12187, 12187], "mapped", [36208]], [[12188, 12188], "mapped", [36275]], [[12189, 12189], "mapped", [36523]], [[12190, 12190], "mapped", [36554]], [[12191, 12191], "mapped", [36763]], [[12192, 12192], "mapped", [36784]], [[12193, 12193], "mapped", [36789]], [[12194, 12194], "mapped", [37009]], [[12195, 12195], "mapped", [37193]], [[12196, 12196], "mapped", [37318]], [[12197, 12197], "mapped", [37324]], [[12198, 12198], "mapped", [37329]], [[12199, 12199], "mapped", [38263]], [[12200, 12200], "mapped", [38272]], [[12201, 12201], "mapped", [38428]], [[12202, 12202], "mapped", [38582]], [[12203, 12203], "mapped", [38585]], [[12204, 12204], "mapped", [38632]], [[12205, 12205], "mapped", [38737]], [[12206, 12206], "mapped", [38750]], [[12207, 12207], "mapped", [38754]], [[12208, 12208], "mapped", [38761]], [[12209, 12209], "mapped", [38859]], [[12210, 12210], "mapped", [38893]], [[12211, 12211], "mapped", [38899]], [[12212, 12212], "mapped", [38913]], [[12213, 12213], "mapped", [39080]], [[12214, 12214], "mapped", [39131]], [[12215, 12215], "mapped", [39135]], [[12216, 12216], "mapped", [39318]], [[12217, 12217], "mapped", [39321]], [[12218, 12218], "mapped", [39340]], [[12219, 12219], "mapped", [39592]], [[12220, 12220], "mapped", [39640]], [[12221, 12221], "mapped", [39647]], [[12222, 12222], "mapped", [39717]], [[12223, 12223], "mapped", [39727]], [[12224, 12224], "mapped", [39730]], [[12225, 12225], "mapped", [39740]], [[12226, 12226], "mapped", [39770]], [[12227, 12227], "mapped", [40165]], [[12228, 12228], "mapped", [40565]], [[12229, 12229], "mapped", [40575]], [[12230, 12230], "mapped", [40613]], [[12231, 12231], "mapped", [40635]], [[12232, 12232], "mapped", [40643]], [[12233, 12233], "mapped", [40653]], [[12234, 12234], "mapped", [40657]], [[12235, 12235], "mapped", [40697]], [[12236, 12236], "mapped", [40701]], [[12237, 12237], "mapped", [40718]], [[12238, 12238], "mapped", [40723]], [[12239, 12239], "mapped", [40736]], [[12240, 12240], "mapped", [40763]], [[12241, 12241], "mapped", [40778]], [[12242, 12242], "mapped", [40786]], [[12243, 12243], "mapped", [40845]], [[12244, 12244], "mapped", [40860]], [[12245, 12245], "mapped", [40864]], [[12246, 12271], "disallowed"], [[12272, 12283], "disallowed"], [[12284, 12287], "disallowed"], [[12288, 12288], "disallowed_STD3_mapped", [32]], [[12289, 12289], "valid", [], "NV8"], [[12290, 12290], "mapped", [46]], [[12291, 12292], "valid", [], "NV8"], [[12293, 12295], "valid"], [[12296, 12329], "valid", [], "NV8"], [[12330, 12333], "valid"], [[12334, 12341], "valid", [], "NV8"], [[12342, 12342], "mapped", [12306]], [[12343, 12343], "valid", [], "NV8"], [[12344, 12344], "mapped", [21313]], [[12345, 12345], "mapped", [21316]], [[12346, 12346], "mapped", [21317]], [[12347, 12347], "valid", [], "NV8"], [[12348, 12348], "valid"], [[12349, 12349], "valid", [], "NV8"], [[12350, 12350], "valid", [], "NV8"], [[12351, 12351], "valid", [], "NV8"], [[12352, 12352], "disallowed"], [[12353, 12436], "valid"], [[12437, 12438], "valid"], [[12439, 12440], "disallowed"], [[12441, 12442], "valid"], [[12443, 12443], "disallowed_STD3_mapped", [32, 12441]], [[12444, 12444], "disallowed_STD3_mapped", [32, 12442]], [[12445, 12446], "valid"], [[12447, 12447], "mapped", [12424, 12426]], [[12448, 12448], "valid", [], "NV8"], [[12449, 12542], "valid"], [[12543, 12543], "mapped", [12467, 12488]], [[12544, 12548], "disallowed"], [[12549, 12588], "valid"], [[12589, 12589], "valid"], [[12590, 12592], "disallowed"], [[12593, 12593], "mapped", [4352]], [[12594, 12594], "mapped", [4353]], [[12595, 12595], "mapped", [4522]], [[12596, 12596], "mapped", [4354]], [[12597, 12597], "mapped", [4524]], [[12598, 12598], "mapped", [4525]], [[12599, 12599], "mapped", [4355]], [[12600, 12600], "mapped", [4356]], [[12601, 12601], "mapped", [4357]], [[12602, 12602], "mapped", [4528]], [[12603, 12603], "mapped", [4529]], [[12604, 12604], "mapped", [4530]], [[12605, 12605], "mapped", [4531]], [[12606, 12606], "mapped", [4532]], [[12607, 12607], "mapped", [4533]], [[12608, 12608], "mapped", [4378]], [[12609, 12609], "mapped", [4358]], [[12610, 12610], "mapped", [4359]], [[12611, 12611], "mapped", [4360]], [[12612, 12612], "mapped", [4385]], [[12613, 12613], "mapped", [4361]], [[12614, 12614], "mapped", [4362]], [[12615, 12615], "mapped", [4363]], [[12616, 12616], "mapped", [4364]], [[12617, 12617], "mapped", [4365]], [[12618, 12618], "mapped", [4366]], [[12619, 12619], "mapped", [4367]], [[12620, 12620], "mapped", [4368]], [[12621, 12621], "mapped", [4369]], [[12622, 12622], "mapped", [4370]], [[12623, 12623], "mapped", [4449]], [[12624, 12624], "mapped", [4450]], [[12625, 12625], "mapped", [4451]], [[12626, 12626], "mapped", [4452]], [[12627, 12627], "mapped", [4453]], [[12628, 12628], "mapped", [4454]], [[12629, 12629], "mapped", [4455]], [[12630, 12630], "mapped", [4456]], [[12631, 12631], "mapped", [4457]], [[12632, 12632], "mapped", [4458]], [[12633, 12633], "mapped", [4459]], [[12634, 12634], "mapped", [4460]], [[12635, 12635], "mapped", [4461]], [[12636, 12636], "mapped", [4462]], [[12637, 12637], "mapped", [4463]], [[12638, 12638], "mapped", [4464]], [[12639, 12639], "mapped", [4465]], [[12640, 12640], "mapped", [4466]], [[12641, 12641], "mapped", [4467]], [[12642, 12642], "mapped", [4468]], [[12643, 12643], "mapped", [4469]], [[12644, 12644], "disallowed"], [[12645, 12645], "mapped", [4372]], [[12646, 12646], "mapped", [4373]], [[12647, 12647], "mapped", [4551]], [[12648, 12648], "mapped", [4552]], [[12649, 12649], "mapped", [4556]], [[12650, 12650], "mapped", [4558]], [[12651, 12651], "mapped", [4563]], [[12652, 12652], "mapped", [4567]], [[12653, 12653], "mapped", [4569]], [[12654, 12654], "mapped", [4380]], [[12655, 12655], "mapped", [4573]], [[12656, 12656], "mapped", [4575]], [[12657, 12657], "mapped", [4381]], [[12658, 12658], "mapped", [4382]], [[12659, 12659], "mapped", [4384]], [[12660, 12660], "mapped", [4386]], [[12661, 12661], "mapped", [4387]], [[12662, 12662], "mapped", [4391]], [[12663, 12663], "mapped", [4393]], [[12664, 12664], "mapped", [4395]], [[12665, 12665], "mapped", [4396]], [[12666, 12666], "mapped", [4397]], [[12667, 12667], "mapped", [4398]], [[12668, 12668], "mapped", [4399]], [[12669, 12669], "mapped", [4402]], [[12670, 12670], "mapped", [4406]], [[12671, 12671], "mapped", [4416]], [[12672, 12672], "mapped", [4423]], [[12673, 12673], "mapped", [4428]], [[12674, 12674], "mapped", [4593]], [[12675, 12675], "mapped", [4594]], [[12676, 12676], "mapped", [4439]], [[12677, 12677], "mapped", [4440]], [[12678, 12678], "mapped", [4441]], [[12679, 12679], "mapped", [4484]], [[12680, 12680], "mapped", [4485]], [[12681, 12681], "mapped", [4488]], [[12682, 12682], "mapped", [4497]], [[12683, 12683], "mapped", [4498]], [[12684, 12684], "mapped", [4500]], [[12685, 12685], "mapped", [4510]], [[12686, 12686], "mapped", [4513]], [[12687, 12687], "disallowed"], [[12688, 12689], "valid", [], "NV8"], [[12690, 12690], "mapped", [19968]], [[12691, 12691], "mapped", [20108]], [[12692, 12692], "mapped", [19977]], [[12693, 12693], "mapped", [22235]], [[12694, 12694], "mapped", [19978]], [[12695, 12695], "mapped", [20013]], [[12696, 12696], "mapped", [19979]], [[12697, 12697], "mapped", [30002]], [[12698, 12698], "mapped", [20057]], [[12699, 12699], "mapped", [19993]], [[12700, 12700], "mapped", [19969]], [[12701, 12701], "mapped", [22825]], [[12702, 12702], "mapped", [22320]], [[12703, 12703], "mapped", [20154]], [[12704, 12727], "valid"], [[12728, 12730], "valid"], [[12731, 12735], "disallowed"], [[12736, 12751], "valid", [], "NV8"], [[12752, 12771], "valid", [], "NV8"], [[12772, 12783], "disallowed"], [[12784, 12799], "valid"], [[12800, 12800], "disallowed_STD3_mapped", [40, 4352, 41]], [[12801, 12801], "disallowed_STD3_mapped", [40, 4354, 41]], [[12802, 12802], "disallowed_STD3_mapped", [40, 4355, 41]], [[12803, 12803], "disallowed_STD3_mapped", [40, 4357, 41]], [[12804, 12804], "disallowed_STD3_mapped", [40, 4358, 41]], [[12805, 12805], "disallowed_STD3_mapped", [40, 4359, 41]], [[12806, 12806], "disallowed_STD3_mapped", [40, 4361, 41]], [[12807, 12807], "disallowed_STD3_mapped", [40, 4363, 41]], [[12808, 12808], "disallowed_STD3_mapped", [40, 4364, 41]], [[12809, 12809], "disallowed_STD3_mapped", [40, 4366, 41]], [[12810, 12810], "disallowed_STD3_mapped", [40, 4367, 41]], [[12811, 12811], "disallowed_STD3_mapped", [40, 4368, 41]], [[12812, 12812], "disallowed_STD3_mapped", [40, 4369, 41]], [[12813, 12813], "disallowed_STD3_mapped", [40, 4370, 41]], [[12814, 12814], "disallowed_STD3_mapped", [40, 44032, 41]], [[12815, 12815], "disallowed_STD3_mapped", [40, 45208, 41]], [[12816, 12816], "disallowed_STD3_mapped", [40, 45796, 41]], [[12817, 12817], "disallowed_STD3_mapped", [40, 46972, 41]], [[12818, 12818], "disallowed_STD3_mapped", [40, 47560, 41]], [[12819, 12819], "disallowed_STD3_mapped", [40, 48148, 41]], [[12820, 12820], "disallowed_STD3_mapped", [40, 49324, 41]], [[12821, 12821], "disallowed_STD3_mapped", [40, 50500, 41]], [[12822, 12822], "disallowed_STD3_mapped", [40, 51088, 41]], [[12823, 12823], "disallowed_STD3_mapped", [40, 52264, 41]], [[12824, 12824], "disallowed_STD3_mapped", [40, 52852, 41]], [[12825, 12825], "disallowed_STD3_mapped", [40, 53440, 41]], [[12826, 12826], "disallowed_STD3_mapped", [40, 54028, 41]], [[12827, 12827], "disallowed_STD3_mapped", [40, 54616, 41]], [[12828, 12828], "disallowed_STD3_mapped", [40, 51452, 41]], [[12829, 12829], "disallowed_STD3_mapped", [40, 50724, 51204, 41]], [[12830, 12830], "disallowed_STD3_mapped", [40, 50724, 54980, 41]], [[12831, 12831], "disallowed"], [[12832, 12832], "disallowed_STD3_mapped", [40, 19968, 41]], [[12833, 12833], "disallowed_STD3_mapped", [40, 20108, 41]], [[12834, 12834], "disallowed_STD3_mapped", [40, 19977, 41]], [[12835, 12835], "disallowed_STD3_mapped", [40, 22235, 41]], [[12836, 12836], "disallowed_STD3_mapped", [40, 20116, 41]], [[12837, 12837], "disallowed_STD3_mapped", [40, 20845, 41]], [[12838, 12838], "disallowed_STD3_mapped", [40, 19971, 41]], [[12839, 12839], "disallowed_STD3_mapped", [40, 20843, 41]], [[12840, 12840], "disallowed_STD3_mapped", [40, 20061, 41]], [[12841, 12841], "disallowed_STD3_mapped", [40, 21313, 41]], [[12842, 12842], "disallowed_STD3_mapped", [40, 26376, 41]], [[12843, 12843], "disallowed_STD3_mapped", [40, 28779, 41]], [[12844, 12844], "disallowed_STD3_mapped", [40, 27700, 41]], [[12845, 12845], "disallowed_STD3_mapped", [40, 26408, 41]], [[12846, 12846], "disallowed_STD3_mapped", [40, 37329, 41]], [[12847, 12847], "disallowed_STD3_mapped", [40, 22303, 41]], [[12848, 12848], "disallowed_STD3_mapped", [40, 26085, 41]], [[12849, 12849], "disallowed_STD3_mapped", [40, 26666, 41]], [[12850, 12850], "disallowed_STD3_mapped", [40, 26377, 41]], [[12851, 12851], "disallowed_STD3_mapped", [40, 31038, 41]], [[12852, 12852], "disallowed_STD3_mapped", [40, 21517, 41]], [[12853, 12853], "disallowed_STD3_mapped", [40, 29305, 41]], [[12854, 12854], "disallowed_STD3_mapped", [40, 36001, 41]], [[12855, 12855], "disallowed_STD3_mapped", [40, 31069, 41]], [[12856, 12856], "disallowed_STD3_mapped", [40, 21172, 41]], [[12857, 12857], "disallowed_STD3_mapped", [40, 20195, 41]], [[12858, 12858], "disallowed_STD3_mapped", [40, 21628, 41]], [[12859, 12859], "disallowed_STD3_mapped", [40, 23398, 41]], [[12860, 12860], "disallowed_STD3_mapped", [40, 30435, 41]], [[12861, 12861], "disallowed_STD3_mapped", [40, 20225, 41]], [[12862, 12862], "disallowed_STD3_mapped", [40, 36039, 41]], [[12863, 12863], "disallowed_STD3_mapped", [40, 21332, 41]], [[12864, 12864], "disallowed_STD3_mapped", [40, 31085, 41]], [[12865, 12865], "disallowed_STD3_mapped", [40, 20241, 41]], [[12866, 12866], "disallowed_STD3_mapped", [40, 33258, 41]], [[12867, 12867], "disallowed_STD3_mapped", [40, 33267, 41]], [[12868, 12868], "mapped", [21839]], [[12869, 12869], "mapped", [24188]], [[12870, 12870], "mapped", [25991]], [[12871, 12871], "mapped", [31631]], [[12872, 12879], "valid", [], "NV8"], [[12880, 12880], "mapped", [112, 116, 101]], [[12881, 12881], "mapped", [50, 49]], [[12882, 12882], "mapped", [50, 50]], [[12883, 12883], "mapped", [50, 51]], [[12884, 12884], "mapped", [50, 52]], [[12885, 12885], "mapped", [50, 53]], [[12886, 12886], "mapped", [50, 54]], [[12887, 12887], "mapped", [50, 55]], [[12888, 12888], "mapped", [50, 56]], [[12889, 12889], "mapped", [50, 57]], [[12890, 12890], "mapped", [51, 48]], [[12891, 12891], "mapped", [51, 49]], [[12892, 12892], "mapped", [51, 50]], [[12893, 12893], "mapped", [51, 51]], [[12894, 12894], "mapped", [51, 52]], [[12895, 12895], "mapped", [51, 53]], [[12896, 12896], "mapped", [4352]], [[12897, 12897], "mapped", [4354]], [[12898, 12898], "mapped", [4355]], [[12899, 12899], "mapped", [4357]], [[12900, 12900], "mapped", [4358]], [[12901, 12901], "mapped", [4359]], [[12902, 12902], "mapped", [4361]], [[12903, 12903], "mapped", [4363]], [[12904, 12904], "mapped", [4364]], [[12905, 12905], "mapped", [4366]], [[12906, 12906], "mapped", [4367]], [[12907, 12907], "mapped", [4368]], [[12908, 12908], "mapped", [4369]], [[12909, 12909], "mapped", [4370]], [[12910, 12910], "mapped", [44032]], [[12911, 12911], "mapped", [45208]], [[12912, 12912], "mapped", [45796]], [[12913, 12913], "mapped", [46972]], [[12914, 12914], "mapped", [47560]], [[12915, 12915], "mapped", [48148]], [[12916, 12916], "mapped", [49324]], [[12917, 12917], "mapped", [50500]], [[12918, 12918], "mapped", [51088]], [[12919, 12919], "mapped", [52264]], [[12920, 12920], "mapped", [52852]], [[12921, 12921], "mapped", [53440]], [[12922, 12922], "mapped", [54028]], [[12923, 12923], "mapped", [54616]], [[12924, 12924], "mapped", [52280, 44256]], [[12925, 12925], "mapped", [51452, 51032]], [[12926, 12926], "mapped", [50864]], [[12927, 12927], "valid", [], "NV8"], [[12928, 12928], "mapped", [19968]], [[12929, 12929], "mapped", [20108]], [[12930, 12930], "mapped", [19977]], [[12931, 12931], "mapped", [22235]], [[12932, 12932], "mapped", [20116]], [[12933, 12933], "mapped", [20845]], [[12934, 12934], "mapped", [19971]], [[12935, 12935], "mapped", [20843]], [[12936, 12936], "mapped", [20061]], [[12937, 12937], "mapped", [21313]], [[12938, 12938], "mapped", [26376]], [[12939, 12939], "mapped", [28779]], [[12940, 12940], "mapped", [27700]], [[12941, 12941], "mapped", [26408]], [[12942, 12942], "mapped", [37329]], [[12943, 12943], "mapped", [22303]], [[12944, 12944], "mapped", [26085]], [[12945, 12945], "mapped", [26666]], [[12946, 12946], "mapped", [26377]], [[12947, 12947], "mapped", [31038]], [[12948, 12948], "mapped", [21517]], [[12949, 12949], "mapped", [29305]], [[12950, 12950], "mapped", [36001]], [[12951, 12951], "mapped", [31069]], [[12952, 12952], "mapped", [21172]], [[12953, 12953], "mapped", [31192]], [[12954, 12954], "mapped", [30007]], [[12955, 12955], "mapped", [22899]], [[12956, 12956], "mapped", [36969]], [[12957, 12957], "mapped", [20778]], [[12958, 12958], "mapped", [21360]], [[12959, 12959], "mapped", [27880]], [[12960, 12960], "mapped", [38917]], [[12961, 12961], "mapped", [20241]], [[12962, 12962], "mapped", [20889]], [[12963, 12963], "mapped", [27491]], [[12964, 12964], "mapped", [19978]], [[12965, 12965], "mapped", [20013]], [[12966, 12966], "mapped", [19979]], [[12967, 12967], "mapped", [24038]], [[12968, 12968], "mapped", [21491]], [[12969, 12969], "mapped", [21307]], [[12970, 12970], "mapped", [23447]], [[12971, 12971], "mapped", [23398]], [[12972, 12972], "mapped", [30435]], [[12973, 12973], "mapped", [20225]], [[12974, 12974], "mapped", [36039]], [[12975, 12975], "mapped", [21332]], [[12976, 12976], "mapped", [22812]], [[12977, 12977], "mapped", [51, 54]], [[12978, 12978], "mapped", [51, 55]], [[12979, 12979], "mapped", [51, 56]], [[12980, 12980], "mapped", [51, 57]], [[12981, 12981], "mapped", [52, 48]], [[12982, 12982], "mapped", [52, 49]], [[12983, 12983], "mapped", [52, 50]], [[12984, 12984], "mapped", [52, 51]], [[12985, 12985], "mapped", [52, 52]], [[12986, 12986], "mapped", [52, 53]], [[12987, 12987], "mapped", [52, 54]], [[12988, 12988], "mapped", [52, 55]], [[12989, 12989], "mapped", [52, 56]], [[12990, 12990], "mapped", [52, 57]], [[12991, 12991], "mapped", [53, 48]], [[12992, 12992], "mapped", [49, 26376]], [[12993, 12993], "mapped", [50, 26376]], [[12994, 12994], "mapped", [51, 26376]], [[12995, 12995], "mapped", [52, 26376]], [[12996, 12996], "mapped", [53, 26376]], [[12997, 12997], "mapped", [54, 26376]], [[12998, 12998], "mapped", [55, 26376]], [[12999, 12999], "mapped", [56, 26376]], [[13000, 13000], "mapped", [57, 26376]], [[13001, 13001], "mapped", [49, 48, 26376]], [[13002, 13002], "mapped", [49, 49, 26376]], [[13003, 13003], "mapped", [49, 50, 26376]], [[13004, 13004], "mapped", [104, 103]], [[13005, 13005], "mapped", [101, 114, 103]], [[13006, 13006], "mapped", [101, 118]], [[13007, 13007], "mapped", [108, 116, 100]], [[13008, 13008], "mapped", [12450]], [[13009, 13009], "mapped", [12452]], [[13010, 13010], "mapped", [12454]], [[13011, 13011], "mapped", [12456]], [[13012, 13012], "mapped", [12458]], [[13013, 13013], "mapped", [12459]], [[13014, 13014], "mapped", [12461]], [[13015, 13015], "mapped", [12463]], [[13016, 13016], "mapped", [12465]], [[13017, 13017], "mapped", [12467]], [[13018, 13018], "mapped", [12469]], [[13019, 13019], "mapped", [12471]], [[13020, 13020], "mapped", [12473]], [[13021, 13021], "mapped", [12475]], [[13022, 13022], "mapped", [12477]], [[13023, 13023], "mapped", [12479]], [[13024, 13024], "mapped", [12481]], [[13025, 13025], "mapped", [12484]], [[13026, 13026], "mapped", [12486]], [[13027, 13027], "mapped", [12488]], [[13028, 13028], "mapped", [12490]], [[13029, 13029], "mapped", [12491]], [[13030, 13030], "mapped", [12492]], [[13031, 13031], "mapped", [12493]], [[13032, 13032], "mapped", [12494]], [[13033, 13033], "mapped", [12495]], [[13034, 13034], "mapped", [12498]], [[13035, 13035], "mapped", [12501]], [[13036, 13036], "mapped", [12504]], [[13037, 13037], "mapped", [12507]], [[13038, 13038], "mapped", [12510]], [[13039, 13039], "mapped", [12511]], [[13040, 13040], "mapped", [12512]], [[13041, 13041], "mapped", [12513]], [[13042, 13042], "mapped", [12514]], [[13043, 13043], "mapped", [12516]], [[13044, 13044], "mapped", [12518]], [[13045, 13045], "mapped", [12520]], [[13046, 13046], "mapped", [12521]], [[13047, 13047], "mapped", [12522]], [[13048, 13048], "mapped", [12523]], [[13049, 13049], "mapped", [12524]], [[13050, 13050], "mapped", [12525]], [[13051, 13051], "mapped", [12527]], [[13052, 13052], "mapped", [12528]], [[13053, 13053], "mapped", [12529]], [[13054, 13054], "mapped", [12530]], [[13055, 13055], "disallowed"], [[13056, 13056], "mapped", [12450, 12497, 12540, 12488]], [[13057, 13057], "mapped", [12450, 12523, 12501, 12449]], [[13058, 13058], "mapped", [12450, 12531, 12506, 12450]], [[13059, 13059], "mapped", [12450, 12540, 12523]], [[13060, 13060], "mapped", [12452, 12491, 12531, 12464]], [[13061, 13061], "mapped", [12452, 12531, 12481]], [[13062, 13062], "mapped", [12454, 12457, 12531]], [[13063, 13063], "mapped", [12456, 12473, 12463, 12540, 12489]], [[13064, 13064], "mapped", [12456, 12540, 12459, 12540]], [[13065, 13065], "mapped", [12458, 12531, 12473]], [[13066, 13066], "mapped", [12458, 12540, 12512]], [[13067, 13067], "mapped", [12459, 12452, 12522]], [[13068, 13068], "mapped", [12459, 12521, 12483, 12488]], [[13069, 13069], "mapped", [12459, 12525, 12522, 12540]], [[13070, 13070], "mapped", [12460, 12525, 12531]], [[13071, 13071], "mapped", [12460, 12531, 12510]], [[13072, 13072], "mapped", [12462, 12460]], [[13073, 13073], "mapped", [12462, 12491, 12540]], [[13074, 13074], "mapped", [12461, 12517, 12522, 12540]], [[13075, 13075], "mapped", [12462, 12523, 12480, 12540]], [[13076, 13076], "mapped", [12461, 12525]], [[13077, 13077], "mapped", [12461, 12525, 12464, 12521, 12512]], [[13078, 13078], "mapped", [12461, 12525, 12513, 12540, 12488, 12523]], [[13079, 13079], "mapped", [12461, 12525, 12527, 12483, 12488]], [[13080, 13080], "mapped", [12464, 12521, 12512]], [[13081, 13081], "mapped", [12464, 12521, 12512, 12488, 12531]], [[13082, 13082], "mapped", [12463, 12523, 12476, 12452, 12525]], [[13083, 13083], "mapped", [12463, 12525, 12540, 12493]], [[13084, 13084], "mapped", [12465, 12540, 12473]], [[13085, 13085], "mapped", [12467, 12523, 12490]], [[13086, 13086], "mapped", [12467, 12540, 12509]], [[13087, 13087], "mapped", [12469, 12452, 12463, 12523]], [[13088, 13088], "mapped", [12469, 12531, 12481, 12540, 12512]], [[13089, 13089], "mapped", [12471, 12522, 12531, 12464]], [[13090, 13090], "mapped", [12475, 12531, 12481]], [[13091, 13091], "mapped", [12475, 12531, 12488]], [[13092, 13092], "mapped", [12480, 12540, 12473]], [[13093, 13093], "mapped", [12487, 12471]], [[13094, 13094], "mapped", [12489, 12523]], [[13095, 13095], "mapped", [12488, 12531]], [[13096, 13096], "mapped", [12490, 12494]], [[13097, 13097], "mapped", [12494, 12483, 12488]], [[13098, 13098], "mapped", [12495, 12452, 12484]], [[13099, 13099], "mapped", [12497, 12540, 12475, 12531, 12488]], [[13100, 13100], "mapped", [12497, 12540, 12484]], [[13101, 13101], "mapped", [12496, 12540, 12524, 12523]], [[13102, 13102], "mapped", [12500, 12450, 12473, 12488, 12523]], [[13103, 13103], "mapped", [12500, 12463, 12523]], [[13104, 13104], "mapped", [12500, 12467]], [[13105, 13105], "mapped", [12499, 12523]], [[13106, 13106], "mapped", [12501, 12449, 12521, 12483, 12489]], [[13107, 13107], "mapped", [12501, 12451, 12540, 12488]], [[13108, 13108], "mapped", [12502, 12483, 12471, 12455, 12523]], [[13109, 13109], "mapped", [12501, 12521, 12531]], [[13110, 13110], "mapped", [12504, 12463, 12479, 12540, 12523]], [[13111, 13111], "mapped", [12506, 12477]], [[13112, 13112], "mapped", [12506, 12491, 12498]], [[13113, 13113], "mapped", [12504, 12523, 12484]], [[13114, 13114], "mapped", [12506, 12531, 12473]], [[13115, 13115], "mapped", [12506, 12540, 12472]], [[13116, 13116], "mapped", [12505, 12540, 12479]], [[13117, 13117], "mapped", [12509, 12452, 12531, 12488]], [[13118, 13118], "mapped", [12508, 12523, 12488]], [[13119, 13119], "mapped", [12507, 12531]], [[13120, 13120], "mapped", [12509, 12531, 12489]], [[13121, 13121], "mapped", [12507, 12540, 12523]], [[13122, 13122], "mapped", [12507, 12540, 12531]], [[13123, 13123], "mapped", [12510, 12452, 12463, 12525]], [[13124, 13124], "mapped", [12510, 12452, 12523]], [[13125, 13125], "mapped", [12510, 12483, 12495]], [[13126, 13126], "mapped", [12510, 12523, 12463]], [[13127, 13127], "mapped", [12510, 12531, 12471, 12519, 12531]], [[13128, 13128], "mapped", [12511, 12463, 12525, 12531]], [[13129, 13129], "mapped", [12511, 12522]], [[13130, 13130], "mapped", [12511, 12522, 12496, 12540, 12523]], [[13131, 13131], "mapped", [12513, 12460]], [[13132, 13132], "mapped", [12513, 12460, 12488, 12531]], [[13133, 13133], "mapped", [12513, 12540, 12488, 12523]], [[13134, 13134], "mapped", [12516, 12540, 12489]], [[13135, 13135], "mapped", [12516, 12540, 12523]], [[13136, 13136], "mapped", [12518, 12450, 12531]], [[13137, 13137], "mapped", [12522, 12483, 12488, 12523]], [[13138, 13138], "mapped", [12522, 12521]], [[13139, 13139], "mapped", [12523, 12500, 12540]], [[13140, 13140], "mapped", [12523, 12540, 12502, 12523]], [[13141, 13141], "mapped", [12524, 12512]], [[13142, 13142], "mapped", [12524, 12531, 12488, 12466, 12531]], [[13143, 13143], "mapped", [12527, 12483, 12488]], [[13144, 13144], "mapped", [48, 28857]], [[13145, 13145], "mapped", [49, 28857]], [[13146, 13146], "mapped", [50, 28857]], [[13147, 13147], "mapped", [51, 28857]], [[13148, 13148], "mapped", [52, 28857]], [[13149, 13149], "mapped", [53, 28857]], [[13150, 13150], "mapped", [54, 28857]], [[13151, 13151], "mapped", [55, 28857]], [[13152, 13152], "mapped", [56, 28857]], [[13153, 13153], "mapped", [57, 28857]], [[13154, 13154], "mapped", [49, 48, 28857]], [[13155, 13155], "mapped", [49, 49, 28857]], [[13156, 13156], "mapped", [49, 50, 28857]], [[13157, 13157], "mapped", [49, 51, 28857]], [[13158, 13158], "mapped", [49, 52, 28857]], [[13159, 13159], "mapped", [49, 53, 28857]], [[13160, 13160], "mapped", [49, 54, 28857]], [[13161, 13161], "mapped", [49, 55, 28857]], [[13162, 13162], "mapped", [49, 56, 28857]], [[13163, 13163], "mapped", [49, 57, 28857]], [[13164, 13164], "mapped", [50, 48, 28857]], [[13165, 13165], "mapped", [50, 49, 28857]], [[13166, 13166], "mapped", [50, 50, 28857]], [[13167, 13167], "mapped", [50, 51, 28857]], [[13168, 13168], "mapped", [50, 52, 28857]], [[13169, 13169], "mapped", [104, 112, 97]], [[13170, 13170], "mapped", [100, 97]], [[13171, 13171], "mapped", [97, 117]], [[13172, 13172], "mapped", [98, 97, 114]], [[13173, 13173], "mapped", [111, 118]], [[13174, 13174], "mapped", [112, 99]], [[13175, 13175], "mapped", [100, 109]], [[13176, 13176], "mapped", [100, 109, 50]], [[13177, 13177], "mapped", [100, 109, 51]], [[13178, 13178], "mapped", [105, 117]], [[13179, 13179], "mapped", [24179, 25104]], [[13180, 13180], "mapped", [26157, 21644]], [[13181, 13181], "mapped", [22823, 27491]], [[13182, 13182], "mapped", [26126, 27835]], [[13183, 13183], "mapped", [26666, 24335, 20250, 31038]], [[13184, 13184], "mapped", [112, 97]], [[13185, 13185], "mapped", [110, 97]], [[13186, 13186], "mapped", [956, 97]], [[13187, 13187], "mapped", [109, 97]], [[13188, 13188], "mapped", [107, 97]], [[13189, 13189], "mapped", [107, 98]], [[13190, 13190], "mapped", [109, 98]], [[13191, 13191], "mapped", [103, 98]], [[13192, 13192], "mapped", [99, 97, 108]], [[13193, 13193], "mapped", [107, 99, 97, 108]], [[13194, 13194], "mapped", [112, 102]], [[13195, 13195], "mapped", [110, 102]], [[13196, 13196], "mapped", [956, 102]], [[13197, 13197], "mapped", [956, 103]], [[13198, 13198], "mapped", [109, 103]], [[13199, 13199], "mapped", [107, 103]], [[13200, 13200], "mapped", [104, 122]], [[13201, 13201], "mapped", [107, 104, 122]], [[13202, 13202], "mapped", [109, 104, 122]], [[13203, 13203], "mapped", [103, 104, 122]], [[13204, 13204], "mapped", [116, 104, 122]], [[13205, 13205], "mapped", [956, 108]], [[13206, 13206], "mapped", [109, 108]], [[13207, 13207], "mapped", [100, 108]], [[13208, 13208], "mapped", [107, 108]], [[13209, 13209], "mapped", [102, 109]], [[13210, 13210], "mapped", [110, 109]], [[13211, 13211], "mapped", [956, 109]], [[13212, 13212], "mapped", [109, 109]], [[13213, 13213], "mapped", [99, 109]], [[13214, 13214], "mapped", [107, 109]], [[13215, 13215], "mapped", [109, 109, 50]], [[13216, 13216], "mapped", [99, 109, 50]], [[13217, 13217], "mapped", [109, 50]], [[13218, 13218], "mapped", [107, 109, 50]], [[13219, 13219], "mapped", [109, 109, 51]], [[13220, 13220], "mapped", [99, 109, 51]], [[13221, 13221], "mapped", [109, 51]], [[13222, 13222], "mapped", [107, 109, 51]], [[13223, 13223], "mapped", [109, 8725, 115]], [[13224, 13224], "mapped", [109, 8725, 115, 50]], [[13225, 13225], "mapped", [112, 97]], [[13226, 13226], "mapped", [107, 112, 97]], [[13227, 13227], "mapped", [109, 112, 97]], [[13228, 13228], "mapped", [103, 112, 97]], [[13229, 13229], "mapped", [114, 97, 100]], [[13230, 13230], "mapped", [114, 97, 100, 8725, 115]], [[13231, 13231], "mapped", [114, 97, 100, 8725, 115, 50]], [[13232, 13232], "mapped", [112, 115]], [[13233, 13233], "mapped", [110, 115]], [[13234, 13234], "mapped", [956, 115]], [[13235, 13235], "mapped", [109, 115]], [[13236, 13236], "mapped", [112, 118]], [[13237, 13237], "mapped", [110, 118]], [[13238, 13238], "mapped", [956, 118]], [[13239, 13239], "mapped", [109, 118]], [[13240, 13240], "mapped", [107, 118]], [[13241, 13241], "mapped", [109, 118]], [[13242, 13242], "mapped", [112, 119]], [[13243, 13243], "mapped", [110, 119]], [[13244, 13244], "mapped", [956, 119]], [[13245, 13245], "mapped", [109, 119]], [[13246, 13246], "mapped", [107, 119]], [[13247, 13247], "mapped", [109, 119]], [[13248, 13248], "mapped", [107, 969]], [[13249, 13249], "mapped", [109, 969]], [[13250, 13250], "disallowed"], [[13251, 13251], "mapped", [98, 113]], [[13252, 13252], "mapped", [99, 99]], [[13253, 13253], "mapped", [99, 100]], [[13254, 13254], "mapped", [99, 8725, 107, 103]], [[13255, 13255], "disallowed"], [[13256, 13256], "mapped", [100, 98]], [[13257, 13257], "mapped", [103, 121]], [[13258, 13258], "mapped", [104, 97]], [[13259, 13259], "mapped", [104, 112]], [[13260, 13260], "mapped", [105, 110]], [[13261, 13261], "mapped", [107, 107]], [[13262, 13262], "mapped", [107, 109]], [[13263, 13263], "mapped", [107, 116]], [[13264, 13264], "mapped", [108, 109]], [[13265, 13265], "mapped", [108, 110]], [[13266, 13266], "mapped", [108, 111, 103]], [[13267, 13267], "mapped", [108, 120]], [[13268, 13268], "mapped", [109, 98]], [[13269, 13269], "mapped", [109, 105, 108]], [[13270, 13270], "mapped", [109, 111, 108]], [[13271, 13271], "mapped", [112, 104]], [[13272, 13272], "disallowed"], [[13273, 13273], "mapped", [112, 112, 109]], [[13274, 13274], "mapped", [112, 114]], [[13275, 13275], "mapped", [115, 114]], [[13276, 13276], "mapped", [115, 118]], [[13277, 13277], "mapped", [119, 98]], [[13278, 13278], "mapped", [118, 8725, 109]], [[13279, 13279], "mapped", [97, 8725, 109]], [[13280, 13280], "mapped", [49, 26085]], [[13281, 13281], "mapped", [50, 26085]], [[13282, 13282], "mapped", [51, 26085]], [[13283, 13283], "mapped", [52, 26085]], [[13284, 13284], "mapped", [53, 26085]], [[13285, 13285], "mapped", [54, 26085]], [[13286, 13286], "mapped", [55, 26085]], [[13287, 13287], "mapped", [56, 26085]], [[13288, 13288], "mapped", [57, 26085]], [[13289, 13289], "mapped", [49, 48, 26085]], [[13290, 13290], "mapped", [49, 49, 26085]], [[13291, 13291], "mapped", [49, 50, 26085]], [[13292, 13292], "mapped", [49, 51, 26085]], [[13293, 13293], "mapped", [49, 52, 26085]], [[13294, 13294], "mapped", [49, 53, 26085]], [[13295, 13295], "mapped", [49, 54, 26085]], [[13296, 13296], "mapped", [49, 55, 26085]], [[13297, 13297], "mapped", [49, 56, 26085]], [[13298, 13298], "mapped", [49, 57, 26085]], [[13299, 13299], "mapped", [50, 48, 26085]], [[13300, 13300], "mapped", [50, 49, 26085]], [[13301, 13301], "mapped", [50, 50, 26085]], [[13302, 13302], "mapped", [50, 51, 26085]], [[13303, 13303], "mapped", [50, 52, 26085]], [[13304, 13304], "mapped", [50, 53, 26085]], [[13305, 13305], "mapped", [50, 54, 26085]], [[13306, 13306], "mapped", [50, 55, 26085]], [[13307, 13307], "mapped", [50, 56, 26085]], [[13308, 13308], "mapped", [50, 57, 26085]], [[13309, 13309], "mapped", [51, 48, 26085]], [[13310, 13310], "mapped", [51, 49, 26085]], [[13311, 13311], "mapped", [103, 97, 108]], [[13312, 19893], "valid"], [[19894, 19903], "disallowed"], [[19904, 19967], "valid", [], "NV8"], [[19968, 40869], "valid"], [[40870, 40891], "valid"], [[40892, 40899], "valid"], [[40900, 40907], "valid"], [[40908, 40908], "valid"], [[40909, 40917], "valid"], [[40918, 40959], "disallowed"], [[40960, 42124], "valid"], [[42125, 42127], "disallowed"], [[42128, 42145], "valid", [], "NV8"], [[42146, 42147], "valid", [], "NV8"], [[42148, 42163], "valid", [], "NV8"], [[42164, 42164], "valid", [], "NV8"], [[42165, 42176], "valid", [], "NV8"], [[42177, 42177], "valid", [], "NV8"], [[42178, 42180], "valid", [], "NV8"], [[42181, 42181], "valid", [], "NV8"], [[42182, 42182], "valid", [], "NV8"], [[42183, 42191], "disallowed"], [[42192, 42237], "valid"], [[42238, 42239], "valid", [], "NV8"], [[42240, 42508], "valid"], [[42509, 42511], "valid", [], "NV8"], [[42512, 42539], "valid"], [[42540, 42559], "disallowed"], [[42560, 42560], "mapped", [42561]], [[42561, 42561], "valid"], [[42562, 42562], "mapped", [42563]], [[42563, 42563], "valid"], [[42564, 42564], "mapped", [42565]], [[42565, 42565], "valid"], [[42566, 42566], "mapped", [42567]], [[42567, 42567], "valid"], [[42568, 42568], "mapped", [42569]], [[42569, 42569], "valid"], [[42570, 42570], "mapped", [42571]], [[42571, 42571], "valid"], [[42572, 42572], "mapped", [42573]], [[42573, 42573], "valid"], [[42574, 42574], "mapped", [42575]], [[42575, 42575], "valid"], [[42576, 42576], "mapped", [42577]], [[42577, 42577], "valid"], [[42578, 42578], "mapped", [42579]], [[42579, 42579], "valid"], [[42580, 42580], "mapped", [42581]], [[42581, 42581], "valid"], [[42582, 42582], "mapped", [42583]], [[42583, 42583], "valid"], [[42584, 42584], "mapped", [42585]], [[42585, 42585], "valid"], [[42586, 42586], "mapped", [42587]], [[42587, 42587], "valid"], [[42588, 42588], "mapped", [42589]], [[42589, 42589], "valid"], [[42590, 42590], "mapped", [42591]], [[42591, 42591], "valid"], [[42592, 42592], "mapped", [42593]], [[42593, 42593], "valid"], [[42594, 42594], "mapped", [42595]], [[42595, 42595], "valid"], [[42596, 42596], "mapped", [42597]], [[42597, 42597], "valid"], [[42598, 42598], "mapped", [42599]], [[42599, 42599], "valid"], [[42600, 42600], "mapped", [42601]], [[42601, 42601], "valid"], [[42602, 42602], "mapped", [42603]], [[42603, 42603], "valid"], [[42604, 42604], "mapped", [42605]], [[42605, 42607], "valid"], [[42608, 42611], "valid", [], "NV8"], [[42612, 42619], "valid"], [[42620, 42621], "valid"], [[42622, 42622], "valid", [], "NV8"], [[42623, 42623], "valid"], [[42624, 42624], "mapped", [42625]], [[42625, 42625], "valid"], [[42626, 42626], "mapped", [42627]], [[42627, 42627], "valid"], [[42628, 42628], "mapped", [42629]], [[42629, 42629], "valid"], [[42630, 42630], "mapped", [42631]], [[42631, 42631], "valid"], [[42632, 42632], "mapped", [42633]], [[42633, 42633], "valid"], [[42634, 42634], "mapped", [42635]], [[42635, 42635], "valid"], [[42636, 42636], "mapped", [42637]], [[42637, 42637], "valid"], [[42638, 42638], "mapped", [42639]], [[42639, 42639], "valid"], [[42640, 42640], "mapped", [42641]], [[42641, 42641], "valid"], [[42642, 42642], "mapped", [42643]], [[42643, 42643], "valid"], [[42644, 42644], "mapped", [42645]], [[42645, 42645], "valid"], [[42646, 42646], "mapped", [42647]], [[42647, 42647], "valid"], [[42648, 42648], "mapped", [42649]], [[42649, 42649], "valid"], [[42650, 42650], "mapped", [42651]], [[42651, 42651], "valid"], [[42652, 42652], "mapped", [1098]], [[42653, 42653], "mapped", [1100]], [[42654, 42654], "valid"], [[42655, 42655], "valid"], [[42656, 42725], "valid"], [[42726, 42735], "valid", [], "NV8"], [[42736, 42737], "valid"], [[42738, 42743], "valid", [], "NV8"], [[42744, 42751], "disallowed"], [[42752, 42774], "valid", [], "NV8"], [[42775, 42778], "valid"], [[42779, 42783], "valid"], [[42784, 42785], "valid", [], "NV8"], [[42786, 42786], "mapped", [42787]], [[42787, 42787], "valid"], [[42788, 42788], "mapped", [42789]], [[42789, 42789], "valid"], [[42790, 42790], "mapped", [42791]], [[42791, 42791], "valid"], [[42792, 42792], "mapped", [42793]], [[42793, 42793], "valid"], [[42794, 42794], "mapped", [42795]], [[42795, 42795], "valid"], [[42796, 42796], "mapped", [42797]], [[42797, 42797], "valid"], [[42798, 42798], "mapped", [42799]], [[42799, 42801], "valid"], [[42802, 42802], "mapped", [42803]], [[42803, 42803], "valid"], [[42804, 42804], "mapped", [42805]], [[42805, 42805], "valid"], [[42806, 42806], "mapped", [42807]], [[42807, 42807], "valid"], [[42808, 42808], "mapped", [42809]], [[42809, 42809], "valid"], [[42810, 42810], "mapped", [42811]], [[42811, 42811], "valid"], [[42812, 42812], "mapped", [42813]], [[42813, 42813], "valid"], [[42814, 42814], "mapped", [42815]], [[42815, 42815], "valid"], [[42816, 42816], "mapped", [42817]], [[42817, 42817], "valid"], [[42818, 42818], "mapped", [42819]], [[42819, 42819], "valid"], [[42820, 42820], "mapped", [42821]], [[42821, 42821], "valid"], [[42822, 42822], "mapped", [42823]], [[42823, 42823], "valid"], [[42824, 42824], "mapped", [42825]], [[42825, 42825], "valid"], [[42826, 42826], "mapped", [42827]], [[42827, 42827], "valid"], [[42828, 42828], "mapped", [42829]], [[42829, 42829], "valid"], [[42830, 42830], "mapped", [42831]], [[42831, 42831], "valid"], [[42832, 42832], "mapped", [42833]], [[42833, 42833], "valid"], [[42834, 42834], "mapped", [42835]], [[42835, 42835], "valid"], [[42836, 42836], "mapped", [42837]], [[42837, 42837], "valid"], [[42838, 42838], "mapped", [42839]], [[42839, 42839], "valid"], [[42840, 42840], "mapped", [42841]], [[42841, 42841], "valid"], [[42842, 42842], "mapped", [42843]], [[42843, 42843], "valid"], [[42844, 42844], "mapped", [42845]], [[42845, 42845], "valid"], [[42846, 42846], "mapped", [42847]], [[42847, 42847], "valid"], [[42848, 42848], "mapped", [42849]], [[42849, 42849], "valid"], [[42850, 42850], "mapped", [42851]], [[42851, 42851], "valid"], [[42852, 42852], "mapped", [42853]], [[42853, 42853], "valid"], [[42854, 42854], "mapped", [42855]], [[42855, 42855], "valid"], [[42856, 42856], "mapped", [42857]], [[42857, 42857], "valid"], [[42858, 42858], "mapped", [42859]], [[42859, 42859], "valid"], [[42860, 42860], "mapped", [42861]], [[42861, 42861], "valid"], [[42862, 42862], "mapped", [42863]], [[42863, 42863], "valid"], [[42864, 42864], "mapped", [42863]], [[42865, 42872], "valid"], [[42873, 42873], "mapped", [42874]], [[42874, 42874], "valid"], [[42875, 42875], "mapped", [42876]], [[42876, 42876], "valid"], [[42877, 42877], "mapped", [7545]], [[42878, 42878], "mapped", [42879]], [[42879, 42879], "valid"], [[42880, 42880], "mapped", [42881]], [[42881, 42881], "valid"], [[42882, 42882], "mapped", [42883]], [[42883, 42883], "valid"], [[42884, 42884], "mapped", [42885]], [[42885, 42885], "valid"], [[42886, 42886], "mapped", [42887]], [[42887, 42888], "valid"], [[42889, 42890], "valid", [], "NV8"], [[42891, 42891], "mapped", [42892]], [[42892, 42892], "valid"], [[42893, 42893], "mapped", [613]], [[42894, 42894], "valid"], [[42895, 42895], "valid"], [[42896, 42896], "mapped", [42897]], [[42897, 42897], "valid"], [[42898, 42898], "mapped", [42899]], [[42899, 42899], "valid"], [[42900, 42901], "valid"], [[42902, 42902], "mapped", [42903]], [[42903, 42903], "valid"], [[42904, 42904], "mapped", [42905]], [[42905, 42905], "valid"], [[42906, 42906], "mapped", [42907]], [[42907, 42907], "valid"], [[42908, 42908], "mapped", [42909]], [[42909, 42909], "valid"], [[42910, 42910], "mapped", [42911]], [[42911, 42911], "valid"], [[42912, 42912], "mapped", [42913]], [[42913, 42913], "valid"], [[42914, 42914], "mapped", [42915]], [[42915, 42915], "valid"], [[42916, 42916], "mapped", [42917]], [[42917, 42917], "valid"], [[42918, 42918], "mapped", [42919]], [[42919, 42919], "valid"], [[42920, 42920], "mapped", [42921]], [[42921, 42921], "valid"], [[42922, 42922], "mapped", [614]], [[42923, 42923], "mapped", [604]], [[42924, 42924], "mapped", [609]], [[42925, 42925], "mapped", [620]], [[42926, 42927], "disallowed"], [[42928, 42928], "mapped", [670]], [[42929, 42929], "mapped", [647]], [[42930, 42930], "mapped", [669]], [[42931, 42931], "mapped", [43859]], [[42932, 42932], "mapped", [42933]], [[42933, 42933], "valid"], [[42934, 42934], "mapped", [42935]], [[42935, 42935], "valid"], [[42936, 42998], "disallowed"], [[42999, 42999], "valid"], [[43000, 43000], "mapped", [295]], [[43001, 43001], "mapped", [339]], [[43002, 43002], "valid"], [[43003, 43007], "valid"], [[43008, 43047], "valid"], [[43048, 43051], "valid", [], "NV8"], [[43052, 43055], "disallowed"], [[43056, 43065], "valid", [], "NV8"], [[43066, 43071], "disallowed"], [[43072, 43123], "valid"], [[43124, 43127], "valid", [], "NV8"], [[43128, 43135], "disallowed"], [[43136, 43204], "valid"], [[43205, 43213], "disallowed"], [[43214, 43215], "valid", [], "NV8"], [[43216, 43225], "valid"], [[43226, 43231], "disallowed"], [[43232, 43255], "valid"], [[43256, 43258], "valid", [], "NV8"], [[43259, 43259], "valid"], [[43260, 43260], "valid", [], "NV8"], [[43261, 43261], "valid"], [[43262, 43263], "disallowed"], [[43264, 43309], "valid"], [[43310, 43311], "valid", [], "NV8"], [[43312, 43347], "valid"], [[43348, 43358], "disallowed"], [[43359, 43359], "valid", [], "NV8"], [[43360, 43388], "valid", [], "NV8"], [[43389, 43391], "disallowed"], [[43392, 43456], "valid"], [[43457, 43469], "valid", [], "NV8"], [[43470, 43470], "disallowed"], [[43471, 43481], "valid"], [[43482, 43485], "disallowed"], [[43486, 43487], "valid", [], "NV8"], [[43488, 43518], "valid"], [[43519, 43519], "disallowed"], [[43520, 43574], "valid"], [[43575, 43583], "disallowed"], [[43584, 43597], "valid"], [[43598, 43599], "disallowed"], [[43600, 43609], "valid"], [[43610, 43611], "disallowed"], [[43612, 43615], "valid", [], "NV8"], [[43616, 43638], "valid"], [[43639, 43641], "valid", [], "NV8"], [[43642, 43643], "valid"], [[43644, 43647], "valid"], [[43648, 43714], "valid"], [[43715, 43738], "disallowed"], [[43739, 43741], "valid"], [[43742, 43743], "valid", [], "NV8"], [[43744, 43759], "valid"], [[43760, 43761], "valid", [], "NV8"], [[43762, 43766], "valid"], [[43767, 43776], "disallowed"], [[43777, 43782], "valid"], [[43783, 43784], "disallowed"], [[43785, 43790], "valid"], [[43791, 43792], "disallowed"], [[43793, 43798], "valid"], [[43799, 43807], "disallowed"], [[43808, 43814], "valid"], [[43815, 43815], "disallowed"], [[43816, 43822], "valid"], [[43823, 43823], "disallowed"], [[43824, 43866], "valid"], [[43867, 43867], "valid", [], "NV8"], [[43868, 43868], "mapped", [42791]], [[43869, 43869], "mapped", [43831]], [[43870, 43870], "mapped", [619]], [[43871, 43871], "mapped", [43858]], [[43872, 43875], "valid"], [[43876, 43877], "valid"], [[43878, 43887], "disallowed"], [[43888, 43888], "mapped", [5024]], [[43889, 43889], "mapped", [5025]], [[43890, 43890], "mapped", [5026]], [[43891, 43891], "mapped", [5027]], [[43892, 43892], "mapped", [5028]], [[43893, 43893], "mapped", [5029]], [[43894, 43894], "mapped", [5030]], [[43895, 43895], "mapped", [5031]], [[43896, 43896], "mapped", [5032]], [[43897, 43897], "mapped", [5033]], [[43898, 43898], "mapped", [5034]], [[43899, 43899], "mapped", [5035]], [[43900, 43900], "mapped", [5036]], [[43901, 43901], "mapped", [5037]], [[43902, 43902], "mapped", [5038]], [[43903, 43903], "mapped", [5039]], [[43904, 43904], "mapped", [5040]], [[43905, 43905], "mapped", [5041]], [[43906, 43906], "mapped", [5042]], [[43907, 43907], "mapped", [5043]], [[43908, 43908], "mapped", [5044]], [[43909, 43909], "mapped", [5045]], [[43910, 43910], "mapped", [5046]], [[43911, 43911], "mapped", [5047]], [[43912, 43912], "mapped", [5048]], [[43913, 43913], "mapped", [5049]], [[43914, 43914], "mapped", [5050]], [[43915, 43915], "mapped", [5051]], [[43916, 43916], "mapped", [5052]], [[43917, 43917], "mapped", [5053]], [[43918, 43918], "mapped", [5054]], [[43919, 43919], "mapped", [5055]], [[43920, 43920], "mapped", [5056]], [[43921, 43921], "mapped", [5057]], [[43922, 43922], "mapped", [5058]], [[43923, 43923], "mapped", [5059]], [[43924, 43924], "mapped", [5060]], [[43925, 43925], "mapped", [5061]], [[43926, 43926], "mapped", [5062]], [[43927, 43927], "mapped", [5063]], [[43928, 43928], "mapped", [5064]], [[43929, 43929], "mapped", [5065]], [[43930, 43930], "mapped", [5066]], [[43931, 43931], "mapped", [5067]], [[43932, 43932], "mapped", [5068]], [[43933, 43933], "mapped", [5069]], [[43934, 43934], "mapped", [5070]], [[43935, 43935], "mapped", [5071]], [[43936, 43936], "mapped", [5072]], [[43937, 43937], "mapped", [5073]], [[43938, 43938], "mapped", [5074]], [[43939, 43939], "mapped", [5075]], [[43940, 43940], "mapped", [5076]], [[43941, 43941], "mapped", [5077]], [[43942, 43942], "mapped", [5078]], [[43943, 43943], "mapped", [5079]], [[43944, 43944], "mapped", [5080]], [[43945, 43945], "mapped", [5081]], [[43946, 43946], "mapped", [5082]], [[43947, 43947], "mapped", [5083]], [[43948, 43948], "mapped", [5084]], [[43949, 43949], "mapped", [5085]], [[43950, 43950], "mapped", [5086]], [[43951, 43951], "mapped", [5087]], [[43952, 43952], "mapped", [5088]], [[43953, 43953], "mapped", [5089]], [[43954, 43954], "mapped", [5090]], [[43955, 43955], "mapped", [5091]], [[43956, 43956], "mapped", [5092]], [[43957, 43957], "mapped", [5093]], [[43958, 43958], "mapped", [5094]], [[43959, 43959], "mapped", [5095]], [[43960, 43960], "mapped", [5096]], [[43961, 43961], "mapped", [5097]], [[43962, 43962], "mapped", [5098]], [[43963, 43963], "mapped", [5099]], [[43964, 43964], "mapped", [5100]], [[43965, 43965], "mapped", [5101]], [[43966, 43966], "mapped", [5102]], [[43967, 43967], "mapped", [5103]], [[43968, 44010], "valid"], [[44011, 44011], "valid", [], "NV8"], [[44012, 44013], "valid"], [[44014, 44015], "disallowed"], [[44016, 44025], "valid"], [[44026, 44031], "disallowed"], [[44032, 55203], "valid"], [[55204, 55215], "disallowed"], [[55216, 55238], "valid", [], "NV8"], [[55239, 55242], "disallowed"], [[55243, 55291], "valid", [], "NV8"], [[55292, 55295], "disallowed"], [[55296, 57343], "disallowed"], [[57344, 63743], "disallowed"], [[63744, 63744], "mapped", [35912]], [[63745, 63745], "mapped", [26356]], [[63746, 63746], "mapped", [36554]], [[63747, 63747], "mapped", [36040]], [[63748, 63748], "mapped", [28369]], [[63749, 63749], "mapped", [20018]], [[63750, 63750], "mapped", [21477]], [[63751, 63752], "mapped", [40860]], [[63753, 63753], "mapped", [22865]], [[63754, 63754], "mapped", [37329]], [[63755, 63755], "mapped", [21895]], [[63756, 63756], "mapped", [22856]], [[63757, 63757], "mapped", [25078]], [[63758, 63758], "mapped", [30313]], [[63759, 63759], "mapped", [32645]], [[63760, 63760], "mapped", [34367]], [[63761, 63761], "mapped", [34746]], [[63762, 63762], "mapped", [35064]], [[63763, 63763], "mapped", [37007]], [[63764, 63764], "mapped", [27138]], [[63765, 63765], "mapped", [27931]], [[63766, 63766], "mapped", [28889]], [[63767, 63767], "mapped", [29662]], [[63768, 63768], "mapped", [33853]], [[63769, 63769], "mapped", [37226]], [[63770, 63770], "mapped", [39409]], [[63771, 63771], "mapped", [20098]], [[63772, 63772], "mapped", [21365]], [[63773, 63773], "mapped", [27396]], [[63774, 63774], "mapped", [29211]], [[63775, 63775], "mapped", [34349]], [[63776, 63776], "mapped", [40478]], [[63777, 63777], "mapped", [23888]], [[63778, 63778], "mapped", [28651]], [[63779, 63779], "mapped", [34253]], [[63780, 63780], "mapped", [35172]], [[63781, 63781], "mapped", [25289]], [[63782, 63782], "mapped", [33240]], [[63783, 63783], "mapped", [34847]], [[63784, 63784], "mapped", [24266]], [[63785, 63785], "mapped", [26391]], [[63786, 63786], "mapped", [28010]], [[63787, 63787], "mapped", [29436]], [[63788, 63788], "mapped", [37070]], [[63789, 63789], "mapped", [20358]], [[63790, 63790], "mapped", [20919]], [[63791, 63791], "mapped", [21214]], [[63792, 63792], "mapped", [25796]], [[63793, 63793], "mapped", [27347]], [[63794, 63794], "mapped", [29200]], [[63795, 63795], "mapped", [30439]], [[63796, 63796], "mapped", [32769]], [[63797, 63797], "mapped", [34310]], [[63798, 63798], "mapped", [34396]], [[63799, 63799], "mapped", [36335]], [[63800, 63800], "mapped", [38706]], [[63801, 63801], "mapped", [39791]], [[63802, 63802], "mapped", [40442]], [[63803, 63803], "mapped", [30860]], [[63804, 63804], "mapped", [31103]], [[63805, 63805], "mapped", [32160]], [[63806, 63806], "mapped", [33737]], [[63807, 63807], "mapped", [37636]], [[63808, 63808], "mapped", [40575]], [[63809, 63809], "mapped", [35542]], [[63810, 63810], "mapped", [22751]], [[63811, 63811], "mapped", [24324]], [[63812, 63812], "mapped", [31840]], [[63813, 63813], "mapped", [32894]], [[63814, 63814], "mapped", [29282]], [[63815, 63815], "mapped", [30922]], [[63816, 63816], "mapped", [36034]], [[63817, 63817], "mapped", [38647]], [[63818, 63818], "mapped", [22744]], [[63819, 63819], "mapped", [23650]], [[63820, 63820], "mapped", [27155]], [[63821, 63821], "mapped", [28122]], [[63822, 63822], "mapped", [28431]], [[63823, 63823], "mapped", [32047]], [[63824, 63824], "mapped", [32311]], [[63825, 63825], "mapped", [38475]], [[63826, 63826], "mapped", [21202]], [[63827, 63827], "mapped", [32907]], [[63828, 63828], "mapped", [20956]], [[63829, 63829], "mapped", [20940]], [[63830, 63830], "mapped", [31260]], [[63831, 63831], "mapped", [32190]], [[63832, 63832], "mapped", [33777]], [[63833, 63833], "mapped", [38517]], [[63834, 63834], "mapped", [35712]], [[63835, 63835], "mapped", [25295]], [[63836, 63836], "mapped", [27138]], [[63837, 63837], "mapped", [35582]], [[63838, 63838], "mapped", [20025]], [[63839, 63839], "mapped", [23527]], [[63840, 63840], "mapped", [24594]], [[63841, 63841], "mapped", [29575]], [[63842, 63842], "mapped", [30064]], [[63843, 63843], "mapped", [21271]], [[63844, 63844], "mapped", [30971]], [[63845, 63845], "mapped", [20415]], [[63846, 63846], "mapped", [24489]], [[63847, 63847], "mapped", [19981]], [[63848, 63848], "mapped", [27852]], [[63849, 63849], "mapped", [25976]], [[63850, 63850], "mapped", [32034]], [[63851, 63851], "mapped", [21443]], [[63852, 63852], "mapped", [22622]], [[63853, 63853], "mapped", [30465]], [[63854, 63854], "mapped", [33865]], [[63855, 63855], "mapped", [35498]], [[63856, 63856], "mapped", [27578]], [[63857, 63857], "mapped", [36784]], [[63858, 63858], "mapped", [27784]], [[63859, 63859], "mapped", [25342]], [[63860, 63860], "mapped", [33509]], [[63861, 63861], "mapped", [25504]], [[63862, 63862], "mapped", [30053]], [[63863, 63863], "mapped", [20142]], [[63864, 63864], "mapped", [20841]], [[63865, 63865], "mapped", [20937]], [[63866, 63866], "mapped", [26753]], [[63867, 63867], "mapped", [31975]], [[63868, 63868], "mapped", [33391]], [[63869, 63869], "mapped", [35538]], [[63870, 63870], "mapped", [37327]], [[63871, 63871], "mapped", [21237]], [[63872, 63872], "mapped", [21570]], [[63873, 63873], "mapped", [22899]], [[63874, 63874], "mapped", [24300]], [[63875, 63875], "mapped", [26053]], [[63876, 63876], "mapped", [28670]], [[63877, 63877], "mapped", [31018]], [[63878, 63878], "mapped", [38317]], [[63879, 63879], "mapped", [39530]], [[63880, 63880], "mapped", [40599]], [[63881, 63881], "mapped", [40654]], [[63882, 63882], "mapped", [21147]], [[63883, 63883], "mapped", [26310]], [[63884, 63884], "mapped", [27511]], [[63885, 63885], "mapped", [36706]], [[63886, 63886], "mapped", [24180]], [[63887, 63887], "mapped", [24976]], [[63888, 63888], "mapped", [25088]], [[63889, 63889], "mapped", [25754]], [[63890, 63890], "mapped", [28451]], [[63891, 63891], "mapped", [29001]], [[63892, 63892], "mapped", [29833]], [[63893, 63893], "mapped", [31178]], [[63894, 63894], "mapped", [32244]], [[63895, 63895], "mapped", [32879]], [[63896, 63896], "mapped", [36646]], [[63897, 63897], "mapped", [34030]], [[63898, 63898], "mapped", [36899]], [[63899, 63899], "mapped", [37706]], [[63900, 63900], "mapped", [21015]], [[63901, 63901], "mapped", [21155]], [[63902, 63902], "mapped", [21693]], [[63903, 63903], "mapped", [28872]], [[63904, 63904], "mapped", [35010]], [[63905, 63905], "mapped", [35498]], [[63906, 63906], "mapped", [24265]], [[63907, 63907], "mapped", [24565]], [[63908, 63908], "mapped", [25467]], [[63909, 63909], "mapped", [27566]], [[63910, 63910], "mapped", [31806]], [[63911, 63911], "mapped", [29557]], [[63912, 63912], "mapped", [20196]], [[63913, 63913], "mapped", [22265]], [[63914, 63914], "mapped", [23527]], [[63915, 63915], "mapped", [23994]], [[63916, 63916], "mapped", [24604]], [[63917, 63917], "mapped", [29618]], [[63918, 63918], "mapped", [29801]], [[63919, 63919], "mapped", [32666]], [[63920, 63920], "mapped", [32838]], [[63921, 63921], "mapped", [37428]], [[63922, 63922], "mapped", [38646]], [[63923, 63923], "mapped", [38728]], [[63924, 63924], "mapped", [38936]], [[63925, 63925], "mapped", [20363]], [[63926, 63926], "mapped", [31150]], [[63927, 63927], "mapped", [37300]], [[63928, 63928], "mapped", [38584]], [[63929, 63929], "mapped", [24801]], [[63930, 63930], "mapped", [20102]], [[63931, 63931], "mapped", [20698]], [[63932, 63932], "mapped", [23534]], [[63933, 63933], "mapped", [23615]], [[63934, 63934], "mapped", [26009]], [[63935, 63935], "mapped", [27138]], [[63936, 63936], "mapped", [29134]], [[63937, 63937], "mapped", [30274]], [[63938, 63938], "mapped", [34044]], [[63939, 63939], "mapped", [36988]], [[63940, 63940], "mapped", [40845]], [[63941, 63941], "mapped", [26248]], [[63942, 63942], "mapped", [38446]], [[63943, 63943], "mapped", [21129]], [[63944, 63944], "mapped", [26491]], [[63945, 63945], "mapped", [26611]], [[63946, 63946], "mapped", [27969]], [[63947, 63947], "mapped", [28316]], [[63948, 63948], "mapped", [29705]], [[63949, 63949], "mapped", [30041]], [[63950, 63950], "mapped", [30827]], [[63951, 63951], "mapped", [32016]], [[63952, 63952], "mapped", [39006]], [[63953, 63953], "mapped", [20845]], [[63954, 63954], "mapped", [25134]], [[63955, 63955], "mapped", [38520]], [[63956, 63956], "mapped", [20523]], [[63957, 63957], "mapped", [23833]], [[63958, 63958], "mapped", [28138]], [[63959, 63959], "mapped", [36650]], [[63960, 63960], "mapped", [24459]], [[63961, 63961], "mapped", [24900]], [[63962, 63962], "mapped", [26647]], [[63963, 63963], "mapped", [29575]], [[63964, 63964], "mapped", [38534]], [[63965, 63965], "mapped", [21033]], [[63966, 63966], "mapped", [21519]], [[63967, 63967], "mapped", [23653]], [[63968, 63968], "mapped", [26131]], [[63969, 63969], "mapped", [26446]], [[63970, 63970], "mapped", [26792]], [[63971, 63971], "mapped", [27877]], [[63972, 63972], "mapped", [29702]], [[63973, 63973], "mapped", [30178]], [[63974, 63974], "mapped", [32633]], [[63975, 63975], "mapped", [35023]], [[63976, 63976], "mapped", [35041]], [[63977, 63977], "mapped", [37324]], [[63978, 63978], "mapped", [38626]], [[63979, 63979], "mapped", [21311]], [[63980, 63980], "mapped", [28346]], [[63981, 63981], "mapped", [21533]], [[63982, 63982], "mapped", [29136]], [[63983, 63983], "mapped", [29848]], [[63984, 63984], "mapped", [34298]], [[63985, 63985], "mapped", [38563]], [[63986, 63986], "mapped", [40023]], [[63987, 63987], "mapped", [40607]], [[63988, 63988], "mapped", [26519]], [[63989, 63989], "mapped", [28107]], [[63990, 63990], "mapped", [33256]], [[63991, 63991], "mapped", [31435]], [[63992, 63992], "mapped", [31520]], [[63993, 63993], "mapped", [31890]], [[63994, 63994], "mapped", [29376]], [[63995, 63995], "mapped", [28825]], [[63996, 63996], "mapped", [35672]], [[63997, 63997], "mapped", [20160]], [[63998, 63998], "mapped", [33590]], [[63999, 63999], "mapped", [21050]], [[64000, 64000], "mapped", [20999]], [[64001, 64001], "mapped", [24230]], [[64002, 64002], "mapped", [25299]], [[64003, 64003], "mapped", [31958]], [[64004, 64004], "mapped", [23429]], [[64005, 64005], "mapped", [27934]], [[64006, 64006], "mapped", [26292]], [[64007, 64007], "mapped", [36667]], [[64008, 64008], "mapped", [34892]], [[64009, 64009], "mapped", [38477]], [[64010, 64010], "mapped", [35211]], [[64011, 64011], "mapped", [24275]], [[64012, 64012], "mapped", [20800]], [[64013, 64013], "mapped", [21952]], [[64014, 64015], "valid"], [[64016, 64016], "mapped", [22618]], [[64017, 64017], "valid"], [[64018, 64018], "mapped", [26228]], [[64019, 64020], "valid"], [[64021, 64021], "mapped", [20958]], [[64022, 64022], "mapped", [29482]], [[64023, 64023], "mapped", [30410]], [[64024, 64024], "mapped", [31036]], [[64025, 64025], "mapped", [31070]], [[64026, 64026], "mapped", [31077]], [[64027, 64027], "mapped", [31119]], [[64028, 64028], "mapped", [38742]], [[64029, 64029], "mapped", [31934]], [[64030, 64030], "mapped", [32701]], [[64031, 64031], "valid"], [[64032, 64032], "mapped", [34322]], [[64033, 64033], "valid"], [[64034, 64034], "mapped", [35576]], [[64035, 64036], "valid"], [[64037, 64037], "mapped", [36920]], [[64038, 64038], "mapped", [37117]], [[64039, 64041], "valid"], [[64042, 64042], "mapped", [39151]], [[64043, 64043], "mapped", [39164]], [[64044, 64044], "mapped", [39208]], [[64045, 64045], "mapped", [40372]], [[64046, 64046], "mapped", [37086]], [[64047, 64047], "mapped", [38583]], [[64048, 64048], "mapped", [20398]], [[64049, 64049], "mapped", [20711]], [[64050, 64050], "mapped", [20813]], [[64051, 64051], "mapped", [21193]], [[64052, 64052], "mapped", [21220]], [[64053, 64053], "mapped", [21329]], [[64054, 64054], "mapped", [21917]], [[64055, 64055], "mapped", [22022]], [[64056, 64056], "mapped", [22120]], [[64057, 64057], "mapped", [22592]], [[64058, 64058], "mapped", [22696]], [[64059, 64059], "mapped", [23652]], [[64060, 64060], "mapped", [23662]], [[64061, 64061], "mapped", [24724]], [[64062, 64062], "mapped", [24936]], [[64063, 64063], "mapped", [24974]], [[64064, 64064], "mapped", [25074]], [[64065, 64065], "mapped", [25935]], [[64066, 64066], "mapped", [26082]], [[64067, 64067], "mapped", [26257]], [[64068, 64068], "mapped", [26757]], [[64069, 64069], "mapped", [28023]], [[64070, 64070], "mapped", [28186]], [[64071, 64071], "mapped", [28450]], [[64072, 64072], "mapped", [29038]], [[64073, 64073], "mapped", [29227]], [[64074, 64074], "mapped", [29730]], [[64075, 64075], "mapped", [30865]], [[64076, 64076], "mapped", [31038]], [[64077, 64077], "mapped", [31049]], [[64078, 64078], "mapped", [31048]], [[64079, 64079], "mapped", [31056]], [[64080, 64080], "mapped", [31062]], [[64081, 64081], "mapped", [31069]], [[64082, 64082], "mapped", [31117]], [[64083, 64083], "mapped", [31118]], [[64084, 64084], "mapped", [31296]], [[64085, 64085], "mapped", [31361]], [[64086, 64086], "mapped", [31680]], [[64087, 64087], "mapped", [32244]], [[64088, 64088], "mapped", [32265]], [[64089, 64089], "mapped", [32321]], [[64090, 64090], "mapped", [32626]], [[64091, 64091], "mapped", [32773]], [[64092, 64092], "mapped", [33261]], [[64093, 64094], "mapped", [33401]], [[64095, 64095], "mapped", [33879]], [[64096, 64096], "mapped", [35088]], [[64097, 64097], "mapped", [35222]], [[64098, 64098], "mapped", [35585]], [[64099, 64099], "mapped", [35641]], [[64100, 64100], "mapped", [36051]], [[64101, 64101], "mapped", [36104]], [[64102, 64102], "mapped", [36790]], [[64103, 64103], "mapped", [36920]], [[64104, 64104], "mapped", [38627]], [[64105, 64105], "mapped", [38911]], [[64106, 64106], "mapped", [38971]], [[64107, 64107], "mapped", [24693]], [[64108, 64108], "mapped", [148206]], [[64109, 64109], "mapped", [33304]], [[64110, 64111], "disallowed"], [[64112, 64112], "mapped", [20006]], [[64113, 64113], "mapped", [20917]], [[64114, 64114], "mapped", [20840]], [[64115, 64115], "mapped", [20352]], [[64116, 64116], "mapped", [20805]], [[64117, 64117], "mapped", [20864]], [[64118, 64118], "mapped", [21191]], [[64119, 64119], "mapped", [21242]], [[64120, 64120], "mapped", [21917]], [[64121, 64121], "mapped", [21845]], [[64122, 64122], "mapped", [21913]], [[64123, 64123], "mapped", [21986]], [[64124, 64124], "mapped", [22618]], [[64125, 64125], "mapped", [22707]], [[64126, 64126], "mapped", [22852]], [[64127, 64127], "mapped", [22868]], [[64128, 64128], "mapped", [23138]], [[64129, 64129], "mapped", [23336]], [[64130, 64130], "mapped", [24274]], [[64131, 64131], "mapped", [24281]], [[64132, 64132], "mapped", [24425]], [[64133, 64133], "mapped", [24493]], [[64134, 64134], "mapped", [24792]], [[64135, 64135], "mapped", [24910]], [[64136, 64136], "mapped", [24840]], [[64137, 64137], "mapped", [24974]], [[64138, 64138], "mapped", [24928]], [[64139, 64139], "mapped", [25074]], [[64140, 64140], "mapped", [25140]], [[64141, 64141], "mapped", [25540]], [[64142, 64142], "mapped", [25628]], [[64143, 64143], "mapped", [25682]], [[64144, 64144], "mapped", [25942]], [[64145, 64145], "mapped", [26228]], [[64146, 64146], "mapped", [26391]], [[64147, 64147], "mapped", [26395]], [[64148, 64148], "mapped", [26454]], [[64149, 64149], "mapped", [27513]], [[64150, 64150], "mapped", [27578]], [[64151, 64151], "mapped", [27969]], [[64152, 64152], "mapped", [28379]], [[64153, 64153], "mapped", [28363]], [[64154, 64154], "mapped", [28450]], [[64155, 64155], "mapped", [28702]], [[64156, 64156], "mapped", [29038]], [[64157, 64157], "mapped", [30631]], [[64158, 64158], "mapped", [29237]], [[64159, 64159], "mapped", [29359]], [[64160, 64160], "mapped", [29482]], [[64161, 64161], "mapped", [29809]], [[64162, 64162], "mapped", [29958]], [[64163, 64163], "mapped", [30011]], [[64164, 64164], "mapped", [30237]], [[64165, 64165], "mapped", [30239]], [[64166, 64166], "mapped", [30410]], [[64167, 64167], "mapped", [30427]], [[64168, 64168], "mapped", [30452]], [[64169, 64169], "mapped", [30538]], [[64170, 64170], "mapped", [30528]], [[64171, 64171], "mapped", [30924]], [[64172, 64172], "mapped", [31409]], [[64173, 64173], "mapped", [31680]], [[64174, 64174], "mapped", [31867]], [[64175, 64175], "mapped", [32091]], [[64176, 64176], "mapped", [32244]], [[64177, 64177], "mapped", [32574]], [[64178, 64178], "mapped", [32773]], [[64179, 64179], "mapped", [33618]], [[64180, 64180], "mapped", [33775]], [[64181, 64181], "mapped", [34681]], [[64182, 64182], "mapped", [35137]], [[64183, 64183], "mapped", [35206]], [[64184, 64184], "mapped", [35222]], [[64185, 64185], "mapped", [35519]], [[64186, 64186], "mapped", [35576]], [[64187, 64187], "mapped", [35531]], [[64188, 64188], "mapped", [35585]], [[64189, 64189], "mapped", [35582]], [[64190, 64190], "mapped", [35565]], [[64191, 64191], "mapped", [35641]], [[64192, 64192], "mapped", [35722]], [[64193, 64193], "mapped", [36104]], [[64194, 64194], "mapped", [36664]], [[64195, 64195], "mapped", [36978]], [[64196, 64196], "mapped", [37273]], [[64197, 64197], "mapped", [37494]], [[64198, 64198], "mapped", [38524]], [[64199, 64199], "mapped", [38627]], [[64200, 64200], "mapped", [38742]], [[64201, 64201], "mapped", [38875]], [[64202, 64202], "mapped", [38911]], [[64203, 64203], "mapped", [38923]], [[64204, 64204], "mapped", [38971]], [[64205, 64205], "mapped", [39698]], [[64206, 64206], "mapped", [40860]], [[64207, 64207], "mapped", [141386]], [[64208, 64208], "mapped", [141380]], [[64209, 64209], "mapped", [144341]], [[64210, 64210], "mapped", [15261]], [[64211, 64211], "mapped", [16408]], [[64212, 64212], "mapped", [16441]], [[64213, 64213], "mapped", [152137]], [[64214, 64214], "mapped", [154832]], [[64215, 64215], "mapped", [163539]], [[64216, 64216], "mapped", [40771]], [[64217, 64217], "mapped", [40846]], [[64218, 64255], "disallowed"], [[64256, 64256], "mapped", [102, 102]], [[64257, 64257], "mapped", [102, 105]], [[64258, 64258], "mapped", [102, 108]], [[64259, 64259], "mapped", [102, 102, 105]], [[64260, 64260], "mapped", [102, 102, 108]], [[64261, 64262], "mapped", [115, 116]], [[64263, 64274], "disallowed"], [[64275, 64275], "mapped", [1396, 1398]], [[64276, 64276], "mapped", [1396, 1381]], [[64277, 64277], "mapped", [1396, 1387]], [[64278, 64278], "mapped", [1406, 1398]], [[64279, 64279], "mapped", [1396, 1389]], [[64280, 64284], "disallowed"], [[64285, 64285], "mapped", [1497, 1460]], [[64286, 64286], "valid"], [[64287, 64287], "mapped", [1522, 1463]], [[64288, 64288], "mapped", [1506]], [[64289, 64289], "mapped", [1488]], [[64290, 64290], "mapped", [1491]], [[64291, 64291], "mapped", [1492]], [[64292, 64292], "mapped", [1499]], [[64293, 64293], "mapped", [1500]], [[64294, 64294], "mapped", [1501]], [[64295, 64295], "mapped", [1512]], [[64296, 64296], "mapped", [1514]], [[64297, 64297], "disallowed_STD3_mapped", [43]], [[64298, 64298], "mapped", [1513, 1473]], [[64299, 64299], "mapped", [1513, 1474]], [[64300, 64300], "mapped", [1513, 1468, 1473]], [[64301, 64301], "mapped", [1513, 1468, 1474]], [[64302, 64302], "mapped", [1488, 1463]], [[64303, 64303], "mapped", [1488, 1464]], [[64304, 64304], "mapped", [1488, 1468]], [[64305, 64305], "mapped", [1489, 1468]], [[64306, 64306], "mapped", [1490, 1468]], [[64307, 64307], "mapped", [1491, 1468]], [[64308, 64308], "mapped", [1492, 1468]], [[64309, 64309], "mapped", [1493, 1468]], [[64310, 64310], "mapped", [1494, 1468]], [[64311, 64311], "disallowed"], [[64312, 64312], "mapped", [1496, 1468]], [[64313, 64313], "mapped", [1497, 1468]], [[64314, 64314], "mapped", [1498, 1468]], [[64315, 64315], "mapped", [1499, 1468]], [[64316, 64316], "mapped", [1500, 1468]], [[64317, 64317], "disallowed"], [[64318, 64318], "mapped", [1502, 1468]], [[64319, 64319], "disallowed"], [[64320, 64320], "mapped", [1504, 1468]], [[64321, 64321], "mapped", [1505, 1468]], [[64322, 64322], "disallowed"], [[64323, 64323], "mapped", [1507, 1468]], [[64324, 64324], "mapped", [1508, 1468]], [[64325, 64325], "disallowed"], [[64326, 64326], "mapped", [1510, 1468]], [[64327, 64327], "mapped", [1511, 1468]], [[64328, 64328], "mapped", [1512, 1468]], [[64329, 64329], "mapped", [1513, 1468]], [[64330, 64330], "mapped", [1514, 1468]], [[64331, 64331], "mapped", [1493, 1465]], [[64332, 64332], "mapped", [1489, 1471]], [[64333, 64333], "mapped", [1499, 1471]], [[64334, 64334], "mapped", [1508, 1471]], [[64335, 64335], "mapped", [1488, 1500]], [[64336, 64337], "mapped", [1649]], [[64338, 64341], "mapped", [1659]], [[64342, 64345], "mapped", [1662]], [[64346, 64349], "mapped", [1664]], [[64350, 64353], "mapped", [1658]], [[64354, 64357], "mapped", [1663]], [[64358, 64361], "mapped", [1657]], [[64362, 64365], "mapped", [1700]], [[64366, 64369], "mapped", [1702]], [[64370, 64373], "mapped", [1668]], [[64374, 64377], "mapped", [1667]], [[64378, 64381], "mapped", [1670]], [[64382, 64385], "mapped", [1671]], [[64386, 64387], "mapped", [1677]], [[64388, 64389], "mapped", [1676]], [[64390, 64391], "mapped", [1678]], [[64392, 64393], "mapped", [1672]], [[64394, 64395], "mapped", [1688]], [[64396, 64397], "mapped", [1681]], [[64398, 64401], "mapped", [1705]], [[64402, 64405], "mapped", [1711]], [[64406, 64409], "mapped", [1715]], [[64410, 64413], "mapped", [1713]], [[64414, 64415], "mapped", [1722]], [[64416, 64419], "mapped", [1723]], [[64420, 64421], "mapped", [1728]], [[64422, 64425], "mapped", [1729]], [[64426, 64429], "mapped", [1726]], [[64430, 64431], "mapped", [1746]], [[64432, 64433], "mapped", [1747]], [[64434, 64449], "valid", [], "NV8"], [[64450, 64466], "disallowed"], [[64467, 64470], "mapped", [1709]], [[64471, 64472], "mapped", [1735]], [[64473, 64474], "mapped", [1734]], [[64475, 64476], "mapped", [1736]], [[64477, 64477], "mapped", [1735, 1652]], [[64478, 64479], "mapped", [1739]], [[64480, 64481], "mapped", [1733]], [[64482, 64483], "mapped", [1737]], [[64484, 64487], "mapped", [1744]], [[64488, 64489], "mapped", [1609]], [[64490, 64491], "mapped", [1574, 1575]], [[64492, 64493], "mapped", [1574, 1749]], [[64494, 64495], "mapped", [1574, 1608]], [[64496, 64497], "mapped", [1574, 1735]], [[64498, 64499], "mapped", [1574, 1734]], [[64500, 64501], "mapped", [1574, 1736]], [[64502, 64504], "mapped", [1574, 1744]], [[64505, 64507], "mapped", [1574, 1609]], [[64508, 64511], "mapped", [1740]], [[64512, 64512], "mapped", [1574, 1580]], [[64513, 64513], "mapped", [1574, 1581]], [[64514, 64514], "mapped", [1574, 1605]], [[64515, 64515], "mapped", [1574, 1609]], [[64516, 64516], "mapped", [1574, 1610]], [[64517, 64517], "mapped", [1576, 1580]], [[64518, 64518], "mapped", [1576, 1581]], [[64519, 64519], "mapped", [1576, 1582]], [[64520, 64520], "mapped", [1576, 1605]], [[64521, 64521], "mapped", [1576, 1609]], [[64522, 64522], "mapped", [1576, 1610]], [[64523, 64523], "mapped", [1578, 1580]], [[64524, 64524], "mapped", [1578, 1581]], [[64525, 64525], "mapped", [1578, 1582]], [[64526, 64526], "mapped", [1578, 1605]], [[64527, 64527], "mapped", [1578, 1609]], [[64528, 64528], "mapped", [1578, 1610]], [[64529, 64529], "mapped", [1579, 1580]], [[64530, 64530], "mapped", [1579, 1605]], [[64531, 64531], "mapped", [1579, 1609]], [[64532, 64532], "mapped", [1579, 1610]], [[64533, 64533], "mapped", [1580, 1581]], [[64534, 64534], "mapped", [1580, 1605]], [[64535, 64535], "mapped", [1581, 1580]], [[64536, 64536], "mapped", [1581, 1605]], [[64537, 64537], "mapped", [1582, 1580]], [[64538, 64538], "mapped", [1582, 1581]], [[64539, 64539], "mapped", [1582, 1605]], [[64540, 64540], "mapped", [1587, 1580]], [[64541, 64541], "mapped", [1587, 1581]], [[64542, 64542], "mapped", [1587, 1582]], [[64543, 64543], "mapped", [1587, 1605]], [[64544, 64544], "mapped", [1589, 1581]], [[64545, 64545], "mapped", [1589, 1605]], [[64546, 64546], "mapped", [1590, 1580]], [[64547, 64547], "mapped", [1590, 1581]], [[64548, 64548], "mapped", [1590, 1582]], [[64549, 64549], "mapped", [1590, 1605]], [[64550, 64550], "mapped", [1591, 1581]], [[64551, 64551], "mapped", [1591, 1605]], [[64552, 64552], "mapped", [1592, 1605]], [[64553, 64553], "mapped", [1593, 1580]], [[64554, 64554], "mapped", [1593, 1605]], [[64555, 64555], "mapped", [1594, 1580]], [[64556, 64556], "mapped", [1594, 1605]], [[64557, 64557], "mapped", [1601, 1580]], [[64558, 64558], "mapped", [1601, 1581]], [[64559, 64559], "mapped", [1601, 1582]], [[64560, 64560], "mapped", [1601, 1605]], [[64561, 64561], "mapped", [1601, 1609]], [[64562, 64562], "mapped", [1601, 1610]], [[64563, 64563], "mapped", [1602, 1581]], [[64564, 64564], "mapped", [1602, 1605]], [[64565, 64565], "mapped", [1602, 1609]], [[64566, 64566], "mapped", [1602, 1610]], [[64567, 64567], "mapped", [1603, 1575]], [[64568, 64568], "mapped", [1603, 1580]], [[64569, 64569], "mapped", [1603, 1581]], [[64570, 64570], "mapped", [1603, 1582]], [[64571, 64571], "mapped", [1603, 1604]], [[64572, 64572], "mapped", [1603, 1605]], [[64573, 64573], "mapped", [1603, 1609]], [[64574, 64574], "mapped", [1603, 1610]], [[64575, 64575], "mapped", [1604, 1580]], [[64576, 64576], "mapped", [1604, 1581]], [[64577, 64577], "mapped", [1604, 1582]], [[64578, 64578], "mapped", [1604, 1605]], [[64579, 64579], "mapped", [1604, 1609]], [[64580, 64580], "mapped", [1604, 1610]], [[64581, 64581], "mapped", [1605, 1580]], [[64582, 64582], "mapped", [1605, 1581]], [[64583, 64583], "mapped", [1605, 1582]], [[64584, 64584], "mapped", [1605, 1605]], [[64585, 64585], "mapped", [1605, 1609]], [[64586, 64586], "mapped", [1605, 1610]], [[64587, 64587], "mapped", [1606, 1580]], [[64588, 64588], "mapped", [1606, 1581]], [[64589, 64589], "mapped", [1606, 1582]], [[64590, 64590], "mapped", [1606, 1605]], [[64591, 64591], "mapped", [1606, 1609]], [[64592, 64592], "mapped", [1606, 1610]], [[64593, 64593], "mapped", [1607, 1580]], [[64594, 64594], "mapped", [1607, 1605]], [[64595, 64595], "mapped", [1607, 1609]], [[64596, 64596], "mapped", [1607, 1610]], [[64597, 64597], "mapped", [1610, 1580]], [[64598, 64598], "mapped", [1610, 1581]], [[64599, 64599], "mapped", [1610, 1582]], [[64600, 64600], "mapped", [1610, 1605]], [[64601, 64601], "mapped", [1610, 1609]], [[64602, 64602], "mapped", [1610, 1610]], [[64603, 64603], "mapped", [1584, 1648]], [[64604, 64604], "mapped", [1585, 1648]], [[64605, 64605], "mapped", [1609, 1648]], [[64606, 64606], "disallowed_STD3_mapped", [32, 1612, 1617]], [[64607, 64607], "disallowed_STD3_mapped", [32, 1613, 1617]], [[64608, 64608], "disallowed_STD3_mapped", [32, 1614, 1617]], [[64609, 64609], "disallowed_STD3_mapped", [32, 1615, 1617]], [[64610, 64610], "disallowed_STD3_mapped", [32, 1616, 1617]], [[64611, 64611], "disallowed_STD3_mapped", [32, 1617, 1648]], [[64612, 64612], "mapped", [1574, 1585]], [[64613, 64613], "mapped", [1574, 1586]], [[64614, 64614], "mapped", [1574, 1605]], [[64615, 64615], "mapped", [1574, 1606]], [[64616, 64616], "mapped", [1574, 1609]], [[64617, 64617], "mapped", [1574, 1610]], [[64618, 64618], "mapped", [1576, 1585]], [[64619, 64619], "mapped", [1576, 1586]], [[64620, 64620], "mapped", [1576, 1605]], [[64621, 64621], "mapped", [1576, 1606]], [[64622, 64622], "mapped", [1576, 1609]], [[64623, 64623], "mapped", [1576, 1610]], [[64624, 64624], "mapped", [1578, 1585]], [[64625, 64625], "mapped", [1578, 1586]], [[64626, 64626], "mapped", [1578, 1605]], [[64627, 64627], "mapped", [1578, 1606]], [[64628, 64628], "mapped", [1578, 1609]], [[64629, 64629], "mapped", [1578, 1610]], [[64630, 64630], "mapped", [1579, 1585]], [[64631, 64631], "mapped", [1579, 1586]], [[64632, 64632], "mapped", [1579, 1605]], [[64633, 64633], "mapped", [1579, 1606]], [[64634, 64634], "mapped", [1579, 1609]], [[64635, 64635], "mapped", [1579, 1610]], [[64636, 64636], "mapped", [1601, 1609]], [[64637, 64637], "mapped", [1601, 1610]], [[64638, 64638], "mapped", [1602, 1609]], [[64639, 64639], "mapped", [1602, 1610]], [[64640, 64640], "mapped", [1603, 1575]], [[64641, 64641], "mapped", [1603, 1604]], [[64642, 64642], "mapped", [1603, 1605]], [[64643, 64643], "mapped", [1603, 1609]], [[64644, 64644], "mapped", [1603, 1610]], [[64645, 64645], "mapped", [1604, 1605]], [[64646, 64646], "mapped", [1604, 1609]], [[64647, 64647], "mapped", [1604, 1610]], [[64648, 64648], "mapped", [1605, 1575]], [[64649, 64649], "mapped", [1605, 1605]], [[64650, 64650], "mapped", [1606, 1585]], [[64651, 64651], "mapped", [1606, 1586]], [[64652, 64652], "mapped", [1606, 1605]], [[64653, 64653], "mapped", [1606, 1606]], [[64654, 64654], "mapped", [1606, 1609]], [[64655, 64655], "mapped", [1606, 1610]], [[64656, 64656], "mapped", [1609, 1648]], [[64657, 64657], "mapped", [1610, 1585]], [[64658, 64658], "mapped", [1610, 1586]], [[64659, 64659], "mapped", [1610, 1605]], [[64660, 64660], "mapped", [1610, 1606]], [[64661, 64661], "mapped", [1610, 1609]], [[64662, 64662], "mapped", [1610, 1610]], [[64663, 64663], "mapped", [1574, 1580]], [[64664, 64664], "mapped", [1574, 1581]], [[64665, 64665], "mapped", [1574, 1582]], [[64666, 64666], "mapped", [1574, 1605]], [[64667, 64667], "mapped", [1574, 1607]], [[64668, 64668], "mapped", [1576, 1580]], [[64669, 64669], "mapped", [1576, 1581]], [[64670, 64670], "mapped", [1576, 1582]], [[64671, 64671], "mapped", [1576, 1605]], [[64672, 64672], "mapped", [1576, 1607]], [[64673, 64673], "mapped", [1578, 1580]], [[64674, 64674], "mapped", [1578, 1581]], [[64675, 64675], "mapped", [1578, 1582]], [[64676, 64676], "mapped", [1578, 1605]], [[64677, 64677], "mapped", [1578, 1607]], [[64678, 64678], "mapped", [1579, 1605]], [[64679, 64679], "mapped", [1580, 1581]], [[64680, 64680], "mapped", [1580, 1605]], [[64681, 64681], "mapped", [1581, 1580]], [[64682, 64682], "mapped", [1581, 1605]], [[64683, 64683], "mapped", [1582, 1580]], [[64684, 64684], "mapped", [1582, 1605]], [[64685, 64685], "mapped", [1587, 1580]], [[64686, 64686], "mapped", [1587, 1581]], [[64687, 64687], "mapped", [1587, 1582]], [[64688, 64688], "mapped", [1587, 1605]], [[64689, 64689], "mapped", [1589, 1581]], [[64690, 64690], "mapped", [1589, 1582]], [[64691, 64691], "mapped", [1589, 1605]], [[64692, 64692], "mapped", [1590, 1580]], [[64693, 64693], "mapped", [1590, 1581]], [[64694, 64694], "mapped", [1590, 1582]], [[64695, 64695], "mapped", [1590, 1605]], [[64696, 64696], "mapped", [1591, 1581]], [[64697, 64697], "mapped", [1592, 1605]], [[64698, 64698], "mapped", [1593, 1580]], [[64699, 64699], "mapped", [1593, 1605]], [[64700, 64700], "mapped", [1594, 1580]], [[64701, 64701], "mapped", [1594, 1605]], [[64702, 64702], "mapped", [1601, 1580]], [[64703, 64703], "mapped", [1601, 1581]], [[64704, 64704], "mapped", [1601, 1582]], [[64705, 64705], "mapped", [1601, 1605]], [[64706, 64706], "mapped", [1602, 1581]], [[64707, 64707], "mapped", [1602, 1605]], [[64708, 64708], "mapped", [1603, 1580]], [[64709, 64709], "mapped", [1603, 1581]], [[64710, 64710], "mapped", [1603, 1582]], [[64711, 64711], "mapped", [1603, 1604]], [[64712, 64712], "mapped", [1603, 1605]], [[64713, 64713], "mapped", [1604, 1580]], [[64714, 64714], "mapped", [1604, 1581]], [[64715, 64715], "mapped", [1604, 1582]], [[64716, 64716], "mapped", [1604, 1605]], [[64717, 64717], "mapped", [1604, 1607]], [[64718, 64718], "mapped", [1605, 1580]], [[64719, 64719], "mapped", [1605, 1581]], [[64720, 64720], "mapped", [1605, 1582]], [[64721, 64721], "mapped", [1605, 1605]], [[64722, 64722], "mapped", [1606, 1580]], [[64723, 64723], "mapped", [1606, 1581]], [[64724, 64724], "mapped", [1606, 1582]], [[64725, 64725], "mapped", [1606, 1605]], [[64726, 64726], "mapped", [1606, 1607]], [[64727, 64727], "mapped", [1607, 1580]], [[64728, 64728], "mapped", [1607, 1605]], [[64729, 64729], "mapped", [1607, 1648]], [[64730, 64730], "mapped", [1610, 1580]], [[64731, 64731], "mapped", [1610, 1581]], [[64732, 64732], "mapped", [1610, 1582]], [[64733, 64733], "mapped", [1610, 1605]], [[64734, 64734], "mapped", [1610, 1607]], [[64735, 64735], "mapped", [1574, 1605]], [[64736, 64736], "mapped", [1574, 1607]], [[64737, 64737], "mapped", [1576, 1605]], [[64738, 64738], "mapped", [1576, 1607]], [[64739, 64739], "mapped", [1578, 1605]], [[64740, 64740], "mapped", [1578, 1607]], [[64741, 64741], "mapped", [1579, 1605]], [[64742, 64742], "mapped", [1579, 1607]], [[64743, 64743], "mapped", [1587, 1605]], [[64744, 64744], "mapped", [1587, 1607]], [[64745, 64745], "mapped", [1588, 1605]], [[64746, 64746], "mapped", [1588, 1607]], [[64747, 64747], "mapped", [1603, 1604]], [[64748, 64748], "mapped", [1603, 1605]], [[64749, 64749], "mapped", [1604, 1605]], [[64750, 64750], "mapped", [1606, 1605]], [[64751, 64751], "mapped", [1606, 1607]], [[64752, 64752], "mapped", [1610, 1605]], [[64753, 64753], "mapped", [1610, 1607]], [[64754, 64754], "mapped", [1600, 1614, 1617]], [[64755, 64755], "mapped", [1600, 1615, 1617]], [[64756, 64756], "mapped", [1600, 1616, 1617]], [[64757, 64757], "mapped", [1591, 1609]], [[64758, 64758], "mapped", [1591, 1610]], [[64759, 64759], "mapped", [1593, 1609]], [[64760, 64760], "mapped", [1593, 1610]], [[64761, 64761], "mapped", [1594, 1609]], [[64762, 64762], "mapped", [1594, 1610]], [[64763, 64763], "mapped", [1587, 1609]], [[64764, 64764], "mapped", [1587, 1610]], [[64765, 64765], "mapped", [1588, 1609]], [[64766, 64766], "mapped", [1588, 1610]], [[64767, 64767], "mapped", [1581, 1609]], [[64768, 64768], "mapped", [1581, 1610]], [[64769, 64769], "mapped", [1580, 1609]], [[64770, 64770], "mapped", [1580, 1610]], [[64771, 64771], "mapped", [1582, 1609]], [[64772, 64772], "mapped", [1582, 1610]], [[64773, 64773], "mapped", [1589, 1609]], [[64774, 64774], "mapped", [1589, 1610]], [[64775, 64775], "mapped", [1590, 1609]], [[64776, 64776], "mapped", [1590, 1610]], [[64777, 64777], "mapped", [1588, 1580]], [[64778, 64778], "mapped", [1588, 1581]], [[64779, 64779], "mapped", [1588, 1582]], [[64780, 64780], "mapped", [1588, 1605]], [[64781, 64781], "mapped", [1588, 1585]], [[64782, 64782], "mapped", [1587, 1585]], [[64783, 64783], "mapped", [1589, 1585]], [[64784, 64784], "mapped", [1590, 1585]], [[64785, 64785], "mapped", [1591, 1609]], [[64786, 64786], "mapped", [1591, 1610]], [[64787, 64787], "mapped", [1593, 1609]], [[64788, 64788], "mapped", [1593, 1610]], [[64789, 64789], "mapped", [1594, 1609]], [[64790, 64790], "mapped", [1594, 1610]], [[64791, 64791], "mapped", [1587, 1609]], [[64792, 64792], "mapped", [1587, 1610]], [[64793, 64793], "mapped", [1588, 1609]], [[64794, 64794], "mapped", [1588, 1610]], [[64795, 64795], "mapped", [1581, 1609]], [[64796, 64796], "mapped", [1581, 1610]], [[64797, 64797], "mapped", [1580, 1609]], [[64798, 64798], "mapped", [1580, 1610]], [[64799, 64799], "mapped", [1582, 1609]], [[64800, 64800], "mapped", [1582, 1610]], [[64801, 64801], "mapped", [1589, 1609]], [[64802, 64802], "mapped", [1589, 1610]], [[64803, 64803], "mapped", [1590, 1609]], [[64804, 64804], "mapped", [1590, 1610]], [[64805, 64805], "mapped", [1588, 1580]], [[64806, 64806], "mapped", [1588, 1581]], [[64807, 64807], "mapped", [1588, 1582]], [[64808, 64808], "mapped", [1588, 1605]], [[64809, 64809], "mapped", [1588, 1585]], [[64810, 64810], "mapped", [1587, 1585]], [[64811, 64811], "mapped", [1589, 1585]], [[64812, 64812], "mapped", [1590, 1585]], [[64813, 64813], "mapped", [1588, 1580]], [[64814, 64814], "mapped", [1588, 1581]], [[64815, 64815], "mapped", [1588, 1582]], [[64816, 64816], "mapped", [1588, 1605]], [[64817, 64817], "mapped", [1587, 1607]], [[64818, 64818], "mapped", [1588, 1607]], [[64819, 64819], "mapped", [1591, 1605]], [[64820, 64820], "mapped", [1587, 1580]], [[64821, 64821], "mapped", [1587, 1581]], [[64822, 64822], "mapped", [1587, 1582]], [[64823, 64823], "mapped", [1588, 1580]], [[64824, 64824], "mapped", [1588, 1581]], [[64825, 64825], "mapped", [1588, 1582]], [[64826, 64826], "mapped", [1591, 1605]], [[64827, 64827], "mapped", [1592, 1605]], [[64828, 64829], "mapped", [1575, 1611]], [[64830, 64831], "valid", [], "NV8"], [[64832, 64847], "disallowed"], [[64848, 64848], "mapped", [1578, 1580, 1605]], [[64849, 64850], "mapped", [1578, 1581, 1580]], [[64851, 64851], "mapped", [1578, 1581, 1605]], [[64852, 64852], "mapped", [1578, 1582, 1605]], [[64853, 64853], "mapped", [1578, 1605, 1580]], [[64854, 64854], "mapped", [1578, 1605, 1581]], [[64855, 64855], "mapped", [1578, 1605, 1582]], [[64856, 64857], "mapped", [1580, 1605, 1581]], [[64858, 64858], "mapped", [1581, 1605, 1610]], [[64859, 64859], "mapped", [1581, 1605, 1609]], [[64860, 64860], "mapped", [1587, 1581, 1580]], [[64861, 64861], "mapped", [1587, 1580, 1581]], [[64862, 64862], "mapped", [1587, 1580, 1609]], [[64863, 64864], "mapped", [1587, 1605, 1581]], [[64865, 64865], "mapped", [1587, 1605, 1580]], [[64866, 64867], "mapped", [1587, 1605, 1605]], [[64868, 64869], "mapped", [1589, 1581, 1581]], [[64870, 64870], "mapped", [1589, 1605, 1605]], [[64871, 64872], "mapped", [1588, 1581, 1605]], [[64873, 64873], "mapped", [1588, 1580, 1610]], [[64874, 64875], "mapped", [1588, 1605, 1582]], [[64876, 64877], "mapped", [1588, 1605, 1605]], [[64878, 64878], "mapped", [1590, 1581, 1609]], [[64879, 64880], "mapped", [1590, 1582, 1605]], [[64881, 64882], "mapped", [1591, 1605, 1581]], [[64883, 64883], "mapped", [1591, 1605, 1605]], [[64884, 64884], "mapped", [1591, 1605, 1610]], [[64885, 64885], "mapped", [1593, 1580, 1605]], [[64886, 64887], "mapped", [1593, 1605, 1605]], [[64888, 64888], "mapped", [1593, 1605, 1609]], [[64889, 64889], "mapped", [1594, 1605, 1605]], [[64890, 64890], "mapped", [1594, 1605, 1610]], [[64891, 64891], "mapped", [1594, 1605, 1609]], [[64892, 64893], "mapped", [1601, 1582, 1605]], [[64894, 64894], "mapped", [1602, 1605, 1581]], [[64895, 64895], "mapped", [1602, 1605, 1605]], [[64896, 64896], "mapped", [1604, 1581, 1605]], [[64897, 64897], "mapped", [1604, 1581, 1610]], [[64898, 64898], "mapped", [1604, 1581, 1609]], [[64899, 64900], "mapped", [1604, 1580, 1580]], [[64901, 64902], "mapped", [1604, 1582, 1605]], [[64903, 64904], "mapped", [1604, 1605, 1581]], [[64905, 64905], "mapped", [1605, 1581, 1580]], [[64906, 64906], "mapped", [1605, 1581, 1605]], [[64907, 64907], "mapped", [1605, 1581, 1610]], [[64908, 64908], "mapped", [1605, 1580, 1581]], [[64909, 64909], "mapped", [1605, 1580, 1605]], [[64910, 64910], "mapped", [1605, 1582, 1580]], [[64911, 64911], "mapped", [1605, 1582, 1605]], [[64912, 64913], "disallowed"], [[64914, 64914], "mapped", [1605, 1580, 1582]], [[64915, 64915], "mapped", [1607, 1605, 1580]], [[64916, 64916], "mapped", [1607, 1605, 1605]], [[64917, 64917], "mapped", [1606, 1581, 1605]], [[64918, 64918], "mapped", [1606, 1581, 1609]], [[64919, 64920], "mapped", [1606, 1580, 1605]], [[64921, 64921], "mapped", [1606, 1580, 1609]], [[64922, 64922], "mapped", [1606, 1605, 1610]], [[64923, 64923], "mapped", [1606, 1605, 1609]], [[64924, 64925], "mapped", [1610, 1605, 1605]], [[64926, 64926], "mapped", [1576, 1582, 1610]], [[64927, 64927], "mapped", [1578, 1580, 1610]], [[64928, 64928], "mapped", [1578, 1580, 1609]], [[64929, 64929], "mapped", [1578, 1582, 1610]], [[64930, 64930], "mapped", [1578, 1582, 1609]], [[64931, 64931], "mapped", [1578, 1605, 1610]], [[64932, 64932], "mapped", [1578, 1605, 1609]], [[64933, 64933], "mapped", [1580, 1605, 1610]], [[64934, 64934], "mapped", [1580, 1581, 1609]], [[64935, 64935], "mapped", [1580, 1605, 1609]], [[64936, 64936], "mapped", [1587, 1582, 1609]], [[64937, 64937], "mapped", [1589, 1581, 1610]], [[64938, 64938], "mapped", [1588, 1581, 1610]], [[64939, 64939], "mapped", [1590, 1581, 1610]], [[64940, 64940], "mapped", [1604, 1580, 1610]], [[64941, 64941], "mapped", [1604, 1605, 1610]], [[64942, 64942], "mapped", [1610, 1581, 1610]], [[64943, 64943], "mapped", [1610, 1580, 1610]], [[64944, 64944], "mapped", [1610, 1605, 1610]], [[64945, 64945], "mapped", [1605, 1605, 1610]], [[64946, 64946], "mapped", [1602, 1605, 1610]], [[64947, 64947], "mapped", [1606, 1581, 1610]], [[64948, 64948], "mapped", [1602, 1605, 1581]], [[64949, 64949], "mapped", [1604, 1581, 1605]], [[64950, 64950], "mapped", [1593, 1605, 1610]], [[64951, 64951], "mapped", [1603, 1605, 1610]], [[64952, 64952], "mapped", [1606, 1580, 1581]], [[64953, 64953], "mapped", [1605, 1582, 1610]], [[64954, 64954], "mapped", [1604, 1580, 1605]], [[64955, 64955], "mapped", [1603, 1605, 1605]], [[64956, 64956], "mapped", [1604, 1580, 1605]], [[64957, 64957], "mapped", [1606, 1580, 1581]], [[64958, 64958], "mapped", [1580, 1581, 1610]], [[64959, 64959], "mapped", [1581, 1580, 1610]], [[64960, 64960], "mapped", [1605, 1580, 1610]], [[64961, 64961], "mapped", [1601, 1605, 1610]], [[64962, 64962], "mapped", [1576, 1581, 1610]], [[64963, 64963], "mapped", [1603, 1605, 1605]], [[64964, 64964], "mapped", [1593, 1580, 1605]], [[64965, 64965], "mapped", [1589, 1605, 1605]], [[64966, 64966], "mapped", [1587, 1582, 1610]], [[64967, 64967], "mapped", [1606, 1580, 1610]], [[64968, 64975], "disallowed"], [[64976, 65007], "disallowed"], [[65008, 65008], "mapped", [1589, 1604, 1746]], [[65009, 65009], "mapped", [1602, 1604, 1746]], [[65010, 65010], "mapped", [1575, 1604, 1604, 1607]], [[65011, 65011], "mapped", [1575, 1603, 1576, 1585]], [[65012, 65012], "mapped", [1605, 1581, 1605, 1583]], [[65013, 65013], "mapped", [1589, 1604, 1593, 1605]], [[65014, 65014], "mapped", [1585, 1587, 1608, 1604]], [[65015, 65015], "mapped", [1593, 1604, 1610, 1607]], [[65016, 65016], "mapped", [1608, 1587, 1604, 1605]], [[65017, 65017], "mapped", [1589, 1604, 1609]], [[65018, 65018], "disallowed_STD3_mapped", [1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610, 1607, 32, 1608, 1587, 1604, 1605]], [[65019, 65019], "disallowed_STD3_mapped", [1580, 1604, 32, 1580, 1604, 1575, 1604, 1607]], [[65020, 65020], "mapped", [1585, 1740, 1575, 1604]], [[65021, 65021], "valid", [], "NV8"], [[65022, 65023], "disallowed"], [[65024, 65039], "ignored"], [[65040, 65040], "disallowed_STD3_mapped", [44]], [[65041, 65041], "mapped", [12289]], [[65042, 65042], "disallowed"], [[65043, 65043], "disallowed_STD3_mapped", [58]], [[65044, 65044], "disallowed_STD3_mapped", [59]], [[65045, 65045], "disallowed_STD3_mapped", [33]], [[65046, 65046], "disallowed_STD3_mapped", [63]], [[65047, 65047], "mapped", [12310]], [[65048, 65048], "mapped", [12311]], [[65049, 65049], "disallowed"], [[65050, 65055], "disallowed"], [[65056, 65059], "valid"], [[65060, 65062], "valid"], [[65063, 65069], "valid"], [[65070, 65071], "valid"], [[65072, 65072], "disallowed"], [[65073, 65073], "mapped", [8212]], [[65074, 65074], "mapped", [8211]], [[65075, 65076], "disallowed_STD3_mapped", [95]], [[65077, 65077], "disallowed_STD3_mapped", [40]], [[65078, 65078], "disallowed_STD3_mapped", [41]], [[65079, 65079], "disallowed_STD3_mapped", [123]], [[65080, 65080], "disallowed_STD3_mapped", [125]], [[65081, 65081], "mapped", [12308]], [[65082, 65082], "mapped", [12309]], [[65083, 65083], "mapped", [12304]], [[65084, 65084], "mapped", [12305]], [[65085, 65085], "mapped", [12298]], [[65086, 65086], "mapped", [12299]], [[65087, 65087], "mapped", [12296]], [[65088, 65088], "mapped", [12297]], [[65089, 65089], "mapped", [12300]], [[65090, 65090], "mapped", [12301]], [[65091, 65091], "mapped", [12302]], [[65092, 65092], "mapped", [12303]], [[65093, 65094], "valid", [], "NV8"], [[65095, 65095], "disallowed_STD3_mapped", [91]], [[65096, 65096], "disallowed_STD3_mapped", [93]], [[65097, 65100], "disallowed_STD3_mapped", [32, 773]], [[65101, 65103], "disallowed_STD3_mapped", [95]], [[65104, 65104], "disallowed_STD3_mapped", [44]], [[65105, 65105], "mapped", [12289]], [[65106, 65106], "disallowed"], [[65107, 65107], "disallowed"], [[65108, 65108], "disallowed_STD3_mapped", [59]], [[65109, 65109], "disallowed_STD3_mapped", [58]], [[65110, 65110], "disallowed_STD3_mapped", [63]], [[65111, 65111], "disallowed_STD3_mapped", [33]], [[65112, 65112], "mapped", [8212]], [[65113, 65113], "disallowed_STD3_mapped", [40]], [[65114, 65114], "disallowed_STD3_mapped", [41]], [[65115, 65115], "disallowed_STD3_mapped", [123]], [[65116, 65116], "disallowed_STD3_mapped", [125]], [[65117, 65117], "mapped", [12308]], [[65118, 65118], "mapped", [12309]], [[65119, 65119], "disallowed_STD3_mapped", [35]], [[65120, 65120], "disallowed_STD3_mapped", [38]], [[65121, 65121], "disallowed_STD3_mapped", [42]], [[65122, 65122], "disallowed_STD3_mapped", [43]], [[65123, 65123], "mapped", [45]], [[65124, 65124], "disallowed_STD3_mapped", [60]], [[65125, 65125], "disallowed_STD3_mapped", [62]], [[65126, 65126], "disallowed_STD3_mapped", [61]], [[65127, 65127], "disallowed"], [[65128, 65128], "disallowed_STD3_mapped", [92]], [[65129, 65129], "disallowed_STD3_mapped", [36]], [[65130, 65130], "disallowed_STD3_mapped", [37]], [[65131, 65131], "disallowed_STD3_mapped", [64]], [[65132, 65135], "disallowed"], [[65136, 65136], "disallowed_STD3_mapped", [32, 1611]], [[65137, 65137], "mapped", [1600, 1611]], [[65138, 65138], "disallowed_STD3_mapped", [32, 1612]], [[65139, 65139], "valid"], [[65140, 65140], "disallowed_STD3_mapped", [32, 1613]], [[65141, 65141], "disallowed"], [[65142, 65142], "disallowed_STD3_mapped", [32, 1614]], [[65143, 65143], "mapped", [1600, 1614]], [[65144, 65144], "disallowed_STD3_mapped", [32, 1615]], [[65145, 65145], "mapped", [1600, 1615]], [[65146, 65146], "disallowed_STD3_mapped", [32, 1616]], [[65147, 65147], "mapped", [1600, 1616]], [[65148, 65148], "disallowed_STD3_mapped", [32, 1617]], [[65149, 65149], "mapped", [1600, 1617]], [[65150, 65150], "disallowed_STD3_mapped", [32, 1618]], [[65151, 65151], "mapped", [1600, 1618]], [[65152, 65152], "mapped", [1569]], [[65153, 65154], "mapped", [1570]], [[65155, 65156], "mapped", [1571]], [[65157, 65158], "mapped", [1572]], [[65159, 65160], "mapped", [1573]], [[65161, 65164], "mapped", [1574]], [[65165, 65166], "mapped", [1575]], [[65167, 65170], "mapped", [1576]], [[65171, 65172], "mapped", [1577]], [[65173, 65176], "mapped", [1578]], [[65177, 65180], "mapped", [1579]], [[65181, 65184], "mapped", [1580]], [[65185, 65188], "mapped", [1581]], [[65189, 65192], "mapped", [1582]], [[65193, 65194], "mapped", [1583]], [[65195, 65196], "mapped", [1584]], [[65197, 65198], "mapped", [1585]], [[65199, 65200], "mapped", [1586]], [[65201, 65204], "mapped", [1587]], [[65205, 65208], "mapped", [1588]], [[65209, 65212], "mapped", [1589]], [[65213, 65216], "mapped", [1590]], [[65217, 65220], "mapped", [1591]], [[65221, 65224], "mapped", [1592]], [[65225, 65228], "mapped", [1593]], [[65229, 65232], "mapped", [1594]], [[65233, 65236], "mapped", [1601]], [[65237, 65240], "mapped", [1602]], [[65241, 65244], "mapped", [1603]], [[65245, 65248], "mapped", [1604]], [[65249, 65252], "mapped", [1605]], [[65253, 65256], "mapped", [1606]], [[65257, 65260], "mapped", [1607]], [[65261, 65262], "mapped", [1608]], [[65263, 65264], "mapped", [1609]], [[65265, 65268], "mapped", [1610]], [[65269, 65270], "mapped", [1604, 1570]], [[65271, 65272], "mapped", [1604, 1571]], [[65273, 65274], "mapped", [1604, 1573]], [[65275, 65276], "mapped", [1604, 1575]], [[65277, 65278], "disallowed"], [[65279, 65279], "ignored"], [[65280, 65280], "disallowed"], [[65281, 65281], "disallowed_STD3_mapped", [33]], [[65282, 65282], "disallowed_STD3_mapped", [34]], [[65283, 65283], "disallowed_STD3_mapped", [35]], [[65284, 65284], "disallowed_STD3_mapped", [36]], [[65285, 65285], "disallowed_STD3_mapped", [37]], [[65286, 65286], "disallowed_STD3_mapped", [38]], [[65287, 65287], "disallowed_STD3_mapped", [39]], [[65288, 65288], "disallowed_STD3_mapped", [40]], [[65289, 65289], "disallowed_STD3_mapped", [41]], [[65290, 65290], "disallowed_STD3_mapped", [42]], [[65291, 65291], "disallowed_STD3_mapped", [43]], [[65292, 65292], "disallowed_STD3_mapped", [44]], [[65293, 65293], "mapped", [45]], [[65294, 65294], "mapped", [46]], [[65295, 65295], "disallowed_STD3_mapped", [47]], [[65296, 65296], "mapped", [48]], [[65297, 65297], "mapped", [49]], [[65298, 65298], "mapped", [50]], [[65299, 65299], "mapped", [51]], [[65300, 65300], "mapped", [52]], [[65301, 65301], "mapped", [53]], [[65302, 65302], "mapped", [54]], [[65303, 65303], "mapped", [55]], [[65304, 65304], "mapped", [56]], [[65305, 65305], "mapped", [57]], [[65306, 65306], "disallowed_STD3_mapped", [58]], [[65307, 65307], "disallowed_STD3_mapped", [59]], [[65308, 65308], "disallowed_STD3_mapped", [60]], [[65309, 65309], "disallowed_STD3_mapped", [61]], [[65310, 65310], "disallowed_STD3_mapped", [62]], [[65311, 65311], "disallowed_STD3_mapped", [63]], [[65312, 65312], "disallowed_STD3_mapped", [64]], [[65313, 65313], "mapped", [97]], [[65314, 65314], "mapped", [98]], [[65315, 65315], "mapped", [99]], [[65316, 65316], "mapped", [100]], [[65317, 65317], "mapped", [101]], [[65318, 65318], "mapped", [102]], [[65319, 65319], "mapped", [103]], [[65320, 65320], "mapped", [104]], [[65321, 65321], "mapped", [105]], [[65322, 65322], "mapped", [106]], [[65323, 65323], "mapped", [107]], [[65324, 65324], "mapped", [108]], [[65325, 65325], "mapped", [109]], [[65326, 65326], "mapped", [110]], [[65327, 65327], "mapped", [111]], [[65328, 65328], "mapped", [112]], [[65329, 65329], "mapped", [113]], [[65330, 65330], "mapped", [114]], [[65331, 65331], "mapped", [115]], [[65332, 65332], "mapped", [116]], [[65333, 65333], "mapped", [117]], [[65334, 65334], "mapped", [118]], [[65335, 65335], "mapped", [119]], [[65336, 65336], "mapped", [120]], [[65337, 65337], "mapped", [121]], [[65338, 65338], "mapped", [122]], [[65339, 65339], "disallowed_STD3_mapped", [91]], [[65340, 65340], "disallowed_STD3_mapped", [92]], [[65341, 65341], "disallowed_STD3_mapped", [93]], [[65342, 65342], "disallowed_STD3_mapped", [94]], [[65343, 65343], "disallowed_STD3_mapped", [95]], [[65344, 65344], "disallowed_STD3_mapped", [96]], [[65345, 65345], "mapped", [97]], [[65346, 65346], "mapped", [98]], [[65347, 65347], "mapped", [99]], [[65348, 65348], "mapped", [100]], [[65349, 65349], "mapped", [101]], [[65350, 65350], "mapped", [102]], [[65351, 65351], "mapped", [103]], [[65352, 65352], "mapped", [104]], [[65353, 65353], "mapped", [105]], [[65354, 65354], "mapped", [106]], [[65355, 65355], "mapped", [107]], [[65356, 65356], "mapped", [108]], [[65357, 65357], "mapped", [109]], [[65358, 65358], "mapped", [110]], [[65359, 65359], "mapped", [111]], [[65360, 65360], "mapped", [112]], [[65361, 65361], "mapped", [113]], [[65362, 65362], "mapped", [114]], [[65363, 65363], "mapped", [115]], [[65364, 65364], "mapped", [116]], [[65365, 65365], "mapped", [117]], [[65366, 65366], "mapped", [118]], [[65367, 65367], "mapped", [119]], [[65368, 65368], "mapped", [120]], [[65369, 65369], "mapped", [121]], [[65370, 65370], "mapped", [122]], [[65371, 65371], "disallowed_STD3_mapped", [123]], [[65372, 65372], "disallowed_STD3_mapped", [124]], [[65373, 65373], "disallowed_STD3_mapped", [125]], [[65374, 65374], "disallowed_STD3_mapped", [126]], [[65375, 65375], "mapped", [10629]], [[65376, 65376], "mapped", [10630]], [[65377, 65377], "mapped", [46]], [[65378, 65378], "mapped", [12300]], [[65379, 65379], "mapped", [12301]], [[65380, 65380], "mapped", [12289]], [[65381, 65381], "mapped", [12539]], [[65382, 65382], "mapped", [12530]], [[65383, 65383], "mapped", [12449]], [[65384, 65384], "mapped", [12451]], [[65385, 65385], "mapped", [12453]], [[65386, 65386], "mapped", [12455]], [[65387, 65387], "mapped", [12457]], [[65388, 65388], "mapped", [12515]], [[65389, 65389], "mapped", [12517]], [[65390, 65390], "mapped", [12519]], [[65391, 65391], "mapped", [12483]], [[65392, 65392], "mapped", [12540]], [[65393, 65393], "mapped", [12450]], [[65394, 65394], "mapped", [12452]], [[65395, 65395], "mapped", [12454]], [[65396, 65396], "mapped", [12456]], [[65397, 65397], "mapped", [12458]], [[65398, 65398], "mapped", [12459]], [[65399, 65399], "mapped", [12461]], [[65400, 65400], "mapped", [12463]], [[65401, 65401], "mapped", [12465]], [[65402, 65402], "mapped", [12467]], [[65403, 65403], "mapped", [12469]], [[65404, 65404], "mapped", [12471]], [[65405, 65405], "mapped", [12473]], [[65406, 65406], "mapped", [12475]], [[65407, 65407], "mapped", [12477]], [[65408, 65408], "mapped", [12479]], [[65409, 65409], "mapped", [12481]], [[65410, 65410], "mapped", [12484]], [[65411, 65411], "mapped", [12486]], [[65412, 65412], "mapped", [12488]], [[65413, 65413], "mapped", [12490]], [[65414, 65414], "mapped", [12491]], [[65415, 65415], "mapped", [12492]], [[65416, 65416], "mapped", [12493]], [[65417, 65417], "mapped", [12494]], [[65418, 65418], "mapped", [12495]], [[65419, 65419], "mapped", [12498]], [[65420, 65420], "mapped", [12501]], [[65421, 65421], "mapped", [12504]], [[65422, 65422], "mapped", [12507]], [[65423, 65423], "mapped", [12510]], [[65424, 65424], "mapped", [12511]], [[65425, 65425], "mapped", [12512]], [[65426, 65426], "mapped", [12513]], [[65427, 65427], "mapped", [12514]], [[65428, 65428], "mapped", [12516]], [[65429, 65429], "mapped", [12518]], [[65430, 65430], "mapped", [12520]], [[65431, 65431], "mapped", [12521]], [[65432, 65432], "mapped", [12522]], [[65433, 65433], "mapped", [12523]], [[65434, 65434], "mapped", [12524]], [[65435, 65435], "mapped", [12525]], [[65436, 65436], "mapped", [12527]], [[65437, 65437], "mapped", [12531]], [[65438, 65438], "mapped", [12441]], [[65439, 65439], "mapped", [12442]], [[65440, 65440], "disallowed"], [[65441, 65441], "mapped", [4352]], [[65442, 65442], "mapped", [4353]], [[65443, 65443], "mapped", [4522]], [[65444, 65444], "mapped", [4354]], [[65445, 65445], "mapped", [4524]], [[65446, 65446], "mapped", [4525]], [[65447, 65447], "mapped", [4355]], [[65448, 65448], "mapped", [4356]], [[65449, 65449], "mapped", [4357]], [[65450, 65450], "mapped", [4528]], [[65451, 65451], "mapped", [4529]], [[65452, 65452], "mapped", [4530]], [[65453, 65453], "mapped", [4531]], [[65454, 65454], "mapped", [4532]], [[65455, 65455], "mapped", [4533]], [[65456, 65456], "mapped", [4378]], [[65457, 65457], "mapped", [4358]], [[65458, 65458], "mapped", [4359]], [[65459, 65459], "mapped", [4360]], [[65460, 65460], "mapped", [4385]], [[65461, 65461], "mapped", [4361]], [[65462, 65462], "mapped", [4362]], [[65463, 65463], "mapped", [4363]], [[65464, 65464], "mapped", [4364]], [[65465, 65465], "mapped", [4365]], [[65466, 65466], "mapped", [4366]], [[65467, 65467], "mapped", [4367]], [[65468, 65468], "mapped", [4368]], [[65469, 65469], "mapped", [4369]], [[65470, 65470], "mapped", [4370]], [[65471, 65473], "disallowed"], [[65474, 65474], "mapped", [4449]], [[65475, 65475], "mapped", [4450]], [[65476, 65476], "mapped", [4451]], [[65477, 65477], "mapped", [4452]], [[65478, 65478], "mapped", [4453]], [[65479, 65479], "mapped", [4454]], [[65480, 65481], "disallowed"], [[65482, 65482], "mapped", [4455]], [[65483, 65483], "mapped", [4456]], [[65484, 65484], "mapped", [4457]], [[65485, 65485], "mapped", [4458]], [[65486, 65486], "mapped", [4459]], [[65487, 65487], "mapped", [4460]], [[65488, 65489], "disallowed"], [[65490, 65490], "mapped", [4461]], [[65491, 65491], "mapped", [4462]], [[65492, 65492], "mapped", [4463]], [[65493, 65493], "mapped", [4464]], [[65494, 65494], "mapped", [4465]], [[65495, 65495], "mapped", [4466]], [[65496, 65497], "disallowed"], [[65498, 65498], "mapped", [4467]], [[65499, 65499], "mapped", [4468]], [[65500, 65500], "mapped", [4469]], [[65501, 65503], "disallowed"], [[65504, 65504], "mapped", [162]], [[65505, 65505], "mapped", [163]], [[65506, 65506], "mapped", [172]], [[65507, 65507], "disallowed_STD3_mapped", [32, 772]], [[65508, 65508], "mapped", [166]], [[65509, 65509], "mapped", [165]], [[65510, 65510], "mapped", [8361]], [[65511, 65511], "disallowed"], [[65512, 65512], "mapped", [9474]], [[65513, 65513], "mapped", [8592]], [[65514, 65514], "mapped", [8593]], [[65515, 65515], "mapped", [8594]], [[65516, 65516], "mapped", [8595]], [[65517, 65517], "mapped", [9632]], [[65518, 65518], "mapped", [9675]], [[65519, 65528], "disallowed"], [[65529, 65531], "disallowed"], [[65532, 65532], "disallowed"], [[65533, 65533], "disallowed"], [[65534, 65535], "disallowed"], [[65536, 65547], "valid"], [[65548, 65548], "disallowed"], [[65549, 65574], "valid"], [[65575, 65575], "disallowed"], [[65576, 65594], "valid"], [[65595, 65595], "disallowed"], [[65596, 65597], "valid"], [[65598, 65598], "disallowed"], [[65599, 65613], "valid"], [[65614, 65615], "disallowed"], [[65616, 65629], "valid"], [[65630, 65663], "disallowed"], [[65664, 65786], "valid"], [[65787, 65791], "disallowed"], [[65792, 65794], "valid", [], "NV8"], [[65795, 65798], "disallowed"], [[65799, 65843], "valid", [], "NV8"], [[65844, 65846], "disallowed"], [[65847, 65855], "valid", [], "NV8"], [[65856, 65930], "valid", [], "NV8"], [[65931, 65932], "valid", [], "NV8"], [[65933, 65935], "disallowed"], [[65936, 65947], "valid", [], "NV8"], [[65948, 65951], "disallowed"], [[65952, 65952], "valid", [], "NV8"], [[65953, 65999], "disallowed"], [[66000, 66044], "valid", [], "NV8"], [[66045, 66045], "valid"], [[66046, 66175], "disallowed"], [[66176, 66204], "valid"], [[66205, 66207], "disallowed"], [[66208, 66256], "valid"], [[66257, 66271], "disallowed"], [[66272, 66272], "valid"], [[66273, 66299], "valid", [], "NV8"], [[66300, 66303], "disallowed"], [[66304, 66334], "valid"], [[66335, 66335], "valid"], [[66336, 66339], "valid", [], "NV8"], [[66340, 66351], "disallowed"], [[66352, 66368], "valid"], [[66369, 66369], "valid", [], "NV8"], [[66370, 66377], "valid"], [[66378, 66378], "valid", [], "NV8"], [[66379, 66383], "disallowed"], [[66384, 66426], "valid"], [[66427, 66431], "disallowed"], [[66432, 66461], "valid"], [[66462, 66462], "disallowed"], [[66463, 66463], "valid", [], "NV8"], [[66464, 66499], "valid"], [[66500, 66503], "disallowed"], [[66504, 66511], "valid"], [[66512, 66517], "valid", [], "NV8"], [[66518, 66559], "disallowed"], [[66560, 66560], "mapped", [66600]], [[66561, 66561], "mapped", [66601]], [[66562, 66562], "mapped", [66602]], [[66563, 66563], "mapped", [66603]], [[66564, 66564], "mapped", [66604]], [[66565, 66565], "mapped", [66605]], [[66566, 66566], "mapped", [66606]], [[66567, 66567], "mapped", [66607]], [[66568, 66568], "mapped", [66608]], [[66569, 66569], "mapped", [66609]], [[66570, 66570], "mapped", [66610]], [[66571, 66571], "mapped", [66611]], [[66572, 66572], "mapped", [66612]], [[66573, 66573], "mapped", [66613]], [[66574, 66574], "mapped", [66614]], [[66575, 66575], "mapped", [66615]], [[66576, 66576], "mapped", [66616]], [[66577, 66577], "mapped", [66617]], [[66578, 66578], "mapped", [66618]], [[66579, 66579], "mapped", [66619]], [[66580, 66580], "mapped", [66620]], [[66581, 66581], "mapped", [66621]], [[66582, 66582], "mapped", [66622]], [[66583, 66583], "mapped", [66623]], [[66584, 66584], "mapped", [66624]], [[66585, 66585], "mapped", [66625]], [[66586, 66586], "mapped", [66626]], [[66587, 66587], "mapped", [66627]], [[66588, 66588], "mapped", [66628]], [[66589, 66589], "mapped", [66629]], [[66590, 66590], "mapped", [66630]], [[66591, 66591], "mapped", [66631]], [[66592, 66592], "mapped", [66632]], [[66593, 66593], "mapped", [66633]], [[66594, 66594], "mapped", [66634]], [[66595, 66595], "mapped", [66635]], [[66596, 66596], "mapped", [66636]], [[66597, 66597], "mapped", [66637]], [[66598, 66598], "mapped", [66638]], [[66599, 66599], "mapped", [66639]], [[66600, 66637], "valid"], [[66638, 66717], "valid"], [[66718, 66719], "disallowed"], [[66720, 66729], "valid"], [[66730, 66815], "disallowed"], [[66816, 66855], "valid"], [[66856, 66863], "disallowed"], [[66864, 66915], "valid"], [[66916, 66926], "disallowed"], [[66927, 66927], "valid", [], "NV8"], [[66928, 67071], "disallowed"], [[67072, 67382], "valid"], [[67383, 67391], "disallowed"], [[67392, 67413], "valid"], [[67414, 67423], "disallowed"], [[67424, 67431], "valid"], [[67432, 67583], "disallowed"], [[67584, 67589], "valid"], [[67590, 67591], "disallowed"], [[67592, 67592], "valid"], [[67593, 67593], "disallowed"], [[67594, 67637], "valid"], [[67638, 67638], "disallowed"], [[67639, 67640], "valid"], [[67641, 67643], "disallowed"], [[67644, 67644], "valid"], [[67645, 67646], "disallowed"], [[67647, 67647], "valid"], [[67648, 67669], "valid"], [[67670, 67670], "disallowed"], [[67671, 67679], "valid", [], "NV8"], [[67680, 67702], "valid"], [[67703, 67711], "valid", [], "NV8"], [[67712, 67742], "valid"], [[67743, 67750], "disallowed"], [[67751, 67759], "valid", [], "NV8"], [[67760, 67807], "disallowed"], [[67808, 67826], "valid"], [[67827, 67827], "disallowed"], [[67828, 67829], "valid"], [[67830, 67834], "disallowed"], [[67835, 67839], "valid", [], "NV8"], [[67840, 67861], "valid"], [[67862, 67865], "valid", [], "NV8"], [[67866, 67867], "valid", [], "NV8"], [[67868, 67870], "disallowed"], [[67871, 67871], "valid", [], "NV8"], [[67872, 67897], "valid"], [[67898, 67902], "disallowed"], [[67903, 67903], "valid", [], "NV8"], [[67904, 67967], "disallowed"], [[67968, 68023], "valid"], [[68024, 68027], "disallowed"], [[68028, 68029], "valid", [], "NV8"], [[68030, 68031], "valid"], [[68032, 68047], "valid", [], "NV8"], [[68048, 68049], "disallowed"], [[68050, 68095], "valid", [], "NV8"], [[68096, 68099], "valid"], [[68100, 68100], "disallowed"], [[68101, 68102], "valid"], [[68103, 68107], "disallowed"], [[68108, 68115], "valid"], [[68116, 68116], "disallowed"], [[68117, 68119], "valid"], [[68120, 68120], "disallowed"], [[68121, 68147], "valid"], [[68148, 68151], "disallowed"], [[68152, 68154], "valid"], [[68155, 68158], "disallowed"], [[68159, 68159], "valid"], [[68160, 68167], "valid", [], "NV8"], [[68168, 68175], "disallowed"], [[68176, 68184], "valid", [], "NV8"], [[68185, 68191], "disallowed"], [[68192, 68220], "valid"], [[68221, 68223], "valid", [], "NV8"], [[68224, 68252], "valid"], [[68253, 68255], "valid", [], "NV8"], [[68256, 68287], "disallowed"], [[68288, 68295], "valid"], [[68296, 68296], "valid", [], "NV8"], [[68297, 68326], "valid"], [[68327, 68330], "disallowed"], [[68331, 68342], "valid", [], "NV8"], [[68343, 68351], "disallowed"], [[68352, 68405], "valid"], [[68406, 68408], "disallowed"], [[68409, 68415], "valid", [], "NV8"], [[68416, 68437], "valid"], [[68438, 68439], "disallowed"], [[68440, 68447], "valid", [], "NV8"], [[68448, 68466], "valid"], [[68467, 68471], "disallowed"], [[68472, 68479], "valid", [], "NV8"], [[68480, 68497], "valid"], [[68498, 68504], "disallowed"], [[68505, 68508], "valid", [], "NV8"], [[68509, 68520], "disallowed"], [[68521, 68527], "valid", [], "NV8"], [[68528, 68607], "disallowed"], [[68608, 68680], "valid"], [[68681, 68735], "disallowed"], [[68736, 68736], "mapped", [68800]], [[68737, 68737], "mapped", [68801]], [[68738, 68738], "mapped", [68802]], [[68739, 68739], "mapped", [68803]], [[68740, 68740], "mapped", [68804]], [[68741, 68741], "mapped", [68805]], [[68742, 68742], "mapped", [68806]], [[68743, 68743], "mapped", [68807]], [[68744, 68744], "mapped", [68808]], [[68745, 68745], "mapped", [68809]], [[68746, 68746], "mapped", [68810]], [[68747, 68747], "mapped", [68811]], [[68748, 68748], "mapped", [68812]], [[68749, 68749], "mapped", [68813]], [[68750, 68750], "mapped", [68814]], [[68751, 68751], "mapped", [68815]], [[68752, 68752], "mapped", [68816]], [[68753, 68753], "mapped", [68817]], [[68754, 68754], "mapped", [68818]], [[68755, 68755], "mapped", [68819]], [[68756, 68756], "mapped", [68820]], [[68757, 68757], "mapped", [68821]], [[68758, 68758], "mapped", [68822]], [[68759, 68759], "mapped", [68823]], [[68760, 68760], "mapped", [68824]], [[68761, 68761], "mapped", [68825]], [[68762, 68762], "mapped", [68826]], [[68763, 68763], "mapped", [68827]], [[68764, 68764], "mapped", [68828]], [[68765, 68765], "mapped", [68829]], [[68766, 68766], "mapped", [68830]], [[68767, 68767], "mapped", [68831]], [[68768, 68768], "mapped", [68832]], [[68769, 68769], "mapped", [68833]], [[68770, 68770], "mapped", [68834]], [[68771, 68771], "mapped", [68835]], [[68772, 68772], "mapped", [68836]], [[68773, 68773], "mapped", [68837]], [[68774, 68774], "mapped", [68838]], [[68775, 68775], "mapped", [68839]], [[68776, 68776], "mapped", [68840]], [[68777, 68777], "mapped", [68841]], [[68778, 68778], "mapped", [68842]], [[68779, 68779], "mapped", [68843]], [[68780, 68780], "mapped", [68844]], [[68781, 68781], "mapped", [68845]], [[68782, 68782], "mapped", [68846]], [[68783, 68783], "mapped", [68847]], [[68784, 68784], "mapped", [68848]], [[68785, 68785], "mapped", [68849]], [[68786, 68786], "mapped", [68850]], [[68787, 68799], "disallowed"], [[68800, 68850], "valid"], [[68851, 68857], "disallowed"], [[68858, 68863], "valid", [], "NV8"], [[68864, 69215], "disallowed"], [[69216, 69246], "valid", [], "NV8"], [[69247, 69631], "disallowed"], [[69632, 69702], "valid"], [[69703, 69709], "valid", [], "NV8"], [[69710, 69713], "disallowed"], [[69714, 69733], "valid", [], "NV8"], [[69734, 69743], "valid"], [[69744, 69758], "disallowed"], [[69759, 69759], "valid"], [[69760, 69818], "valid"], [[69819, 69820], "valid", [], "NV8"], [[69821, 69821], "disallowed"], [[69822, 69825], "valid", [], "NV8"], [[69826, 69839], "disallowed"], [[69840, 69864], "valid"], [[69865, 69871], "disallowed"], [[69872, 69881], "valid"], [[69882, 69887], "disallowed"], [[69888, 69940], "valid"], [[69941, 69941], "disallowed"], [[69942, 69951], "valid"], [[69952, 69955], "valid", [], "NV8"], [[69956, 69967], "disallowed"], [[69968, 70003], "valid"], [[70004, 70005], "valid", [], "NV8"], [[70006, 70006], "valid"], [[70007, 70015], "disallowed"], [[70016, 70084], "valid"], [[70085, 70088], "valid", [], "NV8"], [[70089, 70089], "valid", [], "NV8"], [[70090, 70092], "valid"], [[70093, 70093], "valid", [], "NV8"], [[70094, 70095], "disallowed"], [[70096, 70105], "valid"], [[70106, 70106], "valid"], [[70107, 70107], "valid", [], "NV8"], [[70108, 70108], "valid"], [[70109, 70111], "valid", [], "NV8"], [[70112, 70112], "disallowed"], [[70113, 70132], "valid", [], "NV8"], [[70133, 70143], "disallowed"], [[70144, 70161], "valid"], [[70162, 70162], "disallowed"], [[70163, 70199], "valid"], [[70200, 70205], "valid", [], "NV8"], [[70206, 70271], "disallowed"], [[70272, 70278], "valid"], [[70279, 70279], "disallowed"], [[70280, 70280], "valid"], [[70281, 70281], "disallowed"], [[70282, 70285], "valid"], [[70286, 70286], "disallowed"], [[70287, 70301], "valid"], [[70302, 70302], "disallowed"], [[70303, 70312], "valid"], [[70313, 70313], "valid", [], "NV8"], [[70314, 70319], "disallowed"], [[70320, 70378], "valid"], [[70379, 70383], "disallowed"], [[70384, 70393], "valid"], [[70394, 70399], "disallowed"], [[70400, 70400], "valid"], [[70401, 70403], "valid"], [[70404, 70404], "disallowed"], [[70405, 70412], "valid"], [[70413, 70414], "disallowed"], [[70415, 70416], "valid"], [[70417, 70418], "disallowed"], [[70419, 70440], "valid"], [[70441, 70441], "disallowed"], [[70442, 70448], "valid"], [[70449, 70449], "disallowed"], [[70450, 70451], "valid"], [[70452, 70452], "disallowed"], [[70453, 70457], "valid"], [[70458, 70459], "disallowed"], [[70460, 70468], "valid"], [[70469, 70470], "disallowed"], [[70471, 70472], "valid"], [[70473, 70474], "disallowed"], [[70475, 70477], "valid"], [[70478, 70479], "disallowed"], [[70480, 70480], "valid"], [[70481, 70486], "disallowed"], [[70487, 70487], "valid"], [[70488, 70492], "disallowed"], [[70493, 70499], "valid"], [[70500, 70501], "disallowed"], [[70502, 70508], "valid"], [[70509, 70511], "disallowed"], [[70512, 70516], "valid"], [[70517, 70783], "disallowed"], [[70784, 70853], "valid"], [[70854, 70854], "valid", [], "NV8"], [[70855, 70855], "valid"], [[70856, 70863], "disallowed"], [[70864, 70873], "valid"], [[70874, 71039], "disallowed"], [[71040, 71093], "valid"], [[71094, 71095], "disallowed"], [[71096, 71104], "valid"], [[71105, 71113], "valid", [], "NV8"], [[71114, 71127], "valid", [], "NV8"], [[71128, 71133], "valid"], [[71134, 71167], "disallowed"], [[71168, 71232], "valid"], [[71233, 71235], "valid", [], "NV8"], [[71236, 71236], "valid"], [[71237, 71247], "disallowed"], [[71248, 71257], "valid"], [[71258, 71295], "disallowed"], [[71296, 71351], "valid"], [[71352, 71359], "disallowed"], [[71360, 71369], "valid"], [[71370, 71423], "disallowed"], [[71424, 71449], "valid"], [[71450, 71452], "disallowed"], [[71453, 71467], "valid"], [[71468, 71471], "disallowed"], [[71472, 71481], "valid"], [[71482, 71487], "valid", [], "NV8"], [[71488, 71839], "disallowed"], [[71840, 71840], "mapped", [71872]], [[71841, 71841], "mapped", [71873]], [[71842, 71842], "mapped", [71874]], [[71843, 71843], "mapped", [71875]], [[71844, 71844], "mapped", [71876]], [[71845, 71845], "mapped", [71877]], [[71846, 71846], "mapped", [71878]], [[71847, 71847], "mapped", [71879]], [[71848, 71848], "mapped", [71880]], [[71849, 71849], "mapped", [71881]], [[71850, 71850], "mapped", [71882]], [[71851, 71851], "mapped", [71883]], [[71852, 71852], "mapped", [71884]], [[71853, 71853], "mapped", [71885]], [[71854, 71854], "mapped", [71886]], [[71855, 71855], "mapped", [71887]], [[71856, 71856], "mapped", [71888]], [[71857, 71857], "mapped", [71889]], [[71858, 71858], "mapped", [71890]], [[71859, 71859], "mapped", [71891]], [[71860, 71860], "mapped", [71892]], [[71861, 71861], "mapped", [71893]], [[71862, 71862], "mapped", [71894]], [[71863, 71863], "mapped", [71895]], [[71864, 71864], "mapped", [71896]], [[71865, 71865], "mapped", [71897]], [[71866, 71866], "mapped", [71898]], [[71867, 71867], "mapped", [71899]], [[71868, 71868], "mapped", [71900]], [[71869, 71869], "mapped", [71901]], [[71870, 71870], "mapped", [71902]], [[71871, 71871], "mapped", [71903]], [[71872, 71913], "valid"], [[71914, 71922], "valid", [], "NV8"], [[71923, 71934], "disallowed"], [[71935, 71935], "valid"], [[71936, 72383], "disallowed"], [[72384, 72440], "valid"], [[72441, 73727], "disallowed"], [[73728, 74606], "valid"], [[74607, 74648], "valid"], [[74649, 74649], "valid"], [[74650, 74751], "disallowed"], [[74752, 74850], "valid", [], "NV8"], [[74851, 74862], "valid", [], "NV8"], [[74863, 74863], "disallowed"], [[74864, 74867], "valid", [], "NV8"], [[74868, 74868], "valid", [], "NV8"], [[74869, 74879], "disallowed"], [[74880, 75075], "valid"], [[75076, 77823], "disallowed"], [[77824, 78894], "valid"], [[78895, 82943], "disallowed"], [[82944, 83526], "valid"], [[83527, 92159], "disallowed"], [[92160, 92728], "valid"], [[92729, 92735], "disallowed"], [[92736, 92766], "valid"], [[92767, 92767], "disallowed"], [[92768, 92777], "valid"], [[92778, 92781], "disallowed"], [[92782, 92783], "valid", [], "NV8"], [[92784, 92879], "disallowed"], [[92880, 92909], "valid"], [[92910, 92911], "disallowed"], [[92912, 92916], "valid"], [[92917, 92917], "valid", [], "NV8"], [[92918, 92927], "disallowed"], [[92928, 92982], "valid"], [[92983, 92991], "valid", [], "NV8"], [[92992, 92995], "valid"], [[92996, 92997], "valid", [], "NV8"], [[92998, 93007], "disallowed"], [[93008, 93017], "valid"], [[93018, 93018], "disallowed"], [[93019, 93025], "valid", [], "NV8"], [[93026, 93026], "disallowed"], [[93027, 93047], "valid"], [[93048, 93052], "disallowed"], [[93053, 93071], "valid"], [[93072, 93951], "disallowed"], [[93952, 94020], "valid"], [[94021, 94031], "disallowed"], [[94032, 94078], "valid"], [[94079, 94094], "disallowed"], [[94095, 94111], "valid"], [[94112, 110591], "disallowed"], [[110592, 110593], "valid"], [[110594, 113663], "disallowed"], [[113664, 113770], "valid"], [[113771, 113775], "disallowed"], [[113776, 113788], "valid"], [[113789, 113791], "disallowed"], [[113792, 113800], "valid"], [[113801, 113807], "disallowed"], [[113808, 113817], "valid"], [[113818, 113819], "disallowed"], [[113820, 113820], "valid", [], "NV8"], [[113821, 113822], "valid"], [[113823, 113823], "valid", [], "NV8"], [[113824, 113827], "ignored"], [[113828, 118783], "disallowed"], [[118784, 119029], "valid", [], "NV8"], [[119030, 119039], "disallowed"], [[119040, 119078], "valid", [], "NV8"], [[119079, 119080], "disallowed"], [[119081, 119081], "valid", [], "NV8"], [[119082, 119133], "valid", [], "NV8"], [[119134, 119134], "mapped", [119127, 119141]], [[119135, 119135], "mapped", [119128, 119141]], [[119136, 119136], "mapped", [119128, 119141, 119150]], [[119137, 119137], "mapped", [119128, 119141, 119151]], [[119138, 119138], "mapped", [119128, 119141, 119152]], [[119139, 119139], "mapped", [119128, 119141, 119153]], [[119140, 119140], "mapped", [119128, 119141, 119154]], [[119141, 119154], "valid", [], "NV8"], [[119155, 119162], "disallowed"], [[119163, 119226], "valid", [], "NV8"], [[119227, 119227], "mapped", [119225, 119141]], [[119228, 119228], "mapped", [119226, 119141]], [[119229, 119229], "mapped", [119225, 119141, 119150]], [[119230, 119230], "mapped", [119226, 119141, 119150]], [[119231, 119231], "mapped", [119225, 119141, 119151]], [[119232, 119232], "mapped", [119226, 119141, 119151]], [[119233, 119261], "valid", [], "NV8"], [[119262, 119272], "valid", [], "NV8"], [[119273, 119295], "disallowed"], [[119296, 119365], "valid", [], "NV8"], [[119366, 119551], "disallowed"], [[119552, 119638], "valid", [], "NV8"], [[119639, 119647], "disallowed"], [[119648, 119665], "valid", [], "NV8"], [[119666, 119807], "disallowed"], [[119808, 119808], "mapped", [97]], [[119809, 119809], "mapped", [98]], [[119810, 119810], "mapped", [99]], [[119811, 119811], "mapped", [100]], [[119812, 119812], "mapped", [101]], [[119813, 119813], "mapped", [102]], [[119814, 119814], "mapped", [103]], [[119815, 119815], "mapped", [104]], [[119816, 119816], "mapped", [105]], [[119817, 119817], "mapped", [106]], [[119818, 119818], "mapped", [107]], [[119819, 119819], "mapped", [108]], [[119820, 119820], "mapped", [109]], [[119821, 119821], "mapped", [110]], [[119822, 119822], "mapped", [111]], [[119823, 119823], "mapped", [112]], [[119824, 119824], "mapped", [113]], [[119825, 119825], "mapped", [114]], [[119826, 119826], "mapped", [115]], [[119827, 119827], "mapped", [116]], [[119828, 119828], "mapped", [117]], [[119829, 119829], "mapped", [118]], [[119830, 119830], "mapped", [119]], [[119831, 119831], "mapped", [120]], [[119832, 119832], "mapped", [121]], [[119833, 119833], "mapped", [122]], [[119834, 119834], "mapped", [97]], [[119835, 119835], "mapped", [98]], [[119836, 119836], "mapped", [99]], [[119837, 119837], "mapped", [100]], [[119838, 119838], "mapped", [101]], [[119839, 119839], "mapped", [102]], [[119840, 119840], "mapped", [103]], [[119841, 119841], "mapped", [104]], [[119842, 119842], "mapped", [105]], [[119843, 119843], "mapped", [106]], [[119844, 119844], "mapped", [107]], [[119845, 119845], "mapped", [108]], [[119846, 119846], "mapped", [109]], [[119847, 119847], "mapped", [110]], [[119848, 119848], "mapped", [111]], [[119849, 119849], "mapped", [112]], [[119850, 119850], "mapped", [113]], [[119851, 119851], "mapped", [114]], [[119852, 119852], "mapped", [115]], [[119853, 119853], "mapped", [116]], [[119854, 119854], "mapped", [117]], [[119855, 119855], "mapped", [118]], [[119856, 119856], "mapped", [119]], [[119857, 119857], "mapped", [120]], [[119858, 119858], "mapped", [121]], [[119859, 119859], "mapped", [122]], [[119860, 119860], "mapped", [97]], [[119861, 119861], "mapped", [98]], [[119862, 119862], "mapped", [99]], [[119863, 119863], "mapped", [100]], [[119864, 119864], "mapped", [101]], [[119865, 119865], "mapped", [102]], [[119866, 119866], "mapped", [103]], [[119867, 119867], "mapped", [104]], [[119868, 119868], "mapped", [105]], [[119869, 119869], "mapped", [106]], [[119870, 119870], "mapped", [107]], [[119871, 119871], "mapped", [108]], [[119872, 119872], "mapped", [109]], [[119873, 119873], "mapped", [110]], [[119874, 119874], "mapped", [111]], [[119875, 119875], "mapped", [112]], [[119876, 119876], "mapped", [113]], [[119877, 119877], "mapped", [114]], [[119878, 119878], "mapped", [115]], [[119879, 119879], "mapped", [116]], [[119880, 119880], "mapped", [117]], [[119881, 119881], "mapped", [118]], [[119882, 119882], "mapped", [119]], [[119883, 119883], "mapped", [120]], [[119884, 119884], "mapped", [121]], [[119885, 119885], "mapped", [122]], [[119886, 119886], "mapped", [97]], [[119887, 119887], "mapped", [98]], [[119888, 119888], "mapped", [99]], [[119889, 119889], "mapped", [100]], [[119890, 119890], "mapped", [101]], [[119891, 119891], "mapped", [102]], [[119892, 119892], "mapped", [103]], [[119893, 119893], "disallowed"], [[119894, 119894], "mapped", [105]], [[119895, 119895], "mapped", [106]], [[119896, 119896], "mapped", [107]], [[119897, 119897], "mapped", [108]], [[119898, 119898], "mapped", [109]], [[119899, 119899], "mapped", [110]], [[119900, 119900], "mapped", [111]], [[119901, 119901], "mapped", [112]], [[119902, 119902], "mapped", [113]], [[119903, 119903], "mapped", [114]], [[119904, 119904], "mapped", [115]], [[119905, 119905], "mapped", [116]], [[119906, 119906], "mapped", [117]], [[119907, 119907], "mapped", [118]], [[119908, 119908], "mapped", [119]], [[119909, 119909], "mapped", [120]], [[119910, 119910], "mapped", [121]], [[119911, 119911], "mapped", [122]], [[119912, 119912], "mapped", [97]], [[119913, 119913], "mapped", [98]], [[119914, 119914], "mapped", [99]], [[119915, 119915], "mapped", [100]], [[119916, 119916], "mapped", [101]], [[119917, 119917], "mapped", [102]], [[119918, 119918], "mapped", [103]], [[119919, 119919], "mapped", [104]], [[119920, 119920], "mapped", [105]], [[119921, 119921], "mapped", [106]], [[119922, 119922], "mapped", [107]], [[119923, 119923], "mapped", [108]], [[119924, 119924], "mapped", [109]], [[119925, 119925], "mapped", [110]], [[119926, 119926], "mapped", [111]], [[119927, 119927], "mapped", [112]], [[119928, 119928], "mapped", [113]], [[119929, 119929], "mapped", [114]], [[119930, 119930], "mapped", [115]], [[119931, 119931], "mapped", [116]], [[119932, 119932], "mapped", [117]], [[119933, 119933], "mapped", [118]], [[119934, 119934], "mapped", [119]], [[119935, 119935], "mapped", [120]], [[119936, 119936], "mapped", [121]], [[119937, 119937], "mapped", [122]], [[119938, 119938], "mapped", [97]], [[119939, 119939], "mapped", [98]], [[119940, 119940], "mapped", [99]], [[119941, 119941], "mapped", [100]], [[119942, 119942], "mapped", [101]], [[119943, 119943], "mapped", [102]], [[119944, 119944], "mapped", [103]], [[119945, 119945], "mapped", [104]], [[119946, 119946], "mapped", [105]], [[119947, 119947], "mapped", [106]], [[119948, 119948], "mapped", [107]], [[119949, 119949], "mapped", [108]], [[119950, 119950], "mapped", [109]], [[119951, 119951], "mapped", [110]], [[119952, 119952], "mapped", [111]], [[119953, 119953], "mapped", [112]], [[119954, 119954], "mapped", [113]], [[119955, 119955], "mapped", [114]], [[119956, 119956], "mapped", [115]], [[119957, 119957], "mapped", [116]], [[119958, 119958], "mapped", [117]], [[119959, 119959], "mapped", [118]], [[119960, 119960], "mapped", [119]], [[119961, 119961], "mapped", [120]], [[119962, 119962], "mapped", [121]], [[119963, 119963], "mapped", [122]], [[119964, 119964], "mapped", [97]], [[119965, 119965], "disallowed"], [[119966, 119966], "mapped", [99]], [[119967, 119967], "mapped", [100]], [[119968, 119969], "disallowed"], [[119970, 119970], "mapped", [103]], [[119971, 119972], "disallowed"], [[119973, 119973], "mapped", [106]], [[119974, 119974], "mapped", [107]], [[119975, 119976], "disallowed"], [[119977, 119977], "mapped", [110]], [[119978, 119978], "mapped", [111]], [[119979, 119979], "mapped", [112]], [[119980, 119980], "mapped", [113]], [[119981, 119981], "disallowed"], [[119982, 119982], "mapped", [115]], [[119983, 119983], "mapped", [116]], [[119984, 119984], "mapped", [117]], [[119985, 119985], "mapped", [118]], [[119986, 119986], "mapped", [119]], [[119987, 119987], "mapped", [120]], [[119988, 119988], "mapped", [121]], [[119989, 119989], "mapped", [122]], [[119990, 119990], "mapped", [97]], [[119991, 119991], "mapped", [98]], [[119992, 119992], "mapped", [99]], [[119993, 119993], "mapped", [100]], [[119994, 119994], "disallowed"], [[119995, 119995], "mapped", [102]], [[119996, 119996], "disallowed"], [[119997, 119997], "mapped", [104]], [[119998, 119998], "mapped", [105]], [[119999, 119999], "mapped", [106]], [[120000, 120000], "mapped", [107]], [[120001, 120001], "mapped", [108]], [[120002, 120002], "mapped", [109]], [[120003, 120003], "mapped", [110]], [[120004, 120004], "disallowed"], [[120005, 120005], "mapped", [112]], [[120006, 120006], "mapped", [113]], [[120007, 120007], "mapped", [114]], [[120008, 120008], "mapped", [115]], [[120009, 120009], "mapped", [116]], [[120010, 120010], "mapped", [117]], [[120011, 120011], "mapped", [118]], [[120012, 120012], "mapped", [119]], [[120013, 120013], "mapped", [120]], [[120014, 120014], "mapped", [121]], [[120015, 120015], "mapped", [122]], [[120016, 120016], "mapped", [97]], [[120017, 120017], "mapped", [98]], [[120018, 120018], "mapped", [99]], [[120019, 120019], "mapped", [100]], [[120020, 120020], "mapped", [101]], [[120021, 120021], "mapped", [102]], [[120022, 120022], "mapped", [103]], [[120023, 120023], "mapped", [104]], [[120024, 120024], "mapped", [105]], [[120025, 120025], "mapped", [106]], [[120026, 120026], "mapped", [107]], [[120027, 120027], "mapped", [108]], [[120028, 120028], "mapped", [109]], [[120029, 120029], "mapped", [110]], [[120030, 120030], "mapped", [111]], [[120031, 120031], "mapped", [112]], [[120032, 120032], "mapped", [113]], [[120033, 120033], "mapped", [114]], [[120034, 120034], "mapped", [115]], [[120035, 120035], "mapped", [116]], [[120036, 120036], "mapped", [117]], [[120037, 120037], "mapped", [118]], [[120038, 120038], "mapped", [119]], [[120039, 120039], "mapped", [120]], [[120040, 120040], "mapped", [121]], [[120041, 120041], "mapped", [122]], [[120042, 120042], "mapped", [97]], [[120043, 120043], "mapped", [98]], [[120044, 120044], "mapped", [99]], [[120045, 120045], "mapped", [100]], [[120046, 120046], "mapped", [101]], [[120047, 120047], "mapped", [102]], [[120048, 120048], "mapped", [103]], [[120049, 120049], "mapped", [104]], [[120050, 120050], "mapped", [105]], [[120051, 120051], "mapped", [106]], [[120052, 120052], "mapped", [107]], [[120053, 120053], "mapped", [108]], [[120054, 120054], "mapped", [109]], [[120055, 120055], "mapped", [110]], [[120056, 120056], "mapped", [111]], [[120057, 120057], "mapped", [112]], [[120058, 120058], "mapped", [113]], [[120059, 120059], "mapped", [114]], [[120060, 120060], "mapped", [115]], [[120061, 120061], "mapped", [116]], [[120062, 120062], "mapped", [117]], [[120063, 120063], "mapped", [118]], [[120064, 120064], "mapped", [119]], [[120065, 120065], "mapped", [120]], [[120066, 120066], "mapped", [121]], [[120067, 120067], "mapped", [122]], [[120068, 120068], "mapped", [97]], [[120069, 120069], "mapped", [98]], [[120070, 120070], "disallowed"], [[120071, 120071], "mapped", [100]], [[120072, 120072], "mapped", [101]], [[120073, 120073], "mapped", [102]], [[120074, 120074], "mapped", [103]], [[120075, 120076], "disallowed"], [[120077, 120077], "mapped", [106]], [[120078, 120078], "mapped", [107]], [[120079, 120079], "mapped", [108]], [[120080, 120080], "mapped", [109]], [[120081, 120081], "mapped", [110]], [[120082, 120082], "mapped", [111]], [[120083, 120083], "mapped", [112]], [[120084, 120084], "mapped", [113]], [[120085, 120085], "disallowed"], [[120086, 120086], "mapped", [115]], [[120087, 120087], "mapped", [116]], [[120088, 120088], "mapped", [117]], [[120089, 120089], "mapped", [118]], [[120090, 120090], "mapped", [119]], [[120091, 120091], "mapped", [120]], [[120092, 120092], "mapped", [121]], [[120093, 120093], "disallowed"], [[120094, 120094], "mapped", [97]], [[120095, 120095], "mapped", [98]], [[120096, 120096], "mapped", [99]], [[120097, 120097], "mapped", [100]], [[120098, 120098], "mapped", [101]], [[120099, 120099], "mapped", [102]], [[120100, 120100], "mapped", [103]], [[120101, 120101], "mapped", [104]], [[120102, 120102], "mapped", [105]], [[120103, 120103], "mapped", [106]], [[120104, 120104], "mapped", [107]], [[120105, 120105], "mapped", [108]], [[120106, 120106], "mapped", [109]], [[120107, 120107], "mapped", [110]], [[120108, 120108], "mapped", [111]], [[120109, 120109], "mapped", [112]], [[120110, 120110], "mapped", [113]], [[120111, 120111], "mapped", [114]], [[120112, 120112], "mapped", [115]], [[120113, 120113], "mapped", [116]], [[120114, 120114], "mapped", [117]], [[120115, 120115], "mapped", [118]], [[120116, 120116], "mapped", [119]], [[120117, 120117], "mapped", [120]], [[120118, 120118], "mapped", [121]], [[120119, 120119], "mapped", [122]], [[120120, 120120], "mapped", [97]], [[120121, 120121], "mapped", [98]], [[120122, 120122], "disallowed"], [[120123, 120123], "mapped", [100]], [[120124, 120124], "mapped", [101]], [[120125, 120125], "mapped", [102]], [[120126, 120126], "mapped", [103]], [[120127, 120127], "disallowed"], [[120128, 120128], "mapped", [105]], [[120129, 120129], "mapped", [106]], [[120130, 120130], "mapped", [107]], [[120131, 120131], "mapped", [108]], [[120132, 120132], "mapped", [109]], [[120133, 120133], "disallowed"], [[120134, 120134], "mapped", [111]], [[120135, 120137], "disallowed"], [[120138, 120138], "mapped", [115]], [[120139, 120139], "mapped", [116]], [[120140, 120140], "mapped", [117]], [[120141, 120141], "mapped", [118]], [[120142, 120142], "mapped", [119]], [[120143, 120143], "mapped", [120]], [[120144, 120144], "mapped", [121]], [[120145, 120145], "disallowed"], [[120146, 120146], "mapped", [97]], [[120147, 120147], "mapped", [98]], [[120148, 120148], "mapped", [99]], [[120149, 120149], "mapped", [100]], [[120150, 120150], "mapped", [101]], [[120151, 120151], "mapped", [102]], [[120152, 120152], "mapped", [103]], [[120153, 120153], "mapped", [104]], [[120154, 120154], "mapped", [105]], [[120155, 120155], "mapped", [106]], [[120156, 120156], "mapped", [107]], [[120157, 120157], "mapped", [108]], [[120158, 120158], "mapped", [109]], [[120159, 120159], "mapped", [110]], [[120160, 120160], "mapped", [111]], [[120161, 120161], "mapped", [112]], [[120162, 120162], "mapped", [113]], [[120163, 120163], "mapped", [114]], [[120164, 120164], "mapped", [115]], [[120165, 120165], "mapped", [116]], [[120166, 120166], "mapped", [117]], [[120167, 120167], "mapped", [118]], [[120168, 120168], "mapped", [119]], [[120169, 120169], "mapped", [120]], [[120170, 120170], "mapped", [121]], [[120171, 120171], "mapped", [122]], [[120172, 120172], "mapped", [97]], [[120173, 120173], "mapped", [98]], [[120174, 120174], "mapped", [99]], [[120175, 120175], "mapped", [100]], [[120176, 120176], "mapped", [101]], [[120177, 120177], "mapped", [102]], [[120178, 120178], "mapped", [103]], [[120179, 120179], "mapped", [104]], [[120180, 120180], "mapped", [105]], [[120181, 120181], "mapped", [106]], [[120182, 120182], "mapped", [107]], [[120183, 120183], "mapped", [108]], [[120184, 120184], "mapped", [109]], [[120185, 120185], "mapped", [110]], [[120186, 120186], "mapped", [111]], [[120187, 120187], "mapped", [112]], [[120188, 120188], "mapped", [113]], [[120189, 120189], "mapped", [114]], [[120190, 120190], "mapped", [115]], [[120191, 120191], "mapped", [116]], [[120192, 120192], "mapped", [117]], [[120193, 120193], "mapped", [118]], [[120194, 120194], "mapped", [119]], [[120195, 120195], "mapped", [120]], [[120196, 120196], "mapped", [121]], [[120197, 120197], "mapped", [122]], [[120198, 120198], "mapped", [97]], [[120199, 120199], "mapped", [98]], [[120200, 120200], "mapped", [99]], [[120201, 120201], "mapped", [100]], [[120202, 120202], "mapped", [101]], [[120203, 120203], "mapped", [102]], [[120204, 120204], "mapped", [103]], [[120205, 120205], "mapped", [104]], [[120206, 120206], "mapped", [105]], [[120207, 120207], "mapped", [106]], [[120208, 120208], "mapped", [107]], [[120209, 120209], "mapped", [108]], [[120210, 120210], "mapped", [109]], [[120211, 120211], "mapped", [110]], [[120212, 120212], "mapped", [111]], [[120213, 120213], "mapped", [112]], [[120214, 120214], "mapped", [113]], [[120215, 120215], "mapped", [114]], [[120216, 120216], "mapped", [115]], [[120217, 120217], "mapped", [116]], [[120218, 120218], "mapped", [117]], [[120219, 120219], "mapped", [118]], [[120220, 120220], "mapped", [119]], [[120221, 120221], "mapped", [120]], [[120222, 120222], "mapped", [121]], [[120223, 120223], "mapped", [122]], [[120224, 120224], "mapped", [97]], [[120225, 120225], "mapped", [98]], [[120226, 120226], "mapped", [99]], [[120227, 120227], "mapped", [100]], [[120228, 120228], "mapped", [101]], [[120229, 120229], "mapped", [102]], [[120230, 120230], "mapped", [103]], [[120231, 120231], "mapped", [104]], [[120232, 120232], "mapped", [105]], [[120233, 120233], "mapped", [106]], [[120234, 120234], "mapped", [107]], [[120235, 120235], "mapped", [108]], [[120236, 120236], "mapped", [109]], [[120237, 120237], "mapped", [110]], [[120238, 120238], "mapped", [111]], [[120239, 120239], "mapped", [112]], [[120240, 120240], "mapped", [113]], [[120241, 120241], "mapped", [114]], [[120242, 120242], "mapped", [115]], [[120243, 120243], "mapped", [116]], [[120244, 120244], "mapped", [117]], [[120245, 120245], "mapped", [118]], [[120246, 120246], "mapped", [119]], [[120247, 120247], "mapped", [120]], [[120248, 120248], "mapped", [121]], [[120249, 120249], "mapped", [122]], [[120250, 120250], "mapped", [97]], [[120251, 120251], "mapped", [98]], [[120252, 120252], "mapped", [99]], [[120253, 120253], "mapped", [100]], [[120254, 120254], "mapped", [101]], [[120255, 120255], "mapped", [102]], [[120256, 120256], "mapped", [103]], [[120257, 120257], "mapped", [104]], [[120258, 120258], "mapped", [105]], [[120259, 120259], "mapped", [106]], [[120260, 120260], "mapped", [107]], [[120261, 120261], "mapped", [108]], [[120262, 120262], "mapped", [109]], [[120263, 120263], "mapped", [110]], [[120264, 120264], "mapped", [111]], [[120265, 120265], "mapped", [112]], [[120266, 120266], "mapped", [113]], [[120267, 120267], "mapped", [114]], [[120268, 120268], "mapped", [115]], [[120269, 120269], "mapped", [116]], [[120270, 120270], "mapped", [117]], [[120271, 120271], "mapped", [118]], [[120272, 120272], "mapped", [119]], [[120273, 120273], "mapped", [120]], [[120274, 120274], "mapped", [121]], [[120275, 120275], "mapped", [122]], [[120276, 120276], "mapped", [97]], [[120277, 120277], "mapped", [98]], [[120278, 120278], "mapped", [99]], [[120279, 120279], "mapped", [100]], [[120280, 120280], "mapped", [101]], [[120281, 120281], "mapped", [102]], [[120282, 120282], "mapped", [103]], [[120283, 120283], "mapped", [104]], [[120284, 120284], "mapped", [105]], [[120285, 120285], "mapped", [106]], [[120286, 120286], "mapped", [107]], [[120287, 120287], "mapped", [108]], [[120288, 120288], "mapped", [109]], [[120289, 120289], "mapped", [110]], [[120290, 120290], "mapped", [111]], [[120291, 120291], "mapped", [112]], [[120292, 120292], "mapped", [113]], [[120293, 120293], "mapped", [114]], [[120294, 120294], "mapped", [115]], [[120295, 120295], "mapped", [116]], [[120296, 120296], "mapped", [117]], [[120297, 120297], "mapped", [118]], [[120298, 120298], "mapped", [119]], [[120299, 120299], "mapped", [120]], [[120300, 120300], "mapped", [121]], [[120301, 120301], "mapped", [122]], [[120302, 120302], "mapped", [97]], [[120303, 120303], "mapped", [98]], [[120304, 120304], "mapped", [99]], [[120305, 120305], "mapped", [100]], [[120306, 120306], "mapped", [101]], [[120307, 120307], "mapped", [102]], [[120308, 120308], "mapped", [103]], [[120309, 120309], "mapped", [104]], [[120310, 120310], "mapped", [105]], [[120311, 120311], "mapped", [106]], [[120312, 120312], "mapped", [107]], [[120313, 120313], "mapped", [108]], [[120314, 120314], "mapped", [109]], [[120315, 120315], "mapped", [110]], [[120316, 120316], "mapped", [111]], [[120317, 120317], "mapped", [112]], [[120318, 120318], "mapped", [113]], [[120319, 120319], "mapped", [114]], [[120320, 120320], "mapped", [115]], [[120321, 120321], "mapped", [116]], [[120322, 120322], "mapped", [117]], [[120323, 120323], "mapped", [118]], [[120324, 120324], "mapped", [119]], [[120325, 120325], "mapped", [120]], [[120326, 120326], "mapped", [121]], [[120327, 120327], "mapped", [122]], [[120328, 120328], "mapped", [97]], [[120329, 120329], "mapped", [98]], [[120330, 120330], "mapped", [99]], [[120331, 120331], "mapped", [100]], [[120332, 120332], "mapped", [101]], [[120333, 120333], "mapped", [102]], [[120334, 120334], "mapped", [103]], [[120335, 120335], "mapped", [104]], [[120336, 120336], "mapped", [105]], [[120337, 120337], "mapped", [106]], [[120338, 120338], "mapped", [107]], [[120339, 120339], "mapped", [108]], [[120340, 120340], "mapped", [109]], [[120341, 120341], "mapped", [110]], [[120342, 120342], "mapped", [111]], [[120343, 120343], "mapped", [112]], [[120344, 120344], "mapped", [113]], [[120345, 120345], "mapped", [114]], [[120346, 120346], "mapped", [115]], [[120347, 120347], "mapped", [116]], [[120348, 120348], "mapped", [117]], [[120349, 120349], "mapped", [118]], [[120350, 120350], "mapped", [119]], [[120351, 120351], "mapped", [120]], [[120352, 120352], "mapped", [121]], [[120353, 120353], "mapped", [122]], [[120354, 120354], "mapped", [97]], [[120355, 120355], "mapped", [98]], [[120356, 120356], "mapped", [99]], [[120357, 120357], "mapped", [100]], [[120358, 120358], "mapped", [101]], [[120359, 120359], "mapped", [102]], [[120360, 120360], "mapped", [103]], [[120361, 120361], "mapped", [104]], [[120362, 120362], "mapped", [105]], [[120363, 120363], "mapped", [106]], [[120364, 120364], "mapped", [107]], [[120365, 120365], "mapped", [108]], [[120366, 120366], "mapped", [109]], [[120367, 120367], "mapped", [110]], [[120368, 120368], "mapped", [111]], [[120369, 120369], "mapped", [112]], [[120370, 120370], "mapped", [113]], [[120371, 120371], "mapped", [114]], [[120372, 120372], "mapped", [115]], [[120373, 120373], "mapped", [116]], [[120374, 120374], "mapped", [117]], [[120375, 120375], "mapped", [118]], [[120376, 120376], "mapped", [119]], [[120377, 120377], "mapped", [120]], [[120378, 120378], "mapped", [121]], [[120379, 120379], "mapped", [122]], [[120380, 120380], "mapped", [97]], [[120381, 120381], "mapped", [98]], [[120382, 120382], "mapped", [99]], [[120383, 120383], "mapped", [100]], [[120384, 120384], "mapped", [101]], [[120385, 120385], "mapped", [102]], [[120386, 120386], "mapped", [103]], [[120387, 120387], "mapped", [104]], [[120388, 120388], "mapped", [105]], [[120389, 120389], "mapped", [106]], [[120390, 120390], "mapped", [107]], [[120391, 120391], "mapped", [108]], [[120392, 120392], "mapped", [109]], [[120393, 120393], "mapped", [110]], [[120394, 120394], "mapped", [111]], [[120395, 120395], "mapped", [112]], [[120396, 120396], "mapped", [113]], [[120397, 120397], "mapped", [114]], [[120398, 120398], "mapped", [115]], [[120399, 120399], "mapped", [116]], [[120400, 120400], "mapped", [117]], [[120401, 120401], "mapped", [118]], [[120402, 120402], "mapped", [119]], [[120403, 120403], "mapped", [120]], [[120404, 120404], "mapped", [121]], [[120405, 120405], "mapped", [122]], [[120406, 120406], "mapped", [97]], [[120407, 120407], "mapped", [98]], [[120408, 120408], "mapped", [99]], [[120409, 120409], "mapped", [100]], [[120410, 120410], "mapped", [101]], [[120411, 120411], "mapped", [102]], [[120412, 120412], "mapped", [103]], [[120413, 120413], "mapped", [104]], [[120414, 120414], "mapped", [105]], [[120415, 120415], "mapped", [106]], [[120416, 120416], "mapped", [107]], [[120417, 120417], "mapped", [108]], [[120418, 120418], "mapped", [109]], [[120419, 120419], "mapped", [110]], [[120420, 120420], "mapped", [111]], [[120421, 120421], "mapped", [112]], [[120422, 120422], "mapped", [113]], [[120423, 120423], "mapped", [114]], [[120424, 120424], "mapped", [115]], [[120425, 120425], "mapped", [116]], [[120426, 120426], "mapped", [117]], [[120427, 120427], "mapped", [118]], [[120428, 120428], "mapped", [119]], [[120429, 120429], "mapped", [120]], [[120430, 120430], "mapped", [121]], [[120431, 120431], "mapped", [122]], [[120432, 120432], "mapped", [97]], [[120433, 120433], "mapped", [98]], [[120434, 120434], "mapped", [99]], [[120435, 120435], "mapped", [100]], [[120436, 120436], "mapped", [101]], [[120437, 120437], "mapped", [102]], [[120438, 120438], "mapped", [103]], [[120439, 120439], "mapped", [104]], [[120440, 120440], "mapped", [105]], [[120441, 120441], "mapped", [106]], [[120442, 120442], "mapped", [107]], [[120443, 120443], "mapped", [108]], [[120444, 120444], "mapped", [109]], [[120445, 120445], "mapped", [110]], [[120446, 120446], "mapped", [111]], [[120447, 120447], "mapped", [112]], [[120448, 120448], "mapped", [113]], [[120449, 120449], "mapped", [114]], [[120450, 120450], "mapped", [115]], [[120451, 120451], "mapped", [116]], [[120452, 120452], "mapped", [117]], [[120453, 120453], "mapped", [118]], [[120454, 120454], "mapped", [119]], [[120455, 120455], "mapped", [120]], [[120456, 120456], "mapped", [121]], [[120457, 120457], "mapped", [122]], [[120458, 120458], "mapped", [97]], [[120459, 120459], "mapped", [98]], [[120460, 120460], "mapped", [99]], [[120461, 120461], "mapped", [100]], [[120462, 120462], "mapped", [101]], [[120463, 120463], "mapped", [102]], [[120464, 120464], "mapped", [103]], [[120465, 120465], "mapped", [104]], [[120466, 120466], "mapped", [105]], [[120467, 120467], "mapped", [106]], [[120468, 120468], "mapped", [107]], [[120469, 120469], "mapped", [108]], [[120470, 120470], "mapped", [109]], [[120471, 120471], "mapped", [110]], [[120472, 120472], "mapped", [111]], [[120473, 120473], "mapped", [112]], [[120474, 120474], "mapped", [113]], [[120475, 120475], "mapped", [114]], [[120476, 120476], "mapped", [115]], [[120477, 120477], "mapped", [116]], [[120478, 120478], "mapped", [117]], [[120479, 120479], "mapped", [118]], [[120480, 120480], "mapped", [119]], [[120481, 120481], "mapped", [120]], [[120482, 120482], "mapped", [121]], [[120483, 120483], "mapped", [122]], [[120484, 120484], "mapped", [305]], [[120485, 120485], "mapped", [567]], [[120486, 120487], "disallowed"], [[120488, 120488], "mapped", [945]], [[120489, 120489], "mapped", [946]], [[120490, 120490], "mapped", [947]], [[120491, 120491], "mapped", [948]], [[120492, 120492], "mapped", [949]], [[120493, 120493], "mapped", [950]], [[120494, 120494], "mapped", [951]], [[120495, 120495], "mapped", [952]], [[120496, 120496], "mapped", [953]], [[120497, 120497], "mapped", [954]], [[120498, 120498], "mapped", [955]], [[120499, 120499], "mapped", [956]], [[120500, 120500], "mapped", [957]], [[120501, 120501], "mapped", [958]], [[120502, 120502], "mapped", [959]], [[120503, 120503], "mapped", [960]], [[120504, 120504], "mapped", [961]], [[120505, 120505], "mapped", [952]], [[120506, 120506], "mapped", [963]], [[120507, 120507], "mapped", [964]], [[120508, 120508], "mapped", [965]], [[120509, 120509], "mapped", [966]], [[120510, 120510], "mapped", [967]], [[120511, 120511], "mapped", [968]], [[120512, 120512], "mapped", [969]], [[120513, 120513], "mapped", [8711]], [[120514, 120514], "mapped", [945]], [[120515, 120515], "mapped", [946]], [[120516, 120516], "mapped", [947]], [[120517, 120517], "mapped", [948]], [[120518, 120518], "mapped", [949]], [[120519, 120519], "mapped", [950]], [[120520, 120520], "mapped", [951]], [[120521, 120521], "mapped", [952]], [[120522, 120522], "mapped", [953]], [[120523, 120523], "mapped", [954]], [[120524, 120524], "mapped", [955]], [[120525, 120525], "mapped", [956]], [[120526, 120526], "mapped", [957]], [[120527, 120527], "mapped", [958]], [[120528, 120528], "mapped", [959]], [[120529, 120529], "mapped", [960]], [[120530, 120530], "mapped", [961]], [[120531, 120532], "mapped", [963]], [[120533, 120533], "mapped", [964]], [[120534, 120534], "mapped", [965]], [[120535, 120535], "mapped", [966]], [[120536, 120536], "mapped", [967]], [[120537, 120537], "mapped", [968]], [[120538, 120538], "mapped", [969]], [[120539, 120539], "mapped", [8706]], [[120540, 120540], "mapped", [949]], [[120541, 120541], "mapped", [952]], [[120542, 120542], "mapped", [954]], [[120543, 120543], "mapped", [966]], [[120544, 120544], "mapped", [961]], [[120545, 120545], "mapped", [960]], [[120546, 120546], "mapped", [945]], [[120547, 120547], "mapped", [946]], [[120548, 120548], "mapped", [947]], [[120549, 120549], "mapped", [948]], [[120550, 120550], "mapped", [949]], [[120551, 120551], "mapped", [950]], [[120552, 120552], "mapped", [951]], [[120553, 120553], "mapped", [952]], [[120554, 120554], "mapped", [953]], [[120555, 120555], "mapped", [954]], [[120556, 120556], "mapped", [955]], [[120557, 120557], "mapped", [956]], [[120558, 120558], "mapped", [957]], [[120559, 120559], "mapped", [958]], [[120560, 120560], "mapped", [959]], [[120561, 120561], "mapped", [960]], [[120562, 120562], "mapped", [961]], [[120563, 120563], "mapped", [952]], [[120564, 120564], "mapped", [963]], [[120565, 120565], "mapped", [964]], [[120566, 120566], "mapped", [965]], [[120567, 120567], "mapped", [966]], [[120568, 120568], "mapped", [967]], [[120569, 120569], "mapped", [968]], [[120570, 120570], "mapped", [969]], [[120571, 120571], "mapped", [8711]], [[120572, 120572], "mapped", [945]], [[120573, 120573], "mapped", [946]], [[120574, 120574], "mapped", [947]], [[120575, 120575], "mapped", [948]], [[120576, 120576], "mapped", [949]], [[120577, 120577], "mapped", [950]], [[120578, 120578], "mapped", [951]], [[120579, 120579], "mapped", [952]], [[120580, 120580], "mapped", [953]], [[120581, 120581], "mapped", [954]], [[120582, 120582], "mapped", [955]], [[120583, 120583], "mapped", [956]], [[120584, 120584], "mapped", [957]], [[120585, 120585], "mapped", [958]], [[120586, 120586], "mapped", [959]], [[120587, 120587], "mapped", [960]], [[120588, 120588], "mapped", [961]], [[120589, 120590], "mapped", [963]], [[120591, 120591], "mapped", [964]], [[120592, 120592], "mapped", [965]], [[120593, 120593], "mapped", [966]], [[120594, 120594], "mapped", [967]], [[120595, 120595], "mapped", [968]], [[120596, 120596], "mapped", [969]], [[120597, 120597], "mapped", [8706]], [[120598, 120598], "mapped", [949]], [[120599, 120599], "mapped", [952]], [[120600, 120600], "mapped", [954]], [[120601, 120601], "mapped", [966]], [[120602, 120602], "mapped", [961]], [[120603, 120603], "mapped", [960]], [[120604, 120604], "mapped", [945]], [[120605, 120605], "mapped", [946]], [[120606, 120606], "mapped", [947]], [[120607, 120607], "mapped", [948]], [[120608, 120608], "mapped", [949]], [[120609, 120609], "mapped", [950]], [[120610, 120610], "mapped", [951]], [[120611, 120611], "mapped", [952]], [[120612, 120612], "mapped", [953]], [[120613, 120613], "mapped", [954]], [[120614, 120614], "mapped", [955]], [[120615, 120615], "mapped", [956]], [[120616, 120616], "mapped", [957]], [[120617, 120617], "mapped", [958]], [[120618, 120618], "mapped", [959]], [[120619, 120619], "mapped", [960]], [[120620, 120620], "mapped", [961]], [[120621, 120621], "mapped", [952]], [[120622, 120622], "mapped", [963]], [[120623, 120623], "mapped", [964]], [[120624, 120624], "mapped", [965]], [[120625, 120625], "mapped", [966]], [[120626, 120626], "mapped", [967]], [[120627, 120627], "mapped", [968]], [[120628, 120628], "mapped", [969]], [[120629, 120629], "mapped", [8711]], [[120630, 120630], "mapped", [945]], [[120631, 120631], "mapped", [946]], [[120632, 120632], "mapped", [947]], [[120633, 120633], "mapped", [948]], [[120634, 120634], "mapped", [949]], [[120635, 120635], "mapped", [950]], [[120636, 120636], "mapped", [951]], [[120637, 120637], "mapped", [952]], [[120638, 120638], "mapped", [953]], [[120639, 120639], "mapped", [954]], [[120640, 120640], "mapped", [955]], [[120641, 120641], "mapped", [956]], [[120642, 120642], "mapped", [957]], [[120643, 120643], "mapped", [958]], [[120644, 120644], "mapped", [959]], [[120645, 120645], "mapped", [960]], [[120646, 120646], "mapped", [961]], [[120647, 120648], "mapped", [963]], [[120649, 120649], "mapped", [964]], [[120650, 120650], "mapped", [965]], [[120651, 120651], "mapped", [966]], [[120652, 120652], "mapped", [967]], [[120653, 120653], "mapped", [968]], [[120654, 120654], "mapped", [969]], [[120655, 120655], "mapped", [8706]], [[120656, 120656], "mapped", [949]], [[120657, 120657], "mapped", [952]], [[120658, 120658], "mapped", [954]], [[120659, 120659], "mapped", [966]], [[120660, 120660], "mapped", [961]], [[120661, 120661], "mapped", [960]], [[120662, 120662], "mapped", [945]], [[120663, 120663], "mapped", [946]], [[120664, 120664], "mapped", [947]], [[120665, 120665], "mapped", [948]], [[120666, 120666], "mapped", [949]], [[120667, 120667], "mapped", [950]], [[120668, 120668], "mapped", [951]], [[120669, 120669], "mapped", [952]], [[120670, 120670], "mapped", [953]], [[120671, 120671], "mapped", [954]], [[120672, 120672], "mapped", [955]], [[120673, 120673], "mapped", [956]], [[120674, 120674], "mapped", [957]], [[120675, 120675], "mapped", [958]], [[120676, 120676], "mapped", [959]], [[120677, 120677], "mapped", [960]], [[120678, 120678], "mapped", [961]], [[120679, 120679], "mapped", [952]], [[120680, 120680], "mapped", [963]], [[120681, 120681], "mapped", [964]], [[120682, 120682], "mapped", [965]], [[120683, 120683], "mapped", [966]], [[120684, 120684], "mapped", [967]], [[120685, 120685], "mapped", [968]], [[120686, 120686], "mapped", [969]], [[120687, 120687], "mapped", [8711]], [[120688, 120688], "mapped", [945]], [[120689, 120689], "mapped", [946]], [[120690, 120690], "mapped", [947]], [[120691, 120691], "mapped", [948]], [[120692, 120692], "mapped", [949]], [[120693, 120693], "mapped", [950]], [[120694, 120694], "mapped", [951]], [[120695, 120695], "mapped", [952]], [[120696, 120696], "mapped", [953]], [[120697, 120697], "mapped", [954]], [[120698, 120698], "mapped", [955]], [[120699, 120699], "mapped", [956]], [[120700, 120700], "mapped", [957]], [[120701, 120701], "mapped", [958]], [[120702, 120702], "mapped", [959]], [[120703, 120703], "mapped", [960]], [[120704, 120704], "mapped", [961]], [[120705, 120706], "mapped", [963]], [[120707, 120707], "mapped", [964]], [[120708, 120708], "mapped", [965]], [[120709, 120709], "mapped", [966]], [[120710, 120710], "mapped", [967]], [[120711, 120711], "mapped", [968]], [[120712, 120712], "mapped", [969]], [[120713, 120713], "mapped", [8706]], [[120714, 120714], "mapped", [949]], [[120715, 120715], "mapped", [952]], [[120716, 120716], "mapped", [954]], [[120717, 120717], "mapped", [966]], [[120718, 120718], "mapped", [961]], [[120719, 120719], "mapped", [960]], [[120720, 120720], "mapped", [945]], [[120721, 120721], "mapped", [946]], [[120722, 120722], "mapped", [947]], [[120723, 120723], "mapped", [948]], [[120724, 120724], "mapped", [949]], [[120725, 120725], "mapped", [950]], [[120726, 120726], "mapped", [951]], [[120727, 120727], "mapped", [952]], [[120728, 120728], "mapped", [953]], [[120729, 120729], "mapped", [954]], [[120730, 120730], "mapped", [955]], [[120731, 120731], "mapped", [956]], [[120732, 120732], "mapped", [957]], [[120733, 120733], "mapped", [958]], [[120734, 120734], "mapped", [959]], [[120735, 120735], "mapped", [960]], [[120736, 120736], "mapped", [961]], [[120737, 120737], "mapped", [952]], [[120738, 120738], "mapped", [963]], [[120739, 120739], "mapped", [964]], [[120740, 120740], "mapped", [965]], [[120741, 120741], "mapped", [966]], [[120742, 120742], "mapped", [967]], [[120743, 120743], "mapped", [968]], [[120744, 120744], "mapped", [969]], [[120745, 120745], "mapped", [8711]], [[120746, 120746], "mapped", [945]], [[120747, 120747], "mapped", [946]], [[120748, 120748], "mapped", [947]], [[120749, 120749], "mapped", [948]], [[120750, 120750], "mapped", [949]], [[120751, 120751], "mapped", [950]], [[120752, 120752], "mapped", [951]], [[120753, 120753], "mapped", [952]], [[120754, 120754], "mapped", [953]], [[120755, 120755], "mapped", [954]], [[120756, 120756], "mapped", [955]], [[120757, 120757], "mapped", [956]], [[120758, 120758], "mapped", [957]], [[120759, 120759], "mapped", [958]], [[120760, 120760], "mapped", [959]], [[120761, 120761], "mapped", [960]], [[120762, 120762], "mapped", [961]], [[120763, 120764], "mapped", [963]], [[120765, 120765], "mapped", [964]], [[120766, 120766], "mapped", [965]], [[120767, 120767], "mapped", [966]], [[120768, 120768], "mapped", [967]], [[120769, 120769], "mapped", [968]], [[120770, 120770], "mapped", [969]], [[120771, 120771], "mapped", [8706]], [[120772, 120772], "mapped", [949]], [[120773, 120773], "mapped", [952]], [[120774, 120774], "mapped", [954]], [[120775, 120775], "mapped", [966]], [[120776, 120776], "mapped", [961]], [[120777, 120777], "mapped", [960]], [[120778, 120779], "mapped", [989]], [[120780, 120781], "disallowed"], [[120782, 120782], "mapped", [48]], [[120783, 120783], "mapped", [49]], [[120784, 120784], "mapped", [50]], [[120785, 120785], "mapped", [51]], [[120786, 120786], "mapped", [52]], [[120787, 120787], "mapped", [53]], [[120788, 120788], "mapped", [54]], [[120789, 120789], "mapped", [55]], [[120790, 120790], "mapped", [56]], [[120791, 120791], "mapped", [57]], [[120792, 120792], "mapped", [48]], [[120793, 120793], "mapped", [49]], [[120794, 120794], "mapped", [50]], [[120795, 120795], "mapped", [51]], [[120796, 120796], "mapped", [52]], [[120797, 120797], "mapped", [53]], [[120798, 120798], "mapped", [54]], [[120799, 120799], "mapped", [55]], [[120800, 120800], "mapped", [56]], [[120801, 120801], "mapped", [57]], [[120802, 120802], "mapped", [48]], [[120803, 120803], "mapped", [49]], [[120804, 120804], "mapped", [50]], [[120805, 120805], "mapped", [51]], [[120806, 120806], "mapped", [52]], [[120807, 120807], "mapped", [53]], [[120808, 120808], "mapped", [54]], [[120809, 120809], "mapped", [55]], [[120810, 120810], "mapped", [56]], [[120811, 120811], "mapped", [57]], [[120812, 120812], "mapped", [48]], [[120813, 120813], "mapped", [49]], [[120814, 120814], "mapped", [50]], [[120815, 120815], "mapped", [51]], [[120816, 120816], "mapped", [52]], [[120817, 120817], "mapped", [53]], [[120818, 120818], "mapped", [54]], [[120819, 120819], "mapped", [55]], [[120820, 120820], "mapped", [56]], [[120821, 120821], "mapped", [57]], [[120822, 120822], "mapped", [48]], [[120823, 120823], "mapped", [49]], [[120824, 120824], "mapped", [50]], [[120825, 120825], "mapped", [51]], [[120826, 120826], "mapped", [52]], [[120827, 120827], "mapped", [53]], [[120828, 120828], "mapped", [54]], [[120829, 120829], "mapped", [55]], [[120830, 120830], "mapped", [56]], [[120831, 120831], "mapped", [57]], [[120832, 121343], "valid", [], "NV8"], [[121344, 121398], "valid"], [[121399, 121402], "valid", [], "NV8"], [[121403, 121452], "valid"], [[121453, 121460], "valid", [], "NV8"], [[121461, 121461], "valid"], [[121462, 121475], "valid", [], "NV8"], [[121476, 121476], "valid"], [[121477, 121483], "valid", [], "NV8"], [[121484, 121498], "disallowed"], [[121499, 121503], "valid"], [[121504, 121504], "disallowed"], [[121505, 121519], "valid"], [[121520, 124927], "disallowed"], [[124928, 125124], "valid"], [[125125, 125126], "disallowed"], [[125127, 125135], "valid", [], "NV8"], [[125136, 125142], "valid"], [[125143, 126463], "disallowed"], [[126464, 126464], "mapped", [1575]], [[126465, 126465], "mapped", [1576]], [[126466, 126466], "mapped", [1580]], [[126467, 126467], "mapped", [1583]], [[126468, 126468], "disallowed"], [[126469, 126469], "mapped", [1608]], [[126470, 126470], "mapped", [1586]], [[126471, 126471], "mapped", [1581]], [[126472, 126472], "mapped", [1591]], [[126473, 126473], "mapped", [1610]], [[126474, 126474], "mapped", [1603]], [[126475, 126475], "mapped", [1604]], [[126476, 126476], "mapped", [1605]], [[126477, 126477], "mapped", [1606]], [[126478, 126478], "mapped", [1587]], [[126479, 126479], "mapped", [1593]], [[126480, 126480], "mapped", [1601]], [[126481, 126481], "mapped", [1589]], [[126482, 126482], "mapped", [1602]], [[126483, 126483], "mapped", [1585]], [[126484, 126484], "mapped", [1588]], [[126485, 126485], "mapped", [1578]], [[126486, 126486], "mapped", [1579]], [[126487, 126487], "mapped", [1582]], [[126488, 126488], "mapped", [1584]], [[126489, 126489], "mapped", [1590]], [[126490, 126490], "mapped", [1592]], [[126491, 126491], "mapped", [1594]], [[126492, 126492], "mapped", [1646]], [[126493, 126493], "mapped", [1722]], [[126494, 126494], "mapped", [1697]], [[126495, 126495], "mapped", [1647]], [[126496, 126496], "disallowed"], [[126497, 126497], "mapped", [1576]], [[126498, 126498], "mapped", [1580]], [[126499, 126499], "disallowed"], [[126500, 126500], "mapped", [1607]], [[126501, 126502], "disallowed"], [[126503, 126503], "mapped", [1581]], [[126504, 126504], "disallowed"], [[126505, 126505], "mapped", [1610]], [[126506, 126506], "mapped", [1603]], [[126507, 126507], "mapped", [1604]], [[126508, 126508], "mapped", [1605]], [[126509, 126509], "mapped", [1606]], [[126510, 126510], "mapped", [1587]], [[126511, 126511], "mapped", [1593]], [[126512, 126512], "mapped", [1601]], [[126513, 126513], "mapped", [1589]], [[126514, 126514], "mapped", [1602]], [[126515, 126515], "disallowed"], [[126516, 126516], "mapped", [1588]], [[126517, 126517], "mapped", [1578]], [[126518, 126518], "mapped", [1579]], [[126519, 126519], "mapped", [1582]], [[126520, 126520], "disallowed"], [[126521, 126521], "mapped", [1590]], [[126522, 126522], "disallowed"], [[126523, 126523], "mapped", [1594]], [[126524, 126529], "disallowed"], [[126530, 126530], "mapped", [1580]], [[126531, 126534], "disallowed"], [[126535, 126535], "mapped", [1581]], [[126536, 126536], "disallowed"], [[126537, 126537], "mapped", [1610]], [[126538, 126538], "disallowed"], [[126539, 126539], "mapped", [1604]], [[126540, 126540], "disallowed"], [[126541, 126541], "mapped", [1606]], [[126542, 126542], "mapped", [1587]], [[126543, 126543], "mapped", [1593]], [[126544, 126544], "disallowed"], [[126545, 126545], "mapped", [1589]], [[126546, 126546], "mapped", [1602]], [[126547, 126547], "disallowed"], [[126548, 126548], "mapped", [1588]], [[126549, 126550], "disallowed"], [[126551, 126551], "mapped", [1582]], [[126552, 126552], "disallowed"], [[126553, 126553], "mapped", [1590]], [[126554, 126554], "disallowed"], [[126555, 126555], "mapped", [1594]], [[126556, 126556], "disallowed"], [[126557, 126557], "mapped", [1722]], [[126558, 126558], "disallowed"], [[126559, 126559], "mapped", [1647]], [[126560, 126560], "disallowed"], [[126561, 126561], "mapped", [1576]], [[126562, 126562], "mapped", [1580]], [[126563, 126563], "disallowed"], [[126564, 126564], "mapped", [1607]], [[126565, 126566], "disallowed"], [[126567, 126567], "mapped", [1581]], [[126568, 126568], "mapped", [1591]], [[126569, 126569], "mapped", [1610]], [[126570, 126570], "mapped", [1603]], [[126571, 126571], "disallowed"], [[126572, 126572], "mapped", [1605]], [[126573, 126573], "mapped", [1606]], [[126574, 126574], "mapped", [1587]], [[126575, 126575], "mapped", [1593]], [[126576, 126576], "mapped", [1601]], [[126577, 126577], "mapped", [1589]], [[126578, 126578], "mapped", [1602]], [[126579, 126579], "disallowed"], [[126580, 126580], "mapped", [1588]], [[126581, 126581], "mapped", [1578]], [[126582, 126582], "mapped", [1579]], [[126583, 126583], "mapped", [1582]], [[126584, 126584], "disallowed"], [[126585, 126585], "mapped", [1590]], [[126586, 126586], "mapped", [1592]], [[126587, 126587], "mapped", [1594]], [[126588, 126588], "mapped", [1646]], [[126589, 126589], "disallowed"], [[126590, 126590], "mapped", [1697]], [[126591, 126591], "disallowed"], [[126592, 126592], "mapped", [1575]], [[126593, 126593], "mapped", [1576]], [[126594, 126594], "mapped", [1580]], [[126595, 126595], "mapped", [1583]], [[126596, 126596], "mapped", [1607]], [[126597, 126597], "mapped", [1608]], [[126598, 126598], "mapped", [1586]], [[126599, 126599], "mapped", [1581]], [[126600, 126600], "mapped", [1591]], [[126601, 126601], "mapped", [1610]], [[126602, 126602], "disallowed"], [[126603, 126603], "mapped", [1604]], [[126604, 126604], "mapped", [1605]], [[126605, 126605], "mapped", [1606]], [[126606, 126606], "mapped", [1587]], [[126607, 126607], "mapped", [1593]], [[126608, 126608], "mapped", [1601]], [[126609, 126609], "mapped", [1589]], [[126610, 126610], "mapped", [1602]], [[126611, 126611], "mapped", [1585]], [[126612, 126612], "mapped", [1588]], [[126613, 126613], "mapped", [1578]], [[126614, 126614], "mapped", [1579]], [[126615, 126615], "mapped", [1582]], [[126616, 126616], "mapped", [1584]], [[126617, 126617], "mapped", [1590]], [[126618, 126618], "mapped", [1592]], [[126619, 126619], "mapped", [1594]], [[126620, 126624], "disallowed"], [[126625, 126625], "mapped", [1576]], [[126626, 126626], "mapped", [1580]], [[126627, 126627], "mapped", [1583]], [[126628, 126628], "disallowed"], [[126629, 126629], "mapped", [1608]], [[126630, 126630], "mapped", [1586]], [[126631, 126631], "mapped", [1581]], [[126632, 126632], "mapped", [1591]], [[126633, 126633], "mapped", [1610]], [[126634, 126634], "disallowed"], [[126635, 126635], "mapped", [1604]], [[126636, 126636], "mapped", [1605]], [[126637, 126637], "mapped", [1606]], [[126638, 126638], "mapped", [1587]], [[126639, 126639], "mapped", [1593]], [[126640, 126640], "mapped", [1601]], [[126641, 126641], "mapped", [1589]], [[126642, 126642], "mapped", [1602]], [[126643, 126643], "mapped", [1585]], [[126644, 126644], "mapped", [1588]], [[126645, 126645], "mapped", [1578]], [[126646, 126646], "mapped", [1579]], [[126647, 126647], "mapped", [1582]], [[126648, 126648], "mapped", [1584]], [[126649, 126649], "mapped", [1590]], [[126650, 126650], "mapped", [1592]], [[126651, 126651], "mapped", [1594]], [[126652, 126703], "disallowed"], [[126704, 126705], "valid", [], "NV8"], [[126706, 126975], "disallowed"], [[126976, 127019], "valid", [], "NV8"], [[127020, 127023], "disallowed"], [[127024, 127123], "valid", [], "NV8"], [[127124, 127135], "disallowed"], [[127136, 127150], "valid", [], "NV8"], [[127151, 127152], "disallowed"], [[127153, 127166], "valid", [], "NV8"], [[127167, 127167], "valid", [], "NV8"], [[127168, 127168], "disallowed"], [[127169, 127183], "valid", [], "NV8"], [[127184, 127184], "disallowed"], [[127185, 127199], "valid", [], "NV8"], [[127200, 127221], "valid", [], "NV8"], [[127222, 127231], "disallowed"], [[127232, 127232], "disallowed"], [[127233, 127233], "disallowed_STD3_mapped", [48, 44]], [[127234, 127234], "disallowed_STD3_mapped", [49, 44]], [[127235, 127235], "disallowed_STD3_mapped", [50, 44]], [[127236, 127236], "disallowed_STD3_mapped", [51, 44]], [[127237, 127237], "disallowed_STD3_mapped", [52, 44]], [[127238, 127238], "disallowed_STD3_mapped", [53, 44]], [[127239, 127239], "disallowed_STD3_mapped", [54, 44]], [[127240, 127240], "disallowed_STD3_mapped", [55, 44]], [[127241, 127241], "disallowed_STD3_mapped", [56, 44]], [[127242, 127242], "disallowed_STD3_mapped", [57, 44]], [[127243, 127244], "valid", [], "NV8"], [[127245, 127247], "disallowed"], [[127248, 127248], "disallowed_STD3_mapped", [40, 97, 41]], [[127249, 127249], "disallowed_STD3_mapped", [40, 98, 41]], [[127250, 127250], "disallowed_STD3_mapped", [40, 99, 41]], [[127251, 127251], "disallowed_STD3_mapped", [40, 100, 41]], [[127252, 127252], "disallowed_STD3_mapped", [40, 101, 41]], [[127253, 127253], "disallowed_STD3_mapped", [40, 102, 41]], [[127254, 127254], "disallowed_STD3_mapped", [40, 103, 41]], [[127255, 127255], "disallowed_STD3_mapped", [40, 104, 41]], [[127256, 127256], "disallowed_STD3_mapped", [40, 105, 41]], [[127257, 127257], "disallowed_STD3_mapped", [40, 106, 41]], [[127258, 127258], "disallowed_STD3_mapped", [40, 107, 41]], [[127259, 127259], "disallowed_STD3_mapped", [40, 108, 41]], [[127260, 127260], "disallowed_STD3_mapped", [40, 109, 41]], [[127261, 127261], "disallowed_STD3_mapped", [40, 110, 41]], [[127262, 127262], "disallowed_STD3_mapped", [40, 111, 41]], [[127263, 127263], "disallowed_STD3_mapped", [40, 112, 41]], [[127264, 127264], "disallowed_STD3_mapped", [40, 113, 41]], [[127265, 127265], "disallowed_STD3_mapped", [40, 114, 41]], [[127266, 127266], "disallowed_STD3_mapped", [40, 115, 41]], [[127267, 127267], "disallowed_STD3_mapped", [40, 116, 41]], [[127268, 127268], "disallowed_STD3_mapped", [40, 117, 41]], [[127269, 127269], "disallowed_STD3_mapped", [40, 118, 41]], [[127270, 127270], "disallowed_STD3_mapped", [40, 119, 41]], [[127271, 127271], "disallowed_STD3_mapped", [40, 120, 41]], [[127272, 127272], "disallowed_STD3_mapped", [40, 121, 41]], [[127273, 127273], "disallowed_STD3_mapped", [40, 122, 41]], [[127274, 127274], "mapped", [12308, 115, 12309]], [[127275, 127275], "mapped", [99]], [[127276, 127276], "mapped", [114]], [[127277, 127277], "mapped", [99, 100]], [[127278, 127278], "mapped", [119, 122]], [[127279, 127279], "disallowed"], [[127280, 127280], "mapped", [97]], [[127281, 127281], "mapped", [98]], [[127282, 127282], "mapped", [99]], [[127283, 127283], "mapped", [100]], [[127284, 127284], "mapped", [101]], [[127285, 127285], "mapped", [102]], [[127286, 127286], "mapped", [103]], [[127287, 127287], "mapped", [104]], [[127288, 127288], "mapped", [105]], [[127289, 127289], "mapped", [106]], [[127290, 127290], "mapped", [107]], [[127291, 127291], "mapped", [108]], [[127292, 127292], "mapped", [109]], [[127293, 127293], "mapped", [110]], [[127294, 127294], "mapped", [111]], [[127295, 127295], "mapped", [112]], [[127296, 127296], "mapped", [113]], [[127297, 127297], "mapped", [114]], [[127298, 127298], "mapped", [115]], [[127299, 127299], "mapped", [116]], [[127300, 127300], "mapped", [117]], [[127301, 127301], "mapped", [118]], [[127302, 127302], "mapped", [119]], [[127303, 127303], "mapped", [120]], [[127304, 127304], "mapped", [121]], [[127305, 127305], "mapped", [122]], [[127306, 127306], "mapped", [104, 118]], [[127307, 127307], "mapped", [109, 118]], [[127308, 127308], "mapped", [115, 100]], [[127309, 127309], "mapped", [115, 115]], [[127310, 127310], "mapped", [112, 112, 118]], [[127311, 127311], "mapped", [119, 99]], [[127312, 127318], "valid", [], "NV8"], [[127319, 127319], "valid", [], "NV8"], [[127320, 127326], "valid", [], "NV8"], [[127327, 127327], "valid", [], "NV8"], [[127328, 127337], "valid", [], "NV8"], [[127338, 127338], "mapped", [109, 99]], [[127339, 127339], "mapped", [109, 100]], [[127340, 127343], "disallowed"], [[127344, 127352], "valid", [], "NV8"], [[127353, 127353], "valid", [], "NV8"], [[127354, 127354], "valid", [], "NV8"], [[127355, 127356], "valid", [], "NV8"], [[127357, 127358], "valid", [], "NV8"], [[127359, 127359], "valid", [], "NV8"], [[127360, 127369], "valid", [], "NV8"], [[127370, 127373], "valid", [], "NV8"], [[127374, 127375], "valid", [], "NV8"], [[127376, 127376], "mapped", [100, 106]], [[127377, 127386], "valid", [], "NV8"], [[127387, 127461], "disallowed"], [[127462, 127487], "valid", [], "NV8"], [[127488, 127488], "mapped", [12411, 12363]], [[127489, 127489], "mapped", [12467, 12467]], [[127490, 127490], "mapped", [12469]], [[127491, 127503], "disallowed"], [[127504, 127504], "mapped", [25163]], [[127505, 127505], "mapped", [23383]], [[127506, 127506], "mapped", [21452]], [[127507, 127507], "mapped", [12487]], [[127508, 127508], "mapped", [20108]], [[127509, 127509], "mapped", [22810]], [[127510, 127510], "mapped", [35299]], [[127511, 127511], "mapped", [22825]], [[127512, 127512], "mapped", [20132]], [[127513, 127513], "mapped", [26144]], [[127514, 127514], "mapped", [28961]], [[127515, 127515], "mapped", [26009]], [[127516, 127516], "mapped", [21069]], [[127517, 127517], "mapped", [24460]], [[127518, 127518], "mapped", [20877]], [[127519, 127519], "mapped", [26032]], [[127520, 127520], "mapped", [21021]], [[127521, 127521], "mapped", [32066]], [[127522, 127522], "mapped", [29983]], [[127523, 127523], "mapped", [36009]], [[127524, 127524], "mapped", [22768]], [[127525, 127525], "mapped", [21561]], [[127526, 127526], "mapped", [28436]], [[127527, 127527], "mapped", [25237]], [[127528, 127528], "mapped", [25429]], [[127529, 127529], "mapped", [19968]], [[127530, 127530], "mapped", [19977]], [[127531, 127531], "mapped", [36938]], [[127532, 127532], "mapped", [24038]], [[127533, 127533], "mapped", [20013]], [[127534, 127534], "mapped", [21491]], [[127535, 127535], "mapped", [25351]], [[127536, 127536], "mapped", [36208]], [[127537, 127537], "mapped", [25171]], [[127538, 127538], "mapped", [31105]], [[127539, 127539], "mapped", [31354]], [[127540, 127540], "mapped", [21512]], [[127541, 127541], "mapped", [28288]], [[127542, 127542], "mapped", [26377]], [[127543, 127543], "mapped", [26376]], [[127544, 127544], "mapped", [30003]], [[127545, 127545], "mapped", [21106]], [[127546, 127546], "mapped", [21942]], [[127547, 127551], "disallowed"], [[127552, 127552], "mapped", [12308, 26412, 12309]], [[127553, 127553], "mapped", [12308, 19977, 12309]], [[127554, 127554], "mapped", [12308, 20108, 12309]], [[127555, 127555], "mapped", [12308, 23433, 12309]], [[127556, 127556], "mapped", [12308, 28857, 12309]], [[127557, 127557], "mapped", [12308, 25171, 12309]], [[127558, 127558], "mapped", [12308, 30423, 12309]], [[127559, 127559], "mapped", [12308, 21213, 12309]], [[127560, 127560], "mapped", [12308, 25943, 12309]], [[127561, 127567], "disallowed"], [[127568, 127568], "mapped", [24471]], [[127569, 127569], "mapped", [21487]], [[127570, 127743], "disallowed"], [[127744, 127776], "valid", [], "NV8"], [[127777, 127788], "valid", [], "NV8"], [[127789, 127791], "valid", [], "NV8"], [[127792, 127797], "valid", [], "NV8"], [[127798, 127798], "valid", [], "NV8"], [[127799, 127868], "valid", [], "NV8"], [[127869, 127869], "valid", [], "NV8"], [[127870, 127871], "valid", [], "NV8"], [[127872, 127891], "valid", [], "NV8"], [[127892, 127903], "valid", [], "NV8"], [[127904, 127940], "valid", [], "NV8"], [[127941, 127941], "valid", [], "NV8"], [[127942, 127946], "valid", [], "NV8"], [[127947, 127950], "valid", [], "NV8"], [[127951, 127955], "valid", [], "NV8"], [[127956, 127967], "valid", [], "NV8"], [[127968, 127984], "valid", [], "NV8"], [[127985, 127991], "valid", [], "NV8"], [[127992, 127999], "valid", [], "NV8"], [[128000, 128062], "valid", [], "NV8"], [[128063, 128063], "valid", [], "NV8"], [[128064, 128064], "valid", [], "NV8"], [[128065, 128065], "valid", [], "NV8"], [[128066, 128247], "valid", [], "NV8"], [[128248, 128248], "valid", [], "NV8"], [[128249, 128252], "valid", [], "NV8"], [[128253, 128254], "valid", [], "NV8"], [[128255, 128255], "valid", [], "NV8"], [[128256, 128317], "valid", [], "NV8"], [[128318, 128319], "valid", [], "NV8"], [[128320, 128323], "valid", [], "NV8"], [[128324, 128330], "valid", [], "NV8"], [[128331, 128335], "valid", [], "NV8"], [[128336, 128359], "valid", [], "NV8"], [[128360, 128377], "valid", [], "NV8"], [[128378, 128378], "disallowed"], [[128379, 128419], "valid", [], "NV8"], [[128420, 128420], "disallowed"], [[128421, 128506], "valid", [], "NV8"], [[128507, 128511], "valid", [], "NV8"], [[128512, 128512], "valid", [], "NV8"], [[128513, 128528], "valid", [], "NV8"], [[128529, 128529], "valid", [], "NV8"], [[128530, 128532], "valid", [], "NV8"], [[128533, 128533], "valid", [], "NV8"], [[128534, 128534], "valid", [], "NV8"], [[128535, 128535], "valid", [], "NV8"], [[128536, 128536], "valid", [], "NV8"], [[128537, 128537], "valid", [], "NV8"], [[128538, 128538], "valid", [], "NV8"], [[128539, 128539], "valid", [], "NV8"], [[128540, 128542], "valid", [], "NV8"], [[128543, 128543], "valid", [], "NV8"], [[128544, 128549], "valid", [], "NV8"], [[128550, 128551], "valid", [], "NV8"], [[128552, 128555], "valid", [], "NV8"], [[128556, 128556], "valid", [], "NV8"], [[128557, 128557], "valid", [], "NV8"], [[128558, 128559], "valid", [], "NV8"], [[128560, 128563], "valid", [], "NV8"], [[128564, 128564], "valid", [], "NV8"], [[128565, 128576], "valid", [], "NV8"], [[128577, 128578], "valid", [], "NV8"], [[128579, 128580], "valid", [], "NV8"], [[128581, 128591], "valid", [], "NV8"], [[128592, 128639], "valid", [], "NV8"], [[128640, 128709], "valid", [], "NV8"], [[128710, 128719], "valid", [], "NV8"], [[128720, 128720], "valid", [], "NV8"], [[128721, 128735], "disallowed"], [[128736, 128748], "valid", [], "NV8"], [[128749, 128751], "disallowed"], [[128752, 128755], "valid", [], "NV8"], [[128756, 128767], "disallowed"], [[128768, 128883], "valid", [], "NV8"], [[128884, 128895], "disallowed"], [[128896, 128980], "valid", [], "NV8"], [[128981, 129023], "disallowed"], [[129024, 129035], "valid", [], "NV8"], [[129036, 129039], "disallowed"], [[129040, 129095], "valid", [], "NV8"], [[129096, 129103], "disallowed"], [[129104, 129113], "valid", [], "NV8"], [[129114, 129119], "disallowed"], [[129120, 129159], "valid", [], "NV8"], [[129160, 129167], "disallowed"], [[129168, 129197], "valid", [], "NV8"], [[129198, 129295], "disallowed"], [[129296, 129304], "valid", [], "NV8"], [[129305, 129407], "disallowed"], [[129408, 129412], "valid", [], "NV8"], [[129413, 129471], "disallowed"], [[129472, 129472], "valid", [], "NV8"], [[129473, 131069], "disallowed"], [[131070, 131071], "disallowed"], [[131072, 173782], "valid"], [[173783, 173823], "disallowed"], [[173824, 177972], "valid"], [[177973, 177983], "disallowed"], [[177984, 178205], "valid"], [[178206, 178207], "disallowed"], [[178208, 183969], "valid"], [[183970, 194559], "disallowed"], [[194560, 194560], "mapped", [20029]], [[194561, 194561], "mapped", [20024]], [[194562, 194562], "mapped", [20033]], [[194563, 194563], "mapped", [131362]], [[194564, 194564], "mapped", [20320]], [[194565, 194565], "mapped", [20398]], [[194566, 194566], "mapped", [20411]], [[194567, 194567], "mapped", [20482]], [[194568, 194568], "mapped", [20602]], [[194569, 194569], "mapped", [20633]], [[194570, 194570], "mapped", [20711]], [[194571, 194571], "mapped", [20687]], [[194572, 194572], "mapped", [13470]], [[194573, 194573], "mapped", [132666]], [[194574, 194574], "mapped", [20813]], [[194575, 194575], "mapped", [20820]], [[194576, 194576], "mapped", [20836]], [[194577, 194577], "mapped", [20855]], [[194578, 194578], "mapped", [132380]], [[194579, 194579], "mapped", [13497]], [[194580, 194580], "mapped", [20839]], [[194581, 194581], "mapped", [20877]], [[194582, 194582], "mapped", [132427]], [[194583, 194583], "mapped", [20887]], [[194584, 194584], "mapped", [20900]], [[194585, 194585], "mapped", [20172]], [[194586, 194586], "mapped", [20908]], [[194587, 194587], "mapped", [20917]], [[194588, 194588], "mapped", [168415]], [[194589, 194589], "mapped", [20981]], [[194590, 194590], "mapped", [20995]], [[194591, 194591], "mapped", [13535]], [[194592, 194592], "mapped", [21051]], [[194593, 194593], "mapped", [21062]], [[194594, 194594], "mapped", [21106]], [[194595, 194595], "mapped", [21111]], [[194596, 194596], "mapped", [13589]], [[194597, 194597], "mapped", [21191]], [[194598, 194598], "mapped", [21193]], [[194599, 194599], "mapped", [21220]], [[194600, 194600], "mapped", [21242]], [[194601, 194601], "mapped", [21253]], [[194602, 194602], "mapped", [21254]], [[194603, 194603], "mapped", [21271]], [[194604, 194604], "mapped", [21321]], [[194605, 194605], "mapped", [21329]], [[194606, 194606], "mapped", [21338]], [[194607, 194607], "mapped", [21363]], [[194608, 194608], "mapped", [21373]], [[194609, 194611], "mapped", [21375]], [[194612, 194612], "mapped", [133676]], [[194613, 194613], "mapped", [28784]], [[194614, 194614], "mapped", [21450]], [[194615, 194615], "mapped", [21471]], [[194616, 194616], "mapped", [133987]], [[194617, 194617], "mapped", [21483]], [[194618, 194618], "mapped", [21489]], [[194619, 194619], "mapped", [21510]], [[194620, 194620], "mapped", [21662]], [[194621, 194621], "mapped", [21560]], [[194622, 194622], "mapped", [21576]], [[194623, 194623], "mapped", [21608]], [[194624, 194624], "mapped", [21666]], [[194625, 194625], "mapped", [21750]], [[194626, 194626], "mapped", [21776]], [[194627, 194627], "mapped", [21843]], [[194628, 194628], "mapped", [21859]], [[194629, 194630], "mapped", [21892]], [[194631, 194631], "mapped", [21913]], [[194632, 194632], "mapped", [21931]], [[194633, 194633], "mapped", [21939]], [[194634, 194634], "mapped", [21954]], [[194635, 194635], "mapped", [22294]], [[194636, 194636], "mapped", [22022]], [[194637, 194637], "mapped", [22295]], [[194638, 194638], "mapped", [22097]], [[194639, 194639], "mapped", [22132]], [[194640, 194640], "mapped", [20999]], [[194641, 194641], "mapped", [22766]], [[194642, 194642], "mapped", [22478]], [[194643, 194643], "mapped", [22516]], [[194644, 194644], "mapped", [22541]], [[194645, 194645], "mapped", [22411]], [[194646, 194646], "mapped", [22578]], [[194647, 194647], "mapped", [22577]], [[194648, 194648], "mapped", [22700]], [[194649, 194649], "mapped", [136420]], [[194650, 194650], "mapped", [22770]], [[194651, 194651], "mapped", [22775]], [[194652, 194652], "mapped", [22790]], [[194653, 194653], "mapped", [22810]], [[194654, 194654], "mapped", [22818]], [[194655, 194655], "mapped", [22882]], [[194656, 194656], "mapped", [136872]], [[194657, 194657], "mapped", [136938]], [[194658, 194658], "mapped", [23020]], [[194659, 194659], "mapped", [23067]], [[194660, 194660], "mapped", [23079]], [[194661, 194661], "mapped", [23000]], [[194662, 194662], "mapped", [23142]], [[194663, 194663], "mapped", [14062]], [[194664, 194664], "disallowed"], [[194665, 194665], "mapped", [23304]], [[194666, 194667], "mapped", [23358]], [[194668, 194668], "mapped", [137672]], [[194669, 194669], "mapped", [23491]], [[194670, 194670], "mapped", [23512]], [[194671, 194671], "mapped", [23527]], [[194672, 194672], "mapped", [23539]], [[194673, 194673], "mapped", [138008]], [[194674, 194674], "mapped", [23551]], [[194675, 194675], "mapped", [23558]], [[194676, 194676], "disallowed"], [[194677, 194677], "mapped", [23586]], [[194678, 194678], "mapped", [14209]], [[194679, 194679], "mapped", [23648]], [[194680, 194680], "mapped", [23662]], [[194681, 194681], "mapped", [23744]], [[194682, 194682], "mapped", [23693]], [[194683, 194683], "mapped", [138724]], [[194684, 194684], "mapped", [23875]], [[194685, 194685], "mapped", [138726]], [[194686, 194686], "mapped", [23918]], [[194687, 194687], "mapped", [23915]], [[194688, 194688], "mapped", [23932]], [[194689, 194689], "mapped", [24033]], [[194690, 194690], "mapped", [24034]], [[194691, 194691], "mapped", [14383]], [[194692, 194692], "mapped", [24061]], [[194693, 194693], "mapped", [24104]], [[194694, 194694], "mapped", [24125]], [[194695, 194695], "mapped", [24169]], [[194696, 194696], "mapped", [14434]], [[194697, 194697], "mapped", [139651]], [[194698, 194698], "mapped", [14460]], [[194699, 194699], "mapped", [24240]], [[194700, 194700], "mapped", [24243]], [[194701, 194701], "mapped", [24246]], [[194702, 194702], "mapped", [24266]], [[194703, 194703], "mapped", [172946]], [[194704, 194704], "mapped", [24318]], [[194705, 194706], "mapped", [140081]], [[194707, 194707], "mapped", [33281]], [[194708, 194709], "mapped", [24354]], [[194710, 194710], "mapped", [14535]], [[194711, 194711], "mapped", [144056]], [[194712, 194712], "mapped", [156122]], [[194713, 194713], "mapped", [24418]], [[194714, 194714], "mapped", [24427]], [[194715, 194715], "mapped", [14563]], [[194716, 194716], "mapped", [24474]], [[194717, 194717], "mapped", [24525]], [[194718, 194718], "mapped", [24535]], [[194719, 194719], "mapped", [24569]], [[194720, 194720], "mapped", [24705]], [[194721, 194721], "mapped", [14650]], [[194722, 194722], "mapped", [14620]], [[194723, 194723], "mapped", [24724]], [[194724, 194724], "mapped", [141012]], [[194725, 194725], "mapped", [24775]], [[194726, 194726], "mapped", [24904]], [[194727, 194727], "mapped", [24908]], [[194728, 194728], "mapped", [24910]], [[194729, 194729], "mapped", [24908]], [[194730, 194730], "mapped", [24954]], [[194731, 194731], "mapped", [24974]], [[194732, 194732], "mapped", [25010]], [[194733, 194733], "mapped", [24996]], [[194734, 194734], "mapped", [25007]], [[194735, 194735], "mapped", [25054]], [[194736, 194736], "mapped", [25074]], [[194737, 194737], "mapped", [25078]], [[194738, 194738], "mapped", [25104]], [[194739, 194739], "mapped", [25115]], [[194740, 194740], "mapped", [25181]], [[194741, 194741], "mapped", [25265]], [[194742, 194742], "mapped", [25300]], [[194743, 194743], "mapped", [25424]], [[194744, 194744], "mapped", [142092]], [[194745, 194745], "mapped", [25405]], [[194746, 194746], "mapped", [25340]], [[194747, 194747], "mapped", [25448]], [[194748, 194748], "mapped", [25475]], [[194749, 194749], "mapped", [25572]], [[194750, 194750], "mapped", [142321]], [[194751, 194751], "mapped", [25634]], [[194752, 194752], "mapped", [25541]], [[194753, 194753], "mapped", [25513]], [[194754, 194754], "mapped", [14894]], [[194755, 194755], "mapped", [25705]], [[194756, 194756], "mapped", [25726]], [[194757, 194757], "mapped", [25757]], [[194758, 194758], "mapped", [25719]], [[194759, 194759], "mapped", [14956]], [[194760, 194760], "mapped", [25935]], [[194761, 194761], "mapped", [25964]], [[194762, 194762], "mapped", [143370]], [[194763, 194763], "mapped", [26083]], [[194764, 194764], "mapped", [26360]], [[194765, 194765], "mapped", [26185]], [[194766, 194766], "mapped", [15129]], [[194767, 194767], "mapped", [26257]], [[194768, 194768], "mapped", [15112]], [[194769, 194769], "mapped", [15076]], [[194770, 194770], "mapped", [20882]], [[194771, 194771], "mapped", [20885]], [[194772, 194772], "mapped", [26368]], [[194773, 194773], "mapped", [26268]], [[194774, 194774], "mapped", [32941]], [[194775, 194775], "mapped", [17369]], [[194776, 194776], "mapped", [26391]], [[194777, 194777], "mapped", [26395]], [[194778, 194778], "mapped", [26401]], [[194779, 194779], "mapped", [26462]], [[194780, 194780], "mapped", [26451]], [[194781, 194781], "mapped", [144323]], [[194782, 194782], "mapped", [15177]], [[194783, 194783], "mapped", [26618]], [[194784, 194784], "mapped", [26501]], [[194785, 194785], "mapped", [26706]], [[194786, 194786], "mapped", [26757]], [[194787, 194787], "mapped", [144493]], [[194788, 194788], "mapped", [26766]], [[194789, 194789], "mapped", [26655]], [[194790, 194790], "mapped", [26900]], [[194791, 194791], "mapped", [15261]], [[194792, 194792], "mapped", [26946]], [[194793, 194793], "mapped", [27043]], [[194794, 194794], "mapped", [27114]], [[194795, 194795], "mapped", [27304]], [[194796, 194796], "mapped", [145059]], [[194797, 194797], "mapped", [27355]], [[194798, 194798], "mapped", [15384]], [[194799, 194799], "mapped", [27425]], [[194800, 194800], "mapped", [145575]], [[194801, 194801], "mapped", [27476]], [[194802, 194802], "mapped", [15438]], [[194803, 194803], "mapped", [27506]], [[194804, 194804], "mapped", [27551]], [[194805, 194805], "mapped", [27578]], [[194806, 194806], "mapped", [27579]], [[194807, 194807], "mapped", [146061]], [[194808, 194808], "mapped", [138507]], [[194809, 194809], "mapped", [146170]], [[194810, 194810], "mapped", [27726]], [[194811, 194811], "mapped", [146620]], [[194812, 194812], "mapped", [27839]], [[194813, 194813], "mapped", [27853]], [[194814, 194814], "mapped", [27751]], [[194815, 194815], "mapped", [27926]], [[194816, 194816], "mapped", [27966]], [[194817, 194817], "mapped", [28023]], [[194818, 194818], "mapped", [27969]], [[194819, 194819], "mapped", [28009]], [[194820, 194820], "mapped", [28024]], [[194821, 194821], "mapped", [28037]], [[194822, 194822], "mapped", [146718]], [[194823, 194823], "mapped", [27956]], [[194824, 194824], "mapped", [28207]], [[194825, 194825], "mapped", [28270]], [[194826, 194826], "mapped", [15667]], [[194827, 194827], "mapped", [28363]], [[194828, 194828], "mapped", [28359]], [[194829, 194829], "mapped", [147153]], [[194830, 194830], "mapped", [28153]], [[194831, 194831], "mapped", [28526]], [[194832, 194832], "mapped", [147294]], [[194833, 194833], "mapped", [147342]], [[194834, 194834], "mapped", [28614]], [[194835, 194835], "mapped", [28729]], [[194836, 194836], "mapped", [28702]], [[194837, 194837], "mapped", [28699]], [[194838, 194838], "mapped", [15766]], [[194839, 194839], "mapped", [28746]], [[194840, 194840], "mapped", [28797]], [[194841, 194841], "mapped", [28791]], [[194842, 194842], "mapped", [28845]], [[194843, 194843], "mapped", [132389]], [[194844, 194844], "mapped", [28997]], [[194845, 194845], "mapped", [148067]], [[194846, 194846], "mapped", [29084]], [[194847, 194847], "disallowed"], [[194848, 194848], "mapped", [29224]], [[194849, 194849], "mapped", [29237]], [[194850, 194850], "mapped", [29264]], [[194851, 194851], "mapped", [149000]], [[194852, 194852], "mapped", [29312]], [[194853, 194853], "mapped", [29333]], [[194854, 194854], "mapped", [149301]], [[194855, 194855], "mapped", [149524]], [[194856, 194856], "mapped", [29562]], [[194857, 194857], "mapped", [29579]], [[194858, 194858], "mapped", [16044]], [[194859, 194859], "mapped", [29605]], [[194860, 194861], "mapped", [16056]], [[194862, 194862], "mapped", [29767]], [[194863, 194863], "mapped", [29788]], [[194864, 194864], "mapped", [29809]], [[194865, 194865], "mapped", [29829]], [[194866, 194866], "mapped", [29898]], [[194867, 194867], "mapped", [16155]], [[194868, 194868], "mapped", [29988]], [[194869, 194869], "mapped", [150582]], [[194870, 194870], "mapped", [30014]], [[194871, 194871], "mapped", [150674]], [[194872, 194872], "mapped", [30064]], [[194873, 194873], "mapped", [139679]], [[194874, 194874], "mapped", [30224]], [[194875, 194875], "mapped", [151457]], [[194876, 194876], "mapped", [151480]], [[194877, 194877], "mapped", [151620]], [[194878, 194878], "mapped", [16380]], [[194879, 194879], "mapped", [16392]], [[194880, 194880], "mapped", [30452]], [[194881, 194881], "mapped", [151795]], [[194882, 194882], "mapped", [151794]], [[194883, 194883], "mapped", [151833]], [[194884, 194884], "mapped", [151859]], [[194885, 194885], "mapped", [30494]], [[194886, 194887], "mapped", [30495]], [[194888, 194888], "mapped", [30538]], [[194889, 194889], "mapped", [16441]], [[194890, 194890], "mapped", [30603]], [[194891, 194891], "mapped", [16454]], [[194892, 194892], "mapped", [16534]], [[194893, 194893], "mapped", [152605]], [[194894, 194894], "mapped", [30798]], [[194895, 194895], "mapped", [30860]], [[194896, 194896], "mapped", [30924]], [[194897, 194897], "mapped", [16611]], [[194898, 194898], "mapped", [153126]], [[194899, 194899], "mapped", [31062]], [[194900, 194900], "mapped", [153242]], [[194901, 194901], "mapped", [153285]], [[194902, 194902], "mapped", [31119]], [[194903, 194903], "mapped", [31211]], [[194904, 194904], "mapped", [16687]], [[194905, 194905], "mapped", [31296]], [[194906, 194906], "mapped", [31306]], [[194907, 194907], "mapped", [31311]], [[194908, 194908], "mapped", [153980]], [[194909, 194910], "mapped", [154279]], [[194911, 194911], "disallowed"], [[194912, 194912], "mapped", [16898]], [[194913, 194913], "mapped", [154539]], [[194914, 194914], "mapped", [31686]], [[194915, 194915], "mapped", [31689]], [[194916, 194916], "mapped", [16935]], [[194917, 194917], "mapped", [154752]], [[194918, 194918], "mapped", [31954]], [[194919, 194919], "mapped", [17056]], [[194920, 194920], "mapped", [31976]], [[194921, 194921], "mapped", [31971]], [[194922, 194922], "mapped", [32000]], [[194923, 194923], "mapped", [155526]], [[194924, 194924], "mapped", [32099]], [[194925, 194925], "mapped", [17153]], [[194926, 194926], "mapped", [32199]], [[194927, 194927], "mapped", [32258]], [[194928, 194928], "mapped", [32325]], [[194929, 194929], "mapped", [17204]], [[194930, 194930], "mapped", [156200]], [[194931, 194931], "mapped", [156231]], [[194932, 194932], "mapped", [17241]], [[194933, 194933], "mapped", [156377]], [[194934, 194934], "mapped", [32634]], [[194935, 194935], "mapped", [156478]], [[194936, 194936], "mapped", [32661]], [[194937, 194937], "mapped", [32762]], [[194938, 194938], "mapped", [32773]], [[194939, 194939], "mapped", [156890]], [[194940, 194940], "mapped", [156963]], [[194941, 194941], "mapped", [32864]], [[194942, 194942], "mapped", [157096]], [[194943, 194943], "mapped", [32880]], [[194944, 194944], "mapped", [144223]], [[194945, 194945], "mapped", [17365]], [[194946, 194946], "mapped", [32946]], [[194947, 194947], "mapped", [33027]], [[194948, 194948], "mapped", [17419]], [[194949, 194949], "mapped", [33086]], [[194950, 194950], "mapped", [23221]], [[194951, 194951], "mapped", [157607]], [[194952, 194952], "mapped", [157621]], [[194953, 194953], "mapped", [144275]], [[194954, 194954], "mapped", [144284]], [[194955, 194955], "mapped", [33281]], [[194956, 194956], "mapped", [33284]], [[194957, 194957], "mapped", [36766]], [[194958, 194958], "mapped", [17515]], [[194959, 194959], "mapped", [33425]], [[194960, 194960], "mapped", [33419]], [[194961, 194961], "mapped", [33437]], [[194962, 194962], "mapped", [21171]], [[194963, 194963], "mapped", [33457]], [[194964, 194964], "mapped", [33459]], [[194965, 194965], "mapped", [33469]], [[194966, 194966], "mapped", [33510]], [[194967, 194967], "mapped", [158524]], [[194968, 194968], "mapped", [33509]], [[194969, 194969], "mapped", [33565]], [[194970, 194970], "mapped", [33635]], [[194971, 194971], "mapped", [33709]], [[194972, 194972], "mapped", [33571]], [[194973, 194973], "mapped", [33725]], [[194974, 194974], "mapped", [33767]], [[194975, 194975], "mapped", [33879]], [[194976, 194976], "mapped", [33619]], [[194977, 194977], "mapped", [33738]], [[194978, 194978], "mapped", [33740]], [[194979, 194979], "mapped", [33756]], [[194980, 194980], "mapped", [158774]], [[194981, 194981], "mapped", [159083]], [[194982, 194982], "mapped", [158933]], [[194983, 194983], "mapped", [17707]], [[194984, 194984], "mapped", [34033]], [[194985, 194985], "mapped", [34035]], [[194986, 194986], "mapped", [34070]], [[194987, 194987], "mapped", [160714]], [[194988, 194988], "mapped", [34148]], [[194989, 194989], "mapped", [159532]], [[194990, 194990], "mapped", [17757]], [[194991, 194991], "mapped", [17761]], [[194992, 194992], "mapped", [159665]], [[194993, 194993], "mapped", [159954]], [[194994, 194994], "mapped", [17771]], [[194995, 194995], "mapped", [34384]], [[194996, 194996], "mapped", [34396]], [[194997, 194997], "mapped", [34407]], [[194998, 194998], "mapped", [34409]], [[194999, 194999], "mapped", [34473]], [[195000, 195000], "mapped", [34440]], [[195001, 195001], "mapped", [34574]], [[195002, 195002], "mapped", [34530]], [[195003, 195003], "mapped", [34681]], [[195004, 195004], "mapped", [34600]], [[195005, 195005], "mapped", [34667]], [[195006, 195006], "mapped", [34694]], [[195007, 195007], "disallowed"], [[195008, 195008], "mapped", [34785]], [[195009, 195009], "mapped", [34817]], [[195010, 195010], "mapped", [17913]], [[195011, 195011], "mapped", [34912]], [[195012, 195012], "mapped", [34915]], [[195013, 195013], "mapped", [161383]], [[195014, 195014], "mapped", [35031]], [[195015, 195015], "mapped", [35038]], [[195016, 195016], "mapped", [17973]], [[195017, 195017], "mapped", [35066]], [[195018, 195018], "mapped", [13499]], [[195019, 195019], "mapped", [161966]], [[195020, 195020], "mapped", [162150]], [[195021, 195021], "mapped", [18110]], [[195022, 195022], "mapped", [18119]], [[195023, 195023], "mapped", [35488]], [[195024, 195024], "mapped", [35565]], [[195025, 195025], "mapped", [35722]], [[195026, 195026], "mapped", [35925]], [[195027, 195027], "mapped", [162984]], [[195028, 195028], "mapped", [36011]], [[195029, 195029], "mapped", [36033]], [[195030, 195030], "mapped", [36123]], [[195031, 195031], "mapped", [36215]], [[195032, 195032], "mapped", [163631]], [[195033, 195033], "mapped", [133124]], [[195034, 195034], "mapped", [36299]], [[195035, 195035], "mapped", [36284]], [[195036, 195036], "mapped", [36336]], [[195037, 195037], "mapped", [133342]], [[195038, 195038], "mapped", [36564]], [[195039, 195039], "mapped", [36664]], [[195040, 195040], "mapped", [165330]], [[195041, 195041], "mapped", [165357]], [[195042, 195042], "mapped", [37012]], [[195043, 195043], "mapped", [37105]], [[195044, 195044], "mapped", [37137]], [[195045, 195045], "mapped", [165678]], [[195046, 195046], "mapped", [37147]], [[195047, 195047], "mapped", [37432]], [[195048, 195048], "mapped", [37591]], [[195049, 195049], "mapped", [37592]], [[195050, 195050], "mapped", [37500]], [[195051, 195051], "mapped", [37881]], [[195052, 195052], "mapped", [37909]], [[195053, 195053], "mapped", [166906]], [[195054, 195054], "mapped", [38283]], [[195055, 195055], "mapped", [18837]], [[195056, 195056], "mapped", [38327]], [[195057, 195057], "mapped", [167287]], [[195058, 195058], "mapped", [18918]], [[195059, 195059], "mapped", [38595]], [[195060, 195060], "mapped", [23986]], [[195061, 195061], "mapped", [38691]], [[195062, 195062], "mapped", [168261]], [[195063, 195063], "mapped", [168474]], [[195064, 195064], "mapped", [19054]], [[195065, 195065], "mapped", [19062]], [[195066, 195066], "mapped", [38880]], [[195067, 195067], "mapped", [168970]], [[195068, 195068], "mapped", [19122]], [[195069, 195069], "mapped", [169110]], [[195070, 195071], "mapped", [38923]], [[195072, 195072], "mapped", [38953]], [[195073, 195073], "mapped", [169398]], [[195074, 195074], "mapped", [39138]], [[195075, 195075], "mapped", [19251]], [[195076, 195076], "mapped", [39209]], [[195077, 195077], "mapped", [39335]], [[195078, 195078], "mapped", [39362]], [[195079, 195079], "mapped", [39422]], [[195080, 195080], "mapped", [19406]], [[195081, 195081], "mapped", [170800]], [[195082, 195082], "mapped", [39698]], [[195083, 195083], "mapped", [40000]], [[195084, 195084], "mapped", [40189]], [[195085, 195085], "mapped", [19662]], [[195086, 195086], "mapped", [19693]], [[195087, 195087], "mapped", [40295]], [[195088, 195088], "mapped", [172238]], [[195089, 195089], "mapped", [19704]], [[195090, 195090], "mapped", [172293]], [[195091, 195091], "mapped", [172558]], [[195092, 195092], "mapped", [172689]], [[195093, 195093], "mapped", [40635]], [[195094, 195094], "mapped", [19798]], [[195095, 195095], "mapped", [40697]], [[195096, 195096], "mapped", [40702]], [[195097, 195097], "mapped", [40709]], [[195098, 195098], "mapped", [40719]], [[195099, 195099], "mapped", [40726]], [[195100, 195100], "mapped", [40763]], [[195101, 195101], "mapped", [173568]], [[195102, 196605], "disallowed"], [[196606, 196607], "disallowed"], [[196608, 262141], "disallowed"], [[262142, 262143], "disallowed"], [[262144, 327677], "disallowed"], [[327678, 327679], "disallowed"], [[327680, 393213], "disallowed"], [[393214, 393215], "disallowed"], [[393216, 458749], "disallowed"], [[458750, 458751], "disallowed"], [[458752, 524285], "disallowed"], [[524286, 524287], "disallowed"], [[524288, 589821], "disallowed"], [[589822, 589823], "disallowed"], [[589824, 655357], "disallowed"], [[655358, 655359], "disallowed"], [[655360, 720893], "disallowed"], [[720894, 720895], "disallowed"], [[720896, 786429], "disallowed"], [[786430, 786431], "disallowed"], [[786432, 851965], "disallowed"], [[851966, 851967], "disallowed"], [[851968, 917501], "disallowed"], [[917502, 917503], "disallowed"], [[917504, 917504], "disallowed"], [[917505, 917505], "disallowed"], [[917506, 917535], "disallowed"], [[917536, 917631], "disallowed"], [[917632, 917759], "disallowed"], [[917760, 917999], "ignored"], [[918000, 983037], "disallowed"], [[983038, 983039], "disallowed"], [[983040, 1048573], "disallowed"], [[1048574, 1048575], "disallowed"], [[1048576, 1114109], "disallowed"], [[1114110, 1114111], "disallowed"]];
});

// node_modules/tr46/index.js
var require_tr46 = __commonJS((exports, module) => {
  var normalize = function(str) {
    return str.split("\0").map(function(s) {
      return s.normalize("NFC");
    }).join("\0");
  };
  var findStatus = function(val) {
    var start = 0;
    var end = mappingTable.length - 1;
    while (start <= end) {
      var mid = Math.floor((start + end) / 2);
      var target = mappingTable[mid];
      if (target[0][0] <= val && target[0][1] >= val) {
        return target;
      } else if (target[0][0] > val) {
        end = mid - 1;
      } else {
        start = mid + 1;
      }
    }
    return null;
  };
  var countSymbols = function(string) {
    return string.replace(regexAstralSymbols, "_").length;
  };
  var mapChars = function(domain_name, useSTD3, processing_option) {
    var hasError = false;
    var processed = "";
    var len = countSymbols(domain_name);
    for (var i = 0;i < len; ++i) {
      var codePoint = domain_name.codePointAt(i);
      var status = findStatus(codePoint);
      switch (status[1]) {
        case "disallowed":
          hasError = true;
          processed += String.fromCodePoint(codePoint);
          break;
        case "ignored":
          break;
        case "mapped":
          processed += String.fromCodePoint.apply(String, status[2]);
          break;
        case "deviation":
          if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {
            processed += String.fromCodePoint.apply(String, status[2]);
          } else {
            processed += String.fromCodePoint(codePoint);
          }
          break;
        case "valid":
          processed += String.fromCodePoint(codePoint);
          break;
        case "disallowed_STD3_mapped":
          if (useSTD3) {
            hasError = true;
            processed += String.fromCodePoint(codePoint);
          } else {
            processed += String.fromCodePoint.apply(String, status[2]);
          }
          break;
        case "disallowed_STD3_valid":
          if (useSTD3) {
            hasError = true;
          }
          processed += String.fromCodePoint(codePoint);
          break;
      }
    }
    return {
      string: processed,
      error: hasError
    };
  };
  var validateLabel = function(label, processing_option) {
    if (label.substr(0, 4) === "xn--") {
      label = punycode.toUnicode(label);
      processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;
    }
    var error = false;
    if (normalize(label) !== label || label[3] === "-" && label[4] === "-" || label[0] === "-" || label[label.length - 1] === "-" || label.indexOf(".") !== -1 || label.search(combiningMarksRegex) === 0) {
      error = true;
    }
    var len = countSymbols(label);
    for (var i = 0;i < len; ++i) {
      var status = findStatus(label.codePointAt(i));
      if (processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== "valid" || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && status[1] !== "valid" && status[1] !== "deviation") {
        error = true;
        break;
      }
    }
    return {
      label,
      error
    };
  };
  var processing = function(domain_name, useSTD3, processing_option) {
    var result = mapChars(domain_name, useSTD3, processing_option);
    result.string = normalize(result.string);
    var labels = result.string.split(".");
    for (var i = 0;i < labels.length; ++i) {
      try {
        var validation = validateLabel(labels[i]);
        labels[i] = validation.label;
        result.error = result.error || validation.error;
      } catch (e) {
        result.error = true;
      }
    }
    return {
      string: labels.join("."),
      error: result.error
    };
  };
  var punycode = __require("punycode");
  var mappingTable = require_mappingTable();
  var PROCESSING_OPTIONS = {
    TRANSITIONAL: 0,
    NONTRANSITIONAL: 1
  };
  var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
  exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
    var result = processing(domain_name, useSTD3, processing_option);
    var labels = result.string.split(".");
    labels = labels.map(function(l) {
      try {
        return punycode.toASCII(l);
      } catch (e) {
        result.error = true;
        return l;
      }
    });
    if (verifyDnsLength) {
      var total = labels.slice(0, labels.length - 1).join(".").length;
      if (total.length > 253 || total.length === 0) {
        result.error = true;
      }
      for (var i = 0;i < labels.length; ++i) {
        if (labels.length > 63 || labels.length === 0) {
          result.error = true;
          break;
        }
      }
    }
    if (result.error)
      return null;
    return labels.join(".");
  };
  exports.toUnicode = function(domain_name, useSTD3) {
    var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
    return {
      domain: result.string,
      error: result.error
    };
  };
  exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
});

// node_modules/whatwg-url/lib/url-state-machine.js
var require_url_state_machine = __commonJS((exports, module) => {
  var countSymbols = function(str) {
    return punycode.ucs2.decode(str).length;
  };
  var at = function(input, idx) {
    const c = input[idx];
    return isNaN(c) ? undefined : String.fromCodePoint(c);
  };
  var isASCIIDigit = function(c) {
    return c >= 48 && c <= 57;
  };
  var isASCIIAlpha = function(c) {
    return c >= 65 && c <= 90 || c >= 97 && c <= 122;
  };
  var isASCIIAlphanumeric = function(c) {
    return isASCIIAlpha(c) || isASCIIDigit(c);
  };
  var isASCIIHex = function(c) {
    return isASCIIDigit(c) || c >= 65 && c <= 70 || c >= 97 && c <= 102;
  };
  var isSingleDot = function(buffer) {
    return buffer === "." || buffer.toLowerCase() === "%2e";
  };
  var isDoubleDot = function(buffer) {
    buffer = buffer.toLowerCase();
    return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
  };
  var isWindowsDriveLetterCodePoints = function(cp1, cp2) {
    return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
  };
  var isWindowsDriveLetterString = function(string) {
    return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
  };
  var isNormalizedWindowsDriveLetterString = function(string) {
    return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
  };
  var containsForbiddenHostCodePoint = function(string) {
    return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
  };
  var containsForbiddenHostCodePointExcludingPercent = function(string) {
    return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
  };
  var isSpecialScheme = function(scheme) {
    return specialSchemes[scheme] !== undefined;
  };
  var isSpecial = function(url) {
    return isSpecialScheme(url.scheme);
  };
  var defaultPort = function(scheme) {
    return specialSchemes[scheme];
  };
  var percentEncode = function(c) {
    let hex = c.toString(16).toUpperCase();
    if (hex.length === 1) {
      hex = "0" + hex;
    }
    return "%" + hex;
  };
  var utf8PercentEncode = function(c) {
    const buf = new Buffer(c);
    let str = "";
    for (let i = 0;i < buf.length; ++i) {
      str += percentEncode(buf[i]);
    }
    return str;
  };
  var utf8PercentDecode = function(str) {
    const input = new Buffer(str);
    const output = [];
    for (let i = 0;i < input.length; ++i) {
      if (input[i] !== 37) {
        output.push(input[i]);
      } else if (input[i] === 37 && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {
        output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));
        i += 2;
      } else {
        output.push(input[i]);
      }
    }
    return new Buffer(output).toString();
  };
  var isC0ControlPercentEncode = function(c) {
    return c <= 31 || c > 126;
  };
  var isPathPercentEncode = function(c) {
    return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
  };
  var isUserinfoPercentEncode = function(c) {
    return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
  };
  var percentEncodeChar = function(c, encodeSetPredicate) {
    const cStr = String.fromCodePoint(c);
    if (encodeSetPredicate(c)) {
      return utf8PercentEncode(cStr);
    }
    return cStr;
  };
  var parseIPv4Number = function(input) {
    let R = 10;
    if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
      input = input.substring(2);
      R = 16;
    } else if (input.length >= 2 && input.charAt(0) === "0") {
      input = input.substring(1);
      R = 8;
    }
    if (input === "") {
      return 0;
    }
    const regex = R === 10 ? /[^0-9]/ : R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/;
    if (regex.test(input)) {
      return failure;
    }
    return parseInt(input, R);
  };
  var parseIPv4 = function(input) {
    const parts = input.split(".");
    if (parts[parts.length - 1] === "") {
      if (parts.length > 1) {
        parts.pop();
      }
    }
    if (parts.length > 4) {
      return input;
    }
    const numbers = [];
    for (const part of parts) {
      if (part === "") {
        return input;
      }
      const n = parseIPv4Number(part);
      if (n === failure) {
        return input;
      }
      numbers.push(n);
    }
    for (let i = 0;i < numbers.length - 1; ++i) {
      if (numbers[i] > 255) {
        return failure;
      }
    }
    if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
      return failure;
    }
    let ipv4 = numbers.pop();
    let counter = 0;
    for (const n of numbers) {
      ipv4 += n * Math.pow(256, 3 - counter);
      ++counter;
    }
    return ipv4;
  };
  var serializeIPv4 = function(address) {
    let output = "";
    let n = address;
    for (let i = 1;i <= 4; ++i) {
      output = String(n % 256) + output;
      if (i !== 4) {
        output = "." + output;
      }
      n = Math.floor(n / 256);
    }
    return output;
  };
  var parseIPv6 = function(input) {
    const address = [0, 0, 0, 0, 0, 0, 0, 0];
    let pieceIndex = 0;
    let compress = null;
    let pointer = 0;
    input = punycode.ucs2.decode(input);
    if (input[pointer] === 58) {
      if (input[pointer + 1] !== 58) {
        return failure;
      }
      pointer += 2;
      ++pieceIndex;
      compress = pieceIndex;
    }
    while (pointer < input.length) {
      if (pieceIndex === 8) {
        return failure;
      }
      if (input[pointer] === 58) {
        if (compress !== null) {
          return failure;
        }
        ++pointer;
        ++pieceIndex;
        compress = pieceIndex;
        continue;
      }
      let value = 0;
      let length = 0;
      while (length < 4 && isASCIIHex(input[pointer])) {
        value = value * 16 + parseInt(at(input, pointer), 16);
        ++pointer;
        ++length;
      }
      if (input[pointer] === 46) {
        if (length === 0) {
          return failure;
        }
        pointer -= length;
        if (pieceIndex > 6) {
          return failure;
        }
        let numbersSeen = 0;
        while (input[pointer] !== undefined) {
          let ipv4Piece = null;
          if (numbersSeen > 0) {
            if (input[pointer] === 46 && numbersSeen < 4) {
              ++pointer;
            } else {
              return failure;
            }
          }
          if (!isASCIIDigit(input[pointer])) {
            return failure;
          }
          while (isASCIIDigit(input[pointer])) {
            const number = parseInt(at(input, pointer));
            if (ipv4Piece === null) {
              ipv4Piece = number;
            } else if (ipv4Piece === 0) {
              return failure;
            } else {
              ipv4Piece = ipv4Piece * 10 + number;
            }
            if (ipv4Piece > 255) {
              return failure;
            }
            ++pointer;
          }
          address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
          ++numbersSeen;
          if (numbersSeen === 2 || numbersSeen === 4) {
            ++pieceIndex;
          }
        }
        if (numbersSeen !== 4) {
          return failure;
        }
        break;
      } else if (input[pointer] === 58) {
        ++pointer;
        if (input[pointer] === undefined) {
          return failure;
        }
      } else if (input[pointer] !== undefined) {
        return failure;
      }
      address[pieceIndex] = value;
      ++pieceIndex;
    }
    if (compress !== null) {
      let swaps = pieceIndex - compress;
      pieceIndex = 7;
      while (pieceIndex !== 0 && swaps > 0) {
        const temp = address[compress + swaps - 1];
        address[compress + swaps - 1] = address[pieceIndex];
        address[pieceIndex] = temp;
        --pieceIndex;
        --swaps;
      }
    } else if (compress === null && pieceIndex !== 8) {
      return failure;
    }
    return address;
  };
  var serializeIPv6 = function(address) {
    let output = "";
    const seqResult = findLongestZeroSequence(address);
    const compress = seqResult.idx;
    let ignore0 = false;
    for (let pieceIndex = 0;pieceIndex <= 7; ++pieceIndex) {
      if (ignore0 && address[pieceIndex] === 0) {
        continue;
      } else if (ignore0) {
        ignore0 = false;
      }
      if (compress === pieceIndex) {
        const separator = pieceIndex === 0 ? "::" : ":";
        output += separator;
        ignore0 = true;
        continue;
      }
      output += address[pieceIndex].toString(16);
      if (pieceIndex !== 7) {
        output += ":";
      }
    }
    return output;
  };
  var parseHost = function(input, isSpecialArg) {
    if (input[0] === "[") {
      if (input[input.length - 1] !== "]") {
        return failure;
      }
      return parseIPv6(input.substring(1, input.length - 1));
    }
    if (!isSpecialArg) {
      return parseOpaqueHost(input);
    }
    const domain = utf8PercentDecode(input);
    const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
    if (asciiDomain === null) {
      return failure;
    }
    if (containsForbiddenHostCodePoint(asciiDomain)) {
      return failure;
    }
    const ipv4Host = parseIPv4(asciiDomain);
    if (typeof ipv4Host === "number" || ipv4Host === failure) {
      return ipv4Host;
    }
    return asciiDomain;
  };
  var parseOpaqueHost = function(input) {
    if (containsForbiddenHostCodePointExcludingPercent(input)) {
      return failure;
    }
    let output = "";
    const decoded = punycode.ucs2.decode(input);
    for (let i = 0;i < decoded.length; ++i) {
      output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);
    }
    return output;
  };
  var findLongestZeroSequence = function(arr) {
    let maxIdx = null;
    let maxLen = 1;
    let currStart = null;
    let currLen = 0;
    for (let i = 0;i < arr.length; ++i) {
      if (arr[i] !== 0) {
        if (currLen > maxLen) {
          maxIdx = currStart;
          maxLen = currLen;
        }
        currStart = null;
        currLen = 0;
      } else {
        if (currStart === null) {
          currStart = i;
        }
        ++currLen;
      }
    }
    if (currLen > maxLen) {
      maxIdx = currStart;
      maxLen = currLen;
    }
    return {
      idx: maxIdx,
      len: maxLen
    };
  };
  var serializeHost = function(host) {
    if (typeof host === "number") {
      return serializeIPv4(host);
    }
    if (host instanceof Array) {
      return "[" + serializeIPv6(host) + "]";
    }
    return host;
  };
  var trimControlChars = function(url) {
    return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
  };
  var trimTabAndNewline = function(url) {
    return url.replace(/\u0009|\u000A|\u000D/g, "");
  };
  var shortenPath = function(url) {
    const path = url.path;
    if (path.length === 0) {
      return;
    }
    if (url.scheme === "file" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {
      return;
    }
    path.pop();
  };
  var includesCredentials = function(url) {
    return url.username !== "" || url.password !== "";
  };
  var cannotHaveAUsernamePasswordPort = function(url) {
    return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file";
  };
  var isNormalizedWindowsDriveLetter = function(string) {
    return /^[A-Za-z]:$/.test(string);
  };
  var URLStateMachine = function(input, base, encodingOverride, url, stateOverride) {
    this.pointer = 0;
    this.input = input;
    this.base = base || null;
    this.encodingOverride = encodingOverride || "utf-8";
    this.stateOverride = stateOverride;
    this.url = url;
    this.failure = false;
    this.parseError = false;
    if (!this.url) {
      this.url = {
        scheme: "",
        username: "",
        password: "",
        host: null,
        port: null,
        path: [],
        query: null,
        fragment: null,
        cannotBeABaseURL: false
      };
      const res2 = trimControlChars(this.input);
      if (res2 !== this.input) {
        this.parseError = true;
      }
      this.input = res2;
    }
    const res = trimTabAndNewline(this.input);
    if (res !== this.input) {
      this.parseError = true;
    }
    this.input = res;
    this.state = stateOverride || "scheme start";
    this.buffer = "";
    this.atFlag = false;
    this.arrFlag = false;
    this.passwordTokenSeenFlag = false;
    this.input = punycode.ucs2.decode(this.input);
    for (;this.pointer <= this.input.length; ++this.pointer) {
      const c = this.input[this.pointer];
      const cStr = isNaN(c) ? undefined : String.fromCodePoint(c);
      const ret = this["parse " + this.state](c, cStr);
      if (!ret) {
        break;
      } else if (ret === failure) {
        this.failure = true;
        break;
      }
    }
  };
  var serializeURL = function(url, excludeFragment) {
    let output = url.scheme + ":";
    if (url.host !== null) {
      output += "//";
      if (url.username !== "" || url.password !== "") {
        output += url.username;
        if (url.password !== "") {
          output += ":" + url.password;
        }
        output += "@";
      }
      output += serializeHost(url.host);
      if (url.port !== null) {
        output += ":" + url.port;
      }
    } else if (url.host === null && url.scheme === "file") {
      output += "//";
    }
    if (url.cannotBeABaseURL) {
      output += url.path[0];
    } else {
      for (const string of url.path) {
        output += "/" + string;
      }
    }
    if (url.query !== null) {
      output += "?" + url.query;
    }
    if (!excludeFragment && url.fragment !== null) {
      output += "#" + url.fragment;
    }
    return output;
  };
  var serializeOrigin = function(tuple) {
    let result = tuple.scheme + "://";
    result += serializeHost(tuple.host);
    if (tuple.port !== null) {
      result += ":" + tuple.port;
    }
    return result;
  };
  var punycode = __require("punycode");
  var tr46 = require_tr46();
  var specialSchemes = {
    ftp: 21,
    file: null,
    gopher: 70,
    http: 80,
    https: 443,
    ws: 80,
    wss: 443
  };
  var failure = Symbol("failure");
  var extraPathPercentEncodeSet = new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);
  var extraUserinfoPercentEncodeSet = new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);
  URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
    if (isASCIIAlpha(c)) {
      this.buffer += cStr.toLowerCase();
      this.state = "scheme";
    } else if (!this.stateOverride) {
      this.state = "no scheme";
      --this.pointer;
    } else {
      this.parseError = true;
      return failure;
    }
    return true;
  };
  URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
    if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {
      this.buffer += cStr.toLowerCase();
    } else if (c === 58) {
      if (this.stateOverride) {
        if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
          return false;
        }
        if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
          return false;
        }
        if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
          return false;
        }
        if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
          return false;
        }
      }
      this.url.scheme = this.buffer;
      this.buffer = "";
      if (this.stateOverride) {
        return false;
      }
      if (this.url.scheme === "file") {
        if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
          this.parseError = true;
        }
        this.state = "file";
      } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
        this.state = "special relative or authority";
      } else if (isSpecial(this.url)) {
        this.state = "special authority slashes";
      } else if (this.input[this.pointer + 1] === 47) {
        this.state = "path or authority";
        ++this.pointer;
      } else {
        this.url.cannotBeABaseURL = true;
        this.url.path.push("");
        this.state = "cannot-be-a-base-URL path";
      }
    } else if (!this.stateOverride) {
      this.buffer = "";
      this.state = "no scheme";
      this.pointer = -1;
    } else {
      this.parseError = true;
      return failure;
    }
    return true;
  };
  URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
    if (this.base === null || this.base.cannotBeABaseURL && c !== 35) {
      return failure;
    } else if (this.base.cannotBeABaseURL && c === 35) {
      this.url.scheme = this.base.scheme;
      this.url.path = this.base.path.slice();
      this.url.query = this.base.query;
      this.url.fragment = "";
      this.url.cannotBeABaseURL = true;
      this.state = "fragment";
    } else if (this.base.scheme === "file") {
      this.state = "file";
      --this.pointer;
    } else {
      this.state = "relative";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
    if (c === 47 && this.input[this.pointer + 1] === 47) {
      this.state = "special authority ignore slashes";
      ++this.pointer;
    } else {
      this.parseError = true;
      this.state = "relative";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
    if (c === 47) {
      this.state = "authority";
    } else {
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
    this.url.scheme = this.base.scheme;
    if (isNaN(c)) {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.url.path = this.base.path.slice();
      this.url.query = this.base.query;
    } else if (c === 47) {
      this.state = "relative slash";
    } else if (c === 63) {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.url.path = this.base.path.slice();
      this.url.query = "";
      this.state = "query";
    } else if (c === 35) {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.url.path = this.base.path.slice();
      this.url.query = this.base.query;
      this.url.fragment = "";
      this.state = "fragment";
    } else if (isSpecial(this.url) && c === 92) {
      this.parseError = true;
      this.state = "relative slash";
    } else {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.url.path = this.base.path.slice(0, this.base.path.length - 1);
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
    if (isSpecial(this.url) && (c === 47 || c === 92)) {
      if (c === 92) {
        this.parseError = true;
      }
      this.state = "special authority ignore slashes";
    } else if (c === 47) {
      this.state = "authority";
    } else {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
    if (c === 47 && this.input[this.pointer + 1] === 47) {
      this.state = "special authority ignore slashes";
      ++this.pointer;
    } else {
      this.parseError = true;
      this.state = "special authority ignore slashes";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
    if (c !== 47 && c !== 92) {
      this.state = "authority";
      --this.pointer;
    } else {
      this.parseError = true;
    }
    return true;
  };
  URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
    if (c === 64) {
      this.parseError = true;
      if (this.atFlag) {
        this.buffer = "%40" + this.buffer;
      }
      this.atFlag = true;
      const len = countSymbols(this.buffer);
      for (let pointer = 0;pointer < len; ++pointer) {
        const codePoint = this.buffer.codePointAt(pointer);
        if (codePoint === 58 && !this.passwordTokenSeenFlag) {
          this.passwordTokenSeenFlag = true;
          continue;
        }
        const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
        if (this.passwordTokenSeenFlag) {
          this.url.password += encodedCodePoints;
        } else {
          this.url.username += encodedCodePoints;
        }
      }
      this.buffer = "";
    } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
      if (this.atFlag && this.buffer === "") {
        this.parseError = true;
        return failure;
      }
      this.pointer -= countSymbols(this.buffer) + 1;
      this.buffer = "";
      this.state = "host";
    } else {
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
    if (this.stateOverride && this.url.scheme === "file") {
      --this.pointer;
      this.state = "file host";
    } else if (c === 58 && !this.arrFlag) {
      if (this.buffer === "") {
        this.parseError = true;
        return failure;
      }
      const host = parseHost(this.buffer, isSpecial(this.url));
      if (host === failure) {
        return failure;
      }
      this.url.host = host;
      this.buffer = "";
      this.state = "port";
      if (this.stateOverride === "hostname") {
        return false;
      }
    } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
      --this.pointer;
      if (isSpecial(this.url) && this.buffer === "") {
        this.parseError = true;
        return failure;
      } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
        this.parseError = true;
        return false;
      }
      const host = parseHost(this.buffer, isSpecial(this.url));
      if (host === failure) {
        return failure;
      }
      this.url.host = host;
      this.buffer = "";
      this.state = "path start";
      if (this.stateOverride) {
        return false;
      }
    } else {
      if (c === 91) {
        this.arrFlag = true;
      } else if (c === 93) {
        this.arrFlag = false;
      }
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
    if (isASCIIDigit(c)) {
      this.buffer += cStr;
    } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92 || this.stateOverride) {
      if (this.buffer !== "") {
        const port = parseInt(this.buffer);
        if (port > Math.pow(2, 16) - 1) {
          this.parseError = true;
          return failure;
        }
        this.url.port = port === defaultPort(this.url.scheme) ? null : port;
        this.buffer = "";
      }
      if (this.stateOverride) {
        return false;
      }
      this.state = "path start";
      --this.pointer;
    } else {
      this.parseError = true;
      return failure;
    }
    return true;
  };
  var fileOtherwiseCodePoints = new Set([47, 92, 63, 35]);
  URLStateMachine.prototype["parse file"] = function parseFile(c) {
    this.url.scheme = "file";
    if (c === 47 || c === 92) {
      if (c === 92) {
        this.parseError = true;
      }
      this.state = "file slash";
    } else if (this.base !== null && this.base.scheme === "file") {
      if (isNaN(c)) {
        this.url.host = this.base.host;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
      } else if (c === 63) {
        this.url.host = this.base.host;
        this.url.path = this.base.path.slice();
        this.url.query = "";
        this.state = "query";
      } else if (c === 35) {
        this.url.host = this.base.host;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.state = "fragment";
      } else {
        if (this.input.length - this.pointer - 1 === 0 || !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) || this.input.length - this.pointer - 1 >= 2 && !fileOtherwiseCodePoints.has(this.input[this.pointer + 2])) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          shortenPath(this.url);
        } else {
          this.parseError = true;
        }
        this.state = "path";
        --this.pointer;
      }
    } else {
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
    if (c === 47 || c === 92) {
      if (c === 92) {
        this.parseError = true;
      }
      this.state = "file host";
    } else {
      if (this.base !== null && this.base.scheme === "file") {
        if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
          this.url.path.push(this.base.path[0]);
        } else {
          this.url.host = this.base.host;
        }
      }
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
    if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {
      --this.pointer;
      if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
        this.parseError = true;
        this.state = "path";
      } else if (this.buffer === "") {
        this.url.host = "";
        if (this.stateOverride) {
          return false;
        }
        this.state = "path start";
      } else {
        let host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        if (host === "localhost") {
          host = "";
        }
        this.url.host = host;
        if (this.stateOverride) {
          return false;
        }
        this.buffer = "";
        this.state = "path start";
      }
    } else {
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
    if (isSpecial(this.url)) {
      if (c === 92) {
        this.parseError = true;
      }
      this.state = "path";
      if (c !== 47 && c !== 92) {
        --this.pointer;
      }
    } else if (!this.stateOverride && c === 63) {
      this.url.query = "";
      this.state = "query";
    } else if (!this.stateOverride && c === 35) {
      this.url.fragment = "";
      this.state = "fragment";
    } else if (c !== undefined) {
      this.state = "path";
      if (c !== 47) {
        --this.pointer;
      }
    }
    return true;
  };
  URLStateMachine.prototype["parse path"] = function parsePath(c) {
    if (isNaN(c) || c === 47 || isSpecial(this.url) && c === 92 || !this.stateOverride && (c === 63 || c === 35)) {
      if (isSpecial(this.url) && c === 92) {
        this.parseError = true;
      }
      if (isDoubleDot(this.buffer)) {
        shortenPath(this.url);
        if (c !== 47 && !(isSpecial(this.url) && c === 92)) {
          this.url.path.push("");
        }
      } else if (isSingleDot(this.buffer) && c !== 47 && !(isSpecial(this.url) && c === 92)) {
        this.url.path.push("");
      } else if (!isSingleDot(this.buffer)) {
        if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
          if (this.url.host !== "" && this.url.host !== null) {
            this.parseError = true;
            this.url.host = "";
          }
          this.buffer = this.buffer[0] + ":";
        }
        this.url.path.push(this.buffer);
      }
      this.buffer = "";
      if (this.url.scheme === "file" && (c === undefined || c === 63 || c === 35)) {
        while (this.url.path.length > 1 && this.url.path[0] === "") {
          this.parseError = true;
          this.url.path.shift();
        }
      }
      if (c === 63) {
        this.url.query = "";
        this.state = "query";
      }
      if (c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      }
    } else {
      if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      this.buffer += percentEncodeChar(c, isPathPercentEncode);
    }
    return true;
  };
  URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c) {
    if (c === 63) {
      this.url.query = "";
      this.state = "query";
    } else if (c === 35) {
      this.url.fragment = "";
      this.state = "fragment";
    } else {
      if (!isNaN(c) && c !== 37) {
        this.parseError = true;
      }
      if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      if (!isNaN(c)) {
        this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
      }
    }
    return true;
  };
  URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
    if (isNaN(c) || !this.stateOverride && c === 35) {
      if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
        this.encodingOverride = "utf-8";
      }
      const buffer = new Buffer(this.buffer);
      for (let i = 0;i < buffer.length; ++i) {
        if (buffer[i] < 33 || buffer[i] > 126 || buffer[i] === 34 || buffer[i] === 35 || buffer[i] === 60 || buffer[i] === 62) {
          this.url.query += percentEncode(buffer[i]);
        } else {
          this.url.query += String.fromCodePoint(buffer[i]);
        }
      }
      this.buffer = "";
      if (c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      }
    } else {
      if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
    if (isNaN(c)) {
    } else if (c === 0) {
      this.parseError = true;
    } else {
      if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);
    }
    return true;
  };
  exports.serializeURL = serializeURL;
  exports.serializeURLOrigin = function(url) {
    switch (url.scheme) {
      case "blob":
        try {
          return exports.serializeURLOrigin(exports.parseURL(url.path[0]));
        } catch (e) {
          return "null";
        }
      case "ftp":
      case "gopher":
      case "http":
      case "https":
      case "ws":
      case "wss":
        return serializeOrigin({
          scheme: url.scheme,
          host: url.host,
          port: url.port
        });
      case "file":
        return "file://";
      default:
        return "null";
    }
  };
  exports.basicURLParse = function(input, options2) {
    if (options2 === undefined) {
      options2 = {};
    }
    const usm = new URLStateMachine(input, options2.baseURL, options2.encodingOverride, options2.url, options2.stateOverride);
    if (usm.failure) {
      return "failure";
    }
    return usm.url;
  };
  exports.setTheUsername = function(url, username) {
    url.username = "";
    const decoded = punycode.ucs2.decode(username);
    for (let i = 0;i < decoded.length; ++i) {
      url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
    }
  };
  exports.setThePassword = function(url, password) {
    url.password = "";
    const decoded = punycode.ucs2.decode(password);
    for (let i = 0;i < decoded.length; ++i) {
      url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
    }
  };
  exports.serializeHost = serializeHost;
  exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
  exports.serializeInteger = function(integer) {
    return String(integer);
  };
  exports.parseURL = function(input, options2) {
    if (options2 === undefined) {
      options2 = {};
    }
    return exports.basicURLParse(input, { baseURL: options2.baseURL, encodingOverride: options2.encodingOverride });
  };
});

// node_modules/whatwg-url/lib/URL-impl.js
var require_URL_impl = __commonJS((exports) => {
  var usm = require_url_state_machine();
  exports.implementation = class URLImpl {
    constructor(constructorArgs) {
      const url = constructorArgs[0];
      const base = constructorArgs[1];
      let parsedBase = null;
      if (base !== undefined) {
        parsedBase = usm.basicURLParse(base);
        if (parsedBase === "failure") {
          throw new TypeError("Invalid base URL");
        }
      }
      const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
      if (parsedURL === "failure") {
        throw new TypeError("Invalid URL");
      }
      this._url = parsedURL;
    }
    get href() {
      return usm.serializeURL(this._url);
    }
    set href(v) {
      const parsedURL = usm.basicURLParse(v);
      if (parsedURL === "failure") {
        throw new TypeError("Invalid URL");
      }
      this._url = parsedURL;
    }
    get origin() {
      return usm.serializeURLOrigin(this._url);
    }
    get protocol() {
      return this._url.scheme + ":";
    }
    set protocol(v) {
      usm.basicURLParse(v + ":", { url: this._url, stateOverride: "scheme start" });
    }
    get username() {
      return this._url.username;
    }
    set username(v) {
      if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
        return;
      }
      usm.setTheUsername(this._url, v);
    }
    get password() {
      return this._url.password;
    }
    set password(v) {
      if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
        return;
      }
      usm.setThePassword(this._url, v);
    }
    get host() {
      const url = this._url;
      if (url.host === null) {
        return "";
      }
      if (url.port === null) {
        return usm.serializeHost(url.host);
      }
      return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
    }
    set host(v) {
      if (this._url.cannotBeABaseURL) {
        return;
      }
      usm.basicURLParse(v, { url: this._url, stateOverride: "host" });
    }
    get hostname() {
      if (this._url.host === null) {
        return "";
      }
      return usm.serializeHost(this._url.host);
    }
    set hostname(v) {
      if (this._url.cannotBeABaseURL) {
        return;
      }
      usm.basicURLParse(v, { url: this._url, stateOverride: "hostname" });
    }
    get port() {
      if (this._url.port === null) {
        return "";
      }
      return usm.serializeInteger(this._url.port);
    }
    set port(v) {
      if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
        return;
      }
      if (v === "") {
        this._url.port = null;
      } else {
        usm.basicURLParse(v, { url: this._url, stateOverride: "port" });
      }
    }
    get pathname() {
      if (this._url.cannotBeABaseURL) {
        return this._url.path[0];
      }
      if (this._url.path.length === 0) {
        return "";
      }
      return "/" + this._url.path.join("/");
    }
    set pathname(v) {
      if (this._url.cannotBeABaseURL) {
        return;
      }
      this._url.path = [];
      usm.basicURLParse(v, { url: this._url, stateOverride: "path start" });
    }
    get search() {
      if (this._url.query === null || this._url.query === "") {
        return "";
      }
      return "?" + this._url.query;
    }
    set search(v) {
      const url = this._url;
      if (v === "") {
        url.query = null;
        return;
      }
      const input = v[0] === "?" ? v.substring(1) : v;
      url.query = "";
      usm.basicURLParse(input, { url, stateOverride: "query" });
    }
    get hash() {
      if (this._url.fragment === null || this._url.fragment === "") {
        return "";
      }
      return "#" + this._url.fragment;
    }
    set hash(v) {
      if (v === "") {
        this._url.fragment = null;
        return;
      }
      const input = v[0] === "#" ? v.substring(1) : v;
      this._url.fragment = "";
      usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
    }
    toJSON() {
      return this.href;
    }
  };
});

// node_modules/whatwg-url/lib/URL.js
var require_URL = __commonJS((exports, module) => {
  var URL2 = function(url) {
    if (!this || this[impl] || !(this instanceof URL2)) {
      throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
    }
    if (arguments.length < 1) {
      throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
    }
    const args = [];
    for (let i = 0;i < arguments.length && i < 2; ++i) {
      args[i] = arguments[i];
    }
    args[0] = conversions["USVString"](args[0]);
    if (args[1] !== undefined) {
      args[1] = conversions["USVString"](args[1]);
    }
    exports.setup(this, args);
  };
  var conversions = require_lib();
  var utils = require_utils();
  var Impl = require_URL_impl();
  var impl = utils.implSymbol;
  URL2.prototype.toJSON = function toJSON() {
    if (!this || !exports.is(this)) {
      throw new TypeError("Illegal invocation");
    }
    const args = [];
    for (let i = 0;i < arguments.length && i < 0; ++i) {
      args[i] = arguments[i];
    }
    return this[impl].toJSON.apply(this[impl], args);
  };
  Object.defineProperty(URL2.prototype, "href", {
    get() {
      return this[impl].href;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].href = V;
    },
    enumerable: true,
    configurable: true
  });
  URL2.prototype.toString = function() {
    if (!this || !exports.is(this)) {
      throw new TypeError("Illegal invocation");
    }
    return this.href;
  };
  Object.defineProperty(URL2.prototype, "origin", {
    get() {
      return this[impl].origin;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "protocol", {
    get() {
      return this[impl].protocol;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].protocol = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "username", {
    get() {
      return this[impl].username;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].username = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "password", {
    get() {
      return this[impl].password;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].password = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "host", {
    get() {
      return this[impl].host;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].host = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "hostname", {
    get() {
      return this[impl].hostname;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].hostname = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "port", {
    get() {
      return this[impl].port;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].port = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "pathname", {
    get() {
      return this[impl].pathname;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].pathname = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "search", {
    get() {
      return this[impl].search;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].search = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "hash", {
    get() {
      return this[impl].hash;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].hash = V;
    },
    enumerable: true,
    configurable: true
  });
  module.exports = {
    is(obj) {
      return !!obj && obj[impl] instanceof Impl.implementation;
    },
    create(constructorArgs, privateData) {
      let obj = Object.create(URL2.prototype);
      this.setup(obj, constructorArgs, privateData);
      return obj;
    },
    setup(obj, constructorArgs, privateData) {
      if (!privateData)
        privateData = {};
      privateData.wrapper = obj;
      obj[impl] = new Impl.implementation(constructorArgs, privateData);
      obj[impl][utils.wrapperSymbol] = obj;
    },
    interface: URL2,
    expose: {
      Window: { URL: URL2 },
      Worker: { URL: URL2 }
    }
  };
});

// node_modules/whatwg-url/lib/public-api.js
var require_public_api = __commonJS((exports) => {
  exports.URL = require_URL().interface;
  exports.serializeURL = require_url_state_machine().serializeURL;
  exports.serializeURLOrigin = require_url_state_machine().serializeURLOrigin;
  exports.basicURLParse = require_url_state_machine().basicURLParse;
  exports.setTheUsername = require_url_state_machine().setTheUsername;
  exports.setThePassword = require_url_state_machine().setThePassword;
  exports.serializeHost = require_url_state_machine().serializeHost;
  exports.serializeInteger = require_url_state_machine().serializeInteger;
  exports.parseURL = require_url_state_machine().parseURL;
});

// node_modules/node-fetch/lib/index.js
var require_lib2 = __commonJS((exports, module) => {
  var _interopDefault = function(ex) {
    return ex && typeof ex === "object" && ("default" in ex) ? ex["default"] : ex;
  };
  var FetchError = function(message, type, systemError) {
    Error.call(this, message);
    this.message = message;
    this.type = type;
    if (systemError) {
      this.code = this.errno = systemError.code;
    }
    Error.captureStackTrace(this, this.constructor);
  };
  var Body = function(body) {
    var _this = this;
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref$size = _ref.size;
    let size = _ref$size === undefined ? 0 : _ref$size;
    var _ref$timeout = _ref.timeout;
    let timeout = _ref$timeout === undefined ? 0 : _ref$timeout;
    if (body == null) {
      body = null;
    } else if (isURLSearchParams(body)) {
      body = Buffer.from(body.toString());
    } else if (isBlob(body))
      ;
    else if (Buffer.isBuffer(body))
      ;
    else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
      body = Buffer.from(body);
    } else if (ArrayBuffer.isView(body)) {
      body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
    } else if (body instanceof Stream)
      ;
    else {
      body = Buffer.from(String(body));
    }
    this[INTERNALS] = {
      body,
      disturbed: false,
      error: null
    };
    this.size = size;
    this.timeout = timeout;
    if (body instanceof Stream) {
      body.on("error", function(err) {
        const error = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
        _this[INTERNALS].error = error;
      });
    }
  };
  var consumeBody = function() {
    var _this4 = this;
    if (this[INTERNALS].disturbed) {
      return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
    }
    this[INTERNALS].disturbed = true;
    if (this[INTERNALS].error) {
      return Body.Promise.reject(this[INTERNALS].error);
    }
    let body = this.body;
    if (body === null) {
      return Body.Promise.resolve(Buffer.alloc(0));
    }
    if (isBlob(body)) {
      body = body.stream();
    }
    if (Buffer.isBuffer(body)) {
      return Body.Promise.resolve(body);
    }
    if (!(body instanceof Stream)) {
      return Body.Promise.resolve(Buffer.alloc(0));
    }
    let accum = [];
    let accumBytes = 0;
    let abort = false;
    return new Body.Promise(function(resolve, reject) {
      let resTimeout;
      if (_this4.timeout) {
        resTimeout = setTimeout(function() {
          abort = true;
          reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
        }, _this4.timeout);
      }
      body.on("error", function(err) {
        if (err.name === "AbortError") {
          abort = true;
          reject(err);
        } else {
          reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
        }
      });
      body.on("data", function(chunk) {
        if (abort || chunk === null) {
          return;
        }
        if (_this4.size && accumBytes + chunk.length > _this4.size) {
          abort = true;
          reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
          return;
        }
        accumBytes += chunk.length;
        accum.push(chunk);
      });
      body.on("end", function() {
        if (abort) {
          return;
        }
        clearTimeout(resTimeout);
        try {
          resolve(Buffer.concat(accum, accumBytes));
        } catch (err) {
          reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
        }
      });
    });
  };
  var convertBody = function(buffer, headers) {
    if (typeof convert !== "function") {
      throw new Error("The package `encoding` must be installed to use the textConverted() function");
    }
    const ct = headers.get("content-type");
    let charset = "utf-8";
    let res, str;
    if (ct) {
      res = /charset=([^;]*)/i.exec(ct);
    }
    str = buffer.slice(0, 1024).toString();
    if (!res && str) {
      res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
    }
    if (!res && str) {
      res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
      if (!res) {
        res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
        if (res) {
          res.pop();
        }
      }
      if (res) {
        res = /charset=(.*)/i.exec(res.pop());
      }
    }
    if (!res && str) {
      res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
    }
    if (res) {
      charset = res.pop();
      if (charset === "gb2312" || charset === "gbk") {
        charset = "gb18030";
      }
    }
    return convert(buffer, "UTF-8", charset).toString();
  };
  var isURLSearchParams = function(obj) {
    if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
      return false;
    }
    return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
  };
  var isBlob = function(obj) {
    return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
  };
  var clone = function(instance) {
    let p1, p2;
    let body = instance.body;
    if (instance.bodyUsed) {
      throw new Error("cannot clone body after it is used");
    }
    if (body instanceof Stream && typeof body.getBoundary !== "function") {
      p1 = new PassThrough;
      p2 = new PassThrough;
      body.pipe(p1);
      body.pipe(p2);
      instance[INTERNALS].body = p1;
      body = p2;
    }
    return body;
  };
  var extractContentType = function(body) {
    if (body === null) {
      return null;
    } else if (typeof body === "string") {
      return "text/plain;charset=UTF-8";
    } else if (isURLSearchParams(body)) {
      return "application/x-www-form-urlencoded;charset=UTF-8";
    } else if (isBlob(body)) {
      return body.type || null;
    } else if (Buffer.isBuffer(body)) {
      return null;
    } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
      return null;
    } else if (ArrayBuffer.isView(body)) {
      return null;
    } else if (typeof body.getBoundary === "function") {
      return `multipart/form-data;boundary=${body.getBoundary()}`;
    } else if (body instanceof Stream) {
      return null;
    } else {
      return "text/plain;charset=UTF-8";
    }
  };
  var getTotalBytes = function(instance) {
    const body = instance.body;
    if (body === null) {
      return 0;
    } else if (isBlob(body)) {
      return body.size;
    } else if (Buffer.isBuffer(body)) {
      return body.length;
    } else if (body && typeof body.getLengthSync === "function") {
      if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || body.hasKnownLength && body.hasKnownLength()) {
        return body.getLengthSync();
      }
      return null;
    } else {
      return null;
    }
  };
  var writeToStream = function(dest, instance) {
    const body = instance.body;
    if (body === null) {
      dest.end();
    } else if (isBlob(body)) {
      body.stream().pipe(dest);
    } else if (Buffer.isBuffer(body)) {
      dest.write(body);
      dest.end();
    } else {
      body.pipe(dest);
    }
  };
  var validateName = function(name) {
    name = `${name}`;
    if (invalidTokenRegex.test(name) || name === "") {
      throw new TypeError(`${name} is not a legal HTTP header name`);
    }
  };
  var validateValue = function(value) {
    value = `${value}`;
    if (invalidHeaderCharRegex.test(value)) {
      throw new TypeError(`${value} is not a legal HTTP header value`);
    }
  };
  var find = function(map, name) {
    name = name.toLowerCase();
    for (const key in map) {
      if (key.toLowerCase() === name) {
        return key;
      }
    }
    return;
  };
  var getHeaders = function(headers) {
    let kind2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "key+value";
    const keys = Object.keys(headers[MAP]).sort();
    return keys.map(kind2 === "key" ? function(k) {
      return k.toLowerCase();
    } : kind2 === "value" ? function(k) {
      return headers[MAP][k].join(", ");
    } : function(k) {
      return [k.toLowerCase(), headers[MAP][k].join(", ")];
    });
  };
  var createHeadersIterator = function(target, kind2) {
    const iterator = Object.create(HeadersIteratorPrototype);
    iterator[INTERNAL] = {
      target,
      kind: kind2,
      index: 0
    };
    return iterator;
  };
  var exportNodeCompatibleHeaders = function(headers) {
    const obj = Object.assign({ __proto__: null }, headers[MAP]);
    const hostHeaderKey = find(headers[MAP], "Host");
    if (hostHeaderKey !== undefined) {
      obj[hostHeaderKey] = obj[hostHeaderKey][0];
    }
    return obj;
  };
  var createHeadersLenient = function(obj) {
    const headers = new Headers2;
    for (const name of Object.keys(obj)) {
      if (invalidTokenRegex.test(name)) {
        continue;
      }
      if (Array.isArray(obj[name])) {
        for (const val of obj[name]) {
          if (invalidHeaderCharRegex.test(val)) {
            continue;
          }
          if (headers[MAP][name] === undefined) {
            headers[MAP][name] = [val];
          } else {
            headers[MAP][name].push(val);
          }
        }
      } else if (!invalidHeaderCharRegex.test(obj[name])) {
        headers[MAP][name] = [obj[name]];
      }
    }
    return headers;
  };
  var parseURL = function(urlStr) {
    if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
      urlStr = new URL2(urlStr).toString();
    }
    return parse_url(urlStr);
  };
  var isRequest = function(input) {
    return typeof input === "object" && typeof input[INTERNALS$2] === "object";
  };
  var isAbortSignal = function(signal) {
    const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
    return !!(proto && proto.constructor.name === "AbortSignal");
  };
  var getNodeRequestOptions = function(request) {
    const parsedURL = request[INTERNALS$2].parsedURL;
    const headers = new Headers2(request[INTERNALS$2].headers);
    if (!headers.has("Accept")) {
      headers.set("Accept", "*/*");
    }
    if (!parsedURL.protocol || !parsedURL.hostname) {
      throw new TypeError("Only absolute URLs are supported");
    }
    if (!/^https?:$/.test(parsedURL.protocol)) {
      throw new TypeError("Only HTTP(S) protocols are supported");
    }
    if (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {
      throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
    }
    let contentLengthValue = null;
    if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
      contentLengthValue = "0";
    }
    if (request.body != null) {
      const totalBytes = getTotalBytes(request);
      if (typeof totalBytes === "number") {
        contentLengthValue = String(totalBytes);
      }
    }
    if (contentLengthValue) {
      headers.set("Content-Length", contentLengthValue);
    }
    if (!headers.has("User-Agent")) {
      headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
    }
    if (request.compress && !headers.has("Accept-Encoding")) {
      headers.set("Accept-Encoding", "gzip,deflate");
    }
    let agent = request.agent;
    if (typeof agent === "function") {
      agent = agent(parsedURL);
    }
    return Object.assign({}, parsedURL, {
      method: request.method,
      headers: exportNodeCompatibleHeaders(headers),
      agent
    });
  };
  var AbortError = function(message) {
    Error.call(this, message);
    this.type = "aborted";
    this.message = message;
    Error.captureStackTrace(this, this.constructor);
  };
  var fetch2 = function(url, opts) {
    if (!fetch2.Promise) {
      throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
    }
    Body.Promise = fetch2.Promise;
    return new fetch2.Promise(function(resolve, reject) {
      const request = new Request2(url, opts);
      const options2 = getNodeRequestOptions(request);
      const send = (options2.protocol === "https:" ? https : http).request;
      const signal = request.signal;
      let response = null;
      const abort = function abort() {
        let error = new AbortError("The user aborted a request.");
        reject(error);
        if (request.body && request.body instanceof Stream.Readable) {
          destroyStream(request.body, error);
        }
        if (!response || !response.body)
          return;
        response.body.emit("error", error);
      };
      if (signal && signal.aborted) {
        abort();
        return;
      }
      const abortAndFinalize = function abortAndFinalize() {
        abort();
        finalize();
      };
      const req = send(options2);
      let reqTimeout;
      if (signal) {
        signal.addEventListener("abort", abortAndFinalize);
      }
      function finalize() {
        req.abort();
        if (signal)
          signal.removeEventListener("abort", abortAndFinalize);
        clearTimeout(reqTimeout);
      }
      if (request.timeout) {
        req.once("socket", function(socket) {
          reqTimeout = setTimeout(function() {
            reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
            finalize();
          }, request.timeout);
        });
      }
      req.on("error", function(err) {
        reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
        if (response && response.body) {
          destroyStream(response.body, err);
        }
        finalize();
      });
      fixResponseChunkedTransferBadEnding(req, function(err) {
        if (signal && signal.aborted) {
          return;
        }
        if (response && response.body) {
          destroyStream(response.body, err);
        }
      });
      if (parseInt(process.version.substring(1)) < 14) {
        req.on("socket", function(s) {
          s.addListener("close", function(hadError) {
            const hasDataListener = s.listenerCount("data") > 0;
            if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {
              const err = new Error("Premature close");
              err.code = "ERR_STREAM_PREMATURE_CLOSE";
              response.body.emit("error", err);
            }
          });
        });
      }
      req.on("response", function(res) {
        clearTimeout(reqTimeout);
        const headers = createHeadersLenient(res.headers);
        if (fetch2.isRedirect(res.statusCode)) {
          const location = headers.get("Location");
          let locationURL = null;
          try {
            locationURL = location === null ? null : new URL$1(location, request.url).toString();
          } catch (err) {
            if (request.redirect !== "manual") {
              reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
              finalize();
              return;
            }
          }
          switch (request.redirect) {
            case "error":
              reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
              finalize();
              return;
            case "manual":
              if (locationURL !== null) {
                try {
                  headers.set("Location", locationURL);
                } catch (err) {
                  reject(err);
                }
              }
              break;
            case "follow":
              if (locationURL === null) {
                break;
              }
              if (request.counter >= request.follow) {
                reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                finalize();
                return;
              }
              const requestOpts = {
                headers: new Headers2(request.headers),
                follow: request.follow,
                counter: request.counter + 1,
                agent: request.agent,
                compress: request.compress,
                method: request.method,
                body: request.body,
                signal: request.signal,
                timeout: request.timeout,
                size: request.size
              };
              if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {
                for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                  requestOpts.headers.delete(name);
                }
              }
              if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                finalize();
                return;
              }
              if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
                requestOpts.method = "GET";
                requestOpts.body = undefined;
                requestOpts.headers.delete("content-length");
              }
              resolve(fetch2(new Request2(locationURL, requestOpts)));
              finalize();
              return;
          }
        }
        res.once("end", function() {
          if (signal)
            signal.removeEventListener("abort", abortAndFinalize);
        });
        let body = res.pipe(new PassThrough$1);
        const response_options = {
          url: request.url,
          status: res.statusCode,
          statusText: res.statusMessage,
          headers,
          size: request.size,
          timeout: request.timeout,
          counter: request.counter
        };
        const codings = headers.get("Content-Encoding");
        if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
          response = new Response2(body, response_options);
          resolve(response);
          return;
        }
        const zlibOptions = {
          flush: zlib.Z_SYNC_FLUSH,
          finishFlush: zlib.Z_SYNC_FLUSH
        };
        if (codings == "gzip" || codings == "x-gzip") {
          body = body.pipe(zlib.createGunzip(zlibOptions));
          response = new Response2(body, response_options);
          resolve(response);
          return;
        }
        if (codings == "deflate" || codings == "x-deflate") {
          const raw = res.pipe(new PassThrough$1);
          raw.once("data", function(chunk) {
            if ((chunk[0] & 15) === 8) {
              body = body.pipe(zlib.createInflate());
            } else {
              body = body.pipe(zlib.createInflateRaw());
            }
            response = new Response2(body, response_options);
            resolve(response);
          });
          raw.on("end", function() {
            if (!response) {
              response = new Response2(body, response_options);
              resolve(response);
            }
          });
          return;
        }
        if (codings == "br" && typeof zlib.createBrotliDecompress === "function") {
          body = body.pipe(zlib.createBrotliDecompress());
          response = new Response2(body, response_options);
          resolve(response);
          return;
        }
        response = new Response2(body, response_options);
        resolve(response);
      });
      writeToStream(req, request);
    });
  };
  var fixResponseChunkedTransferBadEnding = function(request, errorCallback) {
    let socket;
    request.on("socket", function(s) {
      socket = s;
    });
    request.on("response", function(response) {
      const headers = response.headers;
      if (headers["transfer-encoding"] === "chunked" && !headers["content-length"]) {
        response.once("close", function(hadError) {
          const hasDataListener = socket && socket.listenerCount("data") > 0;
          if (hasDataListener && !hadError) {
            const err = new Error("Premature close");
            err.code = "ERR_STREAM_PREMATURE_CLOSE";
            errorCallback(err);
          }
        });
      }
    });
  };
  var destroyStream = function(stream, err) {
    if (stream.destroy) {
      stream.destroy(err);
    } else {
      stream.emit("error", err);
      stream.end();
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Stream = _interopDefault(__require("stream"));
  var http = _interopDefault(__require("http"));
  var Url = _interopDefault(__require("url"));
  var whatwgUrl = _interopDefault(require_public_api());
  var https = _interopDefault(__require("https"));
  var zlib = _interopDefault(__require("zlib"));
  var Readable = Stream.Readable;
  var BUFFER = Symbol("buffer");
  var TYPE = Symbol("type");

  class Blob2 {
    constructor() {
      this[TYPE] = "";
      const blobParts = arguments[0];
      const options2 = arguments[1];
      const buffers = [];
      let size = 0;
      if (blobParts) {
        const a = blobParts;
        const length = Number(a.length);
        for (let i = 0;i < length; i++) {
          const element = a[i];
          let buffer;
          if (element instanceof Buffer) {
            buffer = element;
          } else if (ArrayBuffer.isView(element)) {
            buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
          } else if (element instanceof ArrayBuffer) {
            buffer = Buffer.from(element);
          } else if (element instanceof Blob2) {
            buffer = element[BUFFER];
          } else {
            buffer = Buffer.from(typeof element === "string" ? element : String(element));
          }
          size += buffer.length;
          buffers.push(buffer);
        }
      }
      this[BUFFER] = Buffer.concat(buffers);
      let type = options2 && options2.type !== undefined && String(options2.type).toLowerCase();
      if (type && !/[^\u0020-\u007E]/.test(type)) {
        this[TYPE] = type;
      }
    }
    get size() {
      return this[BUFFER].length;
    }
    get type() {
      return this[TYPE];
    }
    text() {
      return Promise.resolve(this[BUFFER].toString());
    }
    arrayBuffer() {
      const buf = this[BUFFER];
      const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
      return Promise.resolve(ab);
    }
    stream() {
      const readable = new Readable;
      readable._read = function() {
      };
      readable.push(this[BUFFER]);
      readable.push(null);
      return readable;
    }
    toString() {
      return "[object Blob]";
    }
    slice() {
      const size = this.size;
      const start = arguments[0];
      const end = arguments[1];
      let relativeStart, relativeEnd;
      if (start === undefined) {
        relativeStart = 0;
      } else if (start < 0) {
        relativeStart = Math.max(size + start, 0);
      } else {
        relativeStart = Math.min(start, size);
      }
      if (end === undefined) {
        relativeEnd = size;
      } else if (end < 0) {
        relativeEnd = Math.max(size + end, 0);
      } else {
        relativeEnd = Math.min(end, size);
      }
      const span = Math.max(relativeEnd - relativeStart, 0);
      const buffer = this[BUFFER];
      const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
      const blob = new Blob2([], { type: arguments[2] });
      blob[BUFFER] = slicedBuffer;
      return blob;
    }
  }
  Object.defineProperties(Blob2.prototype, {
    size: { enumerable: true },
    type: { enumerable: true },
    slice: { enumerable: true }
  });
  Object.defineProperty(Blob2.prototype, Symbol.toStringTag, {
    value: "Blob",
    writable: false,
    enumerable: false,
    configurable: true
  });
  FetchError.prototype = Object.create(Error.prototype);
  FetchError.prototype.constructor = FetchError;
  FetchError.prototype.name = "FetchError";
  var convert;
  try {
    convert = (()=>{ throw new Error(`Cannot require module "encoding"`);})().convert;
  } catch (e) {
  }
  var INTERNALS = Symbol("Body internals");
  var PassThrough = Stream.PassThrough;
  Body.prototype = {
    get body() {
      return this[INTERNALS].body;
    },
    get bodyUsed() {
      return this[INTERNALS].disturbed;
    },
    arrayBuffer() {
      return consumeBody.call(this).then(function(buf) {
        return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
      });
    },
    blob() {
      let ct = this.headers && this.headers.get("content-type") || "";
      return consumeBody.call(this).then(function(buf) {
        return Object.assign(new Blob2([], {
          type: ct.toLowerCase()
        }), {
          [BUFFER]: buf
        });
      });
    },
    json() {
      var _this2 = this;
      return consumeBody.call(this).then(function(buffer) {
        try {
          return JSON.parse(buffer.toString());
        } catch (err) {
          return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
        }
      });
    },
    text() {
      return consumeBody.call(this).then(function(buffer) {
        return buffer.toString();
      });
    },
    buffer() {
      return consumeBody.call(this);
    },
    textConverted() {
      var _this3 = this;
      return consumeBody.call(this).then(function(buffer) {
        return convertBody(buffer, _this3.headers);
      });
    }
  };
  Object.defineProperties(Body.prototype, {
    body: { enumerable: true },
    bodyUsed: { enumerable: true },
    arrayBuffer: { enumerable: true },
    blob: { enumerable: true },
    json: { enumerable: true },
    text: { enumerable: true }
  });
  Body.mixIn = function(proto) {
    for (const name of Object.getOwnPropertyNames(Body.prototype)) {
      if (!(name in proto)) {
        const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
        Object.defineProperty(proto, name, desc);
      }
    }
  };
  Body.Promise = global.Promise;
  var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
  var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
  var MAP = Symbol("map");

  class Headers2 {
    constructor() {
      let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
      this[MAP] = Object.create(null);
      if (init instanceof Headers2) {
        const rawHeaders = init.raw();
        const headerNames = Object.keys(rawHeaders);
        for (const headerName of headerNames) {
          for (const value of rawHeaders[headerName]) {
            this.append(headerName, value);
          }
        }
        return;
      }
      if (init == null)
        ;
      else if (typeof init === "object") {
        const method = init[Symbol.iterator];
        if (method != null) {
          if (typeof method !== "function") {
            throw new TypeError("Header pairs must be iterable");
          }
          const pairs = [];
          for (const pair of init) {
            if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
              throw new TypeError("Each header pair must be iterable");
            }
            pairs.push(Array.from(pair));
          }
          for (const pair of pairs) {
            if (pair.length !== 2) {
              throw new TypeError("Each header pair must be a name/value tuple");
            }
            this.append(pair[0], pair[1]);
          }
        } else {
          for (const key of Object.keys(init)) {
            const value = init[key];
            this.append(key, value);
          }
        }
      } else {
        throw new TypeError("Provided initializer must be an object");
      }
    }
    get(name) {
      name = `${name}`;
      validateName(name);
      const key = find(this[MAP], name);
      if (key === undefined) {
        return null;
      }
      return this[MAP][key].join(", ");
    }
    forEach(callback) {
      let thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      let pairs = getHeaders(this);
      let i = 0;
      while (i < pairs.length) {
        var _pairs$i = pairs[i];
        const name = _pairs$i[0], value = _pairs$i[1];
        callback.call(thisArg, value, name, this);
        pairs = getHeaders(this);
        i++;
      }
    }
    set(name, value) {
      name = `${name}`;
      value = `${value}`;
      validateName(name);
      validateValue(value);
      const key = find(this[MAP], name);
      this[MAP][key !== undefined ? key : name] = [value];
    }
    append(name, value) {
      name = `${name}`;
      value = `${value}`;
      validateName(name);
      validateValue(value);
      const key = find(this[MAP], name);
      if (key !== undefined) {
        this[MAP][key].push(value);
      } else {
        this[MAP][name] = [value];
      }
    }
    has(name) {
      name = `${name}`;
      validateName(name);
      return find(this[MAP], name) !== undefined;
    }
    delete(name) {
      name = `${name}`;
      validateName(name);
      const key = find(this[MAP], name);
      if (key !== undefined) {
        delete this[MAP][key];
      }
    }
    raw() {
      return this[MAP];
    }
    keys() {
      return createHeadersIterator(this, "key");
    }
    values() {
      return createHeadersIterator(this, "value");
    }
    [Symbol.iterator]() {
      return createHeadersIterator(this, "key+value");
    }
  }
  Headers2.prototype.entries = Headers2.prototype[Symbol.iterator];
  Object.defineProperty(Headers2.prototype, Symbol.toStringTag, {
    value: "Headers",
    writable: false,
    enumerable: false,
    configurable: true
  });
  Object.defineProperties(Headers2.prototype, {
    get: { enumerable: true },
    forEach: { enumerable: true },
    set: { enumerable: true },
    append: { enumerable: true },
    has: { enumerable: true },
    delete: { enumerable: true },
    keys: { enumerable: true },
    values: { enumerable: true },
    entries: { enumerable: true }
  });
  var INTERNAL = Symbol("internal");
  var HeadersIteratorPrototype = Object.setPrototypeOf({
    next() {
      if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
        throw new TypeError("Value of `this` is not a HeadersIterator");
      }
      var _INTERNAL = this[INTERNAL];
      const { target, kind: kind2, index } = _INTERNAL;
      const values = getHeaders(target, kind2);
      const len = values.length;
      if (index >= len) {
        return {
          value: undefined,
          done: true
        };
      }
      this[INTERNAL].index = index + 1;
      return {
        value: values[index],
        done: false
      };
    }
  }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
  Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
    value: "HeadersIterator",
    writable: false,
    enumerable: false,
    configurable: true
  });
  var INTERNALS$1 = Symbol("Response internals");
  var STATUS_CODES = http.STATUS_CODES;

  class Response2 {
    constructor() {
      let body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      Body.call(this, body, opts);
      const status = opts.status || 200;
      const headers = new Headers2(opts.headers);
      if (body != null && !headers.has("Content-Type")) {
        const contentType = extractContentType(body);
        if (contentType) {
          headers.append("Content-Type", contentType);
        }
      }
      this[INTERNALS$1] = {
        url: opts.url,
        status,
        statusText: opts.statusText || STATUS_CODES[status],
        headers,
        counter: opts.counter
      };
    }
    get url() {
      return this[INTERNALS$1].url || "";
    }
    get status() {
      return this[INTERNALS$1].status;
    }
    get ok() {
      return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
    }
    get redirected() {
      return this[INTERNALS$1].counter > 0;
    }
    get statusText() {
      return this[INTERNALS$1].statusText;
    }
    get headers() {
      return this[INTERNALS$1].headers;
    }
    clone() {
      return new Response2(clone(this), {
        url: this.url,
        status: this.status,
        statusText: this.statusText,
        headers: this.headers,
        ok: this.ok,
        redirected: this.redirected
      });
    }
  }
  Body.mixIn(Response2.prototype);
  Object.defineProperties(Response2.prototype, {
    url: { enumerable: true },
    status: { enumerable: true },
    ok: { enumerable: true },
    redirected: { enumerable: true },
    statusText: { enumerable: true },
    headers: { enumerable: true },
    clone: { enumerable: true }
  });
  Object.defineProperty(Response2.prototype, Symbol.toStringTag, {
    value: "Response",
    writable: false,
    enumerable: false,
    configurable: true
  });
  var INTERNALS$2 = Symbol("Request internals");
  var URL2 = Url.URL || whatwgUrl.URL;
  var parse_url = Url.parse;
  var format_url = Url.format;
  var streamDestructionSupported = "destroy" in Stream.Readable.prototype;

  class Request2 {
    constructor(input) {
      let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      let parsedURL;
      if (!isRequest(input)) {
        if (input && input.href) {
          parsedURL = parseURL(input.href);
        } else {
          parsedURL = parseURL(`${input}`);
        }
        input = {};
      } else {
        parsedURL = parseURL(input.url);
      }
      let method = init.method || input.method || "GET";
      method = method.toUpperCase();
      if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
        throw new TypeError("Request with GET/HEAD method cannot have body");
      }
      let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
      Body.call(this, inputBody, {
        timeout: init.timeout || input.timeout || 0,
        size: init.size || input.size || 0
      });
      const headers = new Headers2(init.headers || input.headers || {});
      if (inputBody != null && !headers.has("Content-Type")) {
        const contentType = extractContentType(inputBody);
        if (contentType) {
          headers.append("Content-Type", contentType);
        }
      }
      let signal = isRequest(input) ? input.signal : null;
      if ("signal" in init)
        signal = init.signal;
      if (signal != null && !isAbortSignal(signal)) {
        throw new TypeError("Expected signal to be an instanceof AbortSignal");
      }
      this[INTERNALS$2] = {
        method,
        redirect: init.redirect || input.redirect || "follow",
        headers,
        parsedURL,
        signal
      };
      this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;
      this.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;
      this.counter = init.counter || input.counter || 0;
      this.agent = init.agent || input.agent;
    }
    get method() {
      return this[INTERNALS$2].method;
    }
    get url() {
      return format_url(this[INTERNALS$2].parsedURL);
    }
    get headers() {
      return this[INTERNALS$2].headers;
    }
    get redirect() {
      return this[INTERNALS$2].redirect;
    }
    get signal() {
      return this[INTERNALS$2].signal;
    }
    clone() {
      return new Request2(this);
    }
  }
  Body.mixIn(Request2.prototype);
  Object.defineProperty(Request2.prototype, Symbol.toStringTag, {
    value: "Request",
    writable: false,
    enumerable: false,
    configurable: true
  });
  Object.defineProperties(Request2.prototype, {
    method: { enumerable: true },
    url: { enumerable: true },
    headers: { enumerable: true },
    redirect: { enumerable: true },
    clone: { enumerable: true },
    signal: { enumerable: true }
  });
  AbortError.prototype = Object.create(Error.prototype);
  AbortError.prototype.constructor = AbortError;
  AbortError.prototype.name = "AbortError";
  var URL$1 = Url.URL || whatwgUrl.URL;
  var PassThrough$1 = Stream.PassThrough;
  var isDomainOrSubdomain = function isDomainOrSubdomain(destination, original) {
    const orig = new URL$1(original).hostname;
    const dest = new URL$1(destination).hostname;
    return orig === dest || orig[orig.length - dest.length - 1] === "." && orig.endsWith(dest);
  };
  var isSameProtocol = function isSameProtocol(destination, original) {
    const orig = new URL$1(original).protocol;
    const dest = new URL$1(destination).protocol;
    return orig === dest;
  };
  fetch2.isRedirect = function(code) {
    return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
  };
  fetch2.Promise = global.Promise;
  module.exports = exports = fetch2;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = exports;
  exports.Headers = Headers2;
  exports.Request = Request2;
  exports.Response = Response2;
  exports.FetchError = FetchError;
  exports.AbortError = AbortError;
});

// node_modules/formdata-node/node_modules/web-streams-polyfill/dist/ponyfill.mjs
class S {
  constructor() {
    this._cursor = 0, this._size = 0, this._front = { _elements: [], _next: undefined }, this._back = this._front, this._cursor = 0, this._size = 0;
  }
  get length() {
    return this._size;
  }
  push(e2) {
    const t2 = this._back;
    let r2 = t2;
    t2._elements.length === 16383 && (r2 = { _elements: [], _next: undefined }), t2._elements.push(e2), r2 !== t2 && (this._back = r2, t2._next = r2), ++this._size;
  }
  shift() {
    const e2 = this._front;
    let t2 = e2;
    const r2 = this._cursor;
    let o2 = r2 + 1;
    const n2 = e2._elements, a2 = n2[r2];
    return o2 === 16384 && (t2 = e2._next, o2 = 0), --this._size, this._cursor = o2, e2 !== t2 && (this._front = t2), n2[r2] = undefined, a2;
  }
  forEach(e2) {
    let t2 = this._cursor, r2 = this._front, o2 = r2._elements;
    for (;!(t2 === o2.length && r2._next === undefined || t2 === o2.length && (r2 = r2._next, o2 = r2._elements, t2 = 0, o2.length === 0)); )
      e2(o2[t2]), ++t2;
  }
  peek() {
    const e2 = this._front, t2 = this._cursor;
    return e2._elements[t2];
  }
}

class ReadableStreamDefaultReader {
  constructor(e2) {
    if ($(e2, 1, "ReadableStreamDefaultReader"), V(e2, "First parameter"), Ut(e2))
      throw new TypeError("This stream has already been locked for exclusive reading by another reader");
    E(this, e2), this._readRequests = new S;
  }
  get closed() {
    return K(this) ? this._closedPromise : d(ee("closed"));
  }
  cancel(e2) {
    return K(this) ? this._ownerReadableStream === undefined ? d(k("cancel")) : P(this, e2) : d(ee("cancel"));
  }
  read() {
    if (!K(this))
      return d(ee("read"));
    if (this._ownerReadableStream === undefined)
      return d(k("read from"));
    let e2, t2;
    const r2 = u((r3, o2) => {
      e2 = r3, t2 = o2;
    });
    return function(e3, t3) {
      const r3 = e3._ownerReadableStream;
      r3._disturbed = true, r3._state === "closed" ? t3._closeSteps() : r3._state === "errored" ? t3._errorSteps(r3._storedError) : r3._readableStreamController[q](t3);
    }(this, { _chunkSteps: (t3) => e2({ value: t3, done: false }), _closeSteps: () => e2({ value: undefined, done: true }), _errorSteps: (e3) => t2(e3) }), r2;
  }
  releaseLock() {
    if (!K(this))
      throw ee("releaseLock");
    this._ownerReadableStream !== undefined && function(e2) {
      W(e2);
      const t2 = new TypeError("Reader was released");
      Z(e2, t2);
    }(this);
  }
}

class te {
  constructor(e2, t2) {
    this._ongoingPromise = undefined, this._isFinished = false, this._reader = e2, this._preventCancel = t2;
  }
  next() {
    const e2 = () => this._nextSteps();
    return this._ongoingPromise = this._ongoingPromise ? p(this._ongoingPromise, e2, e2) : e2(), this._ongoingPromise;
  }
  return(e2) {
    const t2 = () => this._returnSteps(e2);
    return this._ongoingPromise ? p(this._ongoingPromise, t2, t2) : t2();
  }
  _nextSteps() {
    if (this._isFinished)
      return Promise.resolve({ value: undefined, done: true });
    const e2 = this._reader;
    return e2 === undefined ? d(k("iterate")) : f(e2.read(), (e3) => {
      var t2;
      return this._ongoingPromise = undefined, e3.done && (this._isFinished = true, (t2 = this._reader) === null || t2 === undefined || t2.releaseLock(), this._reader = undefined), e3;
    }, (e3) => {
      var t2;
      throw this._ongoingPromise = undefined, this._isFinished = true, (t2 = this._reader) === null || t2 === undefined || t2.releaseLock(), this._reader = undefined, e3;
    });
  }
  _returnSteps(e2) {
    if (this._isFinished)
      return Promise.resolve({ value: e2, done: true });
    this._isFinished = true;
    const t2 = this._reader;
    if (t2 === undefined)
      return d(k("finish iterating"));
    if (this._reader = undefined, !this._preventCancel) {
      const r2 = t2.cancel(e2);
      return t2.releaseLock(), p(r2, () => ({ value: e2, done: true }));
    }
    return t2.releaseLock(), c({ value: e2, done: true });
  }
}

class ReadableStreamBYOBRequest {
  constructor() {
    throw new TypeError("Illegal constructor");
  }
  get view() {
    if (!fe(this))
      throw Be("view");
    return this._view;
  }
  respond(e2) {
    if (!fe(this))
      throw Be("respond");
    if ($(e2, 1, "respond"), e2 = N(e2, "First parameter"), this._associatedReadableByteStreamController === undefined)
      throw new TypeError("This BYOB request has been invalidated");
    this._view.buffer, function(e3, t2) {
      const r2 = e3._pendingPullIntos.peek();
      if (e3._controlledReadableByteStream._state === "closed") {
        if (t2 !== 0)
          throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
      } else {
        if (t2 === 0)
          throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
        if (r2.bytesFilled + t2 > r2.byteLength)
          throw new RangeError("bytesWritten out of range");
      }
      r2.buffer = r2.buffer, qe(e3, t2);
    }(this._associatedReadableByteStreamController, e2);
  }
  respondWithNewView(e2) {
    if (!fe(this))
      throw Be("respondWithNewView");
    if ($(e2, 1, "respondWithNewView"), !ArrayBuffer.isView(e2))
      throw new TypeError("You can only respond with array buffer views");
    if (this._associatedReadableByteStreamController === undefined)
      throw new TypeError("This BYOB request has been invalidated");
    e2.buffer, function(e3, t2) {
      const r2 = e3._pendingPullIntos.peek();
      if (e3._controlledReadableByteStream._state === "closed") {
        if (t2.byteLength !== 0)
          throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
      } else if (t2.byteLength === 0)
        throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
      if (r2.byteOffset + r2.bytesFilled !== t2.byteOffset)
        throw new RangeError("The region specified by view does not match byobRequest");
      if (r2.bufferByteLength !== t2.buffer.byteLength)
        throw new RangeError("The buffer of view has different capacity than byobRequest");
      if (r2.bytesFilled + t2.byteLength > r2.byteLength)
        throw new RangeError("The region specified by view is larger than byobRequest");
      const o2 = t2.byteLength;
      r2.buffer = t2.buffer, qe(e3, o2);
    }(this._associatedReadableByteStreamController, e2);
  }
}

class ReadableByteStreamController {
  constructor() {
    throw new TypeError("Illegal constructor");
  }
  get byobRequest() {
    if (!de(this))
      throw Ae("byobRequest");
    return function(e2) {
      if (e2._byobRequest === null && e2._pendingPullIntos.length > 0) {
        const t2 = e2._pendingPullIntos.peek(), r2 = new Uint8Array(t2.buffer, t2.byteOffset + t2.bytesFilled, t2.byteLength - t2.bytesFilled), o2 = Object.create(ReadableStreamBYOBRequest.prototype);
        (function(e3, t3, r3) {
          e3._associatedReadableByteStreamController = t3, e3._view = r3;
        })(o2, e2, r2), e2._byobRequest = o2;
      }
      return e2._byobRequest;
    }(this);
  }
  get desiredSize() {
    if (!de(this))
      throw Ae("desiredSize");
    return ke(this);
  }
  close() {
    if (!de(this))
      throw Ae("close");
    if (this._closeRequested)
      throw new TypeError("The stream has already been closed; do not close it again!");
    const e2 = this._controlledReadableByteStream._state;
    if (e2 !== "readable")
      throw new TypeError(`The stream (in ${e2} state) is not in the readable state and cannot be closed`);
    (function(e3) {
      const t2 = e3._controlledReadableByteStream;
      if (e3._closeRequested || t2._state !== "readable")
        return;
      if (e3._queueTotalSize > 0)
        return void (e3._closeRequested = true);
      if (e3._pendingPullIntos.length > 0) {
        if (e3._pendingPullIntos.peek().bytesFilled > 0) {
          const t3 = new TypeError("Insufficient bytes to fill elements in the given buffer");
          throw Pe(e3, t3), t3;
        }
      }
      Ee(e3), Xt(t2);
    })(this);
  }
  enqueue(e2) {
    if (!de(this))
      throw Ae("enqueue");
    if ($(e2, 1, "enqueue"), !ArrayBuffer.isView(e2))
      throw new TypeError("chunk must be an array buffer view");
    if (e2.byteLength === 0)
      throw new TypeError("chunk must have non-zero byteLength");
    if (e2.buffer.byteLength === 0)
      throw new TypeError("chunk's buffer must have non-zero byteLength");
    if (this._closeRequested)
      throw new TypeError("stream is closed or draining");
    const t2 = this._controlledReadableByteStream._state;
    if (t2 !== "readable")
      throw new TypeError(`The stream (in ${t2} state) is not in the readable state and cannot be enqueued to`);
    (function(e3, t3) {
      const r2 = e3._controlledReadableByteStream;
      if (e3._closeRequested || r2._state !== "readable")
        return;
      const { buffer: o2, byteOffset: n2, byteLength: a2 } = t3, i2 = o2;
      if (e3._pendingPullIntos.length > 0) {
        const t4 = e3._pendingPullIntos.peek();
        t4.buffer, Re(e3), t4.buffer = t4.buffer, t4.readerType === "none" && ge(e3, t4);
      }
      if (J(r2))
        if (function(e4) {
          const t4 = e4._controlledReadableByteStream._reader;
          for (;t4._readRequests.length > 0; ) {
            if (e4._queueTotalSize === 0)
              return;
            We(e4, t4._readRequests.shift());
          }
        }(e3), X(r2) === 0)
          me(e3, i2, n2, a2);
        else {
          e3._pendingPullIntos.length > 0 && Ce(e3);
          G(r2, new Uint8Array(i2, n2, a2), false);
        }
      else
        Le(r2) ? (me(e3, i2, n2, a2), Te(e3)) : me(e3, i2, n2, a2);
      be(e3);
    })(this, e2);
  }
  error(e2) {
    if (!de(this))
      throw Ae("error");
    Pe(this, e2);
  }
  [T](e2) {
    he(this), ce(this);
    const t2 = this._cancelAlgorithm(e2);
    return Ee(this), t2;
  }
  [q](e2) {
    const t2 = this._controlledReadableByteStream;
    if (this._queueTotalSize > 0)
      return void We(this, e2);
    const r2 = this._autoAllocateChunkSize;
    if (r2 !== undefined) {
      let t3;
      try {
        t3 = new ArrayBuffer(r2);
      } catch (t4) {
        return void e2._errorSteps(t4);
      }
      const o2 = { buffer: t3, bufferByteLength: r2, byteOffset: 0, byteLength: r2, bytesFilled: 0, elementSize: 1, viewConstructor: Uint8Array, readerType: "default" };
      this._pendingPullIntos.push(o2);
    }
    U(t2, e2), be(this);
  }
  [C]() {
    if (this._pendingPullIntos.length > 0) {
      const e2 = this._pendingPullIntos.peek();
      e2.readerType = "none", this._pendingPullIntos = new S, this._pendingPullIntos.push(e2);
    }
  }
}

class ReadableStreamBYOBReader {
  constructor(e2) {
    if ($(e2, 1, "ReadableStreamBYOBReader"), V(e2, "First parameter"), Ut(e2))
      throw new TypeError("This stream has already been locked for exclusive reading by another reader");
    if (!de(e2._readableStreamController))
      throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
    E(this, e2), this._readIntoRequests = new S;
  }
  get closed() {
    return Fe(this) ? this._closedPromise : d(De("closed"));
  }
  cancel(e2) {
    return Fe(this) ? this._ownerReadableStream === undefined ? d(k("cancel")) : P(this, e2) : d(De("cancel"));
  }
  read(e2) {
    if (!Fe(this))
      return d(De("read"));
    if (!ArrayBuffer.isView(e2))
      return d(new TypeError("view must be an array buffer view"));
    if (e2.byteLength === 0)
      return d(new TypeError("view must have non-zero byteLength"));
    if (e2.buffer.byteLength === 0)
      return d(new TypeError("view's buffer must have non-zero byteLength"));
    if (e2.buffer, this._ownerReadableStream === undefined)
      return d(k("read from"));
    let t2, r2;
    const o2 = u((e3, o3) => {
      t2 = e3, r2 = o3;
    });
    return function(e3, t3, r3) {
      const o3 = e3._ownerReadableStream;
      o3._disturbed = true, o3._state === "errored" ? r3._errorSteps(o3._storedError) : function(e4, t4, r4) {
        const o4 = e4._controlledReadableByteStream;
        let n2 = 1;
        t4.constructor !== DataView && (n2 = t4.constructor.BYTES_PER_ELEMENT);
        const { constructor: a2, buffer: i2 } = t4, l2 = { buffer: i2, bufferByteLength: i2.byteLength, byteOffset: t4.byteOffset, byteLength: t4.byteLength, bytesFilled: 0, elementSize: n2, viewConstructor: a2, readerType: "byob" };
        if (e4._pendingPullIntos.length > 0)
          return e4._pendingPullIntos.push(l2), void je(o4, r4);
        if (o4._state !== "closed") {
          if (e4._queueTotalSize > 0) {
            if (we(e4, l2)) {
              const t5 = pe(l2);
              return ve(e4), void r4._chunkSteps(t5);
            }
            if (e4._closeRequested) {
              const t5 = new TypeError("Insufficient bytes to fill elements in the given buffer");
              return Pe(e4, t5), void r4._errorSteps(t5);
            }
          }
          e4._pendingPullIntos.push(l2), je(o4, r4), be(e4);
        } else {
          const e5 = new a2(l2.buffer, l2.byteOffset, 0);
          r4._closeSteps(e5);
        }
      }(o3._readableStreamController, t3, r3);
    }(this, e2, { _chunkSteps: (e3) => t2({ value: e3, done: false }), _closeSteps: (e3) => t2({ value: e3, done: true }), _errorSteps: (e3) => r2(e3) }), o2;
  }
  releaseLock() {
    if (!Fe(this))
      throw De("releaseLock");
    this._ownerReadableStream !== undefined && function(e2) {
      W(e2);
      const t2 = new TypeError("Reader was released");
      Ie(e2, t2);
    }(this);
  }
}

class WritableStream {
  constructor(e2 = {}, t2 = {}) {
    e2 === undefined ? e2 = null : D(e2, "First parameter");
    const r2 = Ye(t2, "Second parameter"), o2 = function(e3, t3) {
      F(e3, t3);
      const r3 = e3 == null ? undefined : e3.abort, o3 = e3 == null ? undefined : e3.close, n3 = e3 == null ? undefined : e3.start, a3 = e3 == null ? undefined : e3.type, i2 = e3 == null ? undefined : e3.write;
      return { abort: r3 === undefined ? undefined : Ne(r3, e3, `${t3} has member 'abort' that`), close: o3 === undefined ? undefined : He(o3, e3, `${t3} has member 'close' that`), start: n3 === undefined ? undefined : xe(n3, e3, `${t3} has member 'start' that`), write: i2 === undefined ? undefined : Ve(i2, e3, `${t3} has member 'write' that`), type: a3 };
    }(e2, "First parameter");
    var n2;
    (n2 = this)._state = "writable", n2._storedError = undefined, n2._writer = undefined, n2._writableStreamController = undefined, n2._writeRequests = new S, n2._inFlightWriteRequest = undefined, n2._closeRequest = undefined, n2._inFlightCloseRequest = undefined, n2._pendingAbortRequest = undefined, n2._backpressure = false;
    if (o2.type !== undefined)
      throw new RangeError("Invalid type is specified");
    const a2 = Me(r2);
    (function(e3, t3, r3, o3) {
      const n3 = Object.create(WritableStreamDefaultController.prototype);
      let a3, i2, l2, s2;
      a3 = t3.start !== undefined ? () => t3.start(n3) : () => {
      };
      i2 = t3.write !== undefined ? (e4) => t3.write(e4, n3) : () => c(undefined);
      l2 = t3.close !== undefined ? () => t3.close() : () => c(undefined);
      s2 = t3.abort !== undefined ? (e4) => t3.abort(e4) : () => c(undefined);
      (function(e4, t4, r4, o4, n4, a4, i3, l3) {
        t4._controlledWritableStream = e4, e4._writableStreamController = t4, t4._queue = undefined, t4._queueTotalSize = undefined, ce(t4), t4._abortReason = undefined, t4._abortController = function() {
          if (Ue)
            return new AbortController;
        }(), t4._started = false, t4._strategySizeAlgorithm = l3, t4._strategyHWM = i3, t4._writeAlgorithm = o4, t4._closeAlgorithm = n4, t4._abortAlgorithm = a4;
        const s3 = bt(t4);
        nt(e4, s3);
        const u2 = r4();
        b(c(u2), () => (t4._started = true, dt(t4), null), (r5) => (t4._started = true, Ze(e4, r5), null));
      })(e3, n3, a3, i2, l2, s2, r3, o3);
    })(this, o2, $e(r2, 1), a2);
  }
  get locked() {
    if (!Ge(this))
      throw _t("locked");
    return Xe(this);
  }
  abort(e2) {
    return Ge(this) ? Xe(this) ? d(new TypeError("Cannot abort a stream that already has a writer")) : Je(this, e2) : d(_t("abort"));
  }
  close() {
    return Ge(this) ? Xe(this) ? d(new TypeError("Cannot close a stream that already has a writer")) : rt(this) ? d(new TypeError("Cannot close an already-closing stream")) : Ke(this) : d(_t("close"));
  }
  getWriter() {
    if (!Ge(this))
      throw _t("getWriter");
    return new WritableStreamDefaultWriter(this);
  }
}

class WritableStreamDefaultWriter {
  constructor(e2) {
    if ($(e2, 1, "WritableStreamDefaultWriter"), function(e3, t3) {
      if (!Ge(e3))
        throw new TypeError(`${t3} is not a WritableStream.`);
    }(e2, "First parameter"), Xe(e2))
      throw new TypeError("This stream has already been locked for exclusive writing by another writer");
    this._ownerWritableStream = e2, e2._writer = this;
    const t2 = e2._state;
    if (t2 === "writable")
      !rt(e2) && e2._backpressure ? Rt(this) : qt(this), gt(this);
    else if (t2 === "erroring")
      Tt(this, e2._storedError), gt(this);
    else if (t2 === "closed")
      qt(this), gt(r2 = this), vt(r2);
    else {
      const t3 = e2._storedError;
      Tt(this, t3), wt(this, t3);
    }
    var r2;
  }
  get closed() {
    return at(this) ? this._closedPromise : d(mt("closed"));
  }
  get desiredSize() {
    if (!at(this))
      throw mt("desiredSize");
    if (this._ownerWritableStream === undefined)
      throw yt("desiredSize");
    return function(e2) {
      const t2 = e2._ownerWritableStream, r2 = t2._state;
      if (r2 === "errored" || r2 === "erroring")
        return null;
      if (r2 === "closed")
        return 0;
      return ct(t2._writableStreamController);
    }(this);
  }
  get ready() {
    return at(this) ? this._readyPromise : d(mt("ready"));
  }
  abort(e2) {
    return at(this) ? this._ownerWritableStream === undefined ? d(yt("abort")) : function(e3, t2) {
      return Je(e3._ownerWritableStream, t2);
    }(this, e2) : d(mt("abort"));
  }
  close() {
    if (!at(this))
      return d(mt("close"));
    const e2 = this._ownerWritableStream;
    return e2 === undefined ? d(yt("close")) : rt(e2) ? d(new TypeError("Cannot close an already-closing stream")) : Ke(this._ownerWritableStream);
  }
  releaseLock() {
    if (!at(this))
      throw mt("releaseLock");
    this._ownerWritableStream !== undefined && function(e2) {
      const t2 = e2._ownerWritableStream, r2 = new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");
      it(e2, r2), function(e3, t3) {
        e3._closedPromiseState === "pending" ? St(e3, t3) : function(e4, t4) {
          wt(e4, t4);
        }(e3, t3);
      }(e2, r2), t2._writer = undefined, e2._ownerWritableStream = undefined;
    }(this);
  }
  write(e2) {
    return at(this) ? this._ownerWritableStream === undefined ? d(yt("write to")) : function(e3, t2) {
      const r2 = e3._ownerWritableStream, o2 = r2._writableStreamController, n2 = function(e4, t3) {
        try {
          return e4._strategySizeAlgorithm(t3);
        } catch (t4) {
          return ft(e4, t4), 1;
        }
      }(o2, t2);
      if (r2 !== e3._ownerWritableStream)
        return d(yt("write to"));
      const a2 = r2._state;
      if (a2 === "errored")
        return d(r2._storedError);
      if (rt(r2) || a2 === "closed")
        return d(new TypeError("The stream is closing or closed and cannot be written to"));
      if (a2 === "erroring")
        return d(r2._storedError);
      const i2 = function(e4) {
        return u((t3, r3) => {
          const o3 = { _resolve: t3, _reject: r3 };
          e4._writeRequests.push(o3);
        });
      }(r2);
      return function(e4, t3, r3) {
        try {
          ue(e4, t3, r3);
        } catch (t4) {
          return void ft(e4, t4);
        }
        const o3 = e4._controlledWritableStream;
        if (!rt(o3) && o3._state === "writable") {
          nt(o3, bt(e4));
        }
        dt(e4);
      }(o2, t2, n2), i2;
    }(this, e2) : d(mt("write"));
  }
}

class WritableStreamDefaultController {
  constructor() {
    throw new TypeError("Illegal constructor");
  }
  get abortReason() {
    if (!st(this))
      throw pt("abortReason");
    return this._abortReason;
  }
  get signal() {
    if (!st(this))
      throw pt("signal");
    if (this._abortController === undefined)
      throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
    return this._abortController.signal;
  }
  error(e2) {
    if (!st(this))
      throw pt("error");
    this._controlledWritableStream._state === "writable" && ht(this, e2);
  }
  [v](e2) {
    const t2 = this._abortAlgorithm(e2);
    return ut(this), t2;
  }
  [R]() {
    ce(this);
  }
}

class ReadableStreamDefaultController {
  constructor() {
    throw new TypeError("Illegal constructor");
  }
  get desiredSize() {
    if (!Bt(this))
      throw Dt("desiredSize");
    return Lt(this);
  }
  close() {
    if (!Bt(this))
      throw Dt("close");
    if (!Ft(this))
      throw new TypeError("The stream is not in a state that permits close");
    (function(e2) {
      if (!Ft(e2))
        return;
      const t2 = e2._controlledReadableStream;
      e2._closeRequested = true, e2._queue.length === 0 && (jt(e2), Xt(t2));
    })(this);
  }
  enqueue(e2) {
    if (!Bt(this))
      throw Dt("enqueue");
    if (!Ft(this))
      throw new TypeError("The stream is not in a state that permits enqueue");
    return function(e3, t2) {
      if (!Ft(e3))
        return;
      const r2 = e3._controlledReadableStream;
      if (Ut(r2) && X(r2) > 0)
        G(r2, t2, false);
      else {
        let r3;
        try {
          r3 = e3._strategySizeAlgorithm(t2);
        } catch (t3) {
          throw zt(e3, t3), t3;
        }
        try {
          ue(e3, t2, r3);
        } catch (t3) {
          throw zt(e3, t3), t3;
        }
      }
      At(e3);
    }(this, e2);
  }
  error(e2) {
    if (!Bt(this))
      throw Dt("error");
    zt(this, e2);
  }
  [T](e2) {
    ce(this);
    const t2 = this._cancelAlgorithm(e2);
    return jt(this), t2;
  }
  [q](e2) {
    const t2 = this._controlledReadableStream;
    if (this._queue.length > 0) {
      const r2 = se(this);
      this._closeRequested && this._queue.length === 0 ? (jt(this), Xt(t2)) : At(this), e2._chunkSteps(r2);
    } else
      U(t2, e2), At(this);
  }
  [C]() {
  }
}

class ReadableStream2 {
  constructor(e2 = {}, t2 = {}) {
    e2 === undefined ? e2 = null : D(e2, "First parameter");
    const r2 = Ye(t2, "Second parameter"), o2 = function(e3, t3) {
      F(e3, t3);
      const r3 = e3, o3 = r3 == null ? undefined : r3.autoAllocateChunkSize, n3 = r3 == null ? undefined : r3.cancel, a2 = r3 == null ? undefined : r3.pull, i2 = r3 == null ? undefined : r3.start, l2 = r3 == null ? undefined : r3.type;
      return { autoAllocateChunkSize: o3 === undefined ? undefined : N(o3, `${t3} has member 'autoAllocateChunkSize' that`), cancel: n3 === undefined ? undefined : $t(n3, r3, `${t3} has member 'cancel' that`), pull: a2 === undefined ? undefined : Mt(a2, r3, `${t3} has member 'pull' that`), start: i2 === undefined ? undefined : Yt(i2, r3, `${t3} has member 'start' that`), type: l2 === undefined ? undefined : Qt(l2, `${t3} has member 'type' that`) };
    }(e2, "First parameter");
    var n2;
    if ((n2 = this)._state = "readable", n2._reader = undefined, n2._storedError = undefined, n2._disturbed = false, o2.type === "bytes") {
      if (r2.size !== undefined)
        throw new RangeError("The strategy for a byte stream cannot have a size function");
      Oe(this, o2, $e(r2, 0));
    } else {
      const e3 = Me(r2);
      It(this, o2, $e(r2, 1), e3);
    }
  }
  get locked() {
    if (!Vt(this))
      throw Kt("locked");
    return Ut(this);
  }
  cancel(e2) {
    return Vt(this) ? Ut(this) ? d(new TypeError("Cannot cancel a stream that already has a reader")) : Gt(this, e2) : d(Kt("cancel"));
  }
  getReader(e2) {
    if (!Vt(this))
      throw Kt("getReader");
    return function(e3, t2) {
      F(e3, t2);
      const r2 = e3 == null ? undefined : e3.mode;
      return { mode: r2 === undefined ? undefined : Nt(r2, `${t2} has member 'mode' that`) };
    }(e2, "First parameter").mode === undefined ? new ReadableStreamDefaultReader(this) : function(e3) {
      return new ReadableStreamBYOBReader(e3);
    }(this);
  }
  pipeThrough(e2, t2 = {}) {
    if (!H(this))
      throw Kt("pipeThrough");
    $(e2, 1, "pipeThrough");
    const r2 = xt(e2, "First parameter"), o2 = Ht(t2, "Second parameter");
    if (this.locked)
      throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
    if (r2.writable.locked)
      throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
    return m(kt(this, r2.writable, o2.preventClose, o2.preventAbort, o2.preventCancel, o2.signal)), r2.readable;
  }
  pipeTo(e2, t2 = {}) {
    if (!H(this))
      return d(Kt("pipeTo"));
    if (e2 === undefined)
      return d("Parameter 1 is required in 'pipeTo'.");
    if (!x(e2))
      return d(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));
    let r2;
    try {
      r2 = Ht(t2, "Second parameter");
    } catch (e3) {
      return d(e3);
    }
    return this.locked ? d(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")) : e2.locked ? d(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")) : kt(this, e2, r2.preventClose, r2.preventAbort, r2.preventCancel, r2.signal);
  }
  tee() {
    if (!H(this))
      throw Kt("tee");
    if (this.locked)
      throw new TypeError("Cannot tee a stream that already has a reader");
    return Ot(this);
  }
  values(e2) {
    if (!H(this))
      throw Kt("values");
    return function(e3, t2) {
      const r2 = e3.getReader(), o2 = new te(r2, t2), n2 = Object.create(re);
      return n2._asyncIteratorImpl = o2, n2;
    }(this, function(e3, t2) {
      F(e3, t2);
      const r2 = e3 == null ? undefined : e3.preventCancel;
      return { preventCancel: Boolean(r2) };
    }(e2, "First parameter").preventCancel);
  }
}

class ByteLengthQueuingStrategy {
  constructor(e2) {
    $(e2, 1, "ByteLengthQueuingStrategy"), e2 = Zt(e2, "First parameter"), this._byteLengthQueuingStrategyHighWaterMark = e2.highWaterMark;
  }
  get highWaterMark() {
    if (!rr(this))
      throw tr("highWaterMark");
    return this._byteLengthQueuingStrategyHighWaterMark;
  }
  get size() {
    if (!rr(this))
      throw tr("size");
    return er;
  }
}

class CountQueuingStrategy {
  constructor(e2) {
    $(e2, 1, "CountQueuingStrategy"), e2 = Zt(e2, "First parameter"), this._countQueuingStrategyHighWaterMark = e2.highWaterMark;
  }
  get highWaterMark() {
    if (!ar(this))
      throw nr("highWaterMark");
    return this._countQueuingStrategyHighWaterMark;
  }
  get size() {
    if (!ar(this))
      throw nr("size");
    return or;
  }
}

class TransformStream {
  constructor(e2 = {}, t2 = {}, r2 = {}) {
    e2 === undefined && (e2 = null);
    const o2 = Ye(t2, "Second parameter"), n2 = Ye(r2, "Third parameter"), a2 = function(e3, t3) {
      F(e3, t3);
      const r3 = e3 == null ? undefined : e3.flush, o3 = e3 == null ? undefined : e3.readableType, n3 = e3 == null ? undefined : e3.start, a3 = e3 == null ? undefined : e3.transform, i3 = e3 == null ? undefined : e3.writableType;
      return { flush: r3 === undefined ? undefined : ir(r3, e3, `${t3} has member 'flush' that`), readableType: o3, start: n3 === undefined ? undefined : lr(n3, e3, `${t3} has member 'start' that`), transform: a3 === undefined ? undefined : sr(a3, e3, `${t3} has member 'transform' that`), writableType: i3 };
    }(e2, "First parameter");
    if (a2.readableType !== undefined)
      throw new RangeError("Invalid readableType specified");
    if (a2.writableType !== undefined)
      throw new RangeError("Invalid writableType specified");
    const i2 = $e(n2, 0), l2 = Me(n2), s2 = $e(o2, 1), f2 = Me(o2);
    let b2;
    (function(e3, t3, r3, o3, n3, a3) {
      function i3() {
        return t3;
      }
      function l3(t4) {
        return function(e4, t5) {
          const r4 = e4._transformStreamController;
          if (e4._backpressure) {
            return p(e4._backpressureChangePromise, () => {
              if ((Ge(e4._writable) ? e4._writable._state : e4._writableState) === "erroring")
                throw Ge(e4._writable) ? e4._writable._storedError : e4._writableStoredError;
              return pr(r4, t5);
            });
          }
          return pr(r4, t5);
        }(e3, t4);
      }
      function s3(t4) {
        return function(e4, t5) {
          return cr(e4, t5), c(undefined);
        }(e3, t4);
      }
      function u2() {
        return function(e4) {
          const t4 = e4._transformStreamController, r4 = t4._flushAlgorithm();
          return hr(t4), p(r4, () => {
            if (e4._readableState === "errored")
              throw e4._readableStoredError;
            gr(e4) && wr(e4);
          }, (t5) => {
            throw cr(e4, t5), e4._readableStoredError;
          });
        }(e3);
      }
      function d2() {
        return function(e4) {
          return fr(e4, false), e4._backpressureChangePromise;
        }(e3);
      }
      function f3(t4) {
        return dr(e3, t4), c(undefined);
      }
      e3._writableState = "writable", e3._writableStoredError = undefined, e3._writableHasInFlightOperation = false, e3._writableStarted = false, e3._writable = function(e4, t4, r4, o4, n4, a4, i4) {
        return new WritableStream({ start(r5) {
          e4._writableController = r5;
          try {
            const t5 = r5.signal;
            t5 !== undefined && t5.addEventListener("abort", () => {
              e4._writableState === "writable" && (e4._writableState = "erroring", t5.reason && (e4._writableStoredError = t5.reason));
            });
          } catch (e5) {
          }
          return p(t4(), () => (e4._writableStarted = true, Cr(e4), null), (t5) => {
            throw e4._writableStarted = true, Rr(e4, t5), t5;
          });
        }, write: (t5) => (function(e5) {
          e5._writableHasInFlightOperation = true;
        }(e4), p(r4(t5), () => (function(e5) {
          e5._writableHasInFlightOperation = false;
        }(e4), Cr(e4), null), (t6) => {
          throw function(e5, t7) {
            e5._writableHasInFlightOperation = false, Rr(e5, t7);
          }(e4, t6), t6;
        })), close: () => (function(e5) {
          e5._writableHasInFlightOperation = true;
        }(e4), p(o4(), () => (function(e5) {
          e5._writableHasInFlightOperation = false;
          e5._writableState === "erroring" && (e5._writableStoredError = undefined);
          e5._writableState = "closed";
        }(e4), null), (t5) => {
          throw function(e5, t6) {
            e5._writableHasInFlightOperation = false, e5._writableState, Rr(e5, t6);
          }(e4, t5), t5;
        })), abort: (t5) => (e4._writableState = "errored", e4._writableStoredError = t5, n4(t5)) }, { highWaterMark: a4, size: i4 });
      }(e3, i3, l3, u2, s3, r3, o3), e3._readableState = "readable", e3._readableStoredError = undefined, e3._readableCloseRequested = false, e3._readablePulling = false, e3._readable = function(e4, t4, r4, o4, n4, a4) {
        return new ReadableStream2({ start: (r5) => (e4._readableController = r5, t4().catch((t5) => {
          Sr(e4, t5);
        })), pull: () => (e4._readablePulling = true, r4().catch((t5) => {
          Sr(e4, t5);
        })), cancel: (t5) => (e4._readableState = "closed", o4(t5)) }, { highWaterMark: n4, size: a4 });
      }(e3, i3, d2, f3, n3, a3), e3._backpressure = undefined, e3._backpressureChangePromise = undefined, e3._backpressureChangePromise_resolve = undefined, fr(e3, true), e3._transformStreamController = undefined;
    })(this, u((e3) => {
      b2 = e3;
    }), s2, f2, i2, l2), function(e3, t3) {
      const r3 = Object.create(TransformStreamDefaultController.prototype);
      let o3, n3;
      o3 = t3.transform !== undefined ? (e4) => t3.transform(e4, r3) : (e4) => {
        try {
          return _r(r3, e4), c(undefined);
        } catch (e5) {
          return d(e5);
        }
      };
      n3 = t3.flush !== undefined ? () => t3.flush(r3) : () => c(undefined);
      (function(e4, t4, r4, o4) {
        t4._controlledTransformStream = e4, e4._transformStreamController = t4, t4._transformAlgorithm = r4, t4._flushAlgorithm = o4;
      })(e3, r3, o3, n3);
    }(this, a2), a2.start !== undefined ? b2(a2.start(this._transformStreamController)) : b2(undefined);
  }
  get readable() {
    if (!ur(this))
      throw yr("readable");
    return this._readable;
  }
  get writable() {
    if (!ur(this))
      throw yr("writable");
    return this._writable;
  }
}

class TransformStreamDefaultController {
  constructor() {
    throw new TypeError("Illegal constructor");
  }
  get desiredSize() {
    if (!br(this))
      throw mr("desiredSize");
    return vr(this._controlledTransformStream);
  }
  enqueue(e2) {
    if (!br(this))
      throw mr("enqueue");
    _r(this, e2);
  }
  error(e2) {
    if (!br(this))
      throw mr("error");
    var t2;
    t2 = e2, cr(this._controlledTransformStream, t2);
  }
  terminate() {
    if (!br(this))
      throw mr("terminate");
    (function(e2) {
      const t2 = e2._controlledTransformStream;
      gr(t2) && wr(t2);
      const r2 = new TypeError("TransformStream terminated");
      dr(t2, r2);
    })(this);
  }
}
var t, r, n, u, c, d, f, b, h, _, p, m, g, w, E, P, W, k, O, B, A, j, F, I, D, $, M, Y, Q, N, H, x, V, U, G, X, J, K, Z, ee, oe, ne, ie, le, se, ue, ce, de, fe, be, he, _e, pe, me, ye, ge, we, Se, ve, Re, Te, qe, Ce, Ee, Pe, We, ke, Oe, Be, Ae, je, ze, Le, Fe, Ie, De, $e, Me, Ye, Qe, Ne, He, xe, Ve, Ge, Xe, Je, Ke, Ze, et, tt, rt, ot, nt, at, it, st, ut, ct, dt, ft, bt, ht, _t, pt, mt, yt, gt, wt, St, vt, Rt, Tt, qt, Ct, Et, kt, Ot, Bt, At, jt, zt, Lt, Ft, It, Dt, $t, Mt, Yt, Qt, Nt, Ht, xt, Vt, Ut, Gt, Xt, Jt, Kt, Zt, tr, rr, nr, ar, ir, lr, sr, ur, cr, dr, fr, br, hr, _r, pr, mr, yr, gr, wr, Sr, vr, Rr, Tr, qr, Cr, e, o, a, i, l, s, y, v, R, T, q, C, z, L, re, ae, Ue, lt, Pt, Wt, er, or;
var init_ponyfill = __esm(() => {
  t = function() {
  };
  r = function(e) {
    return typeof e == "object" && e !== null || typeof e == "function";
  };
  n = function(e, t2) {
    try {
      Object.defineProperty(e, "name", { value: t2, configurable: true });
    } catch (e2) {
    }
  };
  u = function(e) {
    return new a(e);
  };
  c = function(e) {
    return l(e);
  };
  d = function(e) {
    return s(e);
  };
  f = function(e, t2, r2) {
    return i.call(e, t2, r2);
  };
  b = function(e, t2, r2) {
    f(f(e, t2, r2), undefined, o);
  };
  h = function(e, t2) {
    b(e, t2);
  };
  _ = function(e, t2) {
    b(e, undefined, t2);
  };
  p = function(e, t2, r2) {
    return f(e, t2, r2);
  };
  m = function(e) {
    f(e, undefined, o);
  };
  g = function(e, t2, r2) {
    if (typeof e != "function")
      throw new TypeError("Argument is not a function");
    return Function.prototype.apply.call(e, t2, r2);
  };
  w = function(e, t2, r2) {
    try {
      return c(g(e, t2, r2));
    } catch (e2) {
      return d(e2);
    }
  };
  E = function(e, t2) {
    e._ownerReadableStream = t2, t2._reader = e, t2._state === "readable" ? O(e) : t2._state === "closed" ? function(e2) {
      O(e2), j(e2);
    }(e) : B(e, t2._storedError);
  };
  P = function(e, t2) {
    return Gt(e._ownerReadableStream, t2);
  };
  W = function(e) {
    const t2 = e._ownerReadableStream;
    t2._state === "readable" ? A(e, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")) : function(e2, t3) {
      B(e2, t3);
    }(e, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")), t2._readableStreamController[C](), t2._reader = undefined, e._ownerReadableStream = undefined;
  };
  k = function(e) {
    return new TypeError("Cannot " + e + " a stream using a released reader");
  };
  O = function(e) {
    e._closedPromise = u((t2, r2) => {
      e._closedPromise_resolve = t2, e._closedPromise_reject = r2;
    });
  };
  B = function(e, t2) {
    O(e), A(e, t2);
  };
  A = function(e, t2) {
    e._closedPromise_reject !== undefined && (m(e._closedPromise), e._closedPromise_reject(t2), e._closedPromise_resolve = undefined, e._closedPromise_reject = undefined);
  };
  j = function(e) {
    e._closedPromise_resolve !== undefined && (e._closedPromise_resolve(undefined), e._closedPromise_resolve = undefined, e._closedPromise_reject = undefined);
  };
  F = function(e, t2) {
    if (e !== undefined && (typeof (r2 = e) != "object" && typeof r2 != "function"))
      throw new TypeError(`${t2} is not an object.`);
    var r2;
  };
  I = function(e, t2) {
    if (typeof e != "function")
      throw new TypeError(`${t2} is not a function.`);
  };
  D = function(e, t2) {
    if (!function(e2) {
      return typeof e2 == "object" && e2 !== null || typeof e2 == "function";
    }(e))
      throw new TypeError(`${t2} is not an object.`);
  };
  $ = function(e, t2, r2) {
    if (e === undefined)
      throw new TypeError(`Parameter ${t2} is required in '${r2}'.`);
  };
  M = function(e, t2, r2) {
    if (e === undefined)
      throw new TypeError(`${t2} is required in '${r2}'.`);
  };
  Y = function(e) {
    return Number(e);
  };
  Q = function(e) {
    return e === 0 ? 0 : e;
  };
  N = function(e, t2) {
    const r2 = Number.MAX_SAFE_INTEGER;
    let o = Number(e);
    if (o = Q(o), !z(o))
      throw new TypeError(`${t2} is not a finite number`);
    if (o = function(e2) {
      return Q(L(e2));
    }(o), o < 0 || o > r2)
      throw new TypeError(`${t2} is outside the accepted range of 0 to ${r2}, inclusive`);
    return z(o) && o !== 0 ? o : 0;
  };
  H = function(e) {
    if (!r(e))
      return false;
    if (typeof e.getReader != "function")
      return false;
    try {
      return typeof e.locked == "boolean";
    } catch (e2) {
      return false;
    }
  };
  x = function(e) {
    if (!r(e))
      return false;
    if (typeof e.getWriter != "function")
      return false;
    try {
      return typeof e.locked == "boolean";
    } catch (e2) {
      return false;
    }
  };
  V = function(e, t2) {
    if (!Vt(e))
      throw new TypeError(`${t2} is not a ReadableStream.`);
  };
  U = function(e, t2) {
    e._reader._readRequests.push(t2);
  };
  G = function(e, t2, r2) {
    const o = e._reader._readRequests.shift();
    r2 ? o._closeSteps() : o._chunkSteps(t2);
  };
  X = function(e) {
    return e._reader._readRequests.length;
  };
  J = function(e) {
    const t2 = e._reader;
    return t2 !== undefined && !!K(t2);
  };
  K = function(e) {
    return !!r(e) && (!!Object.prototype.hasOwnProperty.call(e, "_readRequests") && e instanceof ReadableStreamDefaultReader);
  };
  Z = function(e, t2) {
    const r2 = e._readRequests;
    e._readRequests = new S, r2.forEach((e2) => {
      e2._errorSteps(t2);
    });
  };
  ee = function(e) {
    return new TypeError(`ReadableStreamDefaultReader.prototype.${e} can only be used on a ReadableStreamDefaultReader`);
  };
  oe = function(e) {
    if (!r(e))
      return false;
    if (!Object.prototype.hasOwnProperty.call(e, "_asyncIteratorImpl"))
      return false;
    try {
      return e._asyncIteratorImpl instanceof te;
    } catch (e2) {
      return false;
    }
  };
  ne = function(e) {
    return new TypeError(`ReadableStreamAsyncIterator.${e} can only be used on a ReadableSteamAsyncIterator`);
  };
  ie = function(e, t2, r2, o, n2) {
    new Uint8Array(e).set(new Uint8Array(r2, o, n2), t2);
  };
  le = function(e) {
    const t2 = function(e2, t3, r2) {
      if (e2.slice)
        return e2.slice(t3, r2);
      const o = r2 - t3, n2 = new ArrayBuffer(o);
      return ie(n2, 0, e2, t3, o), n2;
    }(e.buffer, e.byteOffset, e.byteOffset + e.byteLength);
    return new Uint8Array(t2);
  };
  se = function(e) {
    const t2 = e._queue.shift();
    return e._queueTotalSize -= t2.size, e._queueTotalSize < 0 && (e._queueTotalSize = 0), t2.value;
  };
  ue = function(e, t2, r2) {
    if (typeof (o = r2) != "number" || ae(o) || o < 0 || r2 === 1 / 0)
      throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
    var o;
    e._queue.push({ value: t2, size: r2 }), e._queueTotalSize += r2;
  };
  ce = function(e) {
    e._queue = new S, e._queueTotalSize = 0;
  };
  de = function(e) {
    return !!r(e) && (!!Object.prototype.hasOwnProperty.call(e, "_controlledReadableByteStream") && e instanceof ReadableByteStreamController);
  };
  fe = function(e) {
    return !!r(e) && (!!Object.prototype.hasOwnProperty.call(e, "_associatedReadableByteStreamController") && e instanceof ReadableStreamBYOBRequest);
  };
  be = function(e) {
    const t2 = function(e2) {
      const t3 = e2._controlledReadableByteStream;
      if (t3._state !== "readable")
        return false;
      if (e2._closeRequested)
        return false;
      if (!e2._started)
        return false;
      if (J(t3) && X(t3) > 0)
        return true;
      if (Le(t3) && ze(t3) > 0)
        return true;
      if (ke(e2) > 0)
        return true;
      return false;
    }(e);
    if (!t2)
      return;
    if (e._pulling)
      return void (e._pullAgain = true);
    e._pulling = true;
    b(e._pullAlgorithm(), () => (e._pulling = false, e._pullAgain && (e._pullAgain = false, be(e)), null), (t3) => (Pe(e, t3), null));
  };
  he = function(e) {
    Re(e), e._pendingPullIntos = new S;
  };
  _e = function(e, t2) {
    let r2 = false;
    e._state === "closed" && (r2 = true);
    const o = pe(t2);
    t2.readerType === "default" ? G(e, o, r2) : function(e2, t3, r3) {
      const o2 = e2._reader._readIntoRequests.shift();
      r3 ? o2._closeSteps(t3) : o2._chunkSteps(t3);
    }(e, o, r2);
  };
  pe = function(e) {
    const { bytesFilled: t2, elementSize: r2 } = e;
    return new e.viewConstructor(e.buffer, e.byteOffset, t2 / r2);
  };
  me = function(e, t2, r2, o) {
    e._queue.push({ buffer: t2, byteOffset: r2, byteLength: o }), e._queueTotalSize += o;
  };
  ye = function(e, t2, r2, o) {
    let n2;
    try {
      n2 = t2.slice(r2, r2 + o);
    } catch (t3) {
      throw Pe(e, t3), t3;
    }
    me(e, n2, 0, o);
  };
  ge = function(e, t2) {
    t2.bytesFilled > 0 && ye(e, t2.buffer, t2.byteOffset, t2.bytesFilled), Ce(e);
  };
  we = function(e, t2) {
    const r2 = t2.elementSize, o = t2.bytesFilled - t2.bytesFilled % r2, n2 = Math.min(e._queueTotalSize, t2.byteLength - t2.bytesFilled), a = t2.bytesFilled + n2, i = a - a % r2;
    let l = n2, s = false;
    i > o && (l = i - t2.bytesFilled, s = true);
    const u2 = e._queue;
    for (;l > 0; ) {
      const r3 = u2.peek(), o2 = Math.min(l, r3.byteLength), n3 = t2.byteOffset + t2.bytesFilled;
      ie(t2.buffer, n3, r3.buffer, r3.byteOffset, o2), r3.byteLength === o2 ? u2.shift() : (r3.byteOffset += o2, r3.byteLength -= o2), e._queueTotalSize -= o2, Se(e, o2, t2), l -= o2;
    }
    return s;
  };
  Se = function(e, t2, r2) {
    r2.bytesFilled += t2;
  };
  ve = function(e) {
    e._queueTotalSize === 0 && e._closeRequested ? (Ee(e), Xt(e._controlledReadableByteStream)) : be(e);
  };
  Re = function(e) {
    e._byobRequest !== null && (e._byobRequest._associatedReadableByteStreamController = undefined, e._byobRequest._view = null, e._byobRequest = null);
  };
  Te = function(e) {
    for (;e._pendingPullIntos.length > 0; ) {
      if (e._queueTotalSize === 0)
        return;
      const t2 = e._pendingPullIntos.peek();
      we(e, t2) && (Ce(e), _e(e._controlledReadableByteStream, t2));
    }
  };
  qe = function(e, t2) {
    const r2 = e._pendingPullIntos.peek();
    Re(e);
    e._controlledReadableByteStream._state === "closed" ? function(e2, t3) {
      t3.readerType === "none" && Ce(e2);
      const r3 = e2._controlledReadableByteStream;
      if (Le(r3))
        for (;ze(r3) > 0; )
          _e(r3, Ce(e2));
    }(e, r2) : function(e2, t3, r3) {
      if (Se(0, t3, r3), r3.readerType === "none")
        return ge(e2, r3), void Te(e2);
      if (r3.bytesFilled < r3.elementSize)
        return;
      Ce(e2);
      const o = r3.bytesFilled % r3.elementSize;
      if (o > 0) {
        const t4 = r3.byteOffset + r3.bytesFilled;
        ye(e2, r3.buffer, t4 - o, o);
      }
      r3.bytesFilled -= o, _e(e2._controlledReadableByteStream, r3), Te(e2);
    }(e, t2, r2), be(e);
  };
  Ce = function(e) {
    return e._pendingPullIntos.shift();
  };
  Ee = function(e) {
    e._pullAlgorithm = undefined, e._cancelAlgorithm = undefined;
  };
  Pe = function(e, t2) {
    const r2 = e._controlledReadableByteStream;
    r2._state === "readable" && (he(e), ce(e), Ee(e), Jt(r2, t2));
  };
  We = function(e, t2) {
    const r2 = e._queue.shift();
    e._queueTotalSize -= r2.byteLength, ve(e);
    const o = new Uint8Array(r2.buffer, r2.byteOffset, r2.byteLength);
    t2._chunkSteps(o);
  };
  ke = function(e) {
    const t2 = e._controlledReadableByteStream._state;
    return t2 === "errored" ? null : t2 === "closed" ? 0 : e._strategyHWM - e._queueTotalSize;
  };
  Oe = function(e, t2, r2) {
    const o = Object.create(ReadableByteStreamController.prototype);
    let n2, a, i;
    n2 = t2.start !== undefined ? () => t2.start(o) : () => {
    }, a = t2.pull !== undefined ? () => t2.pull(o) : () => c(undefined), i = t2.cancel !== undefined ? (e2) => t2.cancel(e2) : () => c(undefined);
    const l = t2.autoAllocateChunkSize;
    if (l === 0)
      throw new TypeError("autoAllocateChunkSize must be greater than 0");
    (function(e2, t3, r3, o2, n3, a2, i2) {
      t3._controlledReadableByteStream = e2, t3._pullAgain = false, t3._pulling = false, t3._byobRequest = null, t3._queue = t3._queueTotalSize = undefined, ce(t3), t3._closeRequested = false, t3._started = false, t3._strategyHWM = a2, t3._pullAlgorithm = o2, t3._cancelAlgorithm = n3, t3._autoAllocateChunkSize = i2, t3._pendingPullIntos = new S, e2._readableStreamController = t3, b(c(r3()), () => (t3._started = true, be(t3), null), (e3) => (Pe(t3, e3), null));
    })(e, o, n2, a, i, r2, l);
  };
  Be = function(e) {
    return new TypeError(`ReadableStreamBYOBRequest.prototype.${e} can only be used on a ReadableStreamBYOBRequest`);
  };
  Ae = function(e) {
    return new TypeError(`ReadableByteStreamController.prototype.${e} can only be used on a ReadableByteStreamController`);
  };
  je = function(e, t2) {
    e._reader._readIntoRequests.push(t2);
  };
  ze = function(e) {
    return e._reader._readIntoRequests.length;
  };
  Le = function(e) {
    const t2 = e._reader;
    return t2 !== undefined && !!Fe(t2);
  };
  Fe = function(e) {
    return !!r(e) && (!!Object.prototype.hasOwnProperty.call(e, "_readIntoRequests") && e instanceof ReadableStreamBYOBReader);
  };
  Ie = function(e, t2) {
    const r2 = e._readIntoRequests;
    e._readIntoRequests = new S, r2.forEach((e2) => {
      e2._errorSteps(t2);
    });
  };
  De = function(e) {
    return new TypeError(`ReadableStreamBYOBReader.prototype.${e} can only be used on a ReadableStreamBYOBReader`);
  };
  $e = function(e, t2) {
    const { highWaterMark: r2 } = e;
    if (r2 === undefined)
      return t2;
    if (ae(r2) || r2 < 0)
      throw new RangeError("Invalid highWaterMark");
    return r2;
  };
  Me = function(e) {
    const { size: t2 } = e;
    return t2 || (() => 1);
  };
  Ye = function(e, t2) {
    F(e, t2);
    const r2 = e == null ? undefined : e.highWaterMark, o = e == null ? undefined : e.size;
    return { highWaterMark: r2 === undefined ? undefined : Y(r2), size: o === undefined ? undefined : Qe(o, `${t2} has member 'size' that`) };
  };
  Qe = function(e, t2) {
    return I(e, t2), (t3) => Y(e(t3));
  };
  Ne = function(e, t2, r2) {
    return I(e, r2), (r3) => w(e, t2, [r3]);
  };
  He = function(e, t2, r2) {
    return I(e, r2), () => w(e, t2, []);
  };
  xe = function(e, t2, r2) {
    return I(e, r2), (r3) => g(e, t2, [r3]);
  };
  Ve = function(e, t2, r2) {
    return I(e, r2), (r3, o) => w(e, t2, [r3, o]);
  };
  Ge = function(e) {
    return !!r(e) && (!!Object.prototype.hasOwnProperty.call(e, "_writableStreamController") && e instanceof WritableStream);
  };
  Xe = function(e) {
    return e._writer !== undefined;
  };
  Je = function(e, t2) {
    var r2;
    if (e._state === "closed" || e._state === "errored")
      return c(undefined);
    e._writableStreamController._abortReason = t2, (r2 = e._writableStreamController._abortController) === null || r2 === undefined || r2.abort(t2);
    const o = e._state;
    if (o === "closed" || o === "errored")
      return c(undefined);
    if (e._pendingAbortRequest !== undefined)
      return e._pendingAbortRequest._promise;
    let n2 = false;
    o === "erroring" && (n2 = true, t2 = undefined);
    const a = u((r3, o2) => {
      e._pendingAbortRequest = { _promise: undefined, _resolve: r3, _reject: o2, _reason: t2, _wasAlreadyErroring: n2 };
    });
    return e._pendingAbortRequest._promise = a, n2 || et(e, t2), a;
  };
  Ke = function(e) {
    const t2 = e._state;
    if (t2 === "closed" || t2 === "errored")
      return d(new TypeError(`The stream (in ${t2} state) is not in the writable state and cannot be closed`));
    const r2 = u((t3, r3) => {
      const o2 = { _resolve: t3, _reject: r3 };
      e._closeRequest = o2;
    }), o = e._writer;
    var n2;
    return o !== undefined && e._backpressure && t2 === "writable" && Et(o), ue(n2 = e._writableStreamController, lt, 0), dt(n2), r2;
  };
  Ze = function(e, t2) {
    e._state !== "writable" ? tt(e) : et(e, t2);
  };
  et = function(e, t2) {
    const r2 = e._writableStreamController;
    e._state = "erroring", e._storedError = t2;
    const o = e._writer;
    o !== undefined && it(o, t2), !function(e2) {
      if (e2._inFlightWriteRequest === undefined && e2._inFlightCloseRequest === undefined)
        return false;
      return true;
    }(e) && r2._started && tt(e);
  };
  tt = function(e) {
    e._state = "errored", e._writableStreamController[R]();
    const t2 = e._storedError;
    if (e._writeRequests.forEach((e2) => {
      e2._reject(t2);
    }), e._writeRequests = new S, e._pendingAbortRequest === undefined)
      return void ot(e);
    const r2 = e._pendingAbortRequest;
    if (e._pendingAbortRequest = undefined, r2._wasAlreadyErroring)
      return r2._reject(t2), void ot(e);
    b(e._writableStreamController[v](r2._reason), () => (r2._resolve(), ot(e), null), (t3) => (r2._reject(t3), ot(e), null));
  };
  rt = function(e) {
    return e._closeRequest !== undefined || e._inFlightCloseRequest !== undefined;
  };
  ot = function(e) {
    e._closeRequest !== undefined && (e._closeRequest._reject(e._storedError), e._closeRequest = undefined);
    const t2 = e._writer;
    t2 !== undefined && St(t2, e._storedError);
  };
  nt = function(e, t2) {
    const r2 = e._writer;
    r2 !== undefined && t2 !== e._backpressure && (t2 ? function(e2) {
      Rt(e2);
    }(r2) : Et(r2)), e._backpressure = t2;
  };
  at = function(e) {
    return !!r(e) && (!!Object.prototype.hasOwnProperty.call(e, "_ownerWritableStream") && e instanceof WritableStreamDefaultWriter);
  };
  it = function(e, t2) {
    e._readyPromiseState === "pending" ? Ct(e, t2) : function(e2, t3) {
      Tt(e2, t3);
    }(e, t2);
  };
  st = function(e) {
    return !!r(e) && (!!Object.prototype.hasOwnProperty.call(e, "_controlledWritableStream") && e instanceof WritableStreamDefaultController);
  };
  ut = function(e) {
    e._writeAlgorithm = undefined, e._closeAlgorithm = undefined, e._abortAlgorithm = undefined, e._strategySizeAlgorithm = undefined;
  };
  ct = function(e) {
    return e._strategyHWM - e._queueTotalSize;
  };
  dt = function(e) {
    const t2 = e._controlledWritableStream;
    if (!e._started)
      return;
    if (t2._inFlightWriteRequest !== undefined)
      return;
    if (t2._state === "erroring")
      return void tt(t2);
    if (e._queue.length === 0)
      return;
    const r2 = e._queue.peek().value;
    r2 === lt ? function(e2) {
      const t3 = e2._controlledWritableStream;
      (function(e3) {
        e3._inFlightCloseRequest = e3._closeRequest, e3._closeRequest = undefined;
      })(t3), se(e2);
      const r3 = e2._closeAlgorithm();
      ut(e2), b(r3, () => (function(e3) {
        e3._inFlightCloseRequest._resolve(undefined), e3._inFlightCloseRequest = undefined, e3._state === "erroring" && (e3._storedError = undefined, e3._pendingAbortRequest !== undefined && (e3._pendingAbortRequest._resolve(), e3._pendingAbortRequest = undefined)), e3._state = "closed";
        const t4 = e3._writer;
        t4 !== undefined && vt(t4);
      }(t3), null), (e3) => (function(e4, t4) {
        e4._inFlightCloseRequest._reject(t4), e4._inFlightCloseRequest = undefined, e4._pendingAbortRequest !== undefined && (e4._pendingAbortRequest._reject(t4), e4._pendingAbortRequest = undefined), Ze(e4, t4);
      }(t3, e3), null));
    }(e) : function(e2, t3) {
      const r3 = e2._controlledWritableStream;
      (function(e3) {
        e3._inFlightWriteRequest = e3._writeRequests.shift();
      })(r3);
      b(e2._writeAlgorithm(t3), () => {
        (function(e3) {
          e3._inFlightWriteRequest._resolve(undefined), e3._inFlightWriteRequest = undefined;
        })(r3);
        const t4 = r3._state;
        if (se(e2), !rt(r3) && t4 === "writable") {
          const t5 = bt(e2);
          nt(r3, t5);
        }
        return dt(e2), null;
      }, (t4) => (r3._state === "writable" && ut(e2), function(e3, t5) {
        e3._inFlightWriteRequest._reject(t5), e3._inFlightWriteRequest = undefined, Ze(e3, t5);
      }(r3, t4), null));
    }(e, r2);
  };
  ft = function(e, t2) {
    e._controlledWritableStream._state === "writable" && ht(e, t2);
  };
  bt = function(e) {
    return ct(e) <= 0;
  };
  ht = function(e, t2) {
    const r2 = e._controlledWritableStream;
    ut(e), et(r2, t2);
  };
  _t = function(e) {
    return new TypeError(`WritableStream.prototype.${e} can only be used on a WritableStream`);
  };
  pt = function(e) {
    return new TypeError(`WritableStreamDefaultController.prototype.${e} can only be used on a WritableStreamDefaultController`);
  };
  mt = function(e) {
    return new TypeError(`WritableStreamDefaultWriter.prototype.${e} can only be used on a WritableStreamDefaultWriter`);
  };
  yt = function(e) {
    return new TypeError("Cannot " + e + " a stream using a released writer");
  };
  gt = function(e) {
    e._closedPromise = u((t2, r2) => {
      e._closedPromise_resolve = t2, e._closedPromise_reject = r2, e._closedPromiseState = "pending";
    });
  };
  wt = function(e, t2) {
    gt(e), St(e, t2);
  };
  St = function(e, t2) {
    e._closedPromise_reject !== undefined && (m(e._closedPromise), e._closedPromise_reject(t2), e._closedPromise_resolve = undefined, e._closedPromise_reject = undefined, e._closedPromiseState = "rejected");
  };
  vt = function(e) {
    e._closedPromise_resolve !== undefined && (e._closedPromise_resolve(undefined), e._closedPromise_resolve = undefined, e._closedPromise_reject = undefined, e._closedPromiseState = "resolved");
  };
  Rt = function(e) {
    e._readyPromise = u((t2, r2) => {
      e._readyPromise_resolve = t2, e._readyPromise_reject = r2;
    }), e._readyPromiseState = "pending";
  };
  Tt = function(e, t2) {
    Rt(e), Ct(e, t2);
  };
  qt = function(e) {
    Rt(e), Et(e);
  };
  Ct = function(e, t2) {
    e._readyPromise_reject !== undefined && (m(e._readyPromise), e._readyPromise_reject(t2), e._readyPromise_resolve = undefined, e._readyPromise_reject = undefined, e._readyPromiseState = "rejected");
  };
  Et = function(e) {
    e._readyPromise_resolve !== undefined && (e._readyPromise_resolve(undefined), e._readyPromise_resolve = undefined, e._readyPromise_reject = undefined, e._readyPromiseState = "fulfilled");
  };
  kt = function(e, t2, r2, o, n2, a) {
    const i = e.getReader(), l = t2.getWriter();
    Vt(e) && (e._disturbed = true);
    let s, _2, g2, w2 = false, S = false, v = "readable", R = "writable", T = false, q = false;
    const C = u((e2) => {
      g2 = e2;
    });
    let E2 = Promise.resolve(undefined);
    return u((P2, W2) => {
      let k2;
      function O2() {
        if (w2)
          return;
        const e2 = u((e3, t3) => {
          (function r(o2) {
            o2 ? e3() : f(function() {
              if (w2)
                return c(true);
              return f(l.ready, () => f(i.read(), (e4) => !!e4.done || (E2 = l.write(e4.value), m(E2), false)));
            }(), r, t3);
          })(false);
        });
        m(e2);
      }
      function B2() {
        return v = "closed", r2 ? L() : z(() => (Ge(t2) && (T = rt(t2), R = t2._state), T || R === "closed" ? c(undefined) : R === "erroring" || R === "errored" ? d(_2) : (T = true, l.close())), false, undefined), null;
      }
      function A2(e2) {
        return w2 || (v = "errored", s = e2, o ? L(true, e2) : z(() => l.abort(e2), true, e2)), null;
      }
      function j2(e2) {
        return S || (R = "errored", _2 = e2, n2 ? L(true, e2) : z(() => i.cancel(e2), true, e2)), null;
      }
      if (a !== undefined && (k2 = () => {
        const e2 = a.reason !== undefined ? a.reason : new Wt("Aborted", "AbortError"), t3 = [];
        o || t3.push(() => R === "writable" ? l.abort(e2) : c(undefined)), n2 || t3.push(() => v === "readable" ? i.cancel(e2) : c(undefined)), z(() => Promise.all(t3.map((e3) => e3())), true, e2);
      }, a.aborted ? k2() : a.addEventListener("abort", k2)), Vt(e) && (v = e._state, s = e._storedError), Ge(t2) && (R = t2._state, _2 = t2._storedError, T = rt(t2)), Vt(e) && Ge(t2) && (q = true, g2()), v === "errored")
        A2(s);
      else if (R === "erroring" || R === "errored")
        j2(_2);
      else if (v === "closed")
        B2();
      else if (T || R === "closed") {
        const e2 = new TypeError("the destination writable stream closed before all data could be piped to it");
        n2 ? L(true, e2) : z(() => i.cancel(e2), true, e2);
      }
      function z(e2, t3, r3) {
        function o2() {
          return R !== "writable" || T ? n3() : h(function() {
            let e3;
            return c(function t() {
              if (e3 !== E2)
                return e3 = E2, p(E2, t, t);
            }());
          }(), n3), null;
        }
        function n3() {
          return e2 ? b(e2(), () => F2(t3, r3), (e3) => F2(true, e3)) : F2(t3, r3), null;
        }
        w2 || (w2 = true, q ? o2() : h(C, o2));
      }
      function L(e2, t3) {
        z(undefined, e2, t3);
      }
      function F2(e2, t3) {
        return S = true, l.releaseLock(), i.releaseLock(), a !== undefined && a.removeEventListener("abort", k2), e2 ? W2(t3) : P2(undefined), null;
      }
      w2 || (b(i.closed, B2, A2), b(l.closed, function() {
        return S || (R = "closed"), null;
      }, j2)), q ? O2() : y(() => {
        q = true, g2(), O2();
      });
    });
  };
  Ot = function(e, t2) {
    return function(e2) {
      try {
        return e2.getReader({ mode: "byob" }).releaseLock(), true;
      } catch (e3) {
        return false;
      }
    }(e) ? function(e2) {
      let t3, r2, o, n2, a, i = e2.getReader(), l = false, s = false, d2 = false, f2 = false, h2 = false, p2 = false;
      const m2 = u((e3) => {
        a = e3;
      });
      function y(e3) {
        _(e3.closed, (t4) => (e3 !== i || (o.error(t4), n2.error(t4), h2 && p2 || a(undefined)), null));
      }
      function g2() {
        l && (i.releaseLock(), i = e2.getReader(), y(i), l = false), b(i.read(), (e3) => {
          var t4, r3;
          if (d2 = false, f2 = false, e3.done)
            return h2 || o.close(), p2 || n2.close(), (t4 = o.byobRequest) === null || t4 === undefined || t4.respond(0), (r3 = n2.byobRequest) === null || r3 === undefined || r3.respond(0), h2 && p2 || a(undefined), null;
          const l2 = e3.value, u2 = l2;
          let c2 = l2;
          if (!h2 && !p2)
            try {
              c2 = le(l2);
            } catch (e4) {
              return o.error(e4), n2.error(e4), a(i.cancel(e4)), null;
            }
          return h2 || o.enqueue(u2), p2 || n2.enqueue(c2), s = false, d2 ? S() : f2 && v(), null;
        }, () => (s = false, null));
      }
      function w2(t4, r3) {
        l || (i.releaseLock(), i = e2.getReader({ mode: "byob" }), y(i), l = true);
        const u2 = r3 ? n2 : o, c2 = r3 ? o : n2;
        b(i.read(t4), (e3) => {
          var t5;
          d2 = false, f2 = false;
          const o2 = r3 ? p2 : h2, n3 = r3 ? h2 : p2;
          if (e3.done) {
            o2 || u2.close(), n3 || c2.close();
            const r4 = e3.value;
            return r4 !== undefined && (o2 || u2.byobRequest.respondWithNewView(r4), n3 || (t5 = c2.byobRequest) === null || t5 === undefined || t5.respond(0)), o2 && n3 || a(undefined), null;
          }
          const l2 = e3.value;
          if (n3)
            o2 || u2.byobRequest.respondWithNewView(l2);
          else {
            let e4;
            try {
              e4 = le(l2);
            } catch (e5) {
              return u2.error(e5), c2.error(e5), a(i.cancel(e5)), null;
            }
            o2 || u2.byobRequest.respondWithNewView(l2), c2.enqueue(e4);
          }
          return s = false, d2 ? S() : f2 && v(), null;
        }, () => (s = false, null));
      }
      function S() {
        if (s)
          return d2 = true, c(undefined);
        s = true;
        const e3 = o.byobRequest;
        return e3 === null ? g2() : w2(e3.view, false), c(undefined);
      }
      function v() {
        if (s)
          return f2 = true, c(undefined);
        s = true;
        const e3 = n2.byobRequest;
        return e3 === null ? g2() : w2(e3.view, true), c(undefined);
      }
      function R(e3) {
        if (h2 = true, t3 = e3, p2) {
          const e4 = [t3, r2], o2 = i.cancel(e4);
          a(o2);
        }
        return m2;
      }
      function T(e3) {
        if (p2 = true, r2 = e3, h2) {
          const e4 = [t3, r2], o2 = i.cancel(e4);
          a(o2);
        }
        return m2;
      }
      const q = new ReadableStream2({ type: "bytes", start(e3) {
        o = e3;
      }, pull: S, cancel: R }), C = new ReadableStream2({ type: "bytes", start(e3) {
        n2 = e3;
      }, pull: v, cancel: T });
      return y(i), [q, C];
    }(e) : function(e2, t3) {
      const r2 = e2.getReader();
      let o, n2, a, i, l, s = false, d2 = false, f2 = false, h2 = false;
      const p2 = u((e3) => {
        l = e3;
      });
      function m2() {
        return s ? (d2 = true, c(undefined)) : (s = true, b(r2.read(), (e3) => {
          if (d2 = false, e3.done)
            return f2 || a.close(), h2 || i.close(), f2 && h2 || l(undefined), null;
          const t4 = e3.value, r3 = t4, o2 = t4;
          return f2 || a.enqueue(r3), h2 || i.enqueue(o2), s = false, d2 && m2(), null;
        }, () => (s = false, null)), c(undefined));
      }
      function y(e3) {
        if (f2 = true, o = e3, h2) {
          const e4 = [o, n2], t4 = r2.cancel(e4);
          l(t4);
        }
        return p2;
      }
      function g2(e3) {
        if (h2 = true, n2 = e3, f2) {
          const e4 = [o, n2], t4 = r2.cancel(e4);
          l(t4);
        }
        return p2;
      }
      const w2 = new ReadableStream2({ start(e3) {
        a = e3;
      }, pull: m2, cancel: y }), S = new ReadableStream2({ start(e3) {
        i = e3;
      }, pull: m2, cancel: g2 });
      return _(r2.closed, (e3) => (a.error(e3), i.error(e3), f2 && h2 || l(undefined), null)), [w2, S];
    }(e);
  };
  Bt = function(e) {
    return !!r(e) && (!!Object.prototype.hasOwnProperty.call(e, "_controlledReadableStream") && e instanceof ReadableStreamDefaultController);
  };
  At = function(e) {
    const t2 = function(e2) {
      const t3 = e2._controlledReadableStream;
      if (!Ft(e2))
        return false;
      if (!e2._started)
        return false;
      if (Ut(t3) && X(t3) > 0)
        return true;
      if (Lt(e2) > 0)
        return true;
      return false;
    }(e);
    if (!t2)
      return;
    if (e._pulling)
      return void (e._pullAgain = true);
    e._pulling = true;
    b(e._pullAlgorithm(), () => (e._pulling = false, e._pullAgain && (e._pullAgain = false, At(e)), null), (t3) => (zt(e, t3), null));
  };
  jt = function(e) {
    e._pullAlgorithm = undefined, e._cancelAlgorithm = undefined, e._strategySizeAlgorithm = undefined;
  };
  zt = function(e, t2) {
    const r2 = e._controlledReadableStream;
    r2._state === "readable" && (ce(e), jt(e), Jt(r2, t2));
  };
  Lt = function(e) {
    const t2 = e._controlledReadableStream._state;
    return t2 === "errored" ? null : t2 === "closed" ? 0 : e._strategyHWM - e._queueTotalSize;
  };
  Ft = function(e) {
    return !e._closeRequested && e._controlledReadableStream._state === "readable";
  };
  It = function(e, t2, r2, o) {
    const n2 = Object.create(ReadableStreamDefaultController.prototype);
    let a, i, l;
    a = t2.start !== undefined ? () => t2.start(n2) : () => {
    }, i = t2.pull !== undefined ? () => t2.pull(n2) : () => c(undefined), l = t2.cancel !== undefined ? (e2) => t2.cancel(e2) : () => c(undefined), function(e2, t3, r3, o2, n3, a2, i2) {
      t3._controlledReadableStream = e2, t3._queue = undefined, t3._queueTotalSize = undefined, ce(t3), t3._started = false, t3._closeRequested = false, t3._pullAgain = false, t3._pulling = false, t3._strategySizeAlgorithm = i2, t3._strategyHWM = a2, t3._pullAlgorithm = o2, t3._cancelAlgorithm = n3, e2._readableStreamController = t3, b(c(r3()), () => (t3._started = true, At(t3), null), (e3) => (zt(t3, e3), null));
    }(e, n2, a, i, l, r2, o);
  };
  Dt = function(e) {
    return new TypeError(`ReadableStreamDefaultController.prototype.${e} can only be used on a ReadableStreamDefaultController`);
  };
  $t = function(e, t2, r2) {
    return I(e, r2), (r3) => w(e, t2, [r3]);
  };
  Mt = function(e, t2, r2) {
    return I(e, r2), (r3) => w(e, t2, [r3]);
  };
  Yt = function(e, t2, r2) {
    return I(e, r2), (r3) => g(e, t2, [r3]);
  };
  Qt = function(e, t2) {
    if ((e = `${e}`) !== "bytes")
      throw new TypeError(`${t2} '${e}' is not a valid enumeration value for ReadableStreamType`);
    return e;
  };
  Nt = function(e, t2) {
    if ((e = `${e}`) !== "byob")
      throw new TypeError(`${t2} '${e}' is not a valid enumeration value for ReadableStreamReaderMode`);
    return e;
  };
  Ht = function(e, t2) {
    F(e, t2);
    const r2 = e == null ? undefined : e.preventAbort, o = e == null ? undefined : e.preventCancel, n2 = e == null ? undefined : e.preventClose, a = e == null ? undefined : e.signal;
    return a !== undefined && function(e2, t3) {
      if (!function(e3) {
        if (typeof e3 != "object" || e3 === null)
          return false;
        try {
          return typeof e3.aborted == "boolean";
        } catch (e4) {
          return false;
        }
      }(e2))
        throw new TypeError(`${t3} is not an AbortSignal.`);
    }(a, `${t2} has member 'signal' that`), { preventAbort: Boolean(r2), preventCancel: Boolean(o), preventClose: Boolean(n2), signal: a };
  };
  xt = function(e, t2) {
    F(e, t2);
    const r2 = e == null ? undefined : e.readable;
    M(r2, "readable", "ReadableWritablePair"), function(e2, t3) {
      if (!H(e2))
        throw new TypeError(`${t3} is not a ReadableStream.`);
    }(r2, `${t2} has member 'readable' that`);
    const o = e == null ? undefined : e.writable;
    return M(o, "writable", "ReadableWritablePair"), function(e2, t3) {
      if (!x(e2))
        throw new TypeError(`${t3} is not a WritableStream.`);
    }(o, `${t2} has member 'writable' that`), { readable: r2, writable: o };
  };
  Vt = function(e) {
    return !!r(e) && (!!Object.prototype.hasOwnProperty.call(e, "_readableStreamController") && e instanceof ReadableStream2);
  };
  Ut = function(e) {
    return e._reader !== undefined;
  };
  Gt = function(e, r2) {
    if (e._disturbed = true, e._state === "closed")
      return c(undefined);
    if (e._state === "errored")
      return d(e._storedError);
    Xt(e);
    const o = e._reader;
    if (o !== undefined && Fe(o)) {
      const e2 = o._readIntoRequests;
      o._readIntoRequests = new S, e2.forEach((e3) => {
        e3._closeSteps(undefined);
      });
    }
    return p(e._readableStreamController[T](r2), t);
  };
  Xt = function(e) {
    e._state = "closed";
    const t2 = e._reader;
    if (t2 !== undefined && (j(t2), K(t2))) {
      const e2 = t2._readRequests;
      t2._readRequests = new S, e2.forEach((e3) => {
        e3._closeSteps();
      });
    }
  };
  Jt = function(e, t2) {
    e._state = "errored", e._storedError = t2;
    const r2 = e._reader;
    r2 !== undefined && (A(r2, t2), K(r2) ? Z(r2, t2) : Ie(r2, t2));
  };
  Kt = function(e) {
    return new TypeError(`ReadableStream.prototype.${e} can only be used on a ReadableStream`);
  };
  Zt = function(e, t2) {
    F(e, t2);
    const r2 = e == null ? undefined : e.highWaterMark;
    return M(r2, "highWaterMark", "QueuingStrategyInit"), { highWaterMark: Y(r2) };
  };
  tr = function(e) {
    return new TypeError(`ByteLengthQueuingStrategy.prototype.${e} can only be used on a ByteLengthQueuingStrategy`);
  };
  rr = function(e) {
    return !!r(e) && (!!Object.prototype.hasOwnProperty.call(e, "_byteLengthQueuingStrategyHighWaterMark") && e instanceof ByteLengthQueuingStrategy);
  };
  nr = function(e) {
    return new TypeError(`CountQueuingStrategy.prototype.${e} can only be used on a CountQueuingStrategy`);
  };
  ar = function(e) {
    return !!r(e) && (!!Object.prototype.hasOwnProperty.call(e, "_countQueuingStrategyHighWaterMark") && e instanceof CountQueuingStrategy);
  };
  ir = function(e, t2, r2) {
    return I(e, r2), (r3) => w(e, t2, [r3]);
  };
  lr = function(e, t2, r2) {
    return I(e, r2), (r3) => g(e, t2, [r3]);
  };
  sr = function(e, t2, r2) {
    return I(e, r2), (r3, o) => w(e, t2, [r3, o]);
  };
  ur = function(e) {
    return !!r(e) && (!!Object.prototype.hasOwnProperty.call(e, "_transformStreamController") && e instanceof TransformStream);
  };
  cr = function(e, t2) {
    Sr(e, t2), dr(e, t2);
  };
  dr = function(e, t2) {
    hr(e._transformStreamController), function(e2, t3) {
      e2._writableController.error(t3);
      e2._writableState === "writable" && Tr(e2, t3);
    }(e, t2), e._backpressure && fr(e, false);
  };
  fr = function(e, t2) {
    e._backpressureChangePromise !== undefined && e._backpressureChangePromise_resolve(), e._backpressureChangePromise = u((t3) => {
      e._backpressureChangePromise_resolve = t3;
    }), e._backpressure = t2;
  };
  br = function(e) {
    return !!r(e) && (!!Object.prototype.hasOwnProperty.call(e, "_controlledTransformStream") && e instanceof TransformStreamDefaultController);
  };
  hr = function(e) {
    e._transformAlgorithm = undefined, e._flushAlgorithm = undefined;
  };
  _r = function(e, t2) {
    const r2 = e._controlledTransformStream;
    if (!gr(r2))
      throw new TypeError("Readable side is not in a state that permits enqueue");
    try {
      (function(e2, t3) {
        e2._readablePulling = false;
        try {
          e2._readableController.enqueue(t3);
        } catch (t4) {
          throw Sr(e2, t4), t4;
        }
      })(r2, t2);
    } catch (e2) {
      throw dr(r2, e2), r2._readableStoredError;
    }
    const o = function(e2) {
      return !function(e3) {
        if (!gr(e3))
          return false;
        if (e3._readablePulling)
          return true;
        if (vr(e3) > 0)
          return true;
        return false;
      }(e2);
    }(r2);
    o !== r2._backpressure && fr(r2, true);
  };
  pr = function(e, t2) {
    return p(e._transformAlgorithm(t2), undefined, (t3) => {
      throw cr(e._controlledTransformStream, t3), t3;
    });
  };
  mr = function(e) {
    return new TypeError(`TransformStreamDefaultController.prototype.${e} can only be used on a TransformStreamDefaultController`);
  };
  yr = function(e) {
    return new TypeError(`TransformStream.prototype.${e} can only be used on a TransformStream`);
  };
  gr = function(e) {
    return !e._readableCloseRequested && e._readableState === "readable";
  };
  wr = function(e) {
    e._readableState = "closed", e._readableCloseRequested = true, e._readableController.close();
  };
  Sr = function(e, t2) {
    e._readableState === "readable" && (e._readableState = "errored", e._readableStoredError = t2), e._readableController.error(t2);
  };
  vr = function(e) {
    return e._readableController.desiredSize;
  };
  Rr = function(e, t2) {
    e._writableState !== "writable" ? qr(e) : Tr(e, t2);
  };
  Tr = function(e, t2) {
    e._writableState = "erroring", e._writableStoredError = t2, !function(e2) {
      return e2._writableHasInFlightOperation;
    }(e) && e._writableStarted && qr(e);
  };
  qr = function(e) {
    e._writableState = "errored";
  };
  Cr = function(e) {
    e._writableState === "erroring" && qr(e);
  };
  e = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol : (e2) => `Symbol(${e2})`;
  o = t;
  a = Promise;
  i = Promise.prototype.then;
  l = Promise.resolve.bind(a);
  s = Promise.reject.bind(a);
  y = (e2) => {
    if (typeof queueMicrotask == "function")
      y = queueMicrotask;
    else {
      const e3 = c(undefined);
      y = (t2) => f(e3, t2);
    }
    return y(e2);
  };
  v = e("[[AbortSteps]]");
  R = e("[[ErrorSteps]]");
  T = e("[[CancelSteps]]");
  q = e("[[PullSteps]]");
  C = e("[[ReleaseSteps]]");
  z = Number.isFinite || function(e2) {
    return typeof e2 == "number" && isFinite(e2);
  };
  L = Math.trunc || function(e2) {
    return e2 < 0 ? Math.ceil(e2) : Math.floor(e2);
  };
  Object.defineProperties(ReadableStreamDefaultReader.prototype, { cancel: { enumerable: true }, read: { enumerable: true }, releaseLock: { enumerable: true }, closed: { enumerable: true } }), n(ReadableStreamDefaultReader.prototype.cancel, "cancel"), n(ReadableStreamDefaultReader.prototype.read, "read"), n(ReadableStreamDefaultReader.prototype.releaseLock, "releaseLock"), typeof e.toStringTag == "symbol" && Object.defineProperty(ReadableStreamDefaultReader.prototype, e.toStringTag, { value: "ReadableStreamDefaultReader", configurable: true });
  re = { next() {
    return oe(this) ? this._asyncIteratorImpl.next() : d(ne("next"));
  }, return(e2) {
    return oe(this) ? this._asyncIteratorImpl.return(e2) : d(ne("return"));
  } };
  typeof e.asyncIterator == "symbol" && Object.defineProperty(re, e.asyncIterator, { value() {
    return this;
  }, writable: true, configurable: true });
  ae = Number.isNaN || function(e2) {
    return e2 != e2;
  };
  Object.defineProperties(ReadableStreamBYOBRequest.prototype, { respond: { enumerable: true }, respondWithNewView: { enumerable: true }, view: { enumerable: true } }), n(ReadableStreamBYOBRequest.prototype.respond, "respond"), n(ReadableStreamBYOBRequest.prototype.respondWithNewView, "respondWithNewView"), typeof e.toStringTag == "symbol" && Object.defineProperty(ReadableStreamBYOBRequest.prototype, e.toStringTag, { value: "ReadableStreamBYOBRequest", configurable: true });
  Object.defineProperties(ReadableByteStreamController.prototype, { close: { enumerable: true }, enqueue: { enumerable: true }, error: { enumerable: true }, byobRequest: { enumerable: true }, desiredSize: { enumerable: true } }), n(ReadableByteStreamController.prototype.close, "close"), n(ReadableByteStreamController.prototype.enqueue, "enqueue"), n(ReadableByteStreamController.prototype.error, "error"), typeof e.toStringTag == "symbol" && Object.defineProperty(ReadableByteStreamController.prototype, e.toStringTag, { value: "ReadableByteStreamController", configurable: true });
  Object.defineProperties(ReadableStreamBYOBReader.prototype, { cancel: { enumerable: true }, read: { enumerable: true }, releaseLock: { enumerable: true }, closed: { enumerable: true } }), n(ReadableStreamBYOBReader.prototype.cancel, "cancel"), n(ReadableStreamBYOBReader.prototype.read, "read"), n(ReadableStreamBYOBReader.prototype.releaseLock, "releaseLock"), typeof e.toStringTag == "symbol" && Object.defineProperty(ReadableStreamBYOBReader.prototype, e.toStringTag, { value: "ReadableStreamBYOBReader", configurable: true });
  Ue = typeof AbortController == "function";
  Object.defineProperties(WritableStream.prototype, { abort: { enumerable: true }, close: { enumerable: true }, getWriter: { enumerable: true }, locked: { enumerable: true } }), n(WritableStream.prototype.abort, "abort"), n(WritableStream.prototype.close, "close"), n(WritableStream.prototype.getWriter, "getWriter"), typeof e.toStringTag == "symbol" && Object.defineProperty(WritableStream.prototype, e.toStringTag, { value: "WritableStream", configurable: true });
  Object.defineProperties(WritableStreamDefaultWriter.prototype, { abort: { enumerable: true }, close: { enumerable: true }, releaseLock: { enumerable: true }, write: { enumerable: true }, closed: { enumerable: true }, desiredSize: { enumerable: true }, ready: { enumerable: true } }), n(WritableStreamDefaultWriter.prototype.abort, "abort"), n(WritableStreamDefaultWriter.prototype.close, "close"), n(WritableStreamDefaultWriter.prototype.releaseLock, "releaseLock"), n(WritableStreamDefaultWriter.prototype.write, "write"), typeof e.toStringTag == "symbol" && Object.defineProperty(WritableStreamDefaultWriter.prototype, e.toStringTag, { value: "WritableStreamDefaultWriter", configurable: true });
  lt = {};
  Object.defineProperties(WritableStreamDefaultController.prototype, { abortReason: { enumerable: true }, signal: { enumerable: true }, error: { enumerable: true } }), typeof e.toStringTag == "symbol" && Object.defineProperty(WritableStreamDefaultController.prototype, e.toStringTag, { value: "WritableStreamDefaultController", configurable: true });
  Pt = typeof DOMException != "undefined" ? DOMException : undefined;
  Wt = function(e2) {
    if (typeof e2 != "function" && typeof e2 != "object")
      return false;
    try {
      return new e2, true;
    } catch (e3) {
      return false;
    }
  }(Pt) ? Pt : function() {
    const e2 = function(e3, t2) {
      this.message = e3 || "", this.name = t2 || "Error", Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
    };
    return e2.prototype = Object.create(Error.prototype), Object.defineProperty(e2.prototype, "constructor", { value: e2, writable: true, configurable: true }), e2;
  }();
  Object.defineProperties(ReadableStreamDefaultController.prototype, { close: { enumerable: true }, enqueue: { enumerable: true }, error: { enumerable: true }, desiredSize: { enumerable: true } }), n(ReadableStreamDefaultController.prototype.close, "close"), n(ReadableStreamDefaultController.prototype.enqueue, "enqueue"), n(ReadableStreamDefaultController.prototype.error, "error"), typeof e.toStringTag == "symbol" && Object.defineProperty(ReadableStreamDefaultController.prototype, e.toStringTag, { value: "ReadableStreamDefaultController", configurable: true });
  Object.defineProperties(ReadableStream2.prototype, { cancel: { enumerable: true }, getReader: { enumerable: true }, pipeThrough: { enumerable: true }, pipeTo: { enumerable: true }, tee: { enumerable: true }, values: { enumerable: true }, locked: { enumerable: true } }), n(ReadableStream2.prototype.cancel, "cancel"), n(ReadableStream2.prototype.getReader, "getReader"), n(ReadableStream2.prototype.pipeThrough, "pipeThrough"), n(ReadableStream2.prototype.pipeTo, "pipeTo"), n(ReadableStream2.prototype.tee, "tee"), n(ReadableStream2.prototype.values, "values"), typeof e.toStringTag == "symbol" && Object.defineProperty(ReadableStream2.prototype, e.toStringTag, { value: "ReadableStream", configurable: true }), typeof e.asyncIterator == "symbol" && Object.defineProperty(ReadableStream2.prototype, e.asyncIterator, { value: ReadableStream2.prototype.values, writable: true, configurable: true });
  er = (e2) => e2.byteLength;
  n(er, "size");
  Object.defineProperties(ByteLengthQueuingStrategy.prototype, { highWaterMark: { enumerable: true }, size: { enumerable: true } }), typeof e.toStringTag == "symbol" && Object.defineProperty(ByteLengthQueuingStrategy.prototype, e.toStringTag, { value: "ByteLengthQueuingStrategy", configurable: true });
  or = () => 1;
  n(or, "size");
  Object.defineProperties(CountQueuingStrategy.prototype, { highWaterMark: { enumerable: true }, size: { enumerable: true } }), typeof e.toStringTag == "symbol" && Object.defineProperty(CountQueuingStrategy.prototype, e.toStringTag, { value: "CountQueuingStrategy", configurable: true });
  Object.defineProperties(TransformStream.prototype, { readable: { enumerable: true }, writable: { enumerable: true } }), typeof e.toStringTag == "symbol" && Object.defineProperty(TransformStream.prototype, e.toStringTag, { value: "TransformStream", configurable: true });
  Object.defineProperties(TransformStreamDefaultController.prototype, { enqueue: { enumerable: true }, error: { enumerable: true }, terminate: { enumerable: true }, desiredSize: { enumerable: true } }), n(TransformStreamDefaultController.prototype.enqueue, "enqueue"), n(TransformStreamDefaultController.prototype.error, "error"), n(TransformStreamDefaultController.prototype.terminate, "terminate"), typeof e.toStringTag == "symbol" && Object.defineProperty(TransformStreamDefaultController.prototype, e.toStringTag, { value: "TransformStreamDefaultController", configurable: true });
});

// node_modules/formdata-node/lib/esm/isFunction.js
var isFunction;
var init_isFunction = __esm(() => {
  isFunction = (value) => typeof value === "function";
});

// node_modules/formdata-node/lib/esm/blobHelpers.js
async function* clonePart(part) {
  const end = part.byteOffset + part.byteLength;
  let position = part.byteOffset;
  while (position !== end) {
    const size = Math.min(end - position, CHUNK_SIZE);
    const chunk = part.buffer.slice(position, position + size);
    position += chunk.byteLength;
    yield new Uint8Array(chunk);
  }
}
async function* consumeNodeBlob(blob) {
  let position = 0;
  while (position !== blob.size) {
    const chunk = blob.slice(position, Math.min(blob.size, position + CHUNK_SIZE));
    const buffer = await chunk.arrayBuffer();
    position += buffer.byteLength;
    yield new Uint8Array(buffer);
  }
}
async function* consumeBlobParts(parts, clone = false) {
  for (const part of parts) {
    if (ArrayBuffer.isView(part)) {
      if (clone) {
        yield* clonePart(part);
      } else {
        yield part;
      }
    } else if (isFunction(part.stream)) {
      yield* part.stream();
    } else {
      yield* consumeNodeBlob(part);
    }
  }
}
function* sliceBlob(blobParts, blobSize, start = 0, end) {
  end !== null && end !== undefined || (end = blobSize);
  let relativeStart = start < 0 ? Math.max(blobSize + start, 0) : Math.min(start, blobSize);
  let relativeEnd = end < 0 ? Math.max(blobSize + end, 0) : Math.min(end, blobSize);
  const span = Math.max(relativeEnd - relativeStart, 0);
  let added = 0;
  for (const part of blobParts) {
    if (added >= span) {
      break;
    }
    const partSize = ArrayBuffer.isView(part) ? part.byteLength : part.size;
    if (relativeStart && partSize <= relativeStart) {
      relativeStart -= partSize;
      relativeEnd -= partSize;
    } else {
      let chunk;
      if (ArrayBuffer.isView(part)) {
        chunk = part.subarray(relativeStart, Math.min(partSize, relativeEnd));
        added += chunk.byteLength;
      } else {
        chunk = part.slice(relativeStart, Math.min(partSize, relativeEnd));
        added += chunk.size;
      }
      relativeEnd -= partSize;
      relativeStart = 0;
      yield chunk;
    }
  }
}
var CHUNK_SIZE;
var init_blobHelpers = __esm(() => {
  init_isFunction();
  /*! Based on fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> & David Frank */
  CHUNK_SIZE = 65536;
});

// node_modules/formdata-node/lib/esm/Blob.js
class Blob2 {
  constructor(blobParts = [], options2 = {}) {
    _Blob_parts.set(this, []);
    _Blob_type.set(this, "");
    _Blob_size.set(this, 0);
    options2 !== null && options2 !== undefined || (options2 = {});
    if (typeof blobParts !== "object" || blobParts === null) {
      throw new TypeError("Failed to construct 'Blob': The provided value cannot be converted to a sequence.");
    }
    if (!isFunction(blobParts[Symbol.iterator])) {
      throw new TypeError("Failed to construct 'Blob': The object must have a callable @@iterator property.");
    }
    if (typeof options2 !== "object" && !isFunction(options2)) {
      throw new TypeError("Failed to construct 'Blob': parameter 2 cannot convert to dictionary.");
    }
    const encoder = new TextEncoder;
    for (const raw of blobParts) {
      let part;
      if (ArrayBuffer.isView(raw)) {
        part = new Uint8Array(raw.buffer.slice(raw.byteOffset, raw.byteOffset + raw.byteLength));
      } else if (raw instanceof ArrayBuffer) {
        part = new Uint8Array(raw.slice(0));
      } else if (raw instanceof Blob2) {
        part = raw;
      } else {
        part = encoder.encode(String(raw));
      }
      __classPrivateFieldSet(this, _Blob_size, __classPrivateFieldGet(this, _Blob_size, "f") + (ArrayBuffer.isView(part) ? part.byteLength : part.size), "f");
      __classPrivateFieldGet(this, _Blob_parts, "f").push(part);
    }
    const type = options2.type === undefined ? "" : String(options2.type);
    __classPrivateFieldSet(this, _Blob_type, /^[\x20-\x7E]*$/.test(type) ? type : "", "f");
  }
  static [(_Blob_parts = new WeakMap, _Blob_type = new WeakMap, _Blob_size = new WeakMap, Symbol.hasInstance)](value) {
    return Boolean(value && typeof value === "object" && isFunction(value.constructor) && (isFunction(value.stream) || isFunction(value.arrayBuffer)) && /^(Blob|File)$/.test(value[Symbol.toStringTag]));
  }
  get type() {
    return __classPrivateFieldGet(this, _Blob_type, "f");
  }
  get size() {
    return __classPrivateFieldGet(this, _Blob_size, "f");
  }
  slice(start, end, contentType) {
    return new Blob2(sliceBlob(__classPrivateFieldGet(this, _Blob_parts, "f"), this.size, start, end), {
      type: contentType
    });
  }
  async text() {
    const decoder = new TextDecoder;
    let result = "";
    for await (const chunk of consumeBlobParts(__classPrivateFieldGet(this, _Blob_parts, "f"))) {
      result += decoder.decode(chunk, { stream: true });
    }
    result += decoder.decode();
    return result;
  }
  async arrayBuffer() {
    const view = new Uint8Array(this.size);
    let offset = 0;
    for await (const chunk of consumeBlobParts(__classPrivateFieldGet(this, _Blob_parts, "f"))) {
      view.set(chunk, offset);
      offset += chunk.length;
    }
    return view.buffer;
  }
  stream() {
    const iterator = consumeBlobParts(__classPrivateFieldGet(this, _Blob_parts, "f"), true);
    return new ReadableStream2({
      async pull(controller) {
        const { value, done } = await iterator.next();
        if (done) {
          return queueMicrotask(() => controller.close());
        }
        controller.enqueue(value);
      },
      async cancel() {
        await iterator.return();
      }
    });
  }
  get [Symbol.toStringTag]() {
    return "Blob";
  }
}
var __classPrivateFieldGet, __classPrivateFieldSet, _Blob_parts, _Blob_type, _Blob_size;
var init_Blob = __esm(() => {
  init_ponyfill();
  init_isFunction();
  init_blobHelpers();
  /*! Based on fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> & David Frank */
  __classPrivateFieldGet = function(receiver, state, kind2, f2) {
    if (kind2 === "a" && !f2)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind2 === "m" ? f2 : kind2 === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
  };
  __classPrivateFieldSet = function(receiver, state, value, kind2, f2) {
    if (kind2 === "m")
      throw new TypeError("Private method is not writable");
    if (kind2 === "a" && !f2)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind2 === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
  };
  Object.defineProperties(Blob2.prototype, {
    type: { enumerable: true },
    size: { enumerable: true },
    slice: { enumerable: true },
    stream: { enumerable: true },
    text: { enumerable: true },
    arrayBuffer: { enumerable: true }
  });
});

// node_modules/formdata-node/lib/esm/File.js
class File2 extends Blob2 {
  constructor(fileBits, name, options2 = {}) {
    super(fileBits, options2);
    _File_name.set(this, undefined);
    _File_lastModified.set(this, 0);
    if (arguments.length < 2) {
      throw new TypeError("Failed to construct 'File': 2 arguments required, " + `but only ${arguments.length} present.`);
    }
    __classPrivateFieldSet2(this, _File_name, String(name), "f");
    const lastModified = options2.lastModified === undefined ? Date.now() : Number(options2.lastModified);
    if (!Number.isNaN(lastModified)) {
      __classPrivateFieldSet2(this, _File_lastModified, lastModified, "f");
    }
  }
  static [(_File_name = new WeakMap, _File_lastModified = new WeakMap, Symbol.hasInstance)](value) {
    return value instanceof Blob2 && value[Symbol.toStringTag] === "File" && typeof value.name === "string";
  }
  get name() {
    return __classPrivateFieldGet2(this, _File_name, "f");
  }
  get lastModified() {
    return __classPrivateFieldGet2(this, _File_lastModified, "f");
  }
  get webkitRelativePath() {
    return "";
  }
  get [Symbol.toStringTag]() {
    return "File";
  }
}
var __classPrivateFieldSet2, __classPrivateFieldGet2, _File_name, _File_lastModified;
var init_File = __esm(() => {
  init_Blob();
  __classPrivateFieldSet2 = function(receiver, state, value, kind2, f2) {
    if (kind2 === "m")
      throw new TypeError("Private method is not writable");
    if (kind2 === "a" && !f2)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind2 === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
  };
  __classPrivateFieldGet2 = function(receiver, state, kind2, f2) {
    if (kind2 === "a" && !f2)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind2 === "m" ? f2 : kind2 === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
  };
});

// node_modules/formdata-node/lib/esm/isFile.js
var isFile;
var init_isFile = __esm(() => {
  init_File();
  isFile = (value) => value instanceof File2;
});

// node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var parse = function(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n2 = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n2 * y2;
      case "weeks":
      case "week":
      case "w":
        return n2 * w2;
      case "days":
      case "day":
      case "d":
        return n2 * d2;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n2 * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n2 * m2;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n2 * s2;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n2;
      default:
        return;
    }
  };
  var fmtShort = function(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d2) {
      return Math.round(ms / d2) + "d";
    }
    if (msAbs >= h2) {
      return Math.round(ms / h2) + "h";
    }
    if (msAbs >= m2) {
      return Math.round(ms / m2) + "m";
    }
    if (msAbs >= s2) {
      return Math.round(ms / s2) + "s";
    }
    return ms + "ms";
  };
  var fmtLong = function(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d2) {
      return plural(ms, msAbs, d2, "day");
    }
    if (msAbs >= h2) {
      return plural(ms, msAbs, h2, "hour");
    }
    if (msAbs >= m2) {
      return plural(ms, msAbs, m2, "minute");
    }
    if (msAbs >= s2) {
      return plural(ms, msAbs, s2, "second");
    }
    return ms + " ms";
  };
  var plural = function(ms, msAbs, n2, name) {
    var isPlural = msAbs >= n2 * 1.5;
    return Math.round(ms / n2) + " " + name + (isPlural ? "s" : "");
  };
  var s2 = 1000;
  var m2 = s2 * 60;
  var h2 = m2 * 60;
  var d2 = h2 * 24;
  var w2 = d2 * 7;
  var y2 = d2 * 365.25;
  module.exports = function(val, options2) {
    options2 = options2 || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isFinite(val)) {
      return options2.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
});

// node_modules/humanize-ms/index.js
var require_humanize_ms = __commonJS((exports, module) => {
  /*!
   * humanize-ms - index.js
   * Copyright(c) 2014 dead_horse <dead_horse@qq.com>
   * MIT Licensed
   */
  var util = __require("util");
  var ms = require_ms();
  module.exports = function(t2) {
    if (typeof t2 === "number")
      return t2;
    var r2 = ms(t2);
    if (r2 === undefined) {
      var err = new Error(util.format("humanize-ms(%j) result undefined", t2));
      console.warn(err.stack);
    }
    return r2;
  };
});

// node_modules/agentkeepalive/lib/constants.js
var require_constants = __commonJS((exports, module) => {
  module.exports = {
    CURRENT_ID: Symbol("agentkeepalive#currentId"),
    CREATE_ID: Symbol("agentkeepalive#createId"),
    INIT_SOCKET: Symbol("agentkeepalive#initSocket"),
    CREATE_HTTPS_CONNECTION: Symbol("agentkeepalive#createHttpsConnection"),
    SOCKET_CREATED_TIME: Symbol("agentkeepalive#socketCreatedTime"),
    SOCKET_NAME: Symbol("agentkeepalive#socketName"),
    SOCKET_REQUEST_COUNT: Symbol("agentkeepalive#socketRequestCount"),
    SOCKET_REQUEST_FINISHED_COUNT: Symbol("agentkeepalive#socketRequestFinishedCount")
  };
});

// node_modules/agentkeepalive/lib/agent.js
var require_agent = __commonJS((exports, module) => {
  var deprecate2 = function(message) {
    console.log("[agentkeepalive:deprecated] %s", message);
  };
  var getSocketTimeout = function(socket) {
    return socket.timeout || socket._idleTimeout;
  };
  var installListeners = function(agent, socket, options2) {
    debug("%s create, timeout %sms", socket[SOCKET_NAME], getSocketTimeout(socket));
    function onFree() {
      if (!socket._httpMessage && socket[SOCKET_REQUEST_COUNT] === 1)
        return;
      socket[SOCKET_REQUEST_FINISHED_COUNT]++;
      agent.requestCount++;
      debug("%s(requests: %s, finished: %s) free", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);
      const name = agent.getName(options2);
      if (socket.writable && agent.requests[name] && agent.requests[name].length) {
        socket[SOCKET_REQUEST_COUNT]++;
        debug("%s(requests: %s, finished: %s) will be reuse on agent free event", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);
      }
    }
    socket.on("free", onFree);
    function onClose(isError) {
      debug("%s(requests: %s, finished: %s) close, isError: %s", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], isError);
      agent.closeSocketCount++;
    }
    socket.on("close", onClose);
    function onTimeout() {
      const listenerCount = socket.listeners("timeout").length;
      const timeout = getSocketTimeout(socket);
      const req = socket._httpMessage;
      const reqTimeoutListenerCount = req && req.listeners("timeout").length || 0;
      debug("%s(requests: %s, finished: %s) timeout after %sms, listeners %s, defaultTimeoutListenerCount %s, hasHttpRequest %s, HttpRequest timeoutListenerCount %s", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], timeout, listenerCount, defaultTimeoutListenerCount, !!req, reqTimeoutListenerCount);
      if (debug.enabled) {
        debug("timeout listeners: %s", socket.listeners("timeout").map((f2) => f2.name).join(", "));
      }
      agent.timeoutSocketCount++;
      const name = agent.getName(options2);
      if (agent.freeSockets[name] && agent.freeSockets[name].indexOf(socket) !== -1) {
        socket.destroy();
        agent.removeSocket(socket, options2);
        debug("%s is free, destroy quietly", socket[SOCKET_NAME]);
      } else {
        if (reqTimeoutListenerCount === 0) {
          const error = new Error("Socket timeout");
          error.code = "ERR_SOCKET_TIMEOUT";
          error.timeout = timeout;
          socket.destroy(error);
          agent.removeSocket(socket, options2);
          debug("%s destroy with timeout error", socket[SOCKET_NAME]);
        }
      }
    }
    socket.on("timeout", onTimeout);
    function onError(err) {
      const listenerCount = socket.listeners("error").length;
      debug("%s(requests: %s, finished: %s) error: %s, listenerCount: %s", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], err, listenerCount);
      agent.errorSocketCount++;
      if (listenerCount === 1) {
        debug("%s emit uncaught error event", socket[SOCKET_NAME]);
        socket.removeListener("error", onError);
        socket.emit("error", err);
      }
    }
    socket.on("error", onError);
    function onRemove() {
      debug("%s(requests: %s, finished: %s) agentRemove", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);
      socket.removeListener("close", onClose);
      socket.removeListener("error", onError);
      socket.removeListener("free", onFree);
      socket.removeListener("timeout", onTimeout);
      socket.removeListener("agentRemove", onRemove);
    }
    socket.on("agentRemove", onRemove);
  };
  var inspect2 = function(obj) {
    const res = {};
    for (const key in obj) {
      res[key] = obj[key].length;
    }
    return res;
  };
  var OriginalAgent = __require("http").Agent;
  var ms = require_humanize_ms();
  var debug = __require("util").debuglog("agentkeepalive");
  var {
    INIT_SOCKET,
    CURRENT_ID,
    CREATE_ID,
    SOCKET_CREATED_TIME,
    SOCKET_NAME,
    SOCKET_REQUEST_COUNT,
    SOCKET_REQUEST_FINISHED_COUNT
  } = require_constants();
  var defaultTimeoutListenerCount = 1;
  var majorVersion = parseInt(process.version.split(".", 1)[0].substring(1));
  if (majorVersion >= 11 && majorVersion <= 12) {
    defaultTimeoutListenerCount = 2;
  } else if (majorVersion >= 13) {
    defaultTimeoutListenerCount = 3;
  }

  class Agent extends OriginalAgent {
    constructor(options2) {
      options2 = options2 || {};
      options2.keepAlive = options2.keepAlive !== false;
      if (options2.freeSocketTimeout === undefined) {
        options2.freeSocketTimeout = 4000;
      }
      if (options2.keepAliveTimeout) {
        deprecate2("options.keepAliveTimeout is deprecated, please use options.freeSocketTimeout instead");
        options2.freeSocketTimeout = options2.keepAliveTimeout;
        delete options2.keepAliveTimeout;
      }
      if (options2.freeSocketKeepAliveTimeout) {
        deprecate2("options.freeSocketKeepAliveTimeout is deprecated, please use options.freeSocketTimeout instead");
        options2.freeSocketTimeout = options2.freeSocketKeepAliveTimeout;
        delete options2.freeSocketKeepAliveTimeout;
      }
      if (options2.timeout === undefined) {
        options2.timeout = Math.max(options2.freeSocketTimeout * 2, 8000);
      }
      options2.timeout = ms(options2.timeout);
      options2.freeSocketTimeout = ms(options2.freeSocketTimeout);
      options2.socketActiveTTL = options2.socketActiveTTL ? ms(options2.socketActiveTTL) : 0;
      super(options2);
      this[CURRENT_ID] = 0;
      this.createSocketCount = 0;
      this.createSocketCountLastCheck = 0;
      this.createSocketErrorCount = 0;
      this.createSocketErrorCountLastCheck = 0;
      this.closeSocketCount = 0;
      this.closeSocketCountLastCheck = 0;
      this.errorSocketCount = 0;
      this.errorSocketCountLastCheck = 0;
      this.requestCount = 0;
      this.requestCountLastCheck = 0;
      this.timeoutSocketCount = 0;
      this.timeoutSocketCountLastCheck = 0;
      this.on("free", (socket) => {
        const timeout = this.calcSocketTimeout(socket);
        if (timeout > 0 && socket.timeout !== timeout) {
          socket.setTimeout(timeout);
        }
      });
    }
    get freeSocketKeepAliveTimeout() {
      deprecate2("agent.freeSocketKeepAliveTimeout is deprecated, please use agent.options.freeSocketTimeout instead");
      return this.options.freeSocketTimeout;
    }
    get timeout() {
      deprecate2("agent.timeout is deprecated, please use agent.options.timeout instead");
      return this.options.timeout;
    }
    get socketActiveTTL() {
      deprecate2("agent.socketActiveTTL is deprecated, please use agent.options.socketActiveTTL instead");
      return this.options.socketActiveTTL;
    }
    calcSocketTimeout(socket) {
      let freeSocketTimeout = this.options.freeSocketTimeout;
      const socketActiveTTL = this.options.socketActiveTTL;
      if (socketActiveTTL) {
        const aliveTime = Date.now() - socket[SOCKET_CREATED_TIME];
        const diff = socketActiveTTL - aliveTime;
        if (diff <= 0) {
          return diff;
        }
        if (freeSocketTimeout && diff < freeSocketTimeout) {
          freeSocketTimeout = diff;
        }
      }
      if (freeSocketTimeout) {
        const customFreeSocketTimeout = socket.freeSocketTimeout || socket.freeSocketKeepAliveTimeout;
        return customFreeSocketTimeout || freeSocketTimeout;
      }
    }
    keepSocketAlive(socket) {
      const result = super.keepSocketAlive(socket);
      if (!result)
        return result;
      const customTimeout = this.calcSocketTimeout(socket);
      if (typeof customTimeout === "undefined") {
        return true;
      }
      if (customTimeout <= 0) {
        debug("%s(requests: %s, finished: %s) free but need to destroy by TTL, request count %s, diff is %s", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], customTimeout);
        return false;
      }
      if (socket.timeout !== customTimeout) {
        socket.setTimeout(customTimeout);
      }
      return true;
    }
    reuseSocket(...args) {
      super.reuseSocket(...args);
      const socket = args[0];
      const req = args[1];
      req.reusedSocket = true;
      const agentTimeout = this.options.timeout;
      if (getSocketTimeout(socket) !== agentTimeout) {
        socket.setTimeout(agentTimeout);
        debug("%s reset timeout to %sms", socket[SOCKET_NAME], agentTimeout);
      }
      socket[SOCKET_REQUEST_COUNT]++;
      debug("%s(requests: %s, finished: %s) reuse on addRequest, timeout %sms", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], getSocketTimeout(socket));
    }
    [CREATE_ID]() {
      const id = this[CURRENT_ID]++;
      if (this[CURRENT_ID] === Number.MAX_SAFE_INTEGER)
        this[CURRENT_ID] = 0;
      return id;
    }
    [INIT_SOCKET](socket, options2) {
      if (options2.timeout) {
        const timeout = getSocketTimeout(socket);
        if (!timeout) {
          socket.setTimeout(options2.timeout);
        }
      }
      if (this.options.keepAlive) {
        socket.setNoDelay(true);
      }
      this.createSocketCount++;
      if (this.options.socketActiveTTL) {
        socket[SOCKET_CREATED_TIME] = Date.now();
      }
      socket[SOCKET_NAME] = `sock[${this[CREATE_ID]()}#${options2._agentKey}]`.split("-----BEGIN", 1)[0];
      socket[SOCKET_REQUEST_COUNT] = 1;
      socket[SOCKET_REQUEST_FINISHED_COUNT] = 0;
      installListeners(this, socket, options2);
    }
    createConnection(options2, oncreate) {
      let called = false;
      const onNewCreate = (err, socket) => {
        if (called)
          return;
        called = true;
        if (err) {
          this.createSocketErrorCount++;
          return oncreate(err);
        }
        this[INIT_SOCKET](socket, options2);
        oncreate(err, socket);
      };
      const newSocket = super.createConnection(options2, onNewCreate);
      if (newSocket)
        onNewCreate(null, newSocket);
      return newSocket;
    }
    get statusChanged() {
      const changed = this.createSocketCount !== this.createSocketCountLastCheck || this.createSocketErrorCount !== this.createSocketErrorCountLastCheck || this.closeSocketCount !== this.closeSocketCountLastCheck || this.errorSocketCount !== this.errorSocketCountLastCheck || this.timeoutSocketCount !== this.timeoutSocketCountLastCheck || this.requestCount !== this.requestCountLastCheck;
      if (changed) {
        this.createSocketCountLastCheck = this.createSocketCount;
        this.createSocketErrorCountLastCheck = this.createSocketErrorCount;
        this.closeSocketCountLastCheck = this.closeSocketCount;
        this.errorSocketCountLastCheck = this.errorSocketCount;
        this.timeoutSocketCountLastCheck = this.timeoutSocketCount;
        this.requestCountLastCheck = this.requestCount;
      }
      return changed;
    }
    getCurrentStatus() {
      return {
        createSocketCount: this.createSocketCount,
        createSocketErrorCount: this.createSocketErrorCount,
        closeSocketCount: this.closeSocketCount,
        errorSocketCount: this.errorSocketCount,
        timeoutSocketCount: this.timeoutSocketCount,
        requestCount: this.requestCount,
        freeSockets: inspect2(this.freeSockets),
        sockets: inspect2(this.sockets),
        requests: inspect2(this.requests)
      };
    }
  }
  module.exports = Agent;
});

// node_modules/agentkeepalive/lib/https_agent.js
var require_https_agent = __commonJS((exports, module) => {
  var OriginalHttpsAgent = __require("https").Agent;
  var HttpAgent = require_agent();
  var {
    INIT_SOCKET,
    CREATE_HTTPS_CONNECTION
  } = require_constants();

  class HttpsAgent extends HttpAgent {
    constructor(options2) {
      super(options2);
      this.defaultPort = 443;
      this.protocol = "https:";
      this.maxCachedSessions = this.options.maxCachedSessions;
      if (this.maxCachedSessions === undefined) {
        this.maxCachedSessions = 100;
      }
      this._sessionCache = {
        map: {},
        list: []
      };
    }
    createConnection(options2, oncreate) {
      const socket = this[CREATE_HTTPS_CONNECTION](options2, oncreate);
      this[INIT_SOCKET](socket, options2);
      return socket;
    }
  }
  HttpsAgent.prototype[CREATE_HTTPS_CONNECTION] = OriginalHttpsAgent.prototype.createConnection;
  [
    "getName",
    "_getSession",
    "_cacheSession",
    "_evictSession"
  ].forEach(function(method) {
    if (typeof OriginalHttpsAgent.prototype[method] === "function") {
      HttpsAgent.prototype[method] = OriginalHttpsAgent.prototype[method];
    }
  });
  module.exports = HttpsAgent;
});

// node_modules/agentkeepalive/index.js
var require_agentkeepalive = __commonJS((exports, module) => {
  module.exports = require_agent();
  module.exports.HttpsAgent = require_https_agent();
  module.exports.constants = require_constants();
});

// node_modules/event-target-shim/dist/event-target-shim.js
var require_event_target_shim = __commonJS((exports, module) => {
  var pd = function(event) {
    const retv = privateData.get(event);
    console.assert(retv != null, "'this' is expected an Event object, but got", event);
    return retv;
  };
  var setCancelFlag = function(data) {
    if (data.passiveListener != null) {
      if (typeof console !== "undefined" && typeof console.error === "function") {
        console.error("Unable to preventDefault inside passive event listener invocation.", data.passiveListener);
      }
      return;
    }
    if (!data.event.cancelable) {
      return;
    }
    data.canceled = true;
    if (typeof data.event.preventDefault === "function") {
      data.event.preventDefault();
    }
  };
  var Event = function(eventTarget, event) {
    privateData.set(this, {
      eventTarget,
      event,
      eventPhase: 2,
      currentTarget: eventTarget,
      canceled: false,
      stopped: false,
      immediateStopped: false,
      passiveListener: null,
      timeStamp: event.timeStamp || Date.now()
    });
    Object.defineProperty(this, "isTrusted", { value: false, enumerable: true });
    const keys = Object.keys(event);
    for (let i2 = 0;i2 < keys.length; ++i2) {
      const key = keys[i2];
      if (!(key in this)) {
        Object.defineProperty(this, key, defineRedirectDescriptor(key));
      }
    }
  };
  var defineRedirectDescriptor = function(key) {
    return {
      get() {
        return pd(this).event[key];
      },
      set(value) {
        pd(this).event[key] = value;
      },
      configurable: true,
      enumerable: true
    };
  };
  var defineCallDescriptor = function(key) {
    return {
      value() {
        const event = pd(this).event;
        return event[key].apply(event, arguments);
      },
      configurable: true,
      enumerable: true
    };
  };
  var defineWrapper = function(BaseEvent, proto) {
    const keys = Object.keys(proto);
    if (keys.length === 0) {
      return BaseEvent;
    }
    function CustomEvent(eventTarget, event) {
      BaseEvent.call(this, eventTarget, event);
    }
    CustomEvent.prototype = Object.create(BaseEvent.prototype, {
      constructor: { value: CustomEvent, configurable: true, writable: true }
    });
    for (let i2 = 0;i2 < keys.length; ++i2) {
      const key = keys[i2];
      if (!(key in BaseEvent.prototype)) {
        const descriptor = Object.getOwnPropertyDescriptor(proto, key);
        const isFunc = typeof descriptor.value === "function";
        Object.defineProperty(CustomEvent.prototype, key, isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key));
      }
    }
    return CustomEvent;
  };
  var getWrapper = function(proto) {
    if (proto == null || proto === Object.prototype) {
      return Event;
    }
    let wrapper = wrappers.get(proto);
    if (wrapper == null) {
      wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);
      wrappers.set(proto, wrapper);
    }
    return wrapper;
  };
  var wrapEvent = function(eventTarget, event) {
    const Wrapper = getWrapper(Object.getPrototypeOf(event));
    return new Wrapper(eventTarget, event);
  };
  var isStopped = function(event) {
    return pd(event).immediateStopped;
  };
  var setEventPhase = function(event, eventPhase) {
    pd(event).eventPhase = eventPhase;
  };
  var setCurrentTarget = function(event, currentTarget) {
    pd(event).currentTarget = currentTarget;
  };
  var setPassiveListener = function(event, passiveListener) {
    pd(event).passiveListener = passiveListener;
  };
  var isObject = function(x2) {
    return x2 !== null && typeof x2 === "object";
  };
  var getListeners = function(eventTarget) {
    const listeners = listenersMap.get(eventTarget);
    if (listeners == null) {
      throw new TypeError("'this' is expected an EventTarget object, but got another value.");
    }
    return listeners;
  };
  var defineEventAttributeDescriptor = function(eventName) {
    return {
      get() {
        const listeners = getListeners(this);
        let node = listeners.get(eventName);
        while (node != null) {
          if (node.listenerType === ATTRIBUTE) {
            return node.listener;
          }
          node = node.next;
        }
        return null;
      },
      set(listener) {
        if (typeof listener !== "function" && !isObject(listener)) {
          listener = null;
        }
        const listeners = getListeners(this);
        let prev = null;
        let node = listeners.get(eventName);
        while (node != null) {
          if (node.listenerType === ATTRIBUTE) {
            if (prev !== null) {
              prev.next = node.next;
            } else if (node.next !== null) {
              listeners.set(eventName, node.next);
            } else {
              listeners.delete(eventName);
            }
          } else {
            prev = node;
          }
          node = node.next;
        }
        if (listener !== null) {
          const newNode = {
            listener,
            listenerType: ATTRIBUTE,
            passive: false,
            once: false,
            next: null
          };
          if (prev === null) {
            listeners.set(eventName, newNode);
          } else {
            prev.next = newNode;
          }
        }
      },
      configurable: true,
      enumerable: true
    };
  };
  var defineEventAttribute = function(eventTargetPrototype, eventName) {
    Object.defineProperty(eventTargetPrototype, `on${eventName}`, defineEventAttributeDescriptor(eventName));
  };
  var defineCustomEventTarget = function(eventNames) {
    function CustomEventTarget() {
      EventTarget.call(this);
    }
    CustomEventTarget.prototype = Object.create(EventTarget.prototype, {
      constructor: {
        value: CustomEventTarget,
        configurable: true,
        writable: true
      }
    });
    for (let i2 = 0;i2 < eventNames.length; ++i2) {
      defineEventAttribute(CustomEventTarget.prototype, eventNames[i2]);
    }
    return CustomEventTarget;
  };
  var EventTarget = function() {
    if (this instanceof EventTarget) {
      listenersMap.set(this, new Map);
      return;
    }
    if (arguments.length === 1 && Array.isArray(arguments[0])) {
      return defineCustomEventTarget(arguments[0]);
    }
    if (arguments.length > 0) {
      const types = new Array(arguments.length);
      for (let i2 = 0;i2 < arguments.length; ++i2) {
        types[i2] = arguments[i2];
      }
      return defineCustomEventTarget(types);
    }
    throw new TypeError("Cannot call a class as a function");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var privateData = new WeakMap;
  var wrappers = new WeakMap;
  Event.prototype = {
    get type() {
      return pd(this).event.type;
    },
    get target() {
      return pd(this).eventTarget;
    },
    get currentTarget() {
      return pd(this).currentTarget;
    },
    composedPath() {
      const currentTarget = pd(this).currentTarget;
      if (currentTarget == null) {
        return [];
      }
      return [currentTarget];
    },
    get NONE() {
      return 0;
    },
    get CAPTURING_PHASE() {
      return 1;
    },
    get AT_TARGET() {
      return 2;
    },
    get BUBBLING_PHASE() {
      return 3;
    },
    get eventPhase() {
      return pd(this).eventPhase;
    },
    stopPropagation() {
      const data = pd(this);
      data.stopped = true;
      if (typeof data.event.stopPropagation === "function") {
        data.event.stopPropagation();
      }
    },
    stopImmediatePropagation() {
      const data = pd(this);
      data.stopped = true;
      data.immediateStopped = true;
      if (typeof data.event.stopImmediatePropagation === "function") {
        data.event.stopImmediatePropagation();
      }
    },
    get bubbles() {
      return Boolean(pd(this).event.bubbles);
    },
    get cancelable() {
      return Boolean(pd(this).event.cancelable);
    },
    preventDefault() {
      setCancelFlag(pd(this));
    },
    get defaultPrevented() {
      return pd(this).canceled;
    },
    get composed() {
      return Boolean(pd(this).event.composed);
    },
    get timeStamp() {
      return pd(this).timeStamp;
    },
    get srcElement() {
      return pd(this).eventTarget;
    },
    get cancelBubble() {
      return pd(this).stopped;
    },
    set cancelBubble(value) {
      if (!value) {
        return;
      }
      const data = pd(this);
      data.stopped = true;
      if (typeof data.event.cancelBubble === "boolean") {
        data.event.cancelBubble = true;
      }
    },
    get returnValue() {
      return !pd(this).canceled;
    },
    set returnValue(value) {
      if (!value) {
        setCancelFlag(pd(this));
      }
    },
    initEvent() {
    }
  };
  Object.defineProperty(Event.prototype, "constructor", {
    value: Event,
    configurable: true,
    writable: true
  });
  if (typeof window !== "undefined" && typeof window.Event !== "undefined") {
    Object.setPrototypeOf(Event.prototype, window.Event.prototype);
    wrappers.set(window.Event.prototype, Event);
  }
  var listenersMap = new WeakMap;
  var CAPTURE = 1;
  var BUBBLE = 2;
  var ATTRIBUTE = 3;
  EventTarget.prototype = {
    addEventListener(eventName, listener, options2) {
      if (listener == null) {
        return;
      }
      if (typeof listener !== "function" && !isObject(listener)) {
        throw new TypeError("'listener' should be a function or an object.");
      }
      const listeners = getListeners(this);
      const optionsIsObj = isObject(options2);
      const capture = optionsIsObj ? Boolean(options2.capture) : Boolean(options2);
      const listenerType = capture ? CAPTURE : BUBBLE;
      const newNode = {
        listener,
        listenerType,
        passive: optionsIsObj && Boolean(options2.passive),
        once: optionsIsObj && Boolean(options2.once),
        next: null
      };
      let node = listeners.get(eventName);
      if (node === undefined) {
        listeners.set(eventName, newNode);
        return;
      }
      let prev = null;
      while (node != null) {
        if (node.listener === listener && node.listenerType === listenerType) {
          return;
        }
        prev = node;
        node = node.next;
      }
      prev.next = newNode;
    },
    removeEventListener(eventName, listener, options2) {
      if (listener == null) {
        return;
      }
      const listeners = getListeners(this);
      const capture = isObject(options2) ? Boolean(options2.capture) : Boolean(options2);
      const listenerType = capture ? CAPTURE : BUBBLE;
      let prev = null;
      let node = listeners.get(eventName);
      while (node != null) {
        if (node.listener === listener && node.listenerType === listenerType) {
          if (prev !== null) {
            prev.next = node.next;
          } else if (node.next !== null) {
            listeners.set(eventName, node.next);
          } else {
            listeners.delete(eventName);
          }
          return;
        }
        prev = node;
        node = node.next;
      }
    },
    dispatchEvent(event) {
      if (event == null || typeof event.type !== "string") {
        throw new TypeError('"event.type" should be a string.');
      }
      const listeners = getListeners(this);
      const eventName = event.type;
      let node = listeners.get(eventName);
      if (node == null) {
        return true;
      }
      const wrappedEvent = wrapEvent(this, event);
      let prev = null;
      while (node != null) {
        if (node.once) {
          if (prev !== null) {
            prev.next = node.next;
          } else if (node.next !== null) {
            listeners.set(eventName, node.next);
          } else {
            listeners.delete(eventName);
          }
        } else {
          prev = node;
        }
        setPassiveListener(wrappedEvent, node.passive ? node.listener : null);
        if (typeof node.listener === "function") {
          try {
            node.listener.call(this, wrappedEvent);
          } catch (err) {
            if (typeof console !== "undefined" && typeof console.error === "function") {
              console.error(err);
            }
          }
        } else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === "function") {
          node.listener.handleEvent(wrappedEvent);
        }
        if (isStopped(wrappedEvent)) {
          break;
        }
        node = node.next;
      }
      setPassiveListener(wrappedEvent, null);
      setEventPhase(wrappedEvent, 0);
      setCurrentTarget(wrappedEvent, null);
      return !wrappedEvent.defaultPrevented;
    }
  };
  Object.defineProperty(EventTarget.prototype, "constructor", {
    value: EventTarget,
    configurable: true,
    writable: true
  });
  if (typeof window !== "undefined" && typeof window.EventTarget !== "undefined") {
    Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
  }
  exports.defineEventAttribute = defineEventAttribute;
  exports.EventTarget = EventTarget;
  exports.default = EventTarget;
  module.exports = EventTarget;
  module.exports.EventTarget = module.exports["default"] = EventTarget;
  module.exports.defineEventAttribute = defineEventAttribute;
});

// node_modules/abort-controller/dist/abort-controller.js
var require_abort_controller = __commonJS((exports, module) => {
  var createAbortSignal = function() {
    const signal = Object.create(AbortSignal.prototype);
    eventTargetShim.EventTarget.call(signal);
    abortedFlags.set(signal, false);
    return signal;
  };
  var abortSignal = function(signal) {
    if (abortedFlags.get(signal) !== false) {
      return;
    }
    abortedFlags.set(signal, true);
    signal.dispatchEvent({ type: "abort" });
  };
  var getSignal = function(controller) {
    const signal = signals.get(controller);
    if (signal == null) {
      throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? "null" : typeof controller}`);
    }
    return signal;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var eventTargetShim = require_event_target_shim();

  class AbortSignal extends eventTargetShim.EventTarget {
    constructor() {
      super();
      throw new TypeError("AbortSignal cannot be constructed directly");
    }
    get aborted() {
      const aborted = abortedFlags.get(this);
      if (typeof aborted !== "boolean") {
        throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
      }
      return aborted;
    }
  }
  eventTargetShim.defineEventAttribute(AbortSignal.prototype, "abort");
  var abortedFlags = new WeakMap;
  Object.defineProperties(AbortSignal.prototype, {
    aborted: { enumerable: true }
  });
  if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
    Object.defineProperty(AbortSignal.prototype, Symbol.toStringTag, {
      configurable: true,
      value: "AbortSignal"
    });
  }

  class AbortController2 {
    constructor() {
      signals.set(this, createAbortSignal());
    }
    get signal() {
      return getSignal(this);
    }
    abort() {
      abortSignal(getSignal(this));
    }
  }
  var signals = new WeakMap;
  Object.defineProperties(AbortController2.prototype, {
    signal: { enumerable: true },
    abort: { enumerable: true }
  });
  if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
    Object.defineProperty(AbortController2.prototype, Symbol.toStringTag, {
      configurable: true,
      value: "AbortController"
    });
  }
  exports.AbortController = AbortController2;
  exports.AbortSignal = AbortSignal;
  exports.default = AbortController2;
  module.exports = AbortController2;
  module.exports.AbortController = module.exports["default"] = AbortController2;
  module.exports.AbortSignal = AbortSignal;
});

// node_modules/web-streams-polyfill/dist/ponyfill.es2018.js
var require_ponyfill_es2018 = __commonJS((exports, module) => {
  (function(global2, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.WebStreamsPolyfill = {}));
  })(exports, function(exports2) {
    const SymbolPolyfill = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol : (description) => `Symbol(${description})`;
    function noop() {
      return;
    }
    function getGlobals() {
      if (typeof self !== "undefined") {
        return self;
      } else if (typeof window !== "undefined") {
        return window;
      } else if (typeof global !== "undefined") {
        return global;
      }
      return;
    }
    const globals = getGlobals();
    function typeIsObject(x2) {
      return typeof x2 === "object" && x2 !== null || typeof x2 === "function";
    }
    const rethrowAssertionErrorRejection = noop;
    const originalPromise = Promise;
    const originalPromiseThen = Promise.prototype.then;
    const originalPromiseResolve = Promise.resolve.bind(originalPromise);
    const originalPromiseReject = Promise.reject.bind(originalPromise);
    function newPromise(executor) {
      return new originalPromise(executor);
    }
    function promiseResolvedWith(value) {
      return originalPromiseResolve(value);
    }
    function promiseRejectedWith(reason) {
      return originalPromiseReject(reason);
    }
    function PerformPromiseThen(promise, onFulfilled, onRejected) {
      return originalPromiseThen.call(promise, onFulfilled, onRejected);
    }
    function uponPromise(promise, onFulfilled, onRejected) {
      PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), undefined, rethrowAssertionErrorRejection);
    }
    function uponFulfillment(promise, onFulfilled) {
      uponPromise(promise, onFulfilled);
    }
    function uponRejection(promise, onRejected) {
      uponPromise(promise, undefined, onRejected);
    }
    function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
      return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
    }
    function setPromiseIsHandledToTrue(promise) {
      PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection);
    }
    const queueMicrotask2 = (() => {
      const globalQueueMicrotask = globals && globals.queueMicrotask;
      if (typeof globalQueueMicrotask === "function") {
        return globalQueueMicrotask;
      }
      const resolvedPromise = promiseResolvedWith(undefined);
      return (fn) => PerformPromiseThen(resolvedPromise, fn);
    })();
    function reflectCall(F2, V2, args) {
      if (typeof F2 !== "function") {
        throw new TypeError("Argument is not a function");
      }
      return Function.prototype.apply.call(F2, V2, args);
    }
    function promiseCall(F2, V2, args) {
      try {
        return promiseResolvedWith(reflectCall(F2, V2, args));
      } catch (value) {
        return promiseRejectedWith(value);
      }
    }
    const QUEUE_MAX_ARRAY_SIZE = 16384;

    class SimpleQueue {
      constructor() {
        this._cursor = 0;
        this._size = 0;
        this._front = {
          _elements: [],
          _next: undefined
        };
        this._back = this._front;
        this._cursor = 0;
        this._size = 0;
      }
      get length() {
        return this._size;
      }
      push(element) {
        const oldBack = this._back;
        let newBack = oldBack;
        if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
          newBack = {
            _elements: [],
            _next: undefined
          };
        }
        oldBack._elements.push(element);
        if (newBack !== oldBack) {
          this._back = newBack;
          oldBack._next = newBack;
        }
        ++this._size;
      }
      shift() {
        const oldFront = this._front;
        let newFront = oldFront;
        const oldCursor = this._cursor;
        let newCursor = oldCursor + 1;
        const elements = oldFront._elements;
        const element = elements[oldCursor];
        if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
          newFront = oldFront._next;
          newCursor = 0;
        }
        --this._size;
        this._cursor = newCursor;
        if (oldFront !== newFront) {
          this._front = newFront;
        }
        elements[oldCursor] = undefined;
        return element;
      }
      forEach(callback) {
        let i2 = this._cursor;
        let node = this._front;
        let elements = node._elements;
        while (i2 !== elements.length || node._next !== undefined) {
          if (i2 === elements.length) {
            node = node._next;
            elements = node._elements;
            i2 = 0;
            if (elements.length === 0) {
              break;
            }
          }
          callback(elements[i2]);
          ++i2;
        }
      }
      peek() {
        const front = this._front;
        const cursor = this._cursor;
        return front._elements[cursor];
      }
    }
    function ReadableStreamReaderGenericInitialize(reader, stream) {
      reader._ownerReadableStream = stream;
      stream._reader = reader;
      if (stream._state === "readable") {
        defaultReaderClosedPromiseInitialize(reader);
      } else if (stream._state === "closed") {
        defaultReaderClosedPromiseInitializeAsResolved(reader);
      } else {
        defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
      }
    }
    function ReadableStreamReaderGenericCancel(reader, reason) {
      const stream = reader._ownerReadableStream;
      return ReadableStreamCancel(stream, reason);
    }
    function ReadableStreamReaderGenericRelease(reader) {
      if (reader._ownerReadableStream._state === "readable") {
        defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
      } else {
        defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
      }
      reader._ownerReadableStream._reader = undefined;
      reader._ownerReadableStream = undefined;
    }
    function readerLockException(name) {
      return new TypeError("Cannot " + name + " a stream using a released reader");
    }
    function defaultReaderClosedPromiseInitialize(reader) {
      reader._closedPromise = newPromise((resolve, reject) => {
        reader._closedPromise_resolve = resolve;
        reader._closedPromise_reject = reject;
      });
    }
    function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
      defaultReaderClosedPromiseInitialize(reader);
      defaultReaderClosedPromiseReject(reader, reason);
    }
    function defaultReaderClosedPromiseInitializeAsResolved(reader) {
      defaultReaderClosedPromiseInitialize(reader);
      defaultReaderClosedPromiseResolve(reader);
    }
    function defaultReaderClosedPromiseReject(reader, reason) {
      if (reader._closedPromise_reject === undefined) {
        return;
      }
      setPromiseIsHandledToTrue(reader._closedPromise);
      reader._closedPromise_reject(reason);
      reader._closedPromise_resolve = undefined;
      reader._closedPromise_reject = undefined;
    }
    function defaultReaderClosedPromiseResetToRejected(reader, reason) {
      defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
    }
    function defaultReaderClosedPromiseResolve(reader) {
      if (reader._closedPromise_resolve === undefined) {
        return;
      }
      reader._closedPromise_resolve(undefined);
      reader._closedPromise_resolve = undefined;
      reader._closedPromise_reject = undefined;
    }
    const AbortSteps = SymbolPolyfill("[[AbortSteps]]");
    const ErrorSteps = SymbolPolyfill("[[ErrorSteps]]");
    const CancelSteps = SymbolPolyfill("[[CancelSteps]]");
    const PullSteps = SymbolPolyfill("[[PullSteps]]");
    const NumberIsFinite = Number.isFinite || function(x2) {
      return typeof x2 === "number" && isFinite(x2);
    };
    const MathTrunc = Math.trunc || function(v2) {
      return v2 < 0 ? Math.ceil(v2) : Math.floor(v2);
    };
    function isDictionary(x2) {
      return typeof x2 === "object" || typeof x2 === "function";
    }
    function assertDictionary(obj, context) {
      if (obj !== undefined && !isDictionary(obj)) {
        throw new TypeError(`${context} is not an object.`);
      }
    }
    function assertFunction(x2, context) {
      if (typeof x2 !== "function") {
        throw new TypeError(`${context} is not a function.`);
      }
    }
    function isObject(x2) {
      return typeof x2 === "object" && x2 !== null || typeof x2 === "function";
    }
    function assertObject(x2, context) {
      if (!isObject(x2)) {
        throw new TypeError(`${context} is not an object.`);
      }
    }
    function assertRequiredArgument(x2, position, context) {
      if (x2 === undefined) {
        throw new TypeError(`Parameter ${position} is required in '${context}'.`);
      }
    }
    function assertRequiredField(x2, field, context) {
      if (x2 === undefined) {
        throw new TypeError(`${field} is required in '${context}'.`);
      }
    }
    function convertUnrestrictedDouble(value) {
      return Number(value);
    }
    function censorNegativeZero(x2) {
      return x2 === 0 ? 0 : x2;
    }
    function integerPart(x2) {
      return censorNegativeZero(MathTrunc(x2));
    }
    function convertUnsignedLongLongWithEnforceRange(value, context) {
      const lowerBound = 0;
      const upperBound = Number.MAX_SAFE_INTEGER;
      let x2 = Number(value);
      x2 = censorNegativeZero(x2);
      if (!NumberIsFinite(x2)) {
        throw new TypeError(`${context} is not a finite number`);
      }
      x2 = integerPart(x2);
      if (x2 < lowerBound || x2 > upperBound) {
        throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);
      }
      if (!NumberIsFinite(x2) || x2 === 0) {
        return 0;
      }
      return x2;
    }
    function assertReadableStream(x2, context) {
      if (!IsReadableStream(x2)) {
        throw new TypeError(`${context} is not a ReadableStream.`);
      }
    }
    function AcquireReadableStreamDefaultReader(stream) {
      return new ReadableStreamDefaultReader2(stream);
    }
    function ReadableStreamAddReadRequest(stream, readRequest) {
      stream._reader._readRequests.push(readRequest);
    }
    function ReadableStreamFulfillReadRequest(stream, chunk, done) {
      const reader = stream._reader;
      const readRequest = reader._readRequests.shift();
      if (done) {
        readRequest._closeSteps();
      } else {
        readRequest._chunkSteps(chunk);
      }
    }
    function ReadableStreamGetNumReadRequests(stream) {
      return stream._reader._readRequests.length;
    }
    function ReadableStreamHasDefaultReader(stream) {
      const reader = stream._reader;
      if (reader === undefined) {
        return false;
      }
      if (!IsReadableStreamDefaultReader(reader)) {
        return false;
      }
      return true;
    }

    class ReadableStreamDefaultReader2 {
      constructor(stream) {
        assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader");
        assertReadableStream(stream, "First parameter");
        if (IsReadableStreamLocked(stream)) {
          throw new TypeError("This stream has already been locked for exclusive reading by another reader");
        }
        ReadableStreamReaderGenericInitialize(this, stream);
        this._readRequests = new SimpleQueue;
      }
      get closed() {
        if (!IsReadableStreamDefaultReader(this)) {
          return promiseRejectedWith(defaultReaderBrandCheckException("closed"));
        }
        return this._closedPromise;
      }
      cancel(reason = undefined) {
        if (!IsReadableStreamDefaultReader(this)) {
          return promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
        }
        if (this._ownerReadableStream === undefined) {
          return promiseRejectedWith(readerLockException("cancel"));
        }
        return ReadableStreamReaderGenericCancel(this, reason);
      }
      read() {
        if (!IsReadableStreamDefaultReader(this)) {
          return promiseRejectedWith(defaultReaderBrandCheckException("read"));
        }
        if (this._ownerReadableStream === undefined) {
          return promiseRejectedWith(readerLockException("read from"));
        }
        let resolvePromise;
        let rejectPromise;
        const promise = newPromise((resolve, reject) => {
          resolvePromise = resolve;
          rejectPromise = reject;
        });
        const readRequest = {
          _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
          _closeSteps: () => resolvePromise({ value: undefined, done: true }),
          _errorSteps: (e2) => rejectPromise(e2)
        };
        ReadableStreamDefaultReaderRead(this, readRequest);
        return promise;
      }
      releaseLock() {
        if (!IsReadableStreamDefaultReader(this)) {
          throw defaultReaderBrandCheckException("releaseLock");
        }
        if (this._ownerReadableStream === undefined) {
          return;
        }
        if (this._readRequests.length > 0) {
          throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
        }
        ReadableStreamReaderGenericRelease(this);
      }
    }
    Object.defineProperties(ReadableStreamDefaultReader2.prototype, {
      cancel: { enumerable: true },
      read: { enumerable: true },
      releaseLock: { enumerable: true },
      closed: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
      Object.defineProperty(ReadableStreamDefaultReader2.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableStreamDefaultReader",
        configurable: true
      });
    }
    function IsReadableStreamDefaultReader(x2) {
      if (!typeIsObject(x2)) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(x2, "_readRequests")) {
        return false;
      }
      return x2 instanceof ReadableStreamDefaultReader2;
    }
    function ReadableStreamDefaultReaderRead(reader, readRequest) {
      const stream = reader._ownerReadableStream;
      stream._disturbed = true;
      if (stream._state === "closed") {
        readRequest._closeSteps();
      } else if (stream._state === "errored") {
        readRequest._errorSteps(stream._storedError);
      } else {
        stream._readableStreamController[PullSteps](readRequest);
      }
    }
    function defaultReaderBrandCheckException(name) {
      return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);
    }
    const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
    }).prototype);

    class ReadableStreamAsyncIteratorImpl {
      constructor(reader, preventCancel) {
        this._ongoingPromise = undefined;
        this._isFinished = false;
        this._reader = reader;
        this._preventCancel = preventCancel;
      }
      next() {
        const nextSteps = () => this._nextSteps();
        this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
        return this._ongoingPromise;
      }
      return(value) {
        const returnSteps = () => this._returnSteps(value);
        return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
      }
      _nextSteps() {
        if (this._isFinished) {
          return Promise.resolve({ value: undefined, done: true });
        }
        const reader = this._reader;
        if (reader._ownerReadableStream === undefined) {
          return promiseRejectedWith(readerLockException("iterate"));
        }
        let resolvePromise;
        let rejectPromise;
        const promise = newPromise((resolve, reject) => {
          resolvePromise = resolve;
          rejectPromise = reject;
        });
        const readRequest = {
          _chunkSteps: (chunk) => {
            this._ongoingPromise = undefined;
            queueMicrotask2(() => resolvePromise({ value: chunk, done: false }));
          },
          _closeSteps: () => {
            this._ongoingPromise = undefined;
            this._isFinished = true;
            ReadableStreamReaderGenericRelease(reader);
            resolvePromise({ value: undefined, done: true });
          },
          _errorSteps: (reason) => {
            this._ongoingPromise = undefined;
            this._isFinished = true;
            ReadableStreamReaderGenericRelease(reader);
            rejectPromise(reason);
          }
        };
        ReadableStreamDefaultReaderRead(reader, readRequest);
        return promise;
      }
      _returnSteps(value) {
        if (this._isFinished) {
          return Promise.resolve({ value, done: true });
        }
        this._isFinished = true;
        const reader = this._reader;
        if (reader._ownerReadableStream === undefined) {
          return promiseRejectedWith(readerLockException("finish iterating"));
        }
        if (!this._preventCancel) {
          const result = ReadableStreamReaderGenericCancel(reader, value);
          ReadableStreamReaderGenericRelease(reader);
          return transformPromiseWith(result, () => ({ value, done: true }));
        }
        ReadableStreamReaderGenericRelease(reader);
        return promiseResolvedWith({ value, done: true });
      }
    }
    const ReadableStreamAsyncIteratorPrototype = {
      next() {
        if (!IsReadableStreamAsyncIterator(this)) {
          return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
        }
        return this._asyncIteratorImpl.next();
      },
      return(value) {
        if (!IsReadableStreamAsyncIterator(this)) {
          return promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
        }
        return this._asyncIteratorImpl.return(value);
      }
    };
    if (AsyncIteratorPrototype !== undefined) {
      Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
    }
    function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
      const reader = AcquireReadableStreamDefaultReader(stream);
      const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
      const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
      iterator._asyncIteratorImpl = impl;
      return iterator;
    }
    function IsReadableStreamAsyncIterator(x2) {
      if (!typeIsObject(x2)) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(x2, "_asyncIteratorImpl")) {
        return false;
      }
      try {
        return x2._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
      } catch (_a) {
        return false;
      }
    }
    function streamAsyncIteratorBrandCheckException(name) {
      return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);
    }
    const NumberIsNaN = Number.isNaN || function(x2) {
      return x2 !== x2;
    };
    function CreateArrayFromList(elements) {
      return elements.slice();
    }
    function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n2) {
      new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n2), destOffset);
    }
    function TransferArrayBuffer(O2) {
      return O2;
    }
    function IsDetachedBuffer(O2) {
      return false;
    }
    function ArrayBufferSlice(buffer, begin, end) {
      if (buffer.slice) {
        return buffer.slice(begin, end);
      }
      const length = end - begin;
      const slice = new ArrayBuffer(length);
      CopyDataBlockBytes(slice, 0, buffer, begin, length);
      return slice;
    }
    function IsNonNegativeNumber(v2) {
      if (typeof v2 !== "number") {
        return false;
      }
      if (NumberIsNaN(v2)) {
        return false;
      }
      if (v2 < 0) {
        return false;
      }
      return true;
    }
    function CloneAsUint8Array(O2) {
      const buffer = ArrayBufferSlice(O2.buffer, O2.byteOffset, O2.byteOffset + O2.byteLength);
      return new Uint8Array(buffer);
    }
    function DequeueValue(container) {
      const pair = container._queue.shift();
      container._queueTotalSize -= pair.size;
      if (container._queueTotalSize < 0) {
        container._queueTotalSize = 0;
      }
      return pair.value;
    }
    function EnqueueValueWithSize(container, value, size) {
      if (!IsNonNegativeNumber(size) || size === Infinity) {
        throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
      }
      container._queue.push({ value, size });
      container._queueTotalSize += size;
    }
    function PeekQueueValue(container) {
      const pair = container._queue.peek();
      return pair.value;
    }
    function ResetQueue(container) {
      container._queue = new SimpleQueue;
      container._queueTotalSize = 0;
    }

    class ReadableStreamBYOBRequest2 {
      constructor() {
        throw new TypeError("Illegal constructor");
      }
      get view() {
        if (!IsReadableStreamBYOBRequest(this)) {
          throw byobRequestBrandCheckException("view");
        }
        return this._view;
      }
      respond(bytesWritten) {
        if (!IsReadableStreamBYOBRequest(this)) {
          throw byobRequestBrandCheckException("respond");
        }
        assertRequiredArgument(bytesWritten, 1, "respond");
        bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter");
        if (this._associatedReadableByteStreamController === undefined) {
          throw new TypeError("This BYOB request has been invalidated");
        }
        if (IsDetachedBuffer(this._view.buffer))
          ;
        ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
      }
      respondWithNewView(view) {
        if (!IsReadableStreamBYOBRequest(this)) {
          throw byobRequestBrandCheckException("respondWithNewView");
        }
        assertRequiredArgument(view, 1, "respondWithNewView");
        if (!ArrayBuffer.isView(view)) {
          throw new TypeError("You can only respond with array buffer views");
        }
        if (this._associatedReadableByteStreamController === undefined) {
          throw new TypeError("This BYOB request has been invalidated");
        }
        if (IsDetachedBuffer(view.buffer))
          ;
        ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
      }
    }
    Object.defineProperties(ReadableStreamBYOBRequest2.prototype, {
      respond: { enumerable: true },
      respondWithNewView: { enumerable: true },
      view: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
      Object.defineProperty(ReadableStreamBYOBRequest2.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableStreamBYOBRequest",
        configurable: true
      });
    }

    class ReadableByteStreamController2 {
      constructor() {
        throw new TypeError("Illegal constructor");
      }
      get byobRequest() {
        if (!IsReadableByteStreamController(this)) {
          throw byteStreamControllerBrandCheckException("byobRequest");
        }
        return ReadableByteStreamControllerGetBYOBRequest(this);
      }
      get desiredSize() {
        if (!IsReadableByteStreamController(this)) {
          throw byteStreamControllerBrandCheckException("desiredSize");
        }
        return ReadableByteStreamControllerGetDesiredSize(this);
      }
      close() {
        if (!IsReadableByteStreamController(this)) {
          throw byteStreamControllerBrandCheckException("close");
        }
        if (this._closeRequested) {
          throw new TypeError("The stream has already been closed; do not close it again!");
        }
        const state = this._controlledReadableByteStream._state;
        if (state !== "readable") {
          throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);
        }
        ReadableByteStreamControllerClose(this);
      }
      enqueue(chunk) {
        if (!IsReadableByteStreamController(this)) {
          throw byteStreamControllerBrandCheckException("enqueue");
        }
        assertRequiredArgument(chunk, 1, "enqueue");
        if (!ArrayBuffer.isView(chunk)) {
          throw new TypeError("chunk must be an array buffer view");
        }
        if (chunk.byteLength === 0) {
          throw new TypeError("chunk must have non-zero byteLength");
        }
        if (chunk.buffer.byteLength === 0) {
          throw new TypeError(`chunk's buffer must have non-zero byteLength`);
        }
        if (this._closeRequested) {
          throw new TypeError("stream is closed or draining");
        }
        const state = this._controlledReadableByteStream._state;
        if (state !== "readable") {
          throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);
        }
        ReadableByteStreamControllerEnqueue(this, chunk);
      }
      error(e2 = undefined) {
        if (!IsReadableByteStreamController(this)) {
          throw byteStreamControllerBrandCheckException("error");
        }
        ReadableByteStreamControllerError(this, e2);
      }
      [CancelSteps](reason) {
        ReadableByteStreamControllerClearPendingPullIntos(this);
        ResetQueue(this);
        const result = this._cancelAlgorithm(reason);
        ReadableByteStreamControllerClearAlgorithms(this);
        return result;
      }
      [PullSteps](readRequest) {
        const stream = this._controlledReadableByteStream;
        if (this._queueTotalSize > 0) {
          const entry = this._queue.shift();
          this._queueTotalSize -= entry.byteLength;
          ReadableByteStreamControllerHandleQueueDrain(this);
          const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
          readRequest._chunkSteps(view);
          return;
        }
        const autoAllocateChunkSize = this._autoAllocateChunkSize;
        if (autoAllocateChunkSize !== undefined) {
          let buffer;
          try {
            buffer = new ArrayBuffer(autoAllocateChunkSize);
          } catch (bufferE) {
            readRequest._errorSteps(bufferE);
            return;
          }
          const pullIntoDescriptor = {
            buffer,
            bufferByteLength: autoAllocateChunkSize,
            byteOffset: 0,
            byteLength: autoAllocateChunkSize,
            bytesFilled: 0,
            elementSize: 1,
            viewConstructor: Uint8Array,
            readerType: "default"
          };
          this._pendingPullIntos.push(pullIntoDescriptor);
        }
        ReadableStreamAddReadRequest(stream, readRequest);
        ReadableByteStreamControllerCallPullIfNeeded(this);
      }
    }
    Object.defineProperties(ReadableByteStreamController2.prototype, {
      close: { enumerable: true },
      enqueue: { enumerable: true },
      error: { enumerable: true },
      byobRequest: { enumerable: true },
      desiredSize: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
      Object.defineProperty(ReadableByteStreamController2.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableByteStreamController",
        configurable: true
      });
    }
    function IsReadableByteStreamController(x2) {
      if (!typeIsObject(x2)) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(x2, "_controlledReadableByteStream")) {
        return false;
      }
      return x2 instanceof ReadableByteStreamController2;
    }
    function IsReadableStreamBYOBRequest(x2) {
      if (!typeIsObject(x2)) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(x2, "_associatedReadableByteStreamController")) {
        return false;
      }
      return x2 instanceof ReadableStreamBYOBRequest2;
    }
    function ReadableByteStreamControllerCallPullIfNeeded(controller) {
      const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
      if (!shouldPull) {
        return;
      }
      if (controller._pulling) {
        controller._pullAgain = true;
        return;
      }
      controller._pulling = true;
      const pullPromise = controller._pullAlgorithm();
      uponPromise(pullPromise, () => {
        controller._pulling = false;
        if (controller._pullAgain) {
          controller._pullAgain = false;
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
      }, (e2) => {
        ReadableByteStreamControllerError(controller, e2);
      });
    }
    function ReadableByteStreamControllerClearPendingPullIntos(controller) {
      ReadableByteStreamControllerInvalidateBYOBRequest(controller);
      controller._pendingPullIntos = new SimpleQueue;
    }
    function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
      let done = false;
      if (stream._state === "closed") {
        done = true;
      }
      const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
      if (pullIntoDescriptor.readerType === "default") {
        ReadableStreamFulfillReadRequest(stream, filledView, done);
      } else {
        ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
      }
    }
    function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
      const bytesFilled = pullIntoDescriptor.bytesFilled;
      const elementSize = pullIntoDescriptor.elementSize;
      return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
    }
    function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
      controller._queue.push({ buffer, byteOffset, byteLength });
      controller._queueTotalSize += byteLength;
    }
    function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
      const elementSize = pullIntoDescriptor.elementSize;
      const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;
      const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
      const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
      const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
      let totalBytesToCopyRemaining = maxBytesToCopy;
      let ready = false;
      if (maxAlignedBytes > currentAlignedBytes) {
        totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
        ready = true;
      }
      const queue = controller._queue;
      while (totalBytesToCopyRemaining > 0) {
        const headOfQueue = queue.peek();
        const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
        const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
        CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
        if (headOfQueue.byteLength === bytesToCopy) {
          queue.shift();
        } else {
          headOfQueue.byteOffset += bytesToCopy;
          headOfQueue.byteLength -= bytesToCopy;
        }
        controller._queueTotalSize -= bytesToCopy;
        ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
        totalBytesToCopyRemaining -= bytesToCopy;
      }
      return ready;
    }
    function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
      pullIntoDescriptor.bytesFilled += size;
    }
    function ReadableByteStreamControllerHandleQueueDrain(controller) {
      if (controller._queueTotalSize === 0 && controller._closeRequested) {
        ReadableByteStreamControllerClearAlgorithms(controller);
        ReadableStreamClose(controller._controlledReadableByteStream);
      } else {
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
    }
    function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
      if (controller._byobRequest === null) {
        return;
      }
      controller._byobRequest._associatedReadableByteStreamController = undefined;
      controller._byobRequest._view = null;
      controller._byobRequest = null;
    }
    function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
      while (controller._pendingPullIntos.length > 0) {
        if (controller._queueTotalSize === 0) {
          return;
        }
        const pullIntoDescriptor = controller._pendingPullIntos.peek();
        if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
          ReadableByteStreamControllerShiftPendingPullInto(controller);
          ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
        }
      }
    }
    function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {
      const stream = controller._controlledReadableByteStream;
      let elementSize = 1;
      if (view.constructor !== DataView) {
        elementSize = view.constructor.BYTES_PER_ELEMENT;
      }
      const ctor = view.constructor;
      const buffer = TransferArrayBuffer(view.buffer);
      const pullIntoDescriptor = {
        buffer,
        bufferByteLength: buffer.byteLength,
        byteOffset: view.byteOffset,
        byteLength: view.byteLength,
        bytesFilled: 0,
        elementSize,
        viewConstructor: ctor,
        readerType: "byob"
      };
      if (controller._pendingPullIntos.length > 0) {
        controller._pendingPullIntos.push(pullIntoDescriptor);
        ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
        return;
      }
      if (stream._state === "closed") {
        const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
        readIntoRequest._closeSteps(emptyView);
        return;
      }
      if (controller._queueTotalSize > 0) {
        if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
          const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
          ReadableByteStreamControllerHandleQueueDrain(controller);
          readIntoRequest._chunkSteps(filledView);
          return;
        }
        if (controller._closeRequested) {
          const e2 = new TypeError("Insufficient bytes to fill elements in the given buffer");
          ReadableByteStreamControllerError(controller, e2);
          readIntoRequest._errorSteps(e2);
          return;
        }
      }
      controller._pendingPullIntos.push(pullIntoDescriptor);
      ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
      ReadableByteStreamControllerCallPullIfNeeded(controller);
    }
    function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
      const stream = controller._controlledReadableByteStream;
      if (ReadableStreamHasBYOBReader(stream)) {
        while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
          const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
          ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
        }
      }
    }
    function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
      ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
      if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
        return;
      }
      ReadableByteStreamControllerShiftPendingPullInto(controller);
      const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
      if (remainderSize > 0) {
        const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
        const remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);
        ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
      }
      pullIntoDescriptor.bytesFilled -= remainderSize;
      ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
      ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
    }
    function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
      const firstDescriptor = controller._pendingPullIntos.peek();
      ReadableByteStreamControllerInvalidateBYOBRequest(controller);
      const state = controller._controlledReadableByteStream._state;
      if (state === "closed") {
        ReadableByteStreamControllerRespondInClosedState(controller);
      } else {
        ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
      }
      ReadableByteStreamControllerCallPullIfNeeded(controller);
    }
    function ReadableByteStreamControllerShiftPendingPullInto(controller) {
      const descriptor = controller._pendingPullIntos.shift();
      return descriptor;
    }
    function ReadableByteStreamControllerShouldCallPull(controller) {
      const stream = controller._controlledReadableByteStream;
      if (stream._state !== "readable") {
        return false;
      }
      if (controller._closeRequested) {
        return false;
      }
      if (!controller._started) {
        return false;
      }
      if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
        return true;
      }
      if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
        return true;
      }
      const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
      if (desiredSize > 0) {
        return true;
      }
      return false;
    }
    function ReadableByteStreamControllerClearAlgorithms(controller) {
      controller._pullAlgorithm = undefined;
      controller._cancelAlgorithm = undefined;
    }
    function ReadableByteStreamControllerClose(controller) {
      const stream = controller._controlledReadableByteStream;
      if (controller._closeRequested || stream._state !== "readable") {
        return;
      }
      if (controller._queueTotalSize > 0) {
        controller._closeRequested = true;
        return;
      }
      if (controller._pendingPullIntos.length > 0) {
        const firstPendingPullInto = controller._pendingPullIntos.peek();
        if (firstPendingPullInto.bytesFilled > 0) {
          const e2 = new TypeError("Insufficient bytes to fill elements in the given buffer");
          ReadableByteStreamControllerError(controller, e2);
          throw e2;
        }
      }
      ReadableByteStreamControllerClearAlgorithms(controller);
      ReadableStreamClose(stream);
    }
    function ReadableByteStreamControllerEnqueue(controller, chunk) {
      const stream = controller._controlledReadableByteStream;
      if (controller._closeRequested || stream._state !== "readable") {
        return;
      }
      const buffer = chunk.buffer;
      const byteOffset = chunk.byteOffset;
      const byteLength = chunk.byteLength;
      const transferredBuffer = TransferArrayBuffer(buffer);
      if (controller._pendingPullIntos.length > 0) {
        const firstPendingPullInto = controller._pendingPullIntos.peek();
        if (IsDetachedBuffer(firstPendingPullInto.buffer))
          ;
        firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
      }
      ReadableByteStreamControllerInvalidateBYOBRequest(controller);
      if (ReadableStreamHasDefaultReader(stream)) {
        if (ReadableStreamGetNumReadRequests(stream) === 0) {
          ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
        } else {
          if (controller._pendingPullIntos.length > 0) {
            ReadableByteStreamControllerShiftPendingPullInto(controller);
          }
          const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
          ReadableStreamFulfillReadRequest(stream, transferredView, false);
        }
      } else if (ReadableStreamHasBYOBReader(stream)) {
        ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
        ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
      } else {
        ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
      }
      ReadableByteStreamControllerCallPullIfNeeded(controller);
    }
    function ReadableByteStreamControllerError(controller, e2) {
      const stream = controller._controlledReadableByteStream;
      if (stream._state !== "readable") {
        return;
      }
      ReadableByteStreamControllerClearPendingPullIntos(controller);
      ResetQueue(controller);
      ReadableByteStreamControllerClearAlgorithms(controller);
      ReadableStreamError(stream, e2);
    }
    function ReadableByteStreamControllerGetBYOBRequest(controller) {
      if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
        const byobRequest = Object.create(ReadableStreamBYOBRequest2.prototype);
        SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
        controller._byobRequest = byobRequest;
      }
      return controller._byobRequest;
    }
    function ReadableByteStreamControllerGetDesiredSize(controller) {
      const state = controller._controlledReadableByteStream._state;
      if (state === "errored") {
        return null;
      }
      if (state === "closed") {
        return 0;
      }
      return controller._strategyHWM - controller._queueTotalSize;
    }
    function ReadableByteStreamControllerRespond(controller, bytesWritten) {
      const firstDescriptor = controller._pendingPullIntos.peek();
      const state = controller._controlledReadableByteStream._state;
      if (state === "closed") {
        if (bytesWritten !== 0) {
          throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
        }
      } else {
        if (bytesWritten === 0) {
          throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
        }
        if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
          throw new RangeError("bytesWritten out of range");
        }
      }
      firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
      ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
    }
    function ReadableByteStreamControllerRespondWithNewView(controller, view) {
      const firstDescriptor = controller._pendingPullIntos.peek();
      const state = controller._controlledReadableByteStream._state;
      if (state === "closed") {
        if (view.byteLength !== 0) {
          throw new TypeError("The view\'s length must be 0 when calling respondWithNewView() on a closed stream");
        }
      } else {
        if (view.byteLength === 0) {
          throw new TypeError("The view\'s length must be greater than 0 when calling respondWithNewView() on a readable stream");
        }
      }
      if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
        throw new RangeError("The region specified by view does not match byobRequest");
      }
      if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
        throw new RangeError("The buffer of view has different capacity than byobRequest");
      }
      if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
        throw new RangeError("The region specified by view is larger than byobRequest");
      }
      const viewByteLength = view.byteLength;
      firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
      ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
    }
    function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
      controller._controlledReadableByteStream = stream;
      controller._pullAgain = false;
      controller._pulling = false;
      controller._byobRequest = null;
      controller._queue = controller._queueTotalSize = undefined;
      ResetQueue(controller);
      controller._closeRequested = false;
      controller._started = false;
      controller._strategyHWM = highWaterMark;
      controller._pullAlgorithm = pullAlgorithm;
      controller._cancelAlgorithm = cancelAlgorithm;
      controller._autoAllocateChunkSize = autoAllocateChunkSize;
      controller._pendingPullIntos = new SimpleQueue;
      stream._readableStreamController = controller;
      const startResult = startAlgorithm();
      uponPromise(promiseResolvedWith(startResult), () => {
        controller._started = true;
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }, (r2) => {
        ReadableByteStreamControllerError(controller, r2);
      });
    }
    function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
      const controller = Object.create(ReadableByteStreamController2.prototype);
      let startAlgorithm = () => {
        return;
      };
      let pullAlgorithm = () => promiseResolvedWith(undefined);
      let cancelAlgorithm = () => promiseResolvedWith(undefined);
      if (underlyingByteSource.start !== undefined) {
        startAlgorithm = () => underlyingByteSource.start(controller);
      }
      if (underlyingByteSource.pull !== undefined) {
        pullAlgorithm = () => underlyingByteSource.pull(controller);
      }
      if (underlyingByteSource.cancel !== undefined) {
        cancelAlgorithm = (reason) => underlyingByteSource.cancel(reason);
      }
      const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
      if (autoAllocateChunkSize === 0) {
        throw new TypeError("autoAllocateChunkSize must be greater than 0");
      }
      SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
    }
    function SetUpReadableStreamBYOBRequest(request, controller, view) {
      request._associatedReadableByteStreamController = controller;
      request._view = view;
    }
    function byobRequestBrandCheckException(name) {
      return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);
    }
    function byteStreamControllerBrandCheckException(name) {
      return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);
    }
    function AcquireReadableStreamBYOBReader(stream) {
      return new ReadableStreamBYOBReader2(stream);
    }
    function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
      stream._reader._readIntoRequests.push(readIntoRequest);
    }
    function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
      const reader = stream._reader;
      const readIntoRequest = reader._readIntoRequests.shift();
      if (done) {
        readIntoRequest._closeSteps(chunk);
      } else {
        readIntoRequest._chunkSteps(chunk);
      }
    }
    function ReadableStreamGetNumReadIntoRequests(stream) {
      return stream._reader._readIntoRequests.length;
    }
    function ReadableStreamHasBYOBReader(stream) {
      const reader = stream._reader;
      if (reader === undefined) {
        return false;
      }
      if (!IsReadableStreamBYOBReader(reader)) {
        return false;
      }
      return true;
    }

    class ReadableStreamBYOBReader2 {
      constructor(stream) {
        assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader");
        assertReadableStream(stream, "First parameter");
        if (IsReadableStreamLocked(stream)) {
          throw new TypeError("This stream has already been locked for exclusive reading by another reader");
        }
        if (!IsReadableByteStreamController(stream._readableStreamController)) {
          throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
        }
        ReadableStreamReaderGenericInitialize(this, stream);
        this._readIntoRequests = new SimpleQueue;
      }
      get closed() {
        if (!IsReadableStreamBYOBReader(this)) {
          return promiseRejectedWith(byobReaderBrandCheckException("closed"));
        }
        return this._closedPromise;
      }
      cancel(reason = undefined) {
        if (!IsReadableStreamBYOBReader(this)) {
          return promiseRejectedWith(byobReaderBrandCheckException("cancel"));
        }
        if (this._ownerReadableStream === undefined) {
          return promiseRejectedWith(readerLockException("cancel"));
        }
        return ReadableStreamReaderGenericCancel(this, reason);
      }
      read(view) {
        if (!IsReadableStreamBYOBReader(this)) {
          return promiseRejectedWith(byobReaderBrandCheckException("read"));
        }
        if (!ArrayBuffer.isView(view)) {
          return promiseRejectedWith(new TypeError("view must be an array buffer view"));
        }
        if (view.byteLength === 0) {
          return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
        }
        if (view.buffer.byteLength === 0) {
          return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));
        }
        if (IsDetachedBuffer(view.buffer))
          ;
        if (this._ownerReadableStream === undefined) {
          return promiseRejectedWith(readerLockException("read from"));
        }
        let resolvePromise;
        let rejectPromise;
        const promise = newPromise((resolve, reject) => {
          resolvePromise = resolve;
          rejectPromise = reject;
        });
        const readIntoRequest = {
          _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
          _closeSteps: (chunk) => resolvePromise({ value: chunk, done: true }),
          _errorSteps: (e2) => rejectPromise(e2)
        };
        ReadableStreamBYOBReaderRead(this, view, readIntoRequest);
        return promise;
      }
      releaseLock() {
        if (!IsReadableStreamBYOBReader(this)) {
          throw byobReaderBrandCheckException("releaseLock");
        }
        if (this._ownerReadableStream === undefined) {
          return;
        }
        if (this._readIntoRequests.length > 0) {
          throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
        }
        ReadableStreamReaderGenericRelease(this);
      }
    }
    Object.defineProperties(ReadableStreamBYOBReader2.prototype, {
      cancel: { enumerable: true },
      read: { enumerable: true },
      releaseLock: { enumerable: true },
      closed: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
      Object.defineProperty(ReadableStreamBYOBReader2.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableStreamBYOBReader",
        configurable: true
      });
    }
    function IsReadableStreamBYOBReader(x2) {
      if (!typeIsObject(x2)) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(x2, "_readIntoRequests")) {
        return false;
      }
      return x2 instanceof ReadableStreamBYOBReader2;
    }
    function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {
      const stream = reader._ownerReadableStream;
      stream._disturbed = true;
      if (stream._state === "errored") {
        readIntoRequest._errorSteps(stream._storedError);
      } else {
        ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);
      }
    }
    function byobReaderBrandCheckException(name) {
      return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);
    }
    function ExtractHighWaterMark(strategy, defaultHWM) {
      const { highWaterMark } = strategy;
      if (highWaterMark === undefined) {
        return defaultHWM;
      }
      if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
        throw new RangeError("Invalid highWaterMark");
      }
      return highWaterMark;
    }
    function ExtractSizeAlgorithm(strategy) {
      const { size } = strategy;
      if (!size) {
        return () => 1;
      }
      return size;
    }
    function convertQueuingStrategy(init, context) {
      assertDictionary(init, context);
      const highWaterMark = init === null || init === undefined ? undefined : init.highWaterMark;
      const size = init === null || init === undefined ? undefined : init.size;
      return {
        highWaterMark: highWaterMark === undefined ? undefined : convertUnrestrictedDouble(highWaterMark),
        size: size === undefined ? undefined : convertQueuingStrategySize(size, `${context} has member 'size' that`)
      };
    }
    function convertQueuingStrategySize(fn, context) {
      assertFunction(fn, context);
      return (chunk) => convertUnrestrictedDouble(fn(chunk));
    }
    function convertUnderlyingSink(original, context) {
      assertDictionary(original, context);
      const abort = original === null || original === undefined ? undefined : original.abort;
      const close = original === null || original === undefined ? undefined : original.close;
      const start = original === null || original === undefined ? undefined : original.start;
      const type = original === null || original === undefined ? undefined : original.type;
      const write = original === null || original === undefined ? undefined : original.write;
      return {
        abort: abort === undefined ? undefined : convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),
        close: close === undefined ? undefined : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),
        start: start === undefined ? undefined : convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),
        write: write === undefined ? undefined : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),
        type
      };
    }
    function convertUnderlyingSinkAbortCallback(fn, original, context) {
      assertFunction(fn, context);
      return (reason) => promiseCall(fn, original, [reason]);
    }
    function convertUnderlyingSinkCloseCallback(fn, original, context) {
      assertFunction(fn, context);
      return () => promiseCall(fn, original, []);
    }
    function convertUnderlyingSinkStartCallback(fn, original, context) {
      assertFunction(fn, context);
      return (controller) => reflectCall(fn, original, [controller]);
    }
    function convertUnderlyingSinkWriteCallback(fn, original, context) {
      assertFunction(fn, context);
      return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
    }
    function assertWritableStream(x2, context) {
      if (!IsWritableStream(x2)) {
        throw new TypeError(`${context} is not a WritableStream.`);
      }
    }
    function isAbortSignal(value) {
      if (typeof value !== "object" || value === null) {
        return false;
      }
      try {
        return typeof value.aborted === "boolean";
      } catch (_a) {
        return false;
      }
    }
    const supportsAbortController = typeof AbortController === "function";
    function createAbortController() {
      if (supportsAbortController) {
        return new AbortController;
      }
      return;
    }

    class WritableStream2 {
      constructor(rawUnderlyingSink = {}, rawStrategy = {}) {
        if (rawUnderlyingSink === undefined) {
          rawUnderlyingSink = null;
        } else {
          assertObject(rawUnderlyingSink, "First parameter");
        }
        const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
        const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
        InitializeWritableStream(this);
        const type = underlyingSink.type;
        if (type !== undefined) {
          throw new RangeError("Invalid type is specified");
        }
        const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
        const highWaterMark = ExtractHighWaterMark(strategy, 1);
        SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
      }
      get locked() {
        if (!IsWritableStream(this)) {
          throw streamBrandCheckException$2("locked");
        }
        return IsWritableStreamLocked(this);
      }
      abort(reason = undefined) {
        if (!IsWritableStream(this)) {
          return promiseRejectedWith(streamBrandCheckException$2("abort"));
        }
        if (IsWritableStreamLocked(this)) {
          return promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer"));
        }
        return WritableStreamAbort(this, reason);
      }
      close() {
        if (!IsWritableStream(this)) {
          return promiseRejectedWith(streamBrandCheckException$2("close"));
        }
        if (IsWritableStreamLocked(this)) {
          return promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer"));
        }
        if (WritableStreamCloseQueuedOrInFlight(this)) {
          return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
        }
        return WritableStreamClose(this);
      }
      getWriter() {
        if (!IsWritableStream(this)) {
          throw streamBrandCheckException$2("getWriter");
        }
        return AcquireWritableStreamDefaultWriter(this);
      }
    }
    Object.defineProperties(WritableStream2.prototype, {
      abort: { enumerable: true },
      close: { enumerable: true },
      getWriter: { enumerable: true },
      locked: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
      Object.defineProperty(WritableStream2.prototype, SymbolPolyfill.toStringTag, {
        value: "WritableStream",
        configurable: true
      });
    }
    function AcquireWritableStreamDefaultWriter(stream) {
      return new WritableStreamDefaultWriter2(stream);
    }
    function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
      const stream = Object.create(WritableStream2.prototype);
      InitializeWritableStream(stream);
      const controller = Object.create(WritableStreamDefaultController2.prototype);
      SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
      return stream;
    }
    function InitializeWritableStream(stream) {
      stream._state = "writable";
      stream._storedError = undefined;
      stream._writer = undefined;
      stream._writableStreamController = undefined;
      stream._writeRequests = new SimpleQueue;
      stream._inFlightWriteRequest = undefined;
      stream._closeRequest = undefined;
      stream._inFlightCloseRequest = undefined;
      stream._pendingAbortRequest = undefined;
      stream._backpressure = false;
    }
    function IsWritableStream(x2) {
      if (!typeIsObject(x2)) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(x2, "_writableStreamController")) {
        return false;
      }
      return x2 instanceof WritableStream2;
    }
    function IsWritableStreamLocked(stream) {
      if (stream._writer === undefined) {
        return false;
      }
      return true;
    }
    function WritableStreamAbort(stream, reason) {
      var _a;
      if (stream._state === "closed" || stream._state === "errored") {
        return promiseResolvedWith(undefined);
      }
      stream._writableStreamController._abortReason = reason;
      (_a = stream._writableStreamController._abortController) === null || _a === undefined || _a.abort();
      const state = stream._state;
      if (state === "closed" || state === "errored") {
        return promiseResolvedWith(undefined);
      }
      if (stream._pendingAbortRequest !== undefined) {
        return stream._pendingAbortRequest._promise;
      }
      let wasAlreadyErroring = false;
      if (state === "erroring") {
        wasAlreadyErroring = true;
        reason = undefined;
      }
      const promise = newPromise((resolve, reject) => {
        stream._pendingAbortRequest = {
          _promise: undefined,
          _resolve: resolve,
          _reject: reject,
          _reason: reason,
          _wasAlreadyErroring: wasAlreadyErroring
        };
      });
      stream._pendingAbortRequest._promise = promise;
      if (!wasAlreadyErroring) {
        WritableStreamStartErroring(stream, reason);
      }
      return promise;
    }
    function WritableStreamClose(stream) {
      const state = stream._state;
      if (state === "closed" || state === "errored") {
        return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));
      }
      const promise = newPromise((resolve, reject) => {
        const closeRequest = {
          _resolve: resolve,
          _reject: reject
        };
        stream._closeRequest = closeRequest;
      });
      const writer = stream._writer;
      if (writer !== undefined && stream._backpressure && state === "writable") {
        defaultWriterReadyPromiseResolve(writer);
      }
      WritableStreamDefaultControllerClose(stream._writableStreamController);
      return promise;
    }
    function WritableStreamAddWriteRequest(stream) {
      const promise = newPromise((resolve, reject) => {
        const writeRequest = {
          _resolve: resolve,
          _reject: reject
        };
        stream._writeRequests.push(writeRequest);
      });
      return promise;
    }
    function WritableStreamDealWithRejection(stream, error) {
      const state = stream._state;
      if (state === "writable") {
        WritableStreamStartErroring(stream, error);
        return;
      }
      WritableStreamFinishErroring(stream);
    }
    function WritableStreamStartErroring(stream, reason) {
      const controller = stream._writableStreamController;
      stream._state = "erroring";
      stream._storedError = reason;
      const writer = stream._writer;
      if (writer !== undefined) {
        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
      }
      if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
        WritableStreamFinishErroring(stream);
      }
    }
    function WritableStreamFinishErroring(stream) {
      stream._state = "errored";
      stream._writableStreamController[ErrorSteps]();
      const storedError = stream._storedError;
      stream._writeRequests.forEach((writeRequest) => {
        writeRequest._reject(storedError);
      });
      stream._writeRequests = new SimpleQueue;
      if (stream._pendingAbortRequest === undefined) {
        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
        return;
      }
      const abortRequest = stream._pendingAbortRequest;
      stream._pendingAbortRequest = undefined;
      if (abortRequest._wasAlreadyErroring) {
        abortRequest._reject(storedError);
        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
        return;
      }
      const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
      uponPromise(promise, () => {
        abortRequest._resolve();
        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
      }, (reason) => {
        abortRequest._reject(reason);
        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
      });
    }
    function WritableStreamFinishInFlightWrite(stream) {
      stream._inFlightWriteRequest._resolve(undefined);
      stream._inFlightWriteRequest = undefined;
    }
    function WritableStreamFinishInFlightWriteWithError(stream, error) {
      stream._inFlightWriteRequest._reject(error);
      stream._inFlightWriteRequest = undefined;
      WritableStreamDealWithRejection(stream, error);
    }
    function WritableStreamFinishInFlightClose(stream) {
      stream._inFlightCloseRequest._resolve(undefined);
      stream._inFlightCloseRequest = undefined;
      const state = stream._state;
      if (state === "erroring") {
        stream._storedError = undefined;
        if (stream._pendingAbortRequest !== undefined) {
          stream._pendingAbortRequest._resolve();
          stream._pendingAbortRequest = undefined;
        }
      }
      stream._state = "closed";
      const writer = stream._writer;
      if (writer !== undefined) {
        defaultWriterClosedPromiseResolve(writer);
      }
    }
    function WritableStreamFinishInFlightCloseWithError(stream, error) {
      stream._inFlightCloseRequest._reject(error);
      stream._inFlightCloseRequest = undefined;
      if (stream._pendingAbortRequest !== undefined) {
        stream._pendingAbortRequest._reject(error);
        stream._pendingAbortRequest = undefined;
      }
      WritableStreamDealWithRejection(stream, error);
    }
    function WritableStreamCloseQueuedOrInFlight(stream) {
      if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {
        return false;
      }
      return true;
    }
    function WritableStreamHasOperationMarkedInFlight(stream) {
      if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {
        return false;
      }
      return true;
    }
    function WritableStreamMarkCloseRequestInFlight(stream) {
      stream._inFlightCloseRequest = stream._closeRequest;
      stream._closeRequest = undefined;
    }
    function WritableStreamMarkFirstWriteRequestInFlight(stream) {
      stream._inFlightWriteRequest = stream._writeRequests.shift();
    }
    function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
      if (stream._closeRequest !== undefined) {
        stream._closeRequest._reject(stream._storedError);
        stream._closeRequest = undefined;
      }
      const writer = stream._writer;
      if (writer !== undefined) {
        defaultWriterClosedPromiseReject(writer, stream._storedError);
      }
    }
    function WritableStreamUpdateBackpressure(stream, backpressure) {
      const writer = stream._writer;
      if (writer !== undefined && backpressure !== stream._backpressure) {
        if (backpressure) {
          defaultWriterReadyPromiseReset(writer);
        } else {
          defaultWriterReadyPromiseResolve(writer);
        }
      }
      stream._backpressure = backpressure;
    }

    class WritableStreamDefaultWriter2 {
      constructor(stream) {
        assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter");
        assertWritableStream(stream, "First parameter");
        if (IsWritableStreamLocked(stream)) {
          throw new TypeError("This stream has already been locked for exclusive writing by another writer");
        }
        this._ownerWritableStream = stream;
        stream._writer = this;
        const state = stream._state;
        if (state === "writable") {
          if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
            defaultWriterReadyPromiseInitialize(this);
          } else {
            defaultWriterReadyPromiseInitializeAsResolved(this);
          }
          defaultWriterClosedPromiseInitialize(this);
        } else if (state === "erroring") {
          defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
          defaultWriterClosedPromiseInitialize(this);
        } else if (state === "closed") {
          defaultWriterReadyPromiseInitializeAsResolved(this);
          defaultWriterClosedPromiseInitializeAsResolved(this);
        } else {
          const storedError = stream._storedError;
          defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
          defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
        }
      }
      get closed() {
        if (!IsWritableStreamDefaultWriter(this)) {
          return promiseRejectedWith(defaultWriterBrandCheckException("closed"));
        }
        return this._closedPromise;
      }
      get desiredSize() {
        if (!IsWritableStreamDefaultWriter(this)) {
          throw defaultWriterBrandCheckException("desiredSize");
        }
        if (this._ownerWritableStream === undefined) {
          throw defaultWriterLockException("desiredSize");
        }
        return WritableStreamDefaultWriterGetDesiredSize(this);
      }
      get ready() {
        if (!IsWritableStreamDefaultWriter(this)) {
          return promiseRejectedWith(defaultWriterBrandCheckException("ready"));
        }
        return this._readyPromise;
      }
      abort(reason = undefined) {
        if (!IsWritableStreamDefaultWriter(this)) {
          return promiseRejectedWith(defaultWriterBrandCheckException("abort"));
        }
        if (this._ownerWritableStream === undefined) {
          return promiseRejectedWith(defaultWriterLockException("abort"));
        }
        return WritableStreamDefaultWriterAbort(this, reason);
      }
      close() {
        if (!IsWritableStreamDefaultWriter(this)) {
          return promiseRejectedWith(defaultWriterBrandCheckException("close"));
        }
        const stream = this._ownerWritableStream;
        if (stream === undefined) {
          return promiseRejectedWith(defaultWriterLockException("close"));
        }
        if (WritableStreamCloseQueuedOrInFlight(stream)) {
          return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
        }
        return WritableStreamDefaultWriterClose(this);
      }
      releaseLock() {
        if (!IsWritableStreamDefaultWriter(this)) {
          throw defaultWriterBrandCheckException("releaseLock");
        }
        const stream = this._ownerWritableStream;
        if (stream === undefined) {
          return;
        }
        WritableStreamDefaultWriterRelease(this);
      }
      write(chunk = undefined) {
        if (!IsWritableStreamDefaultWriter(this)) {
          return promiseRejectedWith(defaultWriterBrandCheckException("write"));
        }
        if (this._ownerWritableStream === undefined) {
          return promiseRejectedWith(defaultWriterLockException("write to"));
        }
        return WritableStreamDefaultWriterWrite(this, chunk);
      }
    }
    Object.defineProperties(WritableStreamDefaultWriter2.prototype, {
      abort: { enumerable: true },
      close: { enumerable: true },
      releaseLock: { enumerable: true },
      write: { enumerable: true },
      closed: { enumerable: true },
      desiredSize: { enumerable: true },
      ready: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
      Object.defineProperty(WritableStreamDefaultWriter2.prototype, SymbolPolyfill.toStringTag, {
        value: "WritableStreamDefaultWriter",
        configurable: true
      });
    }
    function IsWritableStreamDefaultWriter(x2) {
      if (!typeIsObject(x2)) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(x2, "_ownerWritableStream")) {
        return false;
      }
      return x2 instanceof WritableStreamDefaultWriter2;
    }
    function WritableStreamDefaultWriterAbort(writer, reason) {
      const stream = writer._ownerWritableStream;
      return WritableStreamAbort(stream, reason);
    }
    function WritableStreamDefaultWriterClose(writer) {
      const stream = writer._ownerWritableStream;
      return WritableStreamClose(stream);
    }
    function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
      const stream = writer._ownerWritableStream;
      const state = stream._state;
      if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
        return promiseResolvedWith(undefined);
      }
      if (state === "errored") {
        return promiseRejectedWith(stream._storedError);
      }
      return WritableStreamDefaultWriterClose(writer);
    }
    function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
      if (writer._closedPromiseState === "pending") {
        defaultWriterClosedPromiseReject(writer, error);
      } else {
        defaultWriterClosedPromiseResetToRejected(writer, error);
      }
    }
    function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
      if (writer._readyPromiseState === "pending") {
        defaultWriterReadyPromiseReject(writer, error);
      } else {
        defaultWriterReadyPromiseResetToRejected(writer, error);
      }
    }
    function WritableStreamDefaultWriterGetDesiredSize(writer) {
      const stream = writer._ownerWritableStream;
      const state = stream._state;
      if (state === "errored" || state === "erroring") {
        return null;
      }
      if (state === "closed") {
        return 0;
      }
      return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
    }
    function WritableStreamDefaultWriterRelease(writer) {
      const stream = writer._ownerWritableStream;
      const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);
      WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
      WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
      stream._writer = undefined;
      writer._ownerWritableStream = undefined;
    }
    function WritableStreamDefaultWriterWrite(writer, chunk) {
      const stream = writer._ownerWritableStream;
      const controller = stream._writableStreamController;
      const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
      if (stream !== writer._ownerWritableStream) {
        return promiseRejectedWith(defaultWriterLockException("write to"));
      }
      const state = stream._state;
      if (state === "errored") {
        return promiseRejectedWith(stream._storedError);
      }
      if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
        return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
      }
      if (state === "erroring") {
        return promiseRejectedWith(stream._storedError);
      }
      const promise = WritableStreamAddWriteRequest(stream);
      WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
      return promise;
    }
    const closeSentinel = {};

    class WritableStreamDefaultController2 {
      constructor() {
        throw new TypeError("Illegal constructor");
      }
      get abortReason() {
        if (!IsWritableStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException$2("abortReason");
        }
        return this._abortReason;
      }
      get signal() {
        if (!IsWritableStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException$2("signal");
        }
        if (this._abortController === undefined) {
          throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
        }
        return this._abortController.signal;
      }
      error(e2 = undefined) {
        if (!IsWritableStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException$2("error");
        }
        const state = this._controlledWritableStream._state;
        if (state !== "writable") {
          return;
        }
        WritableStreamDefaultControllerError(this, e2);
      }
      [AbortSteps](reason) {
        const result = this._abortAlgorithm(reason);
        WritableStreamDefaultControllerClearAlgorithms(this);
        return result;
      }
      [ErrorSteps]() {
        ResetQueue(this);
      }
    }
    Object.defineProperties(WritableStreamDefaultController2.prototype, {
      abortReason: { enumerable: true },
      signal: { enumerable: true },
      error: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
      Object.defineProperty(WritableStreamDefaultController2.prototype, SymbolPolyfill.toStringTag, {
        value: "WritableStreamDefaultController",
        configurable: true
      });
    }
    function IsWritableStreamDefaultController(x2) {
      if (!typeIsObject(x2)) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(x2, "_controlledWritableStream")) {
        return false;
      }
      return x2 instanceof WritableStreamDefaultController2;
    }
    function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
      controller._controlledWritableStream = stream;
      stream._writableStreamController = controller;
      controller._queue = undefined;
      controller._queueTotalSize = undefined;
      ResetQueue(controller);
      controller._abortReason = undefined;
      controller._abortController = createAbortController();
      controller._started = false;
      controller._strategySizeAlgorithm = sizeAlgorithm;
      controller._strategyHWM = highWaterMark;
      controller._writeAlgorithm = writeAlgorithm;
      controller._closeAlgorithm = closeAlgorithm;
      controller._abortAlgorithm = abortAlgorithm;
      const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
      WritableStreamUpdateBackpressure(stream, backpressure);
      const startResult = startAlgorithm();
      const startPromise = promiseResolvedWith(startResult);
      uponPromise(startPromise, () => {
        controller._started = true;
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
      }, (r2) => {
        controller._started = true;
        WritableStreamDealWithRejection(stream, r2);
      });
    }
    function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
      const controller = Object.create(WritableStreamDefaultController2.prototype);
      let startAlgorithm = () => {
        return;
      };
      let writeAlgorithm = () => promiseResolvedWith(undefined);
      let closeAlgorithm = () => promiseResolvedWith(undefined);
      let abortAlgorithm = () => promiseResolvedWith(undefined);
      if (underlyingSink.start !== undefined) {
        startAlgorithm = () => underlyingSink.start(controller);
      }
      if (underlyingSink.write !== undefined) {
        writeAlgorithm = (chunk) => underlyingSink.write(chunk, controller);
      }
      if (underlyingSink.close !== undefined) {
        closeAlgorithm = () => underlyingSink.close();
      }
      if (underlyingSink.abort !== undefined) {
        abortAlgorithm = (reason) => underlyingSink.abort(reason);
      }
      SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
    }
    function WritableStreamDefaultControllerClearAlgorithms(controller) {
      controller._writeAlgorithm = undefined;
      controller._closeAlgorithm = undefined;
      controller._abortAlgorithm = undefined;
      controller._strategySizeAlgorithm = undefined;
    }
    function WritableStreamDefaultControllerClose(controller) {
      EnqueueValueWithSize(controller, closeSentinel, 0);
      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
    }
    function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
      try {
        return controller._strategySizeAlgorithm(chunk);
      } catch (chunkSizeE) {
        WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
        return 1;
      }
    }
    function WritableStreamDefaultControllerGetDesiredSize(controller) {
      return controller._strategyHWM - controller._queueTotalSize;
    }
    function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
      try {
        EnqueueValueWithSize(controller, chunk, chunkSize);
      } catch (enqueueE) {
        WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
        return;
      }
      const stream = controller._controlledWritableStream;
      if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === "writable") {
        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
        WritableStreamUpdateBackpressure(stream, backpressure);
      }
      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
    }
    function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
      const stream = controller._controlledWritableStream;
      if (!controller._started) {
        return;
      }
      if (stream._inFlightWriteRequest !== undefined) {
        return;
      }
      const state = stream._state;
      if (state === "erroring") {
        WritableStreamFinishErroring(stream);
        return;
      }
      if (controller._queue.length === 0) {
        return;
      }
      const value = PeekQueueValue(controller);
      if (value === closeSentinel) {
        WritableStreamDefaultControllerProcessClose(controller);
      } else {
        WritableStreamDefaultControllerProcessWrite(controller, value);
      }
    }
    function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
      if (controller._controlledWritableStream._state === "writable") {
        WritableStreamDefaultControllerError(controller, error);
      }
    }
    function WritableStreamDefaultControllerProcessClose(controller) {
      const stream = controller._controlledWritableStream;
      WritableStreamMarkCloseRequestInFlight(stream);
      DequeueValue(controller);
      const sinkClosePromise = controller._closeAlgorithm();
      WritableStreamDefaultControllerClearAlgorithms(controller);
      uponPromise(sinkClosePromise, () => {
        WritableStreamFinishInFlightClose(stream);
      }, (reason) => {
        WritableStreamFinishInFlightCloseWithError(stream, reason);
      });
    }
    function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
      const stream = controller._controlledWritableStream;
      WritableStreamMarkFirstWriteRequestInFlight(stream);
      const sinkWritePromise = controller._writeAlgorithm(chunk);
      uponPromise(sinkWritePromise, () => {
        WritableStreamFinishInFlightWrite(stream);
        const state = stream._state;
        DequeueValue(controller);
        if (!WritableStreamCloseQueuedOrInFlight(stream) && state === "writable") {
          const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
          WritableStreamUpdateBackpressure(stream, backpressure);
        }
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
      }, (reason) => {
        if (stream._state === "writable") {
          WritableStreamDefaultControllerClearAlgorithms(controller);
        }
        WritableStreamFinishInFlightWriteWithError(stream, reason);
      });
    }
    function WritableStreamDefaultControllerGetBackpressure(controller) {
      const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
      return desiredSize <= 0;
    }
    function WritableStreamDefaultControllerError(controller, error) {
      const stream = controller._controlledWritableStream;
      WritableStreamDefaultControllerClearAlgorithms(controller);
      WritableStreamStartErroring(stream, error);
    }
    function streamBrandCheckException$2(name) {
      return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);
    }
    function defaultControllerBrandCheckException$2(name) {
      return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);
    }
    function defaultWriterBrandCheckException(name) {
      return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);
    }
    function defaultWriterLockException(name) {
      return new TypeError("Cannot " + name + " a stream using a released writer");
    }
    function defaultWriterClosedPromiseInitialize(writer) {
      writer._closedPromise = newPromise((resolve, reject) => {
        writer._closedPromise_resolve = resolve;
        writer._closedPromise_reject = reject;
        writer._closedPromiseState = "pending";
      });
    }
    function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
      defaultWriterClosedPromiseInitialize(writer);
      defaultWriterClosedPromiseReject(writer, reason);
    }
    function defaultWriterClosedPromiseInitializeAsResolved(writer) {
      defaultWriterClosedPromiseInitialize(writer);
      defaultWriterClosedPromiseResolve(writer);
    }
    function defaultWriterClosedPromiseReject(writer, reason) {
      if (writer._closedPromise_reject === undefined) {
        return;
      }
      setPromiseIsHandledToTrue(writer._closedPromise);
      writer._closedPromise_reject(reason);
      writer._closedPromise_resolve = undefined;
      writer._closedPromise_reject = undefined;
      writer._closedPromiseState = "rejected";
    }
    function defaultWriterClosedPromiseResetToRejected(writer, reason) {
      defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
    }
    function defaultWriterClosedPromiseResolve(writer) {
      if (writer._closedPromise_resolve === undefined) {
        return;
      }
      writer._closedPromise_resolve(undefined);
      writer._closedPromise_resolve = undefined;
      writer._closedPromise_reject = undefined;
      writer._closedPromiseState = "resolved";
    }
    function defaultWriterReadyPromiseInitialize(writer) {
      writer._readyPromise = newPromise((resolve, reject) => {
        writer._readyPromise_resolve = resolve;
        writer._readyPromise_reject = reject;
      });
      writer._readyPromiseState = "pending";
    }
    function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
      defaultWriterReadyPromiseInitialize(writer);
      defaultWriterReadyPromiseReject(writer, reason);
    }
    function defaultWriterReadyPromiseInitializeAsResolved(writer) {
      defaultWriterReadyPromiseInitialize(writer);
      defaultWriterReadyPromiseResolve(writer);
    }
    function defaultWriterReadyPromiseReject(writer, reason) {
      if (writer._readyPromise_reject === undefined) {
        return;
      }
      setPromiseIsHandledToTrue(writer._readyPromise);
      writer._readyPromise_reject(reason);
      writer._readyPromise_resolve = undefined;
      writer._readyPromise_reject = undefined;
      writer._readyPromiseState = "rejected";
    }
    function defaultWriterReadyPromiseReset(writer) {
      defaultWriterReadyPromiseInitialize(writer);
    }
    function defaultWriterReadyPromiseResetToRejected(writer, reason) {
      defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
    }
    function defaultWriterReadyPromiseResolve(writer) {
      if (writer._readyPromise_resolve === undefined) {
        return;
      }
      writer._readyPromise_resolve(undefined);
      writer._readyPromise_resolve = undefined;
      writer._readyPromise_reject = undefined;
      writer._readyPromiseState = "fulfilled";
    }
    const NativeDOMException = typeof DOMException !== "undefined" ? DOMException : undefined;
    function isDOMExceptionConstructor(ctor) {
      if (!(typeof ctor === "function" || typeof ctor === "object")) {
        return false;
      }
      try {
        new ctor;
        return true;
      } catch (_a) {
        return false;
      }
    }
    function createDOMExceptionPolyfill() {
      const ctor = function DOMException(message, name) {
        this.message = message || "";
        this.name = name || "Error";
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
      };
      ctor.prototype = Object.create(Error.prototype);
      Object.defineProperty(ctor.prototype, "constructor", { value: ctor, writable: true, configurable: true });
      return ctor;
    }
    const DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();
    function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
      const reader = AcquireReadableStreamDefaultReader(source);
      const writer = AcquireWritableStreamDefaultWriter(dest);
      source._disturbed = true;
      let shuttingDown = false;
      let currentWrite = promiseResolvedWith(undefined);
      return newPromise((resolve, reject) => {
        let abortAlgorithm;
        if (signal !== undefined) {
          abortAlgorithm = () => {
            const error = new DOMException$1("Aborted", "AbortError");
            const actions = [];
            if (!preventAbort) {
              actions.push(() => {
                if (dest._state === "writable") {
                  return WritableStreamAbort(dest, error);
                }
                return promiseResolvedWith(undefined);
              });
            }
            if (!preventCancel) {
              actions.push(() => {
                if (source._state === "readable") {
                  return ReadableStreamCancel(source, error);
                }
                return promiseResolvedWith(undefined);
              });
            }
            shutdownWithAction(() => Promise.all(actions.map((action) => action())), true, error);
          };
          if (signal.aborted) {
            abortAlgorithm();
            return;
          }
          signal.addEventListener("abort", abortAlgorithm);
        }
        function pipeLoop() {
          return newPromise((resolveLoop, rejectLoop) => {
            function next(done) {
              if (done) {
                resolveLoop();
              } else {
                PerformPromiseThen(pipeStep(), next, rejectLoop);
              }
            }
            next(false);
          });
        }
        function pipeStep() {
          if (shuttingDown) {
            return promiseResolvedWith(true);
          }
          return PerformPromiseThen(writer._readyPromise, () => {
            return newPromise((resolveRead, rejectRead) => {
              ReadableStreamDefaultReaderRead(reader, {
                _chunkSteps: (chunk) => {
                  currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);
                  resolveRead(false);
                },
                _closeSteps: () => resolveRead(true),
                _errorSteps: rejectRead
              });
            });
          });
        }
        isOrBecomesErrored(source, reader._closedPromise, (storedError) => {
          if (!preventAbort) {
            shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);
          } else {
            shutdown(true, storedError);
          }
        });
        isOrBecomesErrored(dest, writer._closedPromise, (storedError) => {
          if (!preventCancel) {
            shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);
          } else {
            shutdown(true, storedError);
          }
        });
        isOrBecomesClosed(source, reader._closedPromise, () => {
          if (!preventClose) {
            shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));
          } else {
            shutdown();
          }
        });
        if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
          const destClosed = new TypeError("the destination writable stream closed before all data could be piped to it");
          if (!preventCancel) {
            shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);
          } else {
            shutdown(true, destClosed);
          }
        }
        setPromiseIsHandledToTrue(pipeLoop());
        function waitForWritesToFinish() {
          const oldCurrentWrite = currentWrite;
          return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined);
        }
        function isOrBecomesErrored(stream, promise, action) {
          if (stream._state === "errored") {
            action(stream._storedError);
          } else {
            uponRejection(promise, action);
          }
        }
        function isOrBecomesClosed(stream, promise, action) {
          if (stream._state === "closed") {
            action();
          } else {
            uponFulfillment(promise, action);
          }
        }
        function shutdownWithAction(action, originalIsError, originalError) {
          if (shuttingDown) {
            return;
          }
          shuttingDown = true;
          if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
            uponFulfillment(waitForWritesToFinish(), doTheRest);
          } else {
            doTheRest();
          }
          function doTheRest() {
            uponPromise(action(), () => finalize(originalIsError, originalError), (newError) => finalize(true, newError));
          }
        }
        function shutdown(isError, error) {
          if (shuttingDown) {
            return;
          }
          shuttingDown = true;
          if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
            uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error));
          } else {
            finalize(isError, error);
          }
        }
        function finalize(isError, error) {
          WritableStreamDefaultWriterRelease(writer);
          ReadableStreamReaderGenericRelease(reader);
          if (signal !== undefined) {
            signal.removeEventListener("abort", abortAlgorithm);
          }
          if (isError) {
            reject(error);
          } else {
            resolve(undefined);
          }
        }
      });
    }

    class ReadableStreamDefaultController2 {
      constructor() {
        throw new TypeError("Illegal constructor");
      }
      get desiredSize() {
        if (!IsReadableStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException$1("desiredSize");
        }
        return ReadableStreamDefaultControllerGetDesiredSize(this);
      }
      close() {
        if (!IsReadableStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException$1("close");
        }
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
          throw new TypeError("The stream is not in a state that permits close");
        }
        ReadableStreamDefaultControllerClose(this);
      }
      enqueue(chunk = undefined) {
        if (!IsReadableStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException$1("enqueue");
        }
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
          throw new TypeError("The stream is not in a state that permits enqueue");
        }
        return ReadableStreamDefaultControllerEnqueue(this, chunk);
      }
      error(e2 = undefined) {
        if (!IsReadableStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException$1("error");
        }
        ReadableStreamDefaultControllerError(this, e2);
      }
      [CancelSteps](reason) {
        ResetQueue(this);
        const result = this._cancelAlgorithm(reason);
        ReadableStreamDefaultControllerClearAlgorithms(this);
        return result;
      }
      [PullSteps](readRequest) {
        const stream = this._controlledReadableStream;
        if (this._queue.length > 0) {
          const chunk = DequeueValue(this);
          if (this._closeRequested && this._queue.length === 0) {
            ReadableStreamDefaultControllerClearAlgorithms(this);
            ReadableStreamClose(stream);
          } else {
            ReadableStreamDefaultControllerCallPullIfNeeded(this);
          }
          readRequest._chunkSteps(chunk);
        } else {
          ReadableStreamAddReadRequest(stream, readRequest);
          ReadableStreamDefaultControllerCallPullIfNeeded(this);
        }
      }
    }
    Object.defineProperties(ReadableStreamDefaultController2.prototype, {
      close: { enumerable: true },
      enqueue: { enumerable: true },
      error: { enumerable: true },
      desiredSize: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
      Object.defineProperty(ReadableStreamDefaultController2.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableStreamDefaultController",
        configurable: true
      });
    }
    function IsReadableStreamDefaultController(x2) {
      if (!typeIsObject(x2)) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(x2, "_controlledReadableStream")) {
        return false;
      }
      return x2 instanceof ReadableStreamDefaultController2;
    }
    function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
      const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
      if (!shouldPull) {
        return;
      }
      if (controller._pulling) {
        controller._pullAgain = true;
        return;
      }
      controller._pulling = true;
      const pullPromise = controller._pullAlgorithm();
      uponPromise(pullPromise, () => {
        controller._pulling = false;
        if (controller._pullAgain) {
          controller._pullAgain = false;
          ReadableStreamDefaultControllerCallPullIfNeeded(controller);
        }
      }, (e2) => {
        ReadableStreamDefaultControllerError(controller, e2);
      });
    }
    function ReadableStreamDefaultControllerShouldCallPull(controller) {
      const stream = controller._controlledReadableStream;
      if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
        return false;
      }
      if (!controller._started) {
        return false;
      }
      if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
        return true;
      }
      const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
      if (desiredSize > 0) {
        return true;
      }
      return false;
    }
    function ReadableStreamDefaultControllerClearAlgorithms(controller) {
      controller._pullAlgorithm = undefined;
      controller._cancelAlgorithm = undefined;
      controller._strategySizeAlgorithm = undefined;
    }
    function ReadableStreamDefaultControllerClose(controller) {
      if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
        return;
      }
      const stream = controller._controlledReadableStream;
      controller._closeRequested = true;
      if (controller._queue.length === 0) {
        ReadableStreamDefaultControllerClearAlgorithms(controller);
        ReadableStreamClose(stream);
      }
    }
    function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
      if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
        return;
      }
      const stream = controller._controlledReadableStream;
      if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
        ReadableStreamFulfillReadRequest(stream, chunk, false);
      } else {
        let chunkSize;
        try {
          chunkSize = controller._strategySizeAlgorithm(chunk);
        } catch (chunkSizeE) {
          ReadableStreamDefaultControllerError(controller, chunkSizeE);
          throw chunkSizeE;
        }
        try {
          EnqueueValueWithSize(controller, chunk, chunkSize);
        } catch (enqueueE) {
          ReadableStreamDefaultControllerError(controller, enqueueE);
          throw enqueueE;
        }
      }
      ReadableStreamDefaultControllerCallPullIfNeeded(controller);
    }
    function ReadableStreamDefaultControllerError(controller, e2) {
      const stream = controller._controlledReadableStream;
      if (stream._state !== "readable") {
        return;
      }
      ResetQueue(controller);
      ReadableStreamDefaultControllerClearAlgorithms(controller);
      ReadableStreamError(stream, e2);
    }
    function ReadableStreamDefaultControllerGetDesiredSize(controller) {
      const state = controller._controlledReadableStream._state;
      if (state === "errored") {
        return null;
      }
      if (state === "closed") {
        return 0;
      }
      return controller._strategyHWM - controller._queueTotalSize;
    }
    function ReadableStreamDefaultControllerHasBackpressure(controller) {
      if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
        return false;
      }
      return true;
    }
    function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
      const state = controller._controlledReadableStream._state;
      if (!controller._closeRequested && state === "readable") {
        return true;
      }
      return false;
    }
    function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
      controller._controlledReadableStream = stream;
      controller._queue = undefined;
      controller._queueTotalSize = undefined;
      ResetQueue(controller);
      controller._started = false;
      controller._closeRequested = false;
      controller._pullAgain = false;
      controller._pulling = false;
      controller._strategySizeAlgorithm = sizeAlgorithm;
      controller._strategyHWM = highWaterMark;
      controller._pullAlgorithm = pullAlgorithm;
      controller._cancelAlgorithm = cancelAlgorithm;
      stream._readableStreamController = controller;
      const startResult = startAlgorithm();
      uponPromise(promiseResolvedWith(startResult), () => {
        controller._started = true;
        ReadableStreamDefaultControllerCallPullIfNeeded(controller);
      }, (r2) => {
        ReadableStreamDefaultControllerError(controller, r2);
      });
    }
    function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
      const controller = Object.create(ReadableStreamDefaultController2.prototype);
      let startAlgorithm = () => {
        return;
      };
      let pullAlgorithm = () => promiseResolvedWith(undefined);
      let cancelAlgorithm = () => promiseResolvedWith(undefined);
      if (underlyingSource.start !== undefined) {
        startAlgorithm = () => underlyingSource.start(controller);
      }
      if (underlyingSource.pull !== undefined) {
        pullAlgorithm = () => underlyingSource.pull(controller);
      }
      if (underlyingSource.cancel !== undefined) {
        cancelAlgorithm = (reason) => underlyingSource.cancel(reason);
      }
      SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
    }
    function defaultControllerBrandCheckException$1(name) {
      return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);
    }
    function ReadableStreamTee(stream, cloneForBranch2) {
      if (IsReadableByteStreamController(stream._readableStreamController)) {
        return ReadableByteStreamTee(stream);
      }
      return ReadableStreamDefaultTee(stream);
    }
    function ReadableStreamDefaultTee(stream, cloneForBranch2) {
      const reader = AcquireReadableStreamDefaultReader(stream);
      let reading = false;
      let readAgain = false;
      let canceled1 = false;
      let canceled2 = false;
      let reason1;
      let reason2;
      let branch1;
      let branch2;
      let resolveCancelPromise;
      const cancelPromise = newPromise((resolve) => {
        resolveCancelPromise = resolve;
      });
      function pullAlgorithm() {
        if (reading) {
          readAgain = true;
          return promiseResolvedWith(undefined);
        }
        reading = true;
        const readRequest = {
          _chunkSteps: (chunk) => {
            queueMicrotask2(() => {
              readAgain = false;
              const chunk1 = chunk;
              const chunk2 = chunk;
              if (!canceled1) {
                ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
              }
              if (!canceled2) {
                ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
              }
              reading = false;
              if (readAgain) {
                pullAlgorithm();
              }
            });
          },
          _closeSteps: () => {
            reading = false;
            if (!canceled1) {
              ReadableStreamDefaultControllerClose(branch1._readableStreamController);
            }
            if (!canceled2) {
              ReadableStreamDefaultControllerClose(branch2._readableStreamController);
            }
            if (!canceled1 || !canceled2) {
              resolveCancelPromise(undefined);
            }
          },
          _errorSteps: () => {
            reading = false;
          }
        };
        ReadableStreamDefaultReaderRead(reader, readRequest);
        return promiseResolvedWith(undefined);
      }
      function cancel1Algorithm(reason) {
        canceled1 = true;
        reason1 = reason;
        if (canceled2) {
          const compositeReason = CreateArrayFromList([reason1, reason2]);
          const cancelResult = ReadableStreamCancel(stream, compositeReason);
          resolveCancelPromise(cancelResult);
        }
        return cancelPromise;
      }
      function cancel2Algorithm(reason) {
        canceled2 = true;
        reason2 = reason;
        if (canceled1) {
          const compositeReason = CreateArrayFromList([reason1, reason2]);
          const cancelResult = ReadableStreamCancel(stream, compositeReason);
          resolveCancelPromise(cancelResult);
        }
        return cancelPromise;
      }
      function startAlgorithm() {
      }
      branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
      branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
      uponRejection(reader._closedPromise, (r2) => {
        ReadableStreamDefaultControllerError(branch1._readableStreamController, r2);
        ReadableStreamDefaultControllerError(branch2._readableStreamController, r2);
        if (!canceled1 || !canceled2) {
          resolveCancelPromise(undefined);
        }
      });
      return [branch1, branch2];
    }
    function ReadableByteStreamTee(stream) {
      let reader = AcquireReadableStreamDefaultReader(stream);
      let reading = false;
      let readAgainForBranch1 = false;
      let readAgainForBranch2 = false;
      let canceled1 = false;
      let canceled2 = false;
      let reason1;
      let reason2;
      let branch1;
      let branch2;
      let resolveCancelPromise;
      const cancelPromise = newPromise((resolve) => {
        resolveCancelPromise = resolve;
      });
      function forwardReaderError(thisReader) {
        uponRejection(thisReader._closedPromise, (r2) => {
          if (thisReader !== reader) {
            return;
          }
          ReadableByteStreamControllerError(branch1._readableStreamController, r2);
          ReadableByteStreamControllerError(branch2._readableStreamController, r2);
          if (!canceled1 || !canceled2) {
            resolveCancelPromise(undefined);
          }
        });
      }
      function pullWithDefaultReader() {
        if (IsReadableStreamBYOBReader(reader)) {
          ReadableStreamReaderGenericRelease(reader);
          reader = AcquireReadableStreamDefaultReader(stream);
          forwardReaderError(reader);
        }
        const readRequest = {
          _chunkSteps: (chunk) => {
            queueMicrotask2(() => {
              readAgainForBranch1 = false;
              readAgainForBranch2 = false;
              const chunk1 = chunk;
              let chunk2 = chunk;
              if (!canceled1 && !canceled2) {
                try {
                  chunk2 = CloneAsUint8Array(chunk);
                } catch (cloneE) {
                  ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
                  ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
                  resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                  return;
                }
              }
              if (!canceled1) {
                ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
              }
              if (!canceled2) {
                ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
              }
              reading = false;
              if (readAgainForBranch1) {
                pull1Algorithm();
              } else if (readAgainForBranch2) {
                pull2Algorithm();
              }
            });
          },
          _closeSteps: () => {
            reading = false;
            if (!canceled1) {
              ReadableByteStreamControllerClose(branch1._readableStreamController);
            }
            if (!canceled2) {
              ReadableByteStreamControllerClose(branch2._readableStreamController);
            }
            if (branch1._readableStreamController._pendingPullIntos.length > 0) {
              ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
            }
            if (branch2._readableStreamController._pendingPullIntos.length > 0) {
              ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
            }
            if (!canceled1 || !canceled2) {
              resolveCancelPromise(undefined);
            }
          },
          _errorSteps: () => {
            reading = false;
          }
        };
        ReadableStreamDefaultReaderRead(reader, readRequest);
      }
      function pullWithBYOBReader(view, forBranch2) {
        if (IsReadableStreamDefaultReader(reader)) {
          ReadableStreamReaderGenericRelease(reader);
          reader = AcquireReadableStreamBYOBReader(stream);
          forwardReaderError(reader);
        }
        const byobBranch = forBranch2 ? branch2 : branch1;
        const otherBranch = forBranch2 ? branch1 : branch2;
        const readIntoRequest = {
          _chunkSteps: (chunk) => {
            queueMicrotask2(() => {
              readAgainForBranch1 = false;
              readAgainForBranch2 = false;
              const byobCanceled = forBranch2 ? canceled2 : canceled1;
              const otherCanceled = forBranch2 ? canceled1 : canceled2;
              if (!otherCanceled) {
                let clonedChunk;
                try {
                  clonedChunk = CloneAsUint8Array(chunk);
                } catch (cloneE) {
                  ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
                  ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
                  resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                  return;
                }
                if (!byobCanceled) {
                  ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                }
                ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
              } else if (!byobCanceled) {
                ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
              }
              reading = false;
              if (readAgainForBranch1) {
                pull1Algorithm();
              } else if (readAgainForBranch2) {
                pull2Algorithm();
              }
            });
          },
          _closeSteps: (chunk) => {
            reading = false;
            const byobCanceled = forBranch2 ? canceled2 : canceled1;
            const otherCanceled = forBranch2 ? canceled1 : canceled2;
            if (!byobCanceled) {
              ReadableByteStreamControllerClose(byobBranch._readableStreamController);
            }
            if (!otherCanceled) {
              ReadableByteStreamControllerClose(otherBranch._readableStreamController);
            }
            if (chunk !== undefined) {
              if (!byobCanceled) {
                ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
              }
              if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
                ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
              }
            }
            if (!byobCanceled || !otherCanceled) {
              resolveCancelPromise(undefined);
            }
          },
          _errorSteps: () => {
            reading = false;
          }
        };
        ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);
      }
      function pull1Algorithm() {
        if (reading) {
          readAgainForBranch1 = true;
          return promiseResolvedWith(undefined);
        }
        reading = true;
        const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
        if (byobRequest === null) {
          pullWithDefaultReader();
        } else {
          pullWithBYOBReader(byobRequest._view, false);
        }
        return promiseResolvedWith(undefined);
      }
      function pull2Algorithm() {
        if (reading) {
          readAgainForBranch2 = true;
          return promiseResolvedWith(undefined);
        }
        reading = true;
        const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
        if (byobRequest === null) {
          pullWithDefaultReader();
        } else {
          pullWithBYOBReader(byobRequest._view, true);
        }
        return promiseResolvedWith(undefined);
      }
      function cancel1Algorithm(reason) {
        canceled1 = true;
        reason1 = reason;
        if (canceled2) {
          const compositeReason = CreateArrayFromList([reason1, reason2]);
          const cancelResult = ReadableStreamCancel(stream, compositeReason);
          resolveCancelPromise(cancelResult);
        }
        return cancelPromise;
      }
      function cancel2Algorithm(reason) {
        canceled2 = true;
        reason2 = reason;
        if (canceled1) {
          const compositeReason = CreateArrayFromList([reason1, reason2]);
          const cancelResult = ReadableStreamCancel(stream, compositeReason);
          resolveCancelPromise(cancelResult);
        }
        return cancelPromise;
      }
      function startAlgorithm() {
        return;
      }
      branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
      branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
      forwardReaderError(reader);
      return [branch1, branch2];
    }
    function convertUnderlyingDefaultOrByteSource(source, context) {
      assertDictionary(source, context);
      const original = source;
      const autoAllocateChunkSize = original === null || original === undefined ? undefined : original.autoAllocateChunkSize;
      const cancel = original === null || original === undefined ? undefined : original.cancel;
      const pull = original === null || original === undefined ? undefined : original.pull;
      const start = original === null || original === undefined ? undefined : original.start;
      const type = original === null || original === undefined ? undefined : original.type;
      return {
        autoAllocateChunkSize: autoAllocateChunkSize === undefined ? undefined : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),
        cancel: cancel === undefined ? undefined : convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),
        pull: pull === undefined ? undefined : convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),
        start: start === undefined ? undefined : convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),
        type: type === undefined ? undefined : convertReadableStreamType(type, `${context} has member 'type' that`)
      };
    }
    function convertUnderlyingSourceCancelCallback(fn, original, context) {
      assertFunction(fn, context);
      return (reason) => promiseCall(fn, original, [reason]);
    }
    function convertUnderlyingSourcePullCallback(fn, original, context) {
      assertFunction(fn, context);
      return (controller) => promiseCall(fn, original, [controller]);
    }
    function convertUnderlyingSourceStartCallback(fn, original, context) {
      assertFunction(fn, context);
      return (controller) => reflectCall(fn, original, [controller]);
    }
    function convertReadableStreamType(type, context) {
      type = `${type}`;
      if (type !== "bytes") {
        throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);
      }
      return type;
    }
    function convertReaderOptions(options2, context) {
      assertDictionary(options2, context);
      const mode = options2 === null || options2 === undefined ? undefined : options2.mode;
      return {
        mode: mode === undefined ? undefined : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)
      };
    }
    function convertReadableStreamReaderMode(mode, context) {
      mode = `${mode}`;
      if (mode !== "byob") {
        throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);
      }
      return mode;
    }
    function convertIteratorOptions(options2, context) {
      assertDictionary(options2, context);
      const preventCancel = options2 === null || options2 === undefined ? undefined : options2.preventCancel;
      return { preventCancel: Boolean(preventCancel) };
    }
    function convertPipeOptions(options2, context) {
      assertDictionary(options2, context);
      const preventAbort = options2 === null || options2 === undefined ? undefined : options2.preventAbort;
      const preventCancel = options2 === null || options2 === undefined ? undefined : options2.preventCancel;
      const preventClose = options2 === null || options2 === undefined ? undefined : options2.preventClose;
      const signal = options2 === null || options2 === undefined ? undefined : options2.signal;
      if (signal !== undefined) {
        assertAbortSignal(signal, `${context} has member 'signal' that`);
      }
      return {
        preventAbort: Boolean(preventAbort),
        preventCancel: Boolean(preventCancel),
        preventClose: Boolean(preventClose),
        signal
      };
    }
    function assertAbortSignal(signal, context) {
      if (!isAbortSignal(signal)) {
        throw new TypeError(`${context} is not an AbortSignal.`);
      }
    }
    function convertReadableWritablePair(pair, context) {
      assertDictionary(pair, context);
      const readable = pair === null || pair === undefined ? undefined : pair.readable;
      assertRequiredField(readable, "readable", "ReadableWritablePair");
      assertReadableStream(readable, `${context} has member 'readable' that`);
      const writable = pair === null || pair === undefined ? undefined : pair.writable;
      assertRequiredField(writable, "writable", "ReadableWritablePair");
      assertWritableStream(writable, `${context} has member 'writable' that`);
      return { readable, writable };
    }

    class ReadableStream3 {
      constructor(rawUnderlyingSource = {}, rawStrategy = {}) {
        if (rawUnderlyingSource === undefined) {
          rawUnderlyingSource = null;
        } else {
          assertObject(rawUnderlyingSource, "First parameter");
        }
        const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
        const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
        InitializeReadableStream(this);
        if (underlyingSource.type === "bytes") {
          if (strategy.size !== undefined) {
            throw new RangeError("The strategy for a byte stream cannot have a size function");
          }
          const highWaterMark = ExtractHighWaterMark(strategy, 0);
          SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
        } else {
          const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
          const highWaterMark = ExtractHighWaterMark(strategy, 1);
          SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
        }
      }
      get locked() {
        if (!IsReadableStream(this)) {
          throw streamBrandCheckException$1("locked");
        }
        return IsReadableStreamLocked(this);
      }
      cancel(reason = undefined) {
        if (!IsReadableStream(this)) {
          return promiseRejectedWith(streamBrandCheckException$1("cancel"));
        }
        if (IsReadableStreamLocked(this)) {
          return promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader"));
        }
        return ReadableStreamCancel(this, reason);
      }
      getReader(rawOptions = undefined) {
        if (!IsReadableStream(this)) {
          throw streamBrandCheckException$1("getReader");
        }
        const options2 = convertReaderOptions(rawOptions, "First parameter");
        if (options2.mode === undefined) {
          return AcquireReadableStreamDefaultReader(this);
        }
        return AcquireReadableStreamBYOBReader(this);
      }
      pipeThrough(rawTransform, rawOptions = {}) {
        if (!IsReadableStream(this)) {
          throw streamBrandCheckException$1("pipeThrough");
        }
        assertRequiredArgument(rawTransform, 1, "pipeThrough");
        const transform = convertReadableWritablePair(rawTransform, "First parameter");
        const options2 = convertPipeOptions(rawOptions, "Second parameter");
        if (IsReadableStreamLocked(this)) {
          throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
        }
        if (IsWritableStreamLocked(transform.writable)) {
          throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
        }
        const promise = ReadableStreamPipeTo(this, transform.writable, options2.preventClose, options2.preventAbort, options2.preventCancel, options2.signal);
        setPromiseIsHandledToTrue(promise);
        return transform.readable;
      }
      pipeTo(destination, rawOptions = {}) {
        if (!IsReadableStream(this)) {
          return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
        }
        if (destination === undefined) {
          return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);
        }
        if (!IsWritableStream(destination)) {
          return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));
        }
        let options2;
        try {
          options2 = convertPipeOptions(rawOptions, "Second parameter");
        } catch (e2) {
          return promiseRejectedWith(e2);
        }
        if (IsReadableStreamLocked(this)) {
          return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));
        }
        if (IsWritableStreamLocked(destination)) {
          return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));
        }
        return ReadableStreamPipeTo(this, destination, options2.preventClose, options2.preventAbort, options2.preventCancel, options2.signal);
      }
      tee() {
        if (!IsReadableStream(this)) {
          throw streamBrandCheckException$1("tee");
        }
        const branches = ReadableStreamTee(this);
        return CreateArrayFromList(branches);
      }
      values(rawOptions = undefined) {
        if (!IsReadableStream(this)) {
          throw streamBrandCheckException$1("values");
        }
        const options2 = convertIteratorOptions(rawOptions, "First parameter");
        return AcquireReadableStreamAsyncIterator(this, options2.preventCancel);
      }
    }
    Object.defineProperties(ReadableStream3.prototype, {
      cancel: { enumerable: true },
      getReader: { enumerable: true },
      pipeThrough: { enumerable: true },
      pipeTo: { enumerable: true },
      tee: { enumerable: true },
      values: { enumerable: true },
      locked: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
      Object.defineProperty(ReadableStream3.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableStream",
        configurable: true
      });
    }
    if (typeof SymbolPolyfill.asyncIterator === "symbol") {
      Object.defineProperty(ReadableStream3.prototype, SymbolPolyfill.asyncIterator, {
        value: ReadableStream3.prototype.values,
        writable: true,
        configurable: true
      });
    }
    function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
      const stream = Object.create(ReadableStream3.prototype);
      InitializeReadableStream(stream);
      const controller = Object.create(ReadableStreamDefaultController2.prototype);
      SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
      return stream;
    }
    function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
      const stream = Object.create(ReadableStream3.prototype);
      InitializeReadableStream(stream);
      const controller = Object.create(ReadableByteStreamController2.prototype);
      SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, undefined);
      return stream;
    }
    function InitializeReadableStream(stream) {
      stream._state = "readable";
      stream._reader = undefined;
      stream._storedError = undefined;
      stream._disturbed = false;
    }
    function IsReadableStream(x2) {
      if (!typeIsObject(x2)) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(x2, "_readableStreamController")) {
        return false;
      }
      return x2 instanceof ReadableStream3;
    }
    function IsReadableStreamLocked(stream) {
      if (stream._reader === undefined) {
        return false;
      }
      return true;
    }
    function ReadableStreamCancel(stream, reason) {
      stream._disturbed = true;
      if (stream._state === "closed") {
        return promiseResolvedWith(undefined);
      }
      if (stream._state === "errored") {
        return promiseRejectedWith(stream._storedError);
      }
      ReadableStreamClose(stream);
      const reader = stream._reader;
      if (reader !== undefined && IsReadableStreamBYOBReader(reader)) {
        reader._readIntoRequests.forEach((readIntoRequest) => {
          readIntoRequest._closeSteps(undefined);
        });
        reader._readIntoRequests = new SimpleQueue;
      }
      const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
      return transformPromiseWith(sourceCancelPromise, noop);
    }
    function ReadableStreamClose(stream) {
      stream._state = "closed";
      const reader = stream._reader;
      if (reader === undefined) {
        return;
      }
      defaultReaderClosedPromiseResolve(reader);
      if (IsReadableStreamDefaultReader(reader)) {
        reader._readRequests.forEach((readRequest) => {
          readRequest._closeSteps();
        });
        reader._readRequests = new SimpleQueue;
      }
    }
    function ReadableStreamError(stream, e2) {
      stream._state = "errored";
      stream._storedError = e2;
      const reader = stream._reader;
      if (reader === undefined) {
        return;
      }
      defaultReaderClosedPromiseReject(reader, e2);
      if (IsReadableStreamDefaultReader(reader)) {
        reader._readRequests.forEach((readRequest) => {
          readRequest._errorSteps(e2);
        });
        reader._readRequests = new SimpleQueue;
      } else {
        reader._readIntoRequests.forEach((readIntoRequest) => {
          readIntoRequest._errorSteps(e2);
        });
        reader._readIntoRequests = new SimpleQueue;
      }
    }
    function streamBrandCheckException$1(name) {
      return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);
    }
    function convertQueuingStrategyInit(init, context) {
      assertDictionary(init, context);
      const highWaterMark = init === null || init === undefined ? undefined : init.highWaterMark;
      assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit");
      return {
        highWaterMark: convertUnrestrictedDouble(highWaterMark)
      };
    }
    const byteLengthSizeFunction = (chunk) => {
      return chunk.byteLength;
    };
    try {
      Object.defineProperty(byteLengthSizeFunction, "name", {
        value: "size",
        configurable: true
      });
    } catch (_a) {
    }

    class ByteLengthQueuingStrategy2 {
      constructor(options2) {
        assertRequiredArgument(options2, 1, "ByteLengthQueuingStrategy");
        options2 = convertQueuingStrategyInit(options2, "First parameter");
        this._byteLengthQueuingStrategyHighWaterMark = options2.highWaterMark;
      }
      get highWaterMark() {
        if (!IsByteLengthQueuingStrategy(this)) {
          throw byteLengthBrandCheckException("highWaterMark");
        }
        return this._byteLengthQueuingStrategyHighWaterMark;
      }
      get size() {
        if (!IsByteLengthQueuingStrategy(this)) {
          throw byteLengthBrandCheckException("size");
        }
        return byteLengthSizeFunction;
      }
    }
    Object.defineProperties(ByteLengthQueuingStrategy2.prototype, {
      highWaterMark: { enumerable: true },
      size: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
      Object.defineProperty(ByteLengthQueuingStrategy2.prototype, SymbolPolyfill.toStringTag, {
        value: "ByteLengthQueuingStrategy",
        configurable: true
      });
    }
    function byteLengthBrandCheckException(name) {
      return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);
    }
    function IsByteLengthQueuingStrategy(x2) {
      if (!typeIsObject(x2)) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(x2, "_byteLengthQueuingStrategyHighWaterMark")) {
        return false;
      }
      return x2 instanceof ByteLengthQueuingStrategy2;
    }
    const countSizeFunction = () => {
      return 1;
    };
    try {
      Object.defineProperty(countSizeFunction, "name", {
        value: "size",
        configurable: true
      });
    } catch (_a) {
    }

    class CountQueuingStrategy2 {
      constructor(options2) {
        assertRequiredArgument(options2, 1, "CountQueuingStrategy");
        options2 = convertQueuingStrategyInit(options2, "First parameter");
        this._countQueuingStrategyHighWaterMark = options2.highWaterMark;
      }
      get highWaterMark() {
        if (!IsCountQueuingStrategy(this)) {
          throw countBrandCheckException("highWaterMark");
        }
        return this._countQueuingStrategyHighWaterMark;
      }
      get size() {
        if (!IsCountQueuingStrategy(this)) {
          throw countBrandCheckException("size");
        }
        return countSizeFunction;
      }
    }
    Object.defineProperties(CountQueuingStrategy2.prototype, {
      highWaterMark: { enumerable: true },
      size: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
      Object.defineProperty(CountQueuingStrategy2.prototype, SymbolPolyfill.toStringTag, {
        value: "CountQueuingStrategy",
        configurable: true
      });
    }
    function countBrandCheckException(name) {
      return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);
    }
    function IsCountQueuingStrategy(x2) {
      if (!typeIsObject(x2)) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(x2, "_countQueuingStrategyHighWaterMark")) {
        return false;
      }
      return x2 instanceof CountQueuingStrategy2;
    }
    function convertTransformer(original, context) {
      assertDictionary(original, context);
      const flush = original === null || original === undefined ? undefined : original.flush;
      const readableType = original === null || original === undefined ? undefined : original.readableType;
      const start = original === null || original === undefined ? undefined : original.start;
      const transform = original === null || original === undefined ? undefined : original.transform;
      const writableType = original === null || original === undefined ? undefined : original.writableType;
      return {
        flush: flush === undefined ? undefined : convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),
        readableType,
        start: start === undefined ? undefined : convertTransformerStartCallback(start, original, `${context} has member 'start' that`),
        transform: transform === undefined ? undefined : convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),
        writableType
      };
    }
    function convertTransformerFlushCallback(fn, original, context) {
      assertFunction(fn, context);
      return (controller) => promiseCall(fn, original, [controller]);
    }
    function convertTransformerStartCallback(fn, original, context) {
      assertFunction(fn, context);
      return (controller) => reflectCall(fn, original, [controller]);
    }
    function convertTransformerTransformCallback(fn, original, context) {
      assertFunction(fn, context);
      return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
    }

    class TransformStream2 {
      constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {
        if (rawTransformer === undefined) {
          rawTransformer = null;
        }
        const writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter");
        const readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter");
        const transformer = convertTransformer(rawTransformer, "First parameter");
        if (transformer.readableType !== undefined) {
          throw new RangeError("Invalid readableType specified");
        }
        if (transformer.writableType !== undefined) {
          throw new RangeError("Invalid writableType specified");
        }
        const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
        const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
        const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
        const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
        let startPromise_resolve;
        const startPromise = newPromise((resolve) => {
          startPromise_resolve = resolve;
        });
        InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
        SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
        if (transformer.start !== undefined) {
          startPromise_resolve(transformer.start(this._transformStreamController));
        } else {
          startPromise_resolve(undefined);
        }
      }
      get readable() {
        if (!IsTransformStream(this)) {
          throw streamBrandCheckException("readable");
        }
        return this._readable;
      }
      get writable() {
        if (!IsTransformStream(this)) {
          throw streamBrandCheckException("writable");
        }
        return this._writable;
      }
    }
    Object.defineProperties(TransformStream2.prototype, {
      readable: { enumerable: true },
      writable: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
      Object.defineProperty(TransformStream2.prototype, SymbolPolyfill.toStringTag, {
        value: "TransformStream",
        configurable: true
      });
    }
    function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
      function startAlgorithm() {
        return startPromise;
      }
      function writeAlgorithm(chunk) {
        return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
      }
      function abortAlgorithm(reason) {
        return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
      }
      function closeAlgorithm() {
        return TransformStreamDefaultSinkCloseAlgorithm(stream);
      }
      stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
      function pullAlgorithm() {
        return TransformStreamDefaultSourcePullAlgorithm(stream);
      }
      function cancelAlgorithm(reason) {
        TransformStreamErrorWritableAndUnblockWrite(stream, reason);
        return promiseResolvedWith(undefined);
      }
      stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
      stream._backpressure = undefined;
      stream._backpressureChangePromise = undefined;
      stream._backpressureChangePromise_resolve = undefined;
      TransformStreamSetBackpressure(stream, true);
      stream._transformStreamController = undefined;
    }
    function IsTransformStream(x2) {
      if (!typeIsObject(x2)) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(x2, "_transformStreamController")) {
        return false;
      }
      return x2 instanceof TransformStream2;
    }
    function TransformStreamError(stream, e2) {
      ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e2);
      TransformStreamErrorWritableAndUnblockWrite(stream, e2);
    }
    function TransformStreamErrorWritableAndUnblockWrite(stream, e2) {
      TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
      WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e2);
      if (stream._backpressure) {
        TransformStreamSetBackpressure(stream, false);
      }
    }
    function TransformStreamSetBackpressure(stream, backpressure) {
      if (stream._backpressureChangePromise !== undefined) {
        stream._backpressureChangePromise_resolve();
      }
      stream._backpressureChangePromise = newPromise((resolve) => {
        stream._backpressureChangePromise_resolve = resolve;
      });
      stream._backpressure = backpressure;
    }

    class TransformStreamDefaultController2 {
      constructor() {
        throw new TypeError("Illegal constructor");
      }
      get desiredSize() {
        if (!IsTransformStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException("desiredSize");
        }
        const readableController = this._controlledTransformStream._readable._readableStreamController;
        return ReadableStreamDefaultControllerGetDesiredSize(readableController);
      }
      enqueue(chunk = undefined) {
        if (!IsTransformStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException("enqueue");
        }
        TransformStreamDefaultControllerEnqueue(this, chunk);
      }
      error(reason = undefined) {
        if (!IsTransformStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException("error");
        }
        TransformStreamDefaultControllerError(this, reason);
      }
      terminate() {
        if (!IsTransformStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException("terminate");
        }
        TransformStreamDefaultControllerTerminate(this);
      }
    }
    Object.defineProperties(TransformStreamDefaultController2.prototype, {
      enqueue: { enumerable: true },
      error: { enumerable: true },
      terminate: { enumerable: true },
      desiredSize: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
      Object.defineProperty(TransformStreamDefaultController2.prototype, SymbolPolyfill.toStringTag, {
        value: "TransformStreamDefaultController",
        configurable: true
      });
    }
    function IsTransformStreamDefaultController(x2) {
      if (!typeIsObject(x2)) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(x2, "_controlledTransformStream")) {
        return false;
      }
      return x2 instanceof TransformStreamDefaultController2;
    }
    function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
      controller._controlledTransformStream = stream;
      stream._transformStreamController = controller;
      controller._transformAlgorithm = transformAlgorithm;
      controller._flushAlgorithm = flushAlgorithm;
    }
    function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
      const controller = Object.create(TransformStreamDefaultController2.prototype);
      let transformAlgorithm = (chunk) => {
        try {
          TransformStreamDefaultControllerEnqueue(controller, chunk);
          return promiseResolvedWith(undefined);
        } catch (transformResultE) {
          return promiseRejectedWith(transformResultE);
        }
      };
      let flushAlgorithm = () => promiseResolvedWith(undefined);
      if (transformer.transform !== undefined) {
        transformAlgorithm = (chunk) => transformer.transform(chunk, controller);
      }
      if (transformer.flush !== undefined) {
        flushAlgorithm = () => transformer.flush(controller);
      }
      SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
    }
    function TransformStreamDefaultControllerClearAlgorithms(controller) {
      controller._transformAlgorithm = undefined;
      controller._flushAlgorithm = undefined;
    }
    function TransformStreamDefaultControllerEnqueue(controller, chunk) {
      const stream = controller._controlledTransformStream;
      const readableController = stream._readable._readableStreamController;
      if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
        throw new TypeError("Readable side is not in a state that permits enqueue");
      }
      try {
        ReadableStreamDefaultControllerEnqueue(readableController, chunk);
      } catch (e2) {
        TransformStreamErrorWritableAndUnblockWrite(stream, e2);
        throw stream._readable._storedError;
      }
      const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
      if (backpressure !== stream._backpressure) {
        TransformStreamSetBackpressure(stream, true);
      }
    }
    function TransformStreamDefaultControllerError(controller, e2) {
      TransformStreamError(controller._controlledTransformStream, e2);
    }
    function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
      const transformPromise = controller._transformAlgorithm(chunk);
      return transformPromiseWith(transformPromise, undefined, (r2) => {
        TransformStreamError(controller._controlledTransformStream, r2);
        throw r2;
      });
    }
    function TransformStreamDefaultControllerTerminate(controller) {
      const stream = controller._controlledTransformStream;
      const readableController = stream._readable._readableStreamController;
      ReadableStreamDefaultControllerClose(readableController);
      const error = new TypeError("TransformStream terminated");
      TransformStreamErrorWritableAndUnblockWrite(stream, error);
    }
    function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
      const controller = stream._transformStreamController;
      if (stream._backpressure) {
        const backpressureChangePromise = stream._backpressureChangePromise;
        return transformPromiseWith(backpressureChangePromise, () => {
          const writable = stream._writable;
          const state = writable._state;
          if (state === "erroring") {
            throw writable._storedError;
          }
          return TransformStreamDefaultControllerPerformTransform(controller, chunk);
        });
      }
      return TransformStreamDefaultControllerPerformTransform(controller, chunk);
    }
    function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
      TransformStreamError(stream, reason);
      return promiseResolvedWith(undefined);
    }
    function TransformStreamDefaultSinkCloseAlgorithm(stream) {
      const readable = stream._readable;
      const controller = stream._transformStreamController;
      const flushPromise = controller._flushAlgorithm();
      TransformStreamDefaultControllerClearAlgorithms(controller);
      return transformPromiseWith(flushPromise, () => {
        if (readable._state === "errored") {
          throw readable._storedError;
        }
        ReadableStreamDefaultControllerClose(readable._readableStreamController);
      }, (r2) => {
        TransformStreamError(stream, r2);
        throw readable._storedError;
      });
    }
    function TransformStreamDefaultSourcePullAlgorithm(stream) {
      TransformStreamSetBackpressure(stream, false);
      return stream._backpressureChangePromise;
    }
    function defaultControllerBrandCheckException(name) {
      return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);
    }
    function streamBrandCheckException(name) {
      return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);
    }
    exports2.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy2;
    exports2.CountQueuingStrategy = CountQueuingStrategy2;
    exports2.ReadableByteStreamController = ReadableByteStreamController2;
    exports2.ReadableStream = ReadableStream3;
    exports2.ReadableStreamBYOBReader = ReadableStreamBYOBReader2;
    exports2.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest2;
    exports2.ReadableStreamDefaultController = ReadableStreamDefaultController2;
    exports2.ReadableStreamDefaultReader = ReadableStreamDefaultReader2;
    exports2.TransformStream = TransformStream2;
    exports2.TransformStreamDefaultController = TransformStreamDefaultController2;
    exports2.WritableStream = WritableStream2;
    exports2.WritableStreamDefaultController = WritableStreamDefaultController2;
    exports2.WritableStreamDefaultWriter = WritableStreamDefaultWriter2;
    Object.defineProperty(exports2, "__esModule", { value: true });
  });
});

// node_modules/node-domexception/index.js
var require_node_domexception = __commonJS((exports, module) => {
  /*! node-domexception. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */
  if (!globalThis.DOMException) {
    try {
      const { MessageChannel } = __require("worker_threads"), port = new MessageChannel().port1, ab = new ArrayBuffer;
      port.postMessage(ab, [ab, ab]);
    } catch (err) {
      err.constructor.name === "DOMException" && (globalThis.DOMException = err.constructor);
    }
  }
  module.exports = globalThis.DOMException;
});

// node_modules/formdata-node/lib/esm/isPlainObject.js
var isPlainObject3, getType2, isPlainObject_default2;
var init_isPlainObject = __esm(() => {
  isPlainObject3 = function(value) {
    if (getType2(value) !== "object") {
      return false;
    }
    const pp = Object.getPrototypeOf(value);
    if (pp === null || pp === undefined) {
      return true;
    }
    const Ctor = pp.constructor && pp.constructor.toString();
    return Ctor === Object.toString();
  };
  getType2 = (value) => Object.prototype.toString.call(value).slice(8, -1).toLowerCase();
  isPlainObject_default2 = isPlainObject3;
});

// node_modules/formdata-node/lib/esm/fileFromPath.js
var exports_fileFromPath = {};
__export(exports_fileFromPath, {
  isFile: () => {
    {
      return isFile;
    }
  },
  fileFromPathSync: () => {
    {
      return fileFromPathSync;
    }
  },
  fileFromPath: () => {
    {
      return fileFromPath2;
    }
  }
});
import {statSync, createReadStream, promises as fs} from "fs";
import {basename} from "path";
function fileFromPathSync(path, filenameOrOptions, options2 = {}) {
  const stats = statSync(path);
  return createFileFromPath(path, stats, filenameOrOptions, options2);
}
async function fileFromPath2(path, filenameOrOptions, options2) {
  const stats = await fs.stat(path);
  return createFileFromPath(path, stats, filenameOrOptions, options2);
}

class FileFromPath {
  constructor(input) {
    _FileFromPath_path.set(this, undefined);
    _FileFromPath_start.set(this, undefined);
    __classPrivateFieldSet4(this, _FileFromPath_path, input.path, "f");
    __classPrivateFieldSet4(this, _FileFromPath_start, input.start || 0, "f");
    this.name = basename(__classPrivateFieldGet5(this, _FileFromPath_path, "f"));
    this.size = input.size;
    this.lastModified = input.lastModified;
  }
  slice(start, end) {
    return new FileFromPath({
      path: __classPrivateFieldGet5(this, _FileFromPath_path, "f"),
      lastModified: this.lastModified,
      size: end - start,
      start
    });
  }
  async* stream() {
    const { mtimeMs } = await fs.stat(__classPrivateFieldGet5(this, _FileFromPath_path, "f"));
    if (mtimeMs > this.lastModified) {
      throw new import_node_domexception.default(MESSAGE, "NotReadableError");
    }
    if (this.size) {
      yield* createReadStream(__classPrivateFieldGet5(this, _FileFromPath_path, "f"), {
        start: __classPrivateFieldGet5(this, _FileFromPath_start, "f"),
        end: __classPrivateFieldGet5(this, _FileFromPath_start, "f") + this.size - 1
      });
    }
  }
  get [(_FileFromPath_path = new WeakMap, _FileFromPath_start = new WeakMap, Symbol.toStringTag)]() {
    return "File";
  }
}
var import_node_domexception, createFileFromPath, __classPrivateFieldSet4, __classPrivateFieldGet5, _FileFromPath_path, _FileFromPath_start, MESSAGE;
var init_fileFromPath = __esm(() => {
  import_node_domexception = __toESM(require_node_domexception(), 1);
  init_File();
  init_isPlainObject();
  init_isFile();
  createFileFromPath = function(path, { mtimeMs, size }, filenameOrOptions, options2 = {}) {
    let filename;
    if (isPlainObject_default2(filenameOrOptions)) {
      [options2, filename] = [filenameOrOptions, undefined];
    } else {
      filename = filenameOrOptions;
    }
    const file = new FileFromPath({ path, size, lastModified: mtimeMs });
    if (!filename) {
      filename = file.name;
    }
    return new File2([file], filename, {
      ...options2,
      lastModified: file.lastModified
    });
  };
  __classPrivateFieldSet4 = function(receiver, state, value, kind2, f2) {
    if (kind2 === "m")
      throw new TypeError("Private method is not writable");
    if (kind2 === "a" && !f2)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind2 === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
  };
  __classPrivateFieldGet5 = function(receiver, state, kind2, f2) {
    if (kind2 === "a" && !f2)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind2 === "m" ? f2 : kind2 === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
  };
  MESSAGE = "The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.";
});

// node_modules/lodash/lodash.js
var require_lodash = __commonJS((exports, module) => {
  (function() {
    var undefined2;
    var VERSION2 = "4.17.21";
    var LARGE_ARRAY_SIZE = 200;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_MEMOIZE_SIZE = 500;
    var PLACEHOLDER = "__lodash_placeholder__";
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, NAN = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ];
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
    var reTrimStart = /^\s+/;
    var reWhitespace = /\s/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEscapeChar = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var deburredLetters = {
      "\xC0": "A",
      "\xC1": "A",
      "\xC2": "A",
      "\xC3": "A",
      "\xC4": "A",
      "\xC5": "A",
      "\xE0": "a",
      "\xE1": "a",
      "\xE2": "a",
      "\xE3": "a",
      "\xE4": "a",
      "\xE5": "a",
      "\xC7": "C",
      "\xE7": "c",
      "\xD0": "D",
      "\xF0": "d",
      "\xC8": "E",
      "\xC9": "E",
      "\xCA": "E",
      "\xCB": "E",
      "\xE8": "e",
      "\xE9": "e",
      "\xEA": "e",
      "\xEB": "e",
      "\xCC": "I",
      "\xCD": "I",
      "\xCE": "I",
      "\xCF": "I",
      "\xEC": "i",
      "\xED": "i",
      "\xEE": "i",
      "\xEF": "i",
      "\xD1": "N",
      "\xF1": "n",
      "\xD2": "O",
      "\xD3": "O",
      "\xD4": "O",
      "\xD5": "O",
      "\xD6": "O",
      "\xD8": "O",
      "\xF2": "o",
      "\xF3": "o",
      "\xF4": "o",
      "\xF5": "o",
      "\xF6": "o",
      "\xF8": "o",
      "\xD9": "U",
      "\xDA": "U",
      "\xDB": "U",
      "\xDC": "U",
      "\xF9": "u",
      "\xFA": "u",
      "\xFB": "u",
      "\xFC": "u",
      "\xDD": "Y",
      "\xFD": "y",
      "\xFF": "y",
      "\xC6": "Ae",
      "\xE6": "ae",
      "\xDE": "Th",
      "\xFE": "th",
      "\xDF": "ss",
      "\u0100": "A",
      "\u0102": "A",
      "\u0104": "A",
      "\u0101": "a",
      "\u0103": "a",
      "\u0105": "a",
      "\u0106": "C",
      "\u0108": "C",
      "\u010A": "C",
      "\u010C": "C",
      "\u0107": "c",
      "\u0109": "c",
      "\u010B": "c",
      "\u010D": "c",
      "\u010E": "D",
      "\u0110": "D",
      "\u010F": "d",
      "\u0111": "d",
      "\u0112": "E",
      "\u0114": "E",
      "\u0116": "E",
      "\u0118": "E",
      "\u011A": "E",
      "\u0113": "e",
      "\u0115": "e",
      "\u0117": "e",
      "\u0119": "e",
      "\u011B": "e",
      "\u011C": "G",
      "\u011E": "G",
      "\u0120": "G",
      "\u0122": "G",
      "\u011D": "g",
      "\u011F": "g",
      "\u0121": "g",
      "\u0123": "g",
      "\u0124": "H",
      "\u0126": "H",
      "\u0125": "h",
      "\u0127": "h",
      "\u0128": "I",
      "\u012A": "I",
      "\u012C": "I",
      "\u012E": "I",
      "\u0130": "I",
      "\u0129": "i",
      "\u012B": "i",
      "\u012D": "i",
      "\u012F": "i",
      "\u0131": "i",
      "\u0134": "J",
      "\u0135": "j",
      "\u0136": "K",
      "\u0137": "k",
      "\u0138": "k",
      "\u0139": "L",
      "\u013B": "L",
      "\u013D": "L",
      "\u013F": "L",
      "\u0141": "L",
      "\u013A": "l",
      "\u013C": "l",
      "\u013E": "l",
      "\u0140": "l",
      "\u0142": "l",
      "\u0143": "N",
      "\u0145": "N",
      "\u0147": "N",
      "\u014A": "N",
      "\u0144": "n",
      "\u0146": "n",
      "\u0148": "n",
      "\u014B": "n",
      "\u014C": "O",
      "\u014E": "O",
      "\u0150": "O",
      "\u014D": "o",
      "\u014F": "o",
      "\u0151": "o",
      "\u0154": "R",
      "\u0156": "R",
      "\u0158": "R",
      "\u0155": "r",
      "\u0157": "r",
      "\u0159": "r",
      "\u015A": "S",
      "\u015C": "S",
      "\u015E": "S",
      "\u0160": "S",
      "\u015B": "s",
      "\u015D": "s",
      "\u015F": "s",
      "\u0161": "s",
      "\u0162": "T",
      "\u0164": "T",
      "\u0166": "T",
      "\u0163": "t",
      "\u0165": "t",
      "\u0167": "t",
      "\u0168": "U",
      "\u016A": "U",
      "\u016C": "U",
      "\u016E": "U",
      "\u0170": "U",
      "\u0172": "U",
      "\u0169": "u",
      "\u016B": "u",
      "\u016D": "u",
      "\u016F": "u",
      "\u0171": "u",
      "\u0173": "u",
      "\u0174": "W",
      "\u0175": "w",
      "\u0176": "Y",
      "\u0177": "y",
      "\u0178": "Y",
      "\u0179": "Z",
      "\u017B": "Z",
      "\u017D": "Z",
      "\u017A": "z",
      "\u017C": "z",
      "\u017E": "z",
      "\u0132": "IJ",
      "\u0133": "ij",
      "\u0152": "Oe",
      "\u0153": "oe",
      "\u0149": "'n",
      "\u017F": "s"
    };
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var freeParseFloat = parseFloat, freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e2) {
      }
    }();
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        var value = array[index];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    function arrayEach(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEachRight(array, iteratee) {
      var length = array == null ? 0 : array.length;
      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEvery(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (!predicate(array[index], index, array)) {
          return false;
        }
      }
      return true;
    }
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
      var length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    var asciiSize = baseProperty("length");
    function asciiToArray(string) {
      return string.split("");
    }
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      eachFunc(collection, function(value, key, collection2) {
        if (predicate(value, key, collection2)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array, value, fromIndex, comparator) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (comparator(array[index], value)) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseMean(array, iteratee) {
      var length = array == null ? 0 : array.length;
      return length ? baseSum(array, iteratee) / length : NAN;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined2 : object[key];
      };
    }
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? undefined2 : object[key];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
      });
      return accumulator;
    }
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    function baseSum(array, iteratee) {
      var result, index = -1, length = array.length;
      while (++index < length) {
        var current = iteratee(array[index]);
        if (current !== undefined2) {
          result = result === undefined2 ? current : result + current;
        }
      }
      return result;
    }
    function baseTimes(n2, iteratee) {
      var index = -1, result = Array(n2);
      while (++index < n2) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseToPairs(object, props) {
      return arrayMap(props, function(key) {
        return [key, object[key]];
      });
    }
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index = -1, length = strSymbols.length;
      while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index = strSymbols.length;
      while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function countHolders(array, placeholder) {
      var length = array.length, result = 0;
      while (length--) {
        if (array[length] === placeholder) {
          ++result;
        }
      }
      return result;
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function getValue(object, key) {
      return object == null ? undefined2 : object[key];
    }
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    function iteratorToArray(iterator) {
      var data, result = [];
      while (!(data = iterator.next()).done) {
        result.push(data.value);
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function replaceHolders(array, placeholder) {
      var index = -1, length = array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (value === placeholder || value === PLACEHOLDER) {
          array[index] = PLACEHOLDER;
          result[resIndex++] = index;
        }
      }
      return result;
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    function setToPairs(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = [value, value];
      });
      return result;
    }
    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function strictLastIndexOf(array, value, fromIndex) {
      var index = fromIndex + 1;
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return index;
    }
    function stringSize(string) {
      return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
    }
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function trimmedEndIndex(string) {
      var index = string.length;
      while (index-- && reWhitespace.test(string.charAt(index))) {
      }
      return index;
    }
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize(string) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string)) {
        ++result;
      }
      return result;
    }
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    var runInContext = function runInContext(context) {
      context = context == null ? root : _2.defaults(root.Object(), context, _2.pick(root, contextProps));
      var { Array: Array2, Date: Date2, Error: Error2, Function: Function2, Math: Math2, Object: Object2, RegExp: RegExp2, String: String2, TypeError: TypeError2 } = context;
      var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
      var coreJsData = context["__core-js_shared__"];
      var funcToString = funcProto.toString;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var idCounter = 0;
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var nativeObjectToString = objectProto.toString;
      var objectCtorString = funcToString.call(Object2);
      var oldDash = root._;
      var reIsNative = RegExp2("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
      var defineProperty = function() {
        try {
          var func = getNative(Object2, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e2) {
        }
      }();
      var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
      var { ceil: nativeCeil, floor: nativeFloor } = Math2, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
      var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
      var metaMap = WeakMap2 && new WeakMap2;
      var realNames = {};
      var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
      var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
      function lodash(value) {
        if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper) {
            return value;
          }
          if (hasOwnProperty.call(value, "__wrapped__")) {
            return wrapperClone(value);
          }
        }
        return new LodashWrapper(value);
      }
      var baseCreate = function() {
        function object() {
        }
        return function(proto) {
          if (!isObject(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result2 = new object;
          object.prototype = undefined2;
          return result2;
        };
      }();
      function baseLodash() {
      }
      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined2;
      }
      lodash.templateSettings = {
        escape: reEscape,
        evaluate: reEvaluate,
        interpolate: reInterpolate,
        variable: "",
        imports: {
          _: lodash
        }
      };
      lodash.prototype = baseLodash.prototype;
      lodash.prototype.constructor = lodash;
      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH;
        this.__views__ = [];
      }
      function lazyClone() {
        var result2 = new LazyWrapper(this.__wrapped__);
        result2.__actions__ = copyArray(this.__actions__);
        result2.__dir__ = this.__dir__;
        result2.__filtered__ = this.__filtered__;
        result2.__iteratees__ = copyArray(this.__iteratees__);
        result2.__takeCount__ = this.__takeCount__;
        result2.__views__ = copyArray(this.__views__);
        return result2;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result2 = new LazyWrapper(this);
          result2.__dir__ = -1;
          result2.__filtered__ = true;
        } else {
          result2 = this.clone();
          result2.__dir__ *= -1;
        }
        return result2;
      }
      function lazyValue() {
        var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length && takeCount == length) {
          return baseWrapperValue(array, this.__actions__);
        }
        var result2 = [];
        outer:
          while (length-- && resIndex < takeCount) {
            index += dir;
            var iterIndex = -1, value = array[index];
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
              if (type == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result2[resIndex++] = value;
          }
        return result2;
      }
      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result2 = this.has(key) && delete this.__data__[key];
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result2 = data[key];
          return result2 === HASH_UNDEFINED ? undefined2 : result2;
        }
        return hasOwnProperty.call(data, key) ? data[key] : undefined2;
      }
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
      }
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? undefined2 : data[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          hash: new Hash,
          map: new (Map2 || ListCache),
          string: new Hash
        };
      }
      function mapCacheDelete(key) {
        var result2 = getMapData(this, key)["delete"](key);
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size2 = data.size;
        data.set(key, value);
        this.size += data.size == size2 ? 0 : 1;
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values2) {
        var index = -1, length = values2 == null ? 0 : values2.length;
        this.__data__ = new MapCache;
        while (++index < length) {
          this.add(values2[index]);
        }
      }
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      function stackClear() {
        this.__data__ = new ListCache;
        this.size = 0;
      }
      function stackDelete(key) {
        var data = this.__data__, result2 = data["delete"](key);
        this.size = data.size;
        return result2;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function arraySample(array) {
        var length = array.length;
        return length ? array[baseRandom(0, length - 1)] : undefined2;
      }
      function arraySampleSize(array, n2) {
        return shuffleSelf(copyArray(array), baseClamp(n2, 0, array.length));
      }
      function arrayShuffle(array) {
        return shuffleSelf(copyArray(array));
      }
      function assignMergeValue(object, key, value) {
        if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        baseEach(collection, function(value, key, collection2) {
          setter(accumulator, value, iteratee2(value), collection2);
        });
        return accumulator;
      }
      function baseAssign(object, source) {
        return object && copyObject(source, keys(source), object);
      }
      function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object);
      }
      function baseAssignValue(object, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object, key, {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        } else {
          object[key] = value;
        }
      }
      function baseAt(object, paths) {
        var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
        while (++index < length) {
          result2[index] = skip ? undefined2 : get(object, paths[index]);
        }
        return result2;
      }
      function baseClamp(number, lower, upper) {
        if (number === number) {
          if (upper !== undefined2) {
            number = number <= upper ? number : upper;
          }
          if (lower !== undefined2) {
            number = number >= lower ? number : lower;
          }
        }
        return number;
      }
      function baseClone(value, bitmask, customizer, key, object, stack) {
        var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result2 = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result2 !== undefined2) {
          return result2;
        }
        if (!isObject(value)) {
          return value;
        }
        var isArr = isArray(value);
        if (isArr) {
          result2 = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result2);
          }
        } else {
          var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object) {
            result2 = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value : {};
            }
            result2 = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack);
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result2);
        if (isSet(value)) {
          value.forEach(function(subValue) {
            result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap(value)) {
          value.forEach(function(subValue, key2) {
            result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
        var props = isArr ? undefined2 : keysFunc(value);
        arrayEach(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        return result2;
      }
      function baseConforms(source) {
        var props = keys(source);
        return function(object) {
          return baseConformsTo(object, source, props);
        };
      }
      function baseConformsTo(object, source, props) {
        var length = props.length;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (length--) {
          var key = props[length], predicate = source[key], value = object[key];
          if (value === undefined2 && !(key in object) || !predicate(value)) {
            return false;
          }
        }
        return true;
      }
      function baseDelay(func, wait, args) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return setTimeout2(function() {
          func.apply(undefined2, args);
        }, wait);
      }
      function baseDifference(array, values2, iteratee2, comparator) {
        var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
        if (!length) {
          return result2;
        }
        if (iteratee2) {
          values2 = arrayMap(values2, baseUnary(iteratee2));
        }
        if (comparator) {
          includes2 = arrayIncludesWith;
          isCommon = false;
        } else if (values2.length >= LARGE_ARRAY_SIZE) {
          includes2 = cacheHas;
          isCommon = false;
          values2 = new SetCache(values2);
        }
        outer:
          while (++index < length) {
            var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values2[valuesIndex] === computed) {
                  continue outer;
                }
              }
              result2.push(value);
            } else if (!includes2(values2, computed, comparator)) {
              result2.push(value);
            }
          }
        return result2;
      }
      var baseEach = createBaseEach(baseForOwn);
      var baseEachRight = createBaseEach(baseForOwnRight, true);
      function baseEvery(collection, predicate) {
        var result2 = true;
        baseEach(collection, function(value, index, collection2) {
          result2 = !!predicate(value, index, collection2);
          return result2;
        });
        return result2;
      }
      function baseExtremum(array, iteratee2, comparator) {
        var index = -1, length = array.length;
        while (++index < length) {
          var value = array[index], current = iteratee2(value);
          if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
            var computed = current, result2 = value;
          }
        }
        return result2;
      }
      function baseFill(array, value, start, end) {
        var length = array.length;
        start = toInteger(start);
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end === undefined2 || end > length ? length : toInteger(end);
        if (end < 0) {
          end += length;
        }
        end = start > end ? 0 : toLength(end);
        while (start < end) {
          array[start++] = value;
        }
        return array;
      }
      function baseFilter(collection, predicate) {
        var result2 = [];
        baseEach(collection, function(value, index, collection2) {
          if (predicate(value, index, collection2)) {
            result2.push(value);
          }
        });
        return result2;
      }
      function baseFlatten(array, depth, predicate, isStrict, result2) {
        var index = -1, length = array.length;
        predicate || (predicate = isFlattenable);
        result2 || (result2 = []);
        while (++index < length) {
          var value = array[index];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result2);
            } else {
              arrayPush(result2, value);
            }
          } else if (!isStrict) {
            result2[result2.length] = value;
          }
        }
        return result2;
      }
      var baseFor = createBaseFor();
      var baseForRight = createBaseFor(true);
      function baseForOwn(object, iteratee2) {
        return object && baseFor(object, iteratee2, keys);
      }
      function baseForOwnRight(object, iteratee2) {
        return object && baseForRight(object, iteratee2, keys);
      }
      function baseFunctions(object, props) {
        return arrayFilter(props, function(key) {
          return isFunction8(object[key]);
        });
      }
      function baseGet(object, path) {
        path = castPath(path, object);
        var index = 0, length = path.length;
        while (object != null && index < length) {
          object = object[toKey(path[index++])];
        }
        return index && index == length ? object : undefined2;
      }
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result2 = keysFunc(object);
        return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
      }
      function baseGetTag(value) {
        if (value == null) {
          return value === undefined2 ? undefinedTag : nullTag;
        }
        return symToStringTag && (symToStringTag in Object2(value)) ? getRawTag(value) : objectToString(value);
      }
      function baseGt(value, other) {
        return value > other;
      }
      function baseHas(object, key) {
        return object != null && hasOwnProperty.call(object, key);
      }
      function baseHasIn(object, key) {
        return object != null && (key in Object2(object));
      }
      function baseInRange(number, start, end) {
        return number >= nativeMin(start, end) && number < nativeMax(start, end);
      }
      function baseIntersection(arrays, iteratee2, comparator) {
        var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
        while (othIndex--) {
          var array = arrays[othIndex];
          if (othIndex && iteratee2) {
            array = arrayMap(array, baseUnary(iteratee2));
          }
          maxLength = nativeMin(array.length, maxLength);
          caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
        }
        array = arrays[0];
        var index = -1, seen = caches[0];
        outer:
          while (++index < length && result2.length < maxLength) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseInverter(object, setter, iteratee2, accumulator) {
        baseForOwn(object, function(value, key, object2) {
          setter(accumulator, iteratee2(value), key, object2);
        });
        return accumulator;
      }
      function baseInvoke(object, path, args) {
        path = castPath(path, object);
        object = parent(object, path);
        var func = object == null ? object : object[toKey(last(path))];
        return func == null ? undefined2 : apply(func, object, args);
      }
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      function baseIsArrayBuffer(value) {
        return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
      }
      function baseIsDate(value) {
        return isObjectLike(value) && baseGetTag(value) == dateTag;
      }
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack);
          return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack);
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack);
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsMap(value) {
        return isObjectLike(value) && getTag(value) == mapTag;
      }
      function baseIsMatch(object, source, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (index--) {
          var data = matchData[index];
          if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
          }
        }
        while (++index < length) {
          data = matchData[index];
          var key = data[0], objValue = object[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === undefined2 && !(key in object)) {
              return false;
            }
          } else {
            var stack = new Stack;
            if (customizer) {
              var result2 = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction8(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseIsRegExp(value) {
        return isObjectLike(value) && baseGetTag(value) == regexpTag;
      }
      function baseIsSet(value) {
        return isObjectLike(value) && getTag(value) == setTag;
      }
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == "object") {
          return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result2 = [];
        for (var key in Object2(object)) {
          if (hasOwnProperty.call(object, key) && key != "constructor") {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseKeysIn(object) {
        if (!isObject(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result2 = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseLt(value, other) {
        return value < other;
      }
      function baseMap(collection, iteratee2) {
        var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value, key, collection2) {
          result2[++index] = iteratee2(value, key, collection2);
        });
        return result2;
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object) {
          var objValue = get(object, path);
          return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseMerge(object, source, srcIndex, customizer, stack) {
        if (object === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack || (stack = new Stack);
          if (isObject(srcValue)) {
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
            if (newValue === undefined2) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
        var isCommon = newValue === undefined2;
        if (isCommon) {
          var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject5(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject(objValue) || isFunction8(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      function baseNth(array, n2) {
        var length = array.length;
        if (!length) {
          return;
        }
        n2 += n2 < 0 ? length : 0;
        return isIndex(n2, length) ? array[n2] : undefined2;
      }
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function(iteratee2) {
            if (isArray(iteratee2)) {
              return function(value) {
                return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
              };
            }
            return iteratee2;
          });
        } else {
          iteratees = [identity];
        }
        var index = -1;
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        var result2 = baseMap(collection, function(value, key, collection2) {
          var criteria = arrayMap(iteratees, function(iteratee2) {
            return iteratee2(value);
          });
          return { criteria, index: ++index, value };
        });
        return baseSortBy(result2, function(object, other) {
          return compareMultiple(object, other, orders);
        });
      }
      function basePick(object, paths) {
        return basePickBy(object, paths, function(value, path) {
          return hasIn(object, path);
        });
      }
      function basePickBy(object, paths, predicate) {
        var index = -1, length = paths.length, result2 = {};
        while (++index < length) {
          var path = paths[index], value = baseGet(object, path);
          if (predicate(value, path)) {
            baseSet(result2, castPath(path, object), value);
          }
        }
        return result2;
      }
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet(object, path);
        };
      }
      function basePullAll(array, values2, iteratee2, comparator) {
        var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
        if (array === values2) {
          values2 = copyArray(values2);
        }
        if (iteratee2) {
          seen = arrayMap(array, baseUnary(iteratee2));
        }
        while (++index < length) {
          var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
          while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
            if (seen !== array) {
              splice.call(seen, fromIndex, 1);
            }
            splice.call(array, fromIndex, 1);
          }
        }
        return array;
      }
      function basePullAt(array, indexes) {
        var length = array ? indexes.length : 0, lastIndex = length - 1;
        while (length--) {
          var index = indexes[length];
          if (length == lastIndex || index !== previous) {
            var previous = index;
            if (isIndex(index)) {
              splice.call(array, index, 1);
            } else {
              baseUnset(array, index);
            }
          }
        }
        return array;
      }
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      function baseRange(start, end, step, fromRight) {
        var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
        while (length--) {
          result2[fromRight ? length : ++index] = start;
          start += step;
        }
        return result2;
      }
      function baseRepeat(string, n2) {
        var result2 = "";
        if (!string || n2 < 1 || n2 > MAX_SAFE_INTEGER) {
          return result2;
        }
        do {
          if (n2 % 2) {
            result2 += string;
          }
          n2 = nativeFloor(n2 / 2);
          if (n2) {
            string += string;
          }
        } while (n2);
        return result2;
      }
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity), func + "");
      }
      function baseSample(collection) {
        return arraySample(values(collection));
      }
      function baseSampleSize(collection, n2) {
        var array = values(collection);
        return shuffleSelf(array, baseClamp(n2, 0, array.length));
      }
      function baseSet(object, path, value, customizer) {
        if (!isObject(object)) {
          return object;
        }
        path = castPath(path, object);
        var index = -1, length = path.length, lastIndex = length - 1, nested = object;
        while (nested != null && ++index < length) {
          var key = toKey(path[index]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object;
          }
          if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined2;
            if (newValue === undefined2) {
              newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      }
      var baseSetData = !metaMap ? identity : function(func, data) {
        metaMap.set(func, data);
        return func;
      };
      var baseSetToString = !defineProperty ? identity : function(func, string) {
        return defineProperty(func, "toString", {
          configurable: true,
          enumerable: false,
          value: constant(string),
          writable: true
        });
      };
      function baseShuffle(collection) {
        return shuffleSelf(values(collection));
      }
      function baseSlice(array, start, end) {
        var index = -1, length = array.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result2 = Array2(length);
        while (++index < length) {
          result2[index] = array[index + start];
        }
        return result2;
      }
      function baseSome(collection, predicate) {
        var result2;
        baseEach(collection, function(value, index, collection2) {
          result2 = predicate(value, index, collection2);
          return !result2;
        });
        return !!result2;
      }
      function baseSortedIndex(array, value, retHighest) {
        var low = 0, high = array == null ? low : array.length;
        if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1, computed = array[mid];
            if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array, value, identity, retHighest);
      }
      function baseSortedIndexBy(array, value, iteratee2, retHighest) {
        var low = 0, high = array == null ? 0 : array.length;
        if (high === 0) {
          return 0;
        }
        value = iteratee2(value);
        var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
        while (low < high) {
          var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed <= value : computed < value;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array, iteratee2) {
        var index = -1, length = array.length, resIndex = 0, result2 = [];
        while (++index < length) {
          var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
          if (!index || !eq(computed, seen)) {
            var seen = computed;
            result2[resIndex++] = value === 0 ? 0 : value;
          }
        }
        return result2;
      }
      function baseToNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        return +value;
      }
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function baseUniq(array, iteratee2, comparator) {
        var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
        if (comparator) {
          isCommon = false;
          includes2 = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set2 = iteratee2 ? null : createSet(array);
          if (set2) {
            return setToArray(set2);
          }
          isCommon = false;
          includes2 = cacheHas;
          seen = new SetCache;
        } else {
          seen = iteratee2 ? [] : result2;
        }
        outer:
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen.push(computed);
              }
              result2.push(value);
            } else if (!includes2(seen, computed, comparator)) {
              if (seen !== result2) {
                seen.push(computed);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseUnset(object, path) {
        path = castPath(path, object);
        object = parent(object, path);
        return object == null || delete object[toKey(last(path))];
      }
      function baseUpdate(object, path, updater, customizer) {
        return baseSet(object, path, updater(baseGet(object, path)), customizer);
      }
      function baseWhile(array, predicate, isDrop, fromRight) {
        var length = array.length, index = fromRight ? length : -1;
        while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
        }
        return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
      }
      function baseWrapperValue(value, actions) {
        var result2 = value;
        if (result2 instanceof LazyWrapper) {
          result2 = result2.value();
        }
        return arrayReduce(actions, function(result3, action) {
          return action.func.apply(action.thisArg, arrayPush([result3], action.args));
        }, result2);
      }
      function baseXor(arrays, iteratee2, comparator) {
        var length = arrays.length;
        if (length < 2) {
          return length ? baseUniq(arrays[0]) : [];
        }
        var index = -1, result2 = Array2(length);
        while (++index < length) {
          var array = arrays[index], othIndex = -1;
          while (++othIndex < length) {
            if (othIndex != index) {
              result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
            }
          }
        }
        return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
      }
      function baseZipObject(props, values2, assignFunc) {
        var index = -1, length = props.length, valsLength = values2.length, result2 = {};
        while (++index < length) {
          var value = index < valsLength ? values2[index] : undefined2;
          assignFunc(result2, props[index], value);
        }
        return result2;
      }
      function castArrayLikeObject(value) {
        return isArrayLikeObject(value) ? value : [];
      }
      function castFunction(value) {
        return typeof value == "function" ? value : identity;
      }
      function castPath(value, object) {
        if (isArray(value)) {
          return value;
        }
        return isKey(value, object) ? [value] : stringToPath(toString2(value));
      }
      var castRest = baseRest;
      function castSlice(array, start, end) {
        var length = array.length;
        end = end === undefined2 ? length : end;
        return !start && end >= length ? array : baseSlice(array, start, end);
      }
      var clearTimeout2 = ctxClearTimeout || function(id) {
        return root.clearTimeout(id);
      };
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result2);
        return result2;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
        return result2;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      function cloneRegExp(regexp) {
        var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result2.lastIndex = regexp.lastIndex;
        return result2;
      }
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
          var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object, other, orders) {
        var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index < length) {
          var result2 = compareAscending(objCriteria[index], othCriteria[index]);
          if (result2) {
            if (index >= ordersLength) {
              return result2;
            }
            var order = orders[index];
            return result2 * (order == "desc" ? -1 : 1);
          }
        }
        return object.index - other.index;
      }
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result2[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result2[leftIndex++] = args[argsIndex++];
        }
        return result2;
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result2[argsIndex] = args[argsIndex];
        }
        var offset = argsIndex;
        while (++rightIndex < rightLength) {
          result2[offset + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[offset + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result2;
      }
      function copyArray(source, array) {
        var index = -1, length = source.length;
        array || (array = Array2(length));
        while (++index < length) {
          array[index] = source[index];
        }
        return array;
      }
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index = -1, length = props.length;
        while (++index < length) {
          var key = props[index];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
          if (newValue === undefined2) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }
      function copySymbolsIn(source, object) {
        return copyObject(source, getSymbolsIn(source), object);
      }
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined2 : customizer;
            length = 1;
          }
          object = Object2(object);
          while (++index < length) {
            var source = sources[index];
            if (source) {
              assigner(object, source, index, customizer);
            }
          }
          return object;
        });
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee2);
          }
          var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
          while (fromRight ? index-- : ++index < length) {
            if (iteratee2(iterable[index], index, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor(fromRight) {
        return function(object, iteratee2, keysFunc) {
          var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee2(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return fn.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper;
      }
      function createCaseFirst(methodName) {
        return function(string) {
          string = toString2(string);
          var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
          var chr = strSymbols ? strSymbols[0] : string.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string) {
          return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor;
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
          return isObject(result2) ? result2 : thisBinding;
        };
      }
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
          while (index--) {
            args[index] = arguments[index];
          }
          var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          length -= holders.length;
          if (length < arity) {
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined2, args, holders, undefined2, undefined2, arity - length);
          }
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return apply(fn, this, args);
        }
        return wrapper;
      }
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object2(collection);
          if (!isArrayLike(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys(collection);
            predicate = function(key) {
              return iteratee2(iterable[key], key, iterable);
            };
          }
          var index = findIndexFunc(collection, predicate, fromIndex);
          return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
        };
      }
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index--) {
            var func = funcs[index];
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (prereq && !wrapper && getFuncName(func) == "wrapper") {
              var wrapper = new LodashWrapper([], true);
            }
          }
          index = wrapper ? index : length;
          while (++index < length) {
            func = funcs[index];
            var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
            if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
              wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
            } else {
              wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
            }
          }
          return function() {
            var args = arguments, value = args[0];
            if (wrapper && args.length == 1 && isArray(value)) {
              return wrapper.plant(value).value();
            }
            var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
            while (++index2 < length) {
              result2 = funcs[index2].call(this, result2);
            }
            return result2;
          };
        });
      }
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index = length;
          while (index--) {
            args[index] = arguments[index];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length -= holdersCount;
          if (isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);
          }
          var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
          length = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length > 1) {
            args.reverse();
          }
          if (isAry && ary2 < length) {
            args.length = ary2;
          }
          if (this && this !== root && this instanceof wrapper) {
            fn = Ctor || createCtor(fn);
          }
          return fn.apply(thisBinding, args);
        }
        return wrapper;
      }
      function createInverter(setter, toIteratee) {
        return function(object, iteratee2) {
          return baseInverter(object, setter, toIteratee(iteratee2), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function(value, other) {
          var result2;
          if (value === undefined2 && other === undefined2) {
            return defaultValue;
          }
          if (value !== undefined2) {
            result2 = value;
          }
          if (other !== undefined2) {
            if (result2 === undefined2) {
              return other;
            }
            if (typeof value == "string" || typeof other == "string") {
              value = baseToString(value);
              other = baseToString(other);
            } else {
              value = baseToNumber(value);
              other = baseToNumber(other);
            }
            result2 = operator(value, other);
          }
          return result2;
        };
      }
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          return baseRest(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply(iteratee2, thisArg, args);
            });
          });
        });
      }
      function createPadding(length, chars) {
        chars = chars === undefined2 ? " " : baseToString(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length) : chars;
        }
        var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
      }
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply(fn, isBind ? thisArg : this, args);
        }
        return wrapper;
      }
      function createRange(fromRight) {
        return function(start, end, step) {
          if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
            end = step = undefined2;
          }
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
          return baseRange(start, end, step, fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function(value, other) {
          if (!(typeof value == "string" && typeof other == "string")) {
            value = toNumber(value);
            other = toNumber(other);
          }
          return operator(value, other);
        };
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [
          func,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ];
        var result2 = wrapFunc.apply(undefined2, newData);
        if (isLaziable(func)) {
          setData(result2, newData);
        }
        result2.placeholder = placeholder;
        return setWrapToString(result2, func, bitmask);
      }
      function createRound(methodName) {
        var func = Math2[methodName];
        return function(number, precision) {
          number = toNumber(number);
          precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
          if (precision && nativeIsFinite(number)) {
            var pair = (toString2(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString2(value) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number);
        };
      }
      var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
        return new Set2(values2);
      };
      function createToPairs(keysFunc) {
        return function(object) {
          var tag = getTag(object);
          if (tag == mapTag) {
            return mapToArray(object);
          }
          if (tag == setTag) {
            return setToPairs(object);
          }
          return baseToPairs(object, keysFunc(object));
        };
      }
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var length = partials ? partials.length : 0;
        if (!length) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined2;
        }
        ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
        arity = arity === undefined2 ? arity : toInteger(arity);
        length -= holders ? holders.length : 0;
        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined2;
        }
        var data = isBindKey ? undefined2 : getData(func);
        var newData = [
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data) {
          mergeData(newData, data);
        }
        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result2 = createBind(func, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result2 = createCurry(func, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result2 = createPartial(func, bitmask, thisArg, partials);
        } else {
          result2 = createHybrid.apply(undefined2, newData);
        }
        var setter = data ? baseSetData : setData;
        return setWrapToString(setter(result2, newData), func, bitmask);
      }
      function customDefaultsAssignIn(objValue, srcValue, key, object) {
        if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
          return srcValue;
        }
        return objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
        if (isObject(objValue) && isObject(srcValue)) {
          stack.set(srcValue, objValue);
          baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
          stack["delete"](srcValue);
        }
        return objValue;
      }
      function customOmitClone(value) {
        return isPlainObject5(value) ? undefined2 : value;
      }
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache : undefined2;
        stack.set(array, other);
        stack.set(other, array);
        while (++index < arrLength) {
          var arrValue = array[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
          }
          if (compared !== undefined2) {
            if (compared) {
              continue;
            }
            result2 = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result2 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result2 = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result2;
      }
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object, other);
            var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result2;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result2 = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }
          if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result2 = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result2 && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && (("constructor" in object) && ("constructor" in other)) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result2 = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result2;
      }
      function flatRest(func) {
        return setToString(overRest(func, undefined2, flatten), func + "");
      }
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols);
      }
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      var getData = !metaMap ? noop : function(func) {
        return metaMap.get(func);
      };
      function getFuncName(func) {
        var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
        while (length--) {
          var data = array[length], otherFunc = data.func;
          if (otherFunc == null || otherFunc == func) {
            return data.name;
          }
        }
        return result2;
      }
      function getHolder(func) {
        var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
        return object.placeholder;
      }
      function getIteratee() {
        var result2 = lodash.iteratee || iteratee;
        result2 = result2 === iteratee ? baseIteratee : result2;
        return arguments.length ? result2(arguments[0], arguments[1]) : result2;
      }
      function getMapData(map2, key) {
        var data = map2.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function getMatchData(object) {
        var result2 = keys(object), length = result2.length;
        while (length--) {
          var key = result2[length], value = object[key];
          result2[length] = [key, value, isStrictComparable(value)];
        }
        return result2;
      }
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : undefined2;
      }
      function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = undefined2;
          var unmasked = true;
        } catch (e2) {
        }
        var result2 = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result2;
      }
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object2(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
        var result2 = [];
        while (object) {
          arrayPush(result2, getSymbols(object));
          object = getPrototype(object);
        }
        return result2;
      };
      var getTag = baseGetTag;
      if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2) != setTag || WeakMap2 && getTag(new WeakMap2) != weakMapTag) {
        getTag = function(value) {
          var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result2;
        };
      }
      function getView(start, end, transforms) {
        var index = -1, length = transforms.length;
        while (++index < length) {
          var data = transforms[index], size2 = data.size;
          switch (data.type) {
            case "drop":
              start += size2;
              break;
            case "dropRight":
              end -= size2;
              break;
            case "take":
              end = nativeMin(end, start + size2);
              break;
            case "takeRight":
              start = nativeMax(start, end - size2);
              break;
          }
        }
        return { start, end };
      }
      function getWrapDetails(source) {
        var match = source.match(reWrapDetails);
        return match ? match[1].split(reSplitDetails) : [];
      }
      function hasPath(object, path, hasFunc) {
        path = castPath(path, object);
        var index = -1, length = path.length, result2 = false;
        while (++index < length) {
          var key = toKey(path[index]);
          if (!(result2 = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result2 || ++index != length) {
          return result2;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
      }
      function initCloneArray(array) {
        var length = array.length, result2 = new array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
          result2.index = array.index;
          result2.input = array.input;
        }
        return result2;
      }
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag:
          case dateTag:
            return new Ctor(+object);
          case dataViewTag:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag:
            return new Ctor;
          case numberTag:
          case stringTag:
            return new Ctor(object);
          case regexpTag:
            return cloneRegExp(object);
          case setTag:
            return new Ctor;
          case symbolTag:
            return cloneSymbol(object);
        }
      }
      function insertWrapDetails(source, details) {
        var length = details.length;
        if (!length) {
          return source;
        }
        var lastIndex = length - 1;
        details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length > 2 ? ", " : " ");
        return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
      }
      function isFlattenable(value) {
        return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function isIterateeCall(value, index, object) {
        if (!isObject(object)) {
          return false;
        }
        var type = typeof index;
        if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && (index in object)) {
          return eq(object[index], value);
        }
        return false;
      }
      function isKey(value, object) {
        if (isArray(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && (value in Object2(object));
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data = getData(other);
        return !!data && func === data[0];
      }
      function isMasked(func) {
        return !!maskSrcKey && (maskSrcKey in func);
      }
      var isMaskable = coreJsData ? isFunction8 : stubFalse;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      function isStrictComparable(value) {
        return value === value && !isObject(value);
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== undefined2 || (key in Object2(object)));
        };
      }
      function memoizeCapped(func) {
        var result2 = memoize(func, function(key) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }
          return key;
        });
        var cache = result2.cache;
        return result2;
      }
      function mergeData(data, source) {
        var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo)) {
          return data;
        }
        if (srcBitmask & WRAP_BIND_FLAG) {
          data[2] = source[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value = source[3];
        if (value) {
          var partials = data[3];
          data[3] = partials ? composeArgs(partials, value, source[4]) : value;
          data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
        }
        value = source[5];
        if (value) {
          partials = data[5];
          data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
          data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
        }
        value = source[7];
        if (value) {
          data[7] = value;
        }
        if (srcBitmask & WRAP_ARY_FLAG) {
          data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
        }
        if (data[9] == null) {
          data[9] = source[9];
        }
        data[0] = source[0];
        data[1] = newBitmask;
        return data;
      }
      function nativeKeysIn(object) {
        var result2 = [];
        if (object != null) {
          for (var key in Object2(object)) {
            result2.push(key);
          }
        }
        return result2;
      }
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      function overRest(func, start, transform2) {
        start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
          while (++index < length) {
            array[index] = args[start + index];
          }
          index = -1;
          var otherArgs = Array2(start + 1);
          while (++index < start) {
            otherArgs[index] = args[index];
          }
          otherArgs[start] = transform2(array);
          return apply(func, this, otherArgs);
        };
      }
      function parent(object, path) {
        return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
      }
      function reorder(array, indexes) {
        var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
        while (length--) {
          var index = indexes[length];
          array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
        }
        return array;
      }
      function safeGet(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      var setData = shortOut(baseSetData);
      var setTimeout2 = ctxSetTimeout || function(func, wait) {
        return root.setTimeout(func, wait);
      };
      var setToString = shortOut(baseSetToString);
      function setWrapToString(wrapper, reference, bitmask) {
        var source = reference + "";
        return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
      }
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(undefined2, arguments);
        };
      }
      function shuffleSelf(array, size2) {
        var index = -1, length = array.length, lastIndex = length - 1;
        size2 = size2 === undefined2 ? length : size2;
        while (++index < size2) {
          var rand = baseRandom(index, lastIndex), value = array[rand];
          array[rand] = array[index];
          array[index] = value;
        }
        array.length = size2;
        return array;
      }
      var stringToPath = memoizeCapped(function(string) {
        var result2 = [];
        if (string.charCodeAt(0) === 46) {
          result2.push("");
        }
        string.replace(rePropName, function(match, number, quote, subString) {
          result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
        });
        return result2;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e2) {
          }
          try {
            return func + "";
          } catch (e2) {
          }
        }
        return "";
      }
      function updateWrapDetails(details, bitmask) {
        arrayEach(wrapFlags, function(pair) {
          var value = "_." + pair[0];
          if (bitmask & pair[1] && !arrayIncludes(details, value)) {
            details.push(value);
          }
        });
        return details.sort();
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }
        var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result2.__actions__ = copyArray(wrapper.__actions__);
        result2.__index__ = wrapper.__index__;
        result2.__values__ = wrapper.__values__;
        return result2;
      }
      function chunk(array, size2, guard) {
        if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
          size2 = 1;
        } else {
          size2 = nativeMax(toInteger(size2), 0);
        }
        var length = array == null ? 0 : array.length;
        if (!length || size2 < 1) {
          return [];
        }
        var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
        while (index < length) {
          result2[resIndex++] = baseSlice(array, index, index += size2);
        }
        return result2;
      }
      function compact(array) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
        while (++index < length) {
          var value = array[index];
          if (value) {
            result2[resIndex++] = value;
          }
        }
        return result2;
      }
      function concat() {
        var length = arguments.length;
        if (!length) {
          return [];
        }
        var args = Array2(length - 1), array = arguments[0], index = length;
        while (index--) {
          args[index - 1] = arguments[index];
        }
        return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
      }
      var difference = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
      });
      var differenceBy = baseRest(function(array, values2) {
        var iteratee2 = last(values2);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined2;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
      });
      var differenceWith = baseRest(function(array, values2) {
        var comparator = last(values2);
        if (isArrayLikeObject(comparator)) {
          comparator = undefined2;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
      });
      function drop(array, n2, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
        return baseSlice(array, n2 < 0 ? 0 : n2, length);
      }
      function dropRight(array, n2, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
        n2 = length - n2;
        return baseSlice(array, 0, n2 < 0 ? 0 : n2);
      }
      function dropRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
      }
      function dropWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
      }
      function fill(array, value, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
          start = 0;
          end = length;
        }
        return baseFill(array, value, start, end);
      }
      function findIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index);
      }
      function findLastIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = length - 1;
        if (fromIndex !== undefined2) {
          index = toInteger(fromIndex);
          index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index, true);
      }
      function flatten(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, 1) : [];
      }
      function flattenDeep(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, INFINITY) : [];
      }
      function flattenDepth(array, depth) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        depth = depth === undefined2 ? 1 : toInteger(depth);
        return baseFlatten(array, depth);
      }
      function fromPairs(pairs) {
        var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
        while (++index < length) {
          var pair = pairs[index];
          result2[pair[0]] = pair[1];
        }
        return result2;
      }
      function head(array) {
        return array && array.length ? array[0] : undefined2;
      }
      function indexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseIndexOf(array, value, index);
      }
      function initial(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 0, -1) : [];
      }
      var intersection = baseRest(function(arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      });
      var intersectionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        if (iteratee2 === last(mapped)) {
          iteratee2 = undefined2;
        } else {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
      });
      var intersectionWith = baseRest(function(arrays) {
        var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        comparator = typeof comparator == "function" ? comparator : undefined2;
        if (comparator) {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
      });
      function join(array, separator) {
        return array == null ? "" : nativeJoin.call(array, separator);
      }
      function last(array) {
        var length = array == null ? 0 : array.length;
        return length ? array[length - 1] : undefined2;
      }
      function lastIndexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = length;
        if (fromIndex !== undefined2) {
          index = toInteger(fromIndex);
          index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }
        return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
      }
      function nth(array, n2) {
        return array && array.length ? baseNth(array, toInteger(n2)) : undefined2;
      }
      var pull = baseRest(pullAll);
      function pullAll(array, values2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
      }
      function pullAllBy(array, values2, iteratee2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
      }
      function pullAllWith(array, values2, comparator) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
      }
      var pullAt = flatRest(function(array, indexes) {
        var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
        basePullAt(array, arrayMap(indexes, function(index) {
          return isIndex(index, length) ? +index : index;
        }).sort(compareAscending));
        return result2;
      });
      function remove(array, predicate) {
        var result2 = [];
        if (!(array && array.length)) {
          return result2;
        }
        var index = -1, indexes = [], length = array.length;
        predicate = getIteratee(predicate, 3);
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result2.push(value);
            indexes.push(index);
          }
        }
        basePullAt(array, indexes);
        return result2;
      }
      function reverse(array) {
        return array == null ? array : nativeReverse.call(array);
      }
      function slice(array, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
          start = 0;
          end = length;
        } else {
          start = start == null ? 0 : toInteger(start);
          end = end === undefined2 ? length : toInteger(end);
        }
        return baseSlice(array, start, end);
      }
      function sortedIndex(array, value) {
        return baseSortedIndex(array, value);
      }
      function sortedIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
      }
      function sortedIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index = baseSortedIndex(array, value);
          if (index < length && eq(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function sortedLastIndex(array, value) {
        return baseSortedIndex(array, value, true);
      }
      function sortedLastIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
      }
      function sortedLastIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index = baseSortedIndex(array, value, true) - 1;
          if (eq(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function sortedUniq(array) {
        return array && array.length ? baseSortedUniq(array) : [];
      }
      function sortedUniqBy(array, iteratee2) {
        return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function tail(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 1, length) : [];
      }
      function take(array, n2, guard) {
        if (!(array && array.length)) {
          return [];
        }
        n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
        return baseSlice(array, 0, n2 < 0 ? 0 : n2);
      }
      function takeRight(array, n2, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
        n2 = length - n2;
        return baseSlice(array, n2 < 0 ? 0 : n2, length);
      }
      function takeRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
      }
      function takeWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
      }
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      var unionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined2;
        }
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
      });
      var unionWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined2;
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
      });
      function uniq(array) {
        return array && array.length ? baseUniq(array) : [];
      }
      function uniqBy(array, iteratee2) {
        return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function uniqWith(array, comparator) {
        comparator = typeof comparator == "function" ? comparator : undefined2;
        return array && array.length ? baseUniq(array, undefined2, comparator) : [];
      }
      function unzip(array) {
        if (!(array && array.length)) {
          return [];
        }
        var length = 0;
        array = arrayFilter(array, function(group) {
          if (isArrayLikeObject(group)) {
            length = nativeMax(group.length, length);
            return true;
          }
        });
        return baseTimes(length, function(index) {
          return arrayMap(array, baseProperty(index));
        });
      }
      function unzipWith(array, iteratee2) {
        if (!(array && array.length)) {
          return [];
        }
        var result2 = unzip(array);
        if (iteratee2 == null) {
          return result2;
        }
        return arrayMap(result2, function(group) {
          return apply(iteratee2, undefined2, group);
        });
      }
      var without = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
      });
      var xor = baseRest(function(arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      });
      var xorBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined2;
        }
        return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
      });
      var xorWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined2;
        return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
      });
      var zip = baseRest(unzip);
      function zipObject(props, values2) {
        return baseZipObject(props || [], values2 || [], assignValue);
      }
      function zipObjectDeep(props, values2) {
        return baseZipObject(props || [], values2 || [], baseSet);
      }
      var zipWith = baseRest(function(arrays) {
        var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
        iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
        return unzipWith(arrays, iteratee2);
      });
      function chain(value) {
        var result2 = lodash(value);
        result2.__chain__ = true;
        return result2;
      }
      function tap(value, interceptor) {
        interceptor(value);
        return value;
      }
      function thru(value, interceptor) {
        return interceptor(value);
      }
      var wrapperAt = flatRest(function(paths) {
        var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
          return baseAt(object, paths);
        };
        if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
          return this.thru(interceptor);
        }
        value = value.slice(start, +start + (length ? 1 : 0));
        value.__actions__.push({
          func: thru,
          args: [interceptor],
          thisArg: undefined2
        });
        return new LodashWrapper(value, this.__chain__).thru(function(array) {
          if (length && !array.length) {
            array.push(undefined2);
          }
          return array;
        });
      });
      function wrapperChain() {
        return chain(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        if (this.__values__ === undefined2) {
          this.__values__ = toArray(this.value());
        }
        var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
        return { done, value };
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value) {
        var result2, parent2 = this;
        while (parent2 instanceof baseLodash) {
          var clone2 = wrapperClone(parent2);
          clone2.__index__ = 0;
          clone2.__values__ = undefined2;
          if (result2) {
            previous.__wrapped__ = clone2;
          } else {
            result2 = clone2;
          }
          var previous = clone2;
          parent2 = parent2.__wrapped__;
        }
        previous.__wrapped__ = value;
        return result2;
      }
      function wrapperReverse() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          var wrapped = value;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            func: thru,
            args: [reverse],
            thisArg: undefined2
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty.call(result2, key)) {
          ++result2[key];
        } else {
          baseAssignValue(result2, key, 1);
        }
      });
      function every(collection, predicate, guard) {
        var func = isArray(collection) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined2;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      function filter(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      var find = createFind(findIndex);
      var findLast = createFind(findLastIndex);
      function flatMap(collection, iteratee2) {
        return baseFlatten(map(collection, iteratee2), 1);
      }
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten(map(collection, iteratee2), INFINITY);
      }
      function flatMapDepth(collection, iteratee2, depth) {
        depth = depth === undefined2 ? 1 : toInteger(depth);
        return baseFlatten(map(collection, iteratee2), depth);
      }
      function forEach(collection, iteratee2) {
        var func = isArray(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function forEachRight(collection, iteratee2) {
        var func = isArray(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee2, 3));
      }
      var groupBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty.call(result2, key)) {
          result2[key].push(value);
        } else {
          baseAssignValue(result2, key, [value]);
        }
      });
      function includes(collection, value, fromIndex, guard) {
        collection = isArrayLike(collection) ? collection : values(collection);
        fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
        var length = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax(length + fromIndex, 0);
        }
        return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
      }
      var invokeMap = baseRest(function(collection, path, args) {
        var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value) {
          result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
        });
        return result2;
      });
      var keyBy = createAggregator(function(result2, value, key) {
        baseAssignValue(result2, key, value);
      });
      function map(collection, iteratee2) {
        var func = isArray(collection) ? arrayMap : baseMap;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function orderBy(collection, iteratees, orders, guard) {
        if (collection == null) {
          return [];
        }
        if (!isArray(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? undefined2 : orders;
        if (!isArray(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }
      var partition2 = createAggregator(function(result2, value, key) {
        result2[key ? 0 : 1].push(value);
      }, function() {
        return [[], []];
      });
      function reduce(collection, iteratee2, accumulator) {
        var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
      }
      function reduceRight(collection, iteratee2, accumulator) {
        var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      function reject(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, negate(getIteratee(predicate, 3)));
      }
      function sample(collection) {
        var func = isArray(collection) ? arraySample : baseSample;
        return func(collection);
      }
      function sampleSize(collection, n2, guard) {
        if (guard ? isIterateeCall(collection, n2, guard) : n2 === undefined2) {
          n2 = 1;
        } else {
          n2 = toInteger(n2);
        }
        var func = isArray(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n2);
      }
      function shuffle(collection) {
        var func = isArray(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      function size(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike(collection)) {
          return isString(collection) ? stringSize(collection) : collection.length;
        }
        var tag = getTag(collection);
        if (tag == mapTag || tag == setTag) {
          return collection.size;
        }
        return baseKeys(collection).length;
      }
      function some(collection, predicate, guard) {
        var func = isArray(collection) ? arraySome : baseSome;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined2;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      var sortBy = baseRest(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length = iteratees.length;
        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });
      var now = ctxNow || function() {
        return root.Date.now();
      };
      function after(n2, func) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n2 = toInteger(n2);
        return function() {
          if (--n2 < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      function ary(func, n2, guard) {
        n2 = guard ? undefined2 : n2;
        n2 = func && n2 == null ? func.length : n2;
        return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n2);
      }
      function before(n2, func) {
        var result2;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n2 = toInteger(n2);
        return function() {
          if (--n2 > 0) {
            result2 = func.apply(this, arguments);
          }
          if (n2 <= 1) {
            func = undefined2;
          }
          return result2;
        };
      }
      var bind = baseRest(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      });
      var bindKey = baseRest(function(object, key, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key, bitmask, object, partials, holders);
      });
      function curry(func, arity, guard) {
        arity = guard ? undefined2 : arity;
        var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
        result2.placeholder = curry.placeholder;
        return result2;
      }
      function curryRight(func, arity, guard) {
        arity = guard ? undefined2 : arity;
        var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
        result2.placeholder = curryRight.placeholder;
        return result2;
      }
      function debounce(func, wait, options2) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject(options2)) {
          leading = !!options2.leading;
          maxing = ("maxWait" in options2);
          maxWait = maxing ? nativeMax(toNumber(options2.maxWait) || 0, wait) : maxWait;
          trailing = ("trailing" in options2) ? !!options2.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = undefined2;
          lastInvokeTime = time;
          result2 = func.apply(thisArg, args);
          return result2;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout2(timerExpired, wait);
          return leading ? invokeFunc(time) : result2;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout2(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = undefined2;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined2;
          return result2;
        }
        function cancel() {
          if (timerId !== undefined2) {
            clearTimeout2(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined2;
        }
        function flush() {
          return timerId === undefined2 ? result2 : trailingEdge(now());
        }
        function debounced() {
          var time = now(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === undefined2) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout2(timerId);
              timerId = setTimeout2(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined2) {
            timerId = setTimeout2(timerExpired, wait);
          }
          return result2;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      var defer = baseRest(function(func, args) {
        return baseDelay(func, 1, args);
      });
      var delay = baseRest(function(func, wait, args) {
        return baseDelay(func, toNumber(wait) || 0, args);
      });
      function flip(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result2 = func.apply(this, args);
          memoized.cache = cache.set(key, result2) || cache;
          return result2;
        };
        memoized.cache = new (memoize.Cache || MapCache);
        return memoized;
      }
      memoize.Cache = MapCache;
      function negate(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      function once(func) {
        return before(2, func);
      }
      var overArgs = castRest(function(func, transforms) {
        transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest(function(args) {
          var index = -1, length = nativeMin(args.length, funcsLength);
          while (++index < length) {
            args[index] = transforms[index].call(this, args[index]);
          }
          return apply(func, this, args);
        });
      });
      var partial = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
      });
      var partialRight = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
      });
      var rearg = flatRest(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
      });
      function rest(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start === undefined2 ? start : toInteger(start);
        return baseRest(func, start);
      }
      function spread(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start == null ? 0 : nativeMax(toInteger(start), 0);
        return baseRest(function(args) {
          var array = args[start], otherArgs = castSlice(args, 0, start);
          if (array) {
            arrayPush(otherArgs, array);
          }
          return apply(func, this, otherArgs);
        });
      }
      function throttle(func, wait, options2) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        if (isObject(options2)) {
          leading = ("leading" in options2) ? !!options2.leading : leading;
          trailing = ("trailing" in options2) ? !!options2.trailing : trailing;
        }
        return debounce(func, wait, {
          leading,
          maxWait: wait,
          trailing
        });
      }
      function unary(func) {
        return ary(func, 1);
      }
      function wrap(value, wrapper) {
        return partial(castFunction(wrapper), value);
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray(value) ? value : [value];
      }
      function clone(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      function cloneWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
      }
      function cloneDeep(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      function cloneDeepWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }
      function conformsTo(object, source) {
        return source == null || baseConformsTo(object, source, keys(source));
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var gt2 = createRelationalOperation(baseGt);
      var gte = createRelationalOperation(function(value, other) {
        return value >= other;
      });
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      var isArray = Array2.isArray;
      var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction8(value);
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      function isBoolean(value) {
        return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
      }
      var isBuffer = nativeIsBuffer || stubFalse;
      var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
      function isElement(value) {
        return isObjectLike(value) && value.nodeType === 1 && !isPlainObject5(value);
      }
      function isEmpty(value) {
        if (value == null) {
          return true;
        }
        if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
          return !value.length;
        }
        var tag = getTag(value);
        if (tag == mapTag || tag == setTag) {
          return !value.size;
        }
        if (isPrototype(value)) {
          return !baseKeys(value).length;
        }
        for (var key in value) {
          if (hasOwnProperty.call(value, key)) {
            return false;
          }
        }
        return true;
      }
      function isEqual(value, other) {
        return baseIsEqual(value, other);
      }
      function isEqualWith(value, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        var result2 = customizer ? customizer(value, other) : undefined2;
        return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
      }
      function isError(value) {
        if (!isObjectLike(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject5(value);
      }
      function isFinite2(value) {
        return typeof value == "number" && nativeIsFinite(value);
      }
      function isFunction8(value) {
        if (!isObject(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      function isInteger(value) {
        return typeof value == "number" && value == toInteger(value);
      }
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isObject(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      function isMatch(object, source) {
        return object === source || baseIsMatch(object, source, getMatchData(source));
      }
      function isMatchWith(object, source, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return baseIsMatch(object, source, getMatchData(source), customizer);
      }
      function isNaN2(value) {
        return isNumber(value) && value != +value;
      }
      function isNative(value) {
        if (isMaskable(value)) {
          throw new Error2(CORE_ERROR_TEXT);
        }
        return baseIsNative(value);
      }
      function isNull(value) {
        return value === null;
      }
      function isNil(value) {
        return value == null;
      }
      function isNumber(value) {
        return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
      }
      function isPlainObject5(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value) {
        return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
      }
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      function isString(value) {
        return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function isUndefined(value) {
        return value === undefined2;
      }
      function isWeakMap(value) {
        return isObjectLike(value) && getTag(value) == weakMapTag;
      }
      function isWeakSet(value) {
        return isObjectLike(value) && baseGetTag(value) == weakSetTag;
      }
      var lt2 = createRelationalOperation(baseLt);
      var lte = createRelationalOperation(function(value, other) {
        return value <= other;
      });
      function toArray(value) {
        if (!value) {
          return [];
        }
        if (isArrayLike(value)) {
          return isString(value) ? stringToArray(value) : copyArray(value);
        }
        if (symIterator && value[symIterator]) {
          return iteratorToArray(value[symIterator]());
        }
        var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
        return func(value);
      }
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY || value === -INFINITY) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger(value) {
        var result2 = toFinite(value), remainder = result2 % 1;
        return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
      }
      function toLength(value) {
        return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
      }
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function toSafeInteger(value) {
        return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
      }
      function toString2(value) {
        return value == null ? "" : baseToString(value);
      }
      var assign = createAssigner(function(object, source) {
        if (isPrototype(source) || isArrayLike(source)) {
          copyObject(source, keys(source), object);
          return;
        }
        for (var key in source) {
          if (hasOwnProperty.call(source, key)) {
            assignValue(object, key, source[key]);
          }
        }
      });
      var assignIn = createAssigner(function(object, source) {
        copyObject(source, keysIn(source), object);
      });
      var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keysIn(source), object, customizer);
      });
      var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keys(source), object, customizer);
      });
      var at2 = flatRest(baseAt);
      function create(prototype, properties) {
        var result2 = baseCreate(prototype);
        return properties == null ? result2 : baseAssign(result2, properties);
      }
      var defaults = baseRest(function(object, sources) {
        object = Object2(object);
        var index = -1;
        var length = sources.length;
        var guard = length > 2 ? sources[2] : undefined2;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length = 1;
        }
        while (++index < length) {
          var source = sources[index];
          var props = keysIn(source);
          var propsIndex = -1;
          var propsLength = props.length;
          while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value = object[key];
            if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
              object[key] = source[key];
            }
          }
        }
        return object;
      });
      var defaultsDeep = baseRest(function(args) {
        args.push(undefined2, customDefaultsMerge);
        return apply(mergeWith, undefined2, args);
      });
      function findKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
      }
      function findLastKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
      }
      function forIn(object, iteratee2) {
        return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forInRight(object, iteratee2) {
        return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forOwn(object, iteratee2) {
        return object && baseForOwn(object, getIteratee(iteratee2, 3));
      }
      function forOwnRight(object, iteratee2) {
        return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
      }
      function functions(object) {
        return object == null ? [] : baseFunctions(object, keys(object));
      }
      function functionsIn(object) {
        return object == null ? [] : baseFunctions(object, keysIn(object));
      }
      function get(object, path, defaultValue) {
        var result2 = object == null ? undefined2 : baseGet(object, path);
        return result2 === undefined2 ? defaultValue : result2;
      }
      function has(object, path) {
        return object != null && hasPath(object, path, baseHas);
      }
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      var invert = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        result2[value] = key;
      }, constant(identity));
      var invertBy = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        if (hasOwnProperty.call(result2, value)) {
          result2[value].push(key);
        } else {
          result2[value] = [key];
        }
      }, getIteratee);
      var invoke = baseRest(baseInvoke);
      function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      function mapKeys(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result2, iteratee2(value, key, object2), value);
        });
        return result2;
      }
      function mapValues(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result2, key, iteratee2(value, key, object2));
        });
        return result2;
      }
      var merge = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
        baseMerge(object, source, srcIndex, customizer);
      });
      var omit = flatRest(function(object, paths) {
        var result2 = {};
        if (object == null) {
          return result2;
        }
        var isDeep = false;
        paths = arrayMap(paths, function(path) {
          path = castPath(path, object);
          isDeep || (isDeep = path.length > 1);
          return path;
        });
        copyObject(object, getAllKeysIn(object), result2);
        if (isDeep) {
          result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
        }
        var length = paths.length;
        while (length--) {
          baseUnset(result2, paths[length]);
        }
        return result2;
      });
      function omitBy(object, predicate) {
        return pickBy(object, negate(getIteratee(predicate)));
      }
      var pick = flatRest(function(object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      function pickBy(object, predicate) {
        if (object == null) {
          return {};
        }
        var props = arrayMap(getAllKeysIn(object), function(prop) {
          return [prop];
        });
        predicate = getIteratee(predicate);
        return basePickBy(object, props, function(value, path) {
          return predicate(value, path[0]);
        });
      }
      function result(object, path, defaultValue) {
        path = castPath(path, object);
        var index = -1, length = path.length;
        if (!length) {
          length = 1;
          object = undefined2;
        }
        while (++index < length) {
          var value = object == null ? undefined2 : object[toKey(path[index])];
          if (value === undefined2) {
            index = length;
            value = defaultValue;
          }
          object = isFunction8(value) ? value.call(object) : value;
        }
        return object;
      }
      function set(object, path, value) {
        return object == null ? object : baseSet(object, path, value);
      }
      function setWith(object, path, value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return object == null ? object : baseSet(object, path, value, customizer);
      }
      var toPairs = createToPairs(keys);
      var toPairsIn = createToPairs(keysIn);
      function transform(object, iteratee2, accumulator) {
        var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
        iteratee2 = getIteratee(iteratee2, 4);
        if (accumulator == null) {
          var Ctor = object && object.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor : [];
          } else if (isObject(object)) {
            accumulator = isFunction8(Ctor) ? baseCreate(getPrototype(object)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
          return iteratee2(accumulator, value, index, object2);
        });
        return accumulator;
      }
      function unset(object, path) {
        return object == null ? true : baseUnset(object, path);
      }
      function update(object, path, updater) {
        return object == null ? object : baseUpdate(object, path, castFunction(updater));
      }
      function updateWith(object, path, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
      }
      function values(object) {
        return object == null ? [] : baseValues(object, keys(object));
      }
      function valuesIn(object) {
        return object == null ? [] : baseValues(object, keysIn(object));
      }
      function clamp(number, lower, upper) {
        if (upper === undefined2) {
          upper = lower;
          lower = undefined2;
        }
        if (upper !== undefined2) {
          upper = toNumber(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower !== undefined2) {
          lower = toNumber(lower);
          lower = lower === lower ? lower : 0;
        }
        return baseClamp(toNumber(number), lower, upper);
      }
      function inRange(number, start, end) {
        start = toFinite(start);
        if (end === undefined2) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        number = toNumber(number);
        return baseInRange(number, start, end);
      }
      function random(lower, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
          upper = floating = undefined2;
        }
        if (floating === undefined2) {
          if (typeof upper == "boolean") {
            floating = upper;
            upper = undefined2;
          } else if (typeof lower == "boolean") {
            floating = lower;
            lower = undefined2;
          }
        }
        if (lower === undefined2 && upper === undefined2) {
          lower = 0;
          upper = 1;
        } else {
          lower = toFinite(lower);
          if (upper === undefined2) {
            upper = lower;
            lower = 0;
          } else {
            upper = toFinite(upper);
          }
        }
        if (lower > upper) {
          var temp = lower;
          lower = upper;
          upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }
      var camelCase = createCompounder(function(result2, word, index) {
        word = word.toLowerCase();
        return result2 + (index ? capitalize(word) : word);
      });
      function capitalize(string) {
        return upperFirst(toString2(string).toLowerCase());
      }
      function deburr(string) {
        string = toString2(string);
        return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      function endsWith(string, target, position) {
        string = toString2(string);
        target = baseToString(target);
        var length = string.length;
        position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
        var end = position;
        position -= target.length;
        return position >= 0 && string.slice(position, end) == target;
      }
      function escape2(string) {
        string = toString2(string);
        return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
      }
      function escapeRegExp(string) {
        string = toString2(string);
        return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
      }
      var kebabCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? "-" : "") + word.toLowerCase();
      });
      var lowerCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst("toLowerCase");
      function pad(string, length, chars) {
        string = toString2(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        if (!length || strLength >= length) {
          return string;
        }
        var mid = (length - strLength) / 2;
        return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
      }
      function padEnd(string, length, chars) {
        string = toString2(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
      }
      function padStart(string, length, chars) {
        string = toString2(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
      }
      function parseInt2(string, radix, guard) {
        if (guard || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString2(string).replace(reTrimStart, ""), radix || 0);
      }
      function repeat(string, n2, guard) {
        if (guard ? isIterateeCall(string, n2, guard) : n2 === undefined2) {
          n2 = 1;
        } else {
          n2 = toInteger(n2);
        }
        return baseRepeat(toString2(string), n2);
      }
      function replace() {
        var args = arguments, string = toString2(args[0]);
        return args.length < 3 ? string : string.replace(args[1], args[2]);
      }
      var snakeCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? "_" : "") + word.toLowerCase();
      });
      function split(string, separator, limit) {
        if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
          separator = limit = undefined2;
        }
        limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
        if (!limit) {
          return [];
        }
        string = toString2(string);
        if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
          separator = baseToString(separator);
          if (!separator && hasUnicode(string)) {
            return castSlice(stringToArray(string), 0, limit);
          }
        }
        return string.split(separator, limit);
      }
      var startCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + upperFirst(word);
      });
      function startsWith(string, target, position) {
        string = toString2(string);
        position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
        target = baseToString(target);
        return string.slice(position, position + target.length) == target;
      }
      function template(string, options2, guard) {
        var settings = lodash.templateSettings;
        if (guard && isIterateeCall(string, options2, guard)) {
          options2 = undefined2;
        }
        string = toString2(string);
        options2 = assignInWith({}, options2, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options2.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
        var isEscaping, isEvaluating, index = 0, interpolate = options2.interpolate || reNoMatch, source = "__p += '";
        var reDelimiters = RegExp2((options2.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options2.evaluate || reNoMatch).source + "|$", "g");
        var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options2, "sourceURL") ? (options2.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
        string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index = offset + match.length;
          return match;
        });
        source += "';\n";
        var variable = hasOwnProperty.call(options2, "variable") && options2.variable;
        if (!variable) {
          source = "with (obj) {\n" + source + "\n}\n";
        } else if (reForbiddenIdentifierChars.test(variable)) {
          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
        }
        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
        var result2 = attempt(function() {
          return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
        });
        result2.source = source;
        if (isError(result2)) {
          throw result2;
        }
        return result2;
      }
      function toLower(value) {
        return toString2(value).toLowerCase();
      }
      function toUpper(value) {
        return toString2(value).toUpperCase();
      }
      function trim(string, chars, guard) {
        string = toString2(string);
        if (string && (guard || chars === undefined2)) {
          return baseTrim(string);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start, end).join("");
      }
      function trimEnd(string, chars, guard) {
        string = toString2(string);
        if (string && (guard || chars === undefined2)) {
          return string.slice(0, trimmedEndIndex(string) + 1);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end).join("");
      }
      function trimStart(string, chars, guard) {
        string = toString2(string);
        if (string && (guard || chars === undefined2)) {
          return string.replace(reTrimStart, "");
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start).join("");
      }
      function truncate(string, options2) {
        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject(options2)) {
          var separator = "separator" in options2 ? options2.separator : separator;
          length = ("length" in options2) ? toInteger(options2.length) : length;
          omission = ("omission" in options2) ? baseToString(options2.omission) : omission;
        }
        string = toString2(string);
        var strLength = string.length;
        if (hasUnicode(string)) {
          var strSymbols = stringToArray(string);
          strLength = strSymbols.length;
        }
        if (length >= strLength) {
          return string;
        }
        var end = length - stringSize(omission);
        if (end < 1) {
          return omission;
        }
        var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
        if (separator === undefined2) {
          return result2 + omission;
        }
        if (strSymbols) {
          end += result2.length - end;
        }
        if (isRegExp(separator)) {
          if (string.slice(end).search(separator)) {
            var match, substring = result2;
            if (!separator.global) {
              separator = RegExp2(separator.source, toString2(reFlags.exec(separator)) + "g");
            }
            separator.lastIndex = 0;
            while (match = separator.exec(substring)) {
              var newEnd = match.index;
            }
            result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
          }
        } else if (string.indexOf(baseToString(separator), end) != end) {
          var index = result2.lastIndexOf(separator);
          if (index > -1) {
            result2 = result2.slice(0, index);
          }
        }
        return result2 + omission;
      }
      function unescape3(string) {
        string = toString2(string);
        return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
      }
      var upperCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + word.toUpperCase();
      });
      var upperFirst = createCaseFirst("toUpperCase");
      function words(string, pattern, guard) {
        string = toString2(string);
        pattern = guard ? undefined2 : pattern;
        if (pattern === undefined2) {
          return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
        }
        return string.match(pattern) || [];
      }
      var attempt = baseRest(function(func, args) {
        try {
          return apply(func, undefined2, args);
        } catch (e2) {
          return isError(e2) ? e2 : new Error2(e2);
        }
      });
      var bindAll = flatRest(function(object, methodNames) {
        arrayEach(methodNames, function(key) {
          key = toKey(key);
          baseAssignValue(object, key, bind(object[key], object));
        });
        return object;
      });
      function cond(pairs) {
        var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
        pairs = !length ? [] : arrayMap(pairs, function(pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest(function(args) {
          var index = -1;
          while (++index < length) {
            var pair = pairs[index];
            if (apply(pair[0], this, args)) {
              return apply(pair[1], this, args);
            }
          }
        });
      }
      function conforms(source) {
        return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      function defaultTo(value, defaultValue) {
        return value == null || value !== value ? defaultValue : value;
      }
      var flow = createFlow();
      var flowRight = createFlow(true);
      function identity(value) {
        return value;
      }
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
      }
      function matches(source) {
        return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
      }
      function matchesProperty(path, srcValue) {
        return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
      }
      var method = baseRest(function(path, args) {
        return function(object) {
          return baseInvoke(object, path, args);
        };
      });
      var methodOf = baseRest(function(object, args) {
        return function(path) {
          return baseInvoke(object, path, args);
        };
      });
      function mixin(object, source, options2) {
        var props = keys(source), methodNames = baseFunctions(source, props);
        if (options2 == null && !(isObject(source) && (methodNames.length || !props.length))) {
          options2 = source;
          source = object;
          object = this;
          methodNames = baseFunctions(source, keys(source));
        }
        var chain2 = !(isObject(options2) && ("chain" in options2)) || !!options2.chain, isFunc = isFunction8(object);
        arrayEach(methodNames, function(methodName) {
          var func = source[methodName];
          object[methodName] = func;
          if (isFunc) {
            object.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain2 || chainAll) {
                var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                actions.push({ func, args: arguments, thisArg: object });
                result2.__chain__ = chainAll;
                return result2;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }
        });
        return object;
      }
      function noConflict() {
        if (root._ === this) {
          root._ = oldDash;
        }
        return this;
      }
      function noop() {
      }
      function nthArg(n2) {
        n2 = toInteger(n2);
        return baseRest(function(args) {
          return baseNth(args, n2);
        });
      }
      var over = createOver(arrayMap);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome);
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      function propertyOf(object) {
        return function(path) {
          return object == null ? undefined2 : baseGet(object, path);
        };
      }
      var range = createRange();
      var rangeRight = createRange(true);
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return false;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return true;
      }
      function times(n2, iteratee2) {
        n2 = toInteger(n2);
        if (n2 < 1 || n2 > MAX_SAFE_INTEGER) {
          return [];
        }
        var index = MAX_ARRAY_LENGTH, length = nativeMin(n2, MAX_ARRAY_LENGTH);
        iteratee2 = getIteratee(iteratee2);
        n2 -= MAX_ARRAY_LENGTH;
        var result2 = baseTimes(length, iteratee2);
        while (++index < n2) {
          iteratee2(index);
        }
        return result2;
      }
      function toPath(value) {
        if (isArray(value)) {
          return arrayMap(value, toKey);
        }
        return isSymbol(value) ? [value] : copyArray(stringToPath(toString2(value)));
      }
      function uniqueId(prefix) {
        var id = ++idCounter;
        return toString2(prefix) + id;
      }
      var add = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var ceil = createRound("ceil");
      var divide = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor = createRound("floor");
      function max(array) {
        return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
      }
      function maxBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
      }
      function mean(array) {
        return baseMean(array, identity);
      }
      function meanBy(array, iteratee2) {
        return baseMean(array, getIteratee(iteratee2, 2));
      }
      function min(array) {
        return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
      }
      function minBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
      }
      var multiply = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round = createRound("round");
      var subtract = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum(array) {
        return array && array.length ? baseSum(array, identity) : 0;
      }
      function sumBy(array, iteratee2) {
        return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
      }
      lodash.after = after;
      lodash.ary = ary;
      lodash.assign = assign;
      lodash.assignIn = assignIn;
      lodash.assignInWith = assignInWith;
      lodash.assignWith = assignWith;
      lodash.at = at2;
      lodash.before = before;
      lodash.bind = bind;
      lodash.bindAll = bindAll;
      lodash.bindKey = bindKey;
      lodash.castArray = castArray;
      lodash.chain = chain;
      lodash.chunk = chunk;
      lodash.compact = compact;
      lodash.concat = concat;
      lodash.cond = cond;
      lodash.conforms = conforms;
      lodash.constant = constant;
      lodash.countBy = countBy;
      lodash.create = create;
      lodash.curry = curry;
      lodash.curryRight = curryRight;
      lodash.debounce = debounce;
      lodash.defaults = defaults;
      lodash.defaultsDeep = defaultsDeep;
      lodash.defer = defer;
      lodash.delay = delay;
      lodash.difference = difference;
      lodash.differenceBy = differenceBy;
      lodash.differenceWith = differenceWith;
      lodash.drop = drop;
      lodash.dropRight = dropRight;
      lodash.dropRightWhile = dropRightWhile;
      lodash.dropWhile = dropWhile;
      lodash.fill = fill;
      lodash.filter = filter;
      lodash.flatMap = flatMap;
      lodash.flatMapDeep = flatMapDeep;
      lodash.flatMapDepth = flatMapDepth;
      lodash.flatten = flatten;
      lodash.flattenDeep = flattenDeep;
      lodash.flattenDepth = flattenDepth;
      lodash.flip = flip;
      lodash.flow = flow;
      lodash.flowRight = flowRight;
      lodash.fromPairs = fromPairs;
      lodash.functions = functions;
      lodash.functionsIn = functionsIn;
      lodash.groupBy = groupBy;
      lodash.initial = initial;
      lodash.intersection = intersection;
      lodash.intersectionBy = intersectionBy;
      lodash.intersectionWith = intersectionWith;
      lodash.invert = invert;
      lodash.invertBy = invertBy;
      lodash.invokeMap = invokeMap;
      lodash.iteratee = iteratee;
      lodash.keyBy = keyBy;
      lodash.keys = keys;
      lodash.keysIn = keysIn;
      lodash.map = map;
      lodash.mapKeys = mapKeys;
      lodash.mapValues = mapValues;
      lodash.matches = matches;
      lodash.matchesProperty = matchesProperty;
      lodash.memoize = memoize;
      lodash.merge = merge;
      lodash.mergeWith = mergeWith;
      lodash.method = method;
      lodash.methodOf = methodOf;
      lodash.mixin = mixin;
      lodash.negate = negate;
      lodash.nthArg = nthArg;
      lodash.omit = omit;
      lodash.omitBy = omitBy;
      lodash.once = once;
      lodash.orderBy = orderBy;
      lodash.over = over;
      lodash.overArgs = overArgs;
      lodash.overEvery = overEvery;
      lodash.overSome = overSome;
      lodash.partial = partial;
      lodash.partialRight = partialRight;
      lodash.partition = partition2;
      lodash.pick = pick;
      lodash.pickBy = pickBy;
      lodash.property = property;
      lodash.propertyOf = propertyOf;
      lodash.pull = pull;
      lodash.pullAll = pullAll;
      lodash.pullAllBy = pullAllBy;
      lodash.pullAllWith = pullAllWith;
      lodash.pullAt = pullAt;
      lodash.range = range;
      lodash.rangeRight = rangeRight;
      lodash.rearg = rearg;
      lodash.reject = reject;
      lodash.remove = remove;
      lodash.rest = rest;
      lodash.reverse = reverse;
      lodash.sampleSize = sampleSize;
      lodash.set = set;
      lodash.setWith = setWith;
      lodash.shuffle = shuffle;
      lodash.slice = slice;
      lodash.sortBy = sortBy;
      lodash.sortedUniq = sortedUniq;
      lodash.sortedUniqBy = sortedUniqBy;
      lodash.split = split;
      lodash.spread = spread;
      lodash.tail = tail;
      lodash.take = take;
      lodash.takeRight = takeRight;
      lodash.takeRightWhile = takeRightWhile;
      lodash.takeWhile = takeWhile;
      lodash.tap = tap;
      lodash.throttle = throttle;
      lodash.thru = thru;
      lodash.toArray = toArray;
      lodash.toPairs = toPairs;
      lodash.toPairsIn = toPairsIn;
      lodash.toPath = toPath;
      lodash.toPlainObject = toPlainObject;
      lodash.transform = transform;
      lodash.unary = unary;
      lodash.union = union;
      lodash.unionBy = unionBy;
      lodash.unionWith = unionWith;
      lodash.uniq = uniq;
      lodash.uniqBy = uniqBy;
      lodash.uniqWith = uniqWith;
      lodash.unset = unset;
      lodash.unzip = unzip;
      lodash.unzipWith = unzipWith;
      lodash.update = update;
      lodash.updateWith = updateWith;
      lodash.values = values;
      lodash.valuesIn = valuesIn;
      lodash.without = without;
      lodash.words = words;
      lodash.wrap = wrap;
      lodash.xor = xor;
      lodash.xorBy = xorBy;
      lodash.xorWith = xorWith;
      lodash.zip = zip;
      lodash.zipObject = zipObject;
      lodash.zipObjectDeep = zipObjectDeep;
      lodash.zipWith = zipWith;
      lodash.entries = toPairs;
      lodash.entriesIn = toPairsIn;
      lodash.extend = assignIn;
      lodash.extendWith = assignInWith;
      mixin(lodash, lodash);
      lodash.add = add;
      lodash.attempt = attempt;
      lodash.camelCase = camelCase;
      lodash.capitalize = capitalize;
      lodash.ceil = ceil;
      lodash.clamp = clamp;
      lodash.clone = clone;
      lodash.cloneDeep = cloneDeep;
      lodash.cloneDeepWith = cloneDeepWith;
      lodash.cloneWith = cloneWith;
      lodash.conformsTo = conformsTo;
      lodash.deburr = deburr;
      lodash.defaultTo = defaultTo;
      lodash.divide = divide;
      lodash.endsWith = endsWith;
      lodash.eq = eq;
      lodash.escape = escape2;
      lodash.escapeRegExp = escapeRegExp;
      lodash.every = every;
      lodash.find = find;
      lodash.findIndex = findIndex;
      lodash.findKey = findKey;
      lodash.findLast = findLast;
      lodash.findLastIndex = findLastIndex;
      lodash.findLastKey = findLastKey;
      lodash.floor = floor;
      lodash.forEach = forEach;
      lodash.forEachRight = forEachRight;
      lodash.forIn = forIn;
      lodash.forInRight = forInRight;
      lodash.forOwn = forOwn;
      lodash.forOwnRight = forOwnRight;
      lodash.get = get;
      lodash.gt = gt2;
      lodash.gte = gte;
      lodash.has = has;
      lodash.hasIn = hasIn;
      lodash.head = head;
      lodash.identity = identity;
      lodash.includes = includes;
      lodash.indexOf = indexOf;
      lodash.inRange = inRange;
      lodash.invoke = invoke;
      lodash.isArguments = isArguments;
      lodash.isArray = isArray;
      lodash.isArrayBuffer = isArrayBuffer;
      lodash.isArrayLike = isArrayLike;
      lodash.isArrayLikeObject = isArrayLikeObject;
      lodash.isBoolean = isBoolean;
      lodash.isBuffer = isBuffer;
      lodash.isDate = isDate;
      lodash.isElement = isElement;
      lodash.isEmpty = isEmpty;
      lodash.isEqual = isEqual;
      lodash.isEqualWith = isEqualWith;
      lodash.isError = isError;
      lodash.isFinite = isFinite2;
      lodash.isFunction = isFunction8;
      lodash.isInteger = isInteger;
      lodash.isLength = isLength;
      lodash.isMap = isMap;
      lodash.isMatch = isMatch;
      lodash.isMatchWith = isMatchWith;
      lodash.isNaN = isNaN2;
      lodash.isNative = isNative;
      lodash.isNil = isNil;
      lodash.isNull = isNull;
      lodash.isNumber = isNumber;
      lodash.isObject = isObject;
      lodash.isObjectLike = isObjectLike;
      lodash.isPlainObject = isPlainObject5;
      lodash.isRegExp = isRegExp;
      lodash.isSafeInteger = isSafeInteger;
      lodash.isSet = isSet;
      lodash.isString = isString;
      lodash.isSymbol = isSymbol;
      lodash.isTypedArray = isTypedArray;
      lodash.isUndefined = isUndefined;
      lodash.isWeakMap = isWeakMap;
      lodash.isWeakSet = isWeakSet;
      lodash.join = join;
      lodash.kebabCase = kebabCase;
      lodash.last = last;
      lodash.lastIndexOf = lastIndexOf;
      lodash.lowerCase = lowerCase;
      lodash.lowerFirst = lowerFirst;
      lodash.lt = lt2;
      lodash.lte = lte;
      lodash.max = max;
      lodash.maxBy = maxBy;
      lodash.mean = mean;
      lodash.meanBy = meanBy;
      lodash.min = min;
      lodash.minBy = minBy;
      lodash.stubArray = stubArray;
      lodash.stubFalse = stubFalse;
      lodash.stubObject = stubObject;
      lodash.stubString = stubString;
      lodash.stubTrue = stubTrue;
      lodash.multiply = multiply;
      lodash.nth = nth;
      lodash.noConflict = noConflict;
      lodash.noop = noop;
      lodash.now = now;
      lodash.pad = pad;
      lodash.padEnd = padEnd;
      lodash.padStart = padStart;
      lodash.parseInt = parseInt2;
      lodash.random = random;
      lodash.reduce = reduce;
      lodash.reduceRight = reduceRight;
      lodash.repeat = repeat;
      lodash.replace = replace;
      lodash.result = result;
      lodash.round = round;
      lodash.runInContext = runInContext;
      lodash.sample = sample;
      lodash.size = size;
      lodash.snakeCase = snakeCase;
      lodash.some = some;
      lodash.sortedIndex = sortedIndex;
      lodash.sortedIndexBy = sortedIndexBy;
      lodash.sortedIndexOf = sortedIndexOf;
      lodash.sortedLastIndex = sortedLastIndex;
      lodash.sortedLastIndexBy = sortedLastIndexBy;
      lodash.sortedLastIndexOf = sortedLastIndexOf;
      lodash.startCase = startCase;
      lodash.startsWith = startsWith;
      lodash.subtract = subtract;
      lodash.sum = sum;
      lodash.sumBy = sumBy;
      lodash.template = template;
      lodash.times = times;
      lodash.toFinite = toFinite;
      lodash.toInteger = toInteger;
      lodash.toLength = toLength;
      lodash.toLower = toLower;
      lodash.toNumber = toNumber;
      lodash.toSafeInteger = toSafeInteger;
      lodash.toString = toString2;
      lodash.toUpper = toUpper;
      lodash.trim = trim;
      lodash.trimEnd = trimEnd;
      lodash.trimStart = trimStart;
      lodash.truncate = truncate;
      lodash.unescape = unescape3;
      lodash.uniqueId = uniqueId;
      lodash.upperCase = upperCase;
      lodash.upperFirst = upperFirst;
      lodash.each = forEach;
      lodash.eachRight = forEachRight;
      lodash.first = head;
      mixin(lodash, function() {
        var source = {};
        baseForOwn(lodash, function(func, methodName) {
          if (!hasOwnProperty.call(lodash.prototype, methodName)) {
            source[methodName] = func;
          }
        });
        return source;
      }(), { chain: false });
      lodash.VERSION = VERSION2;
      arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash[methodName].placeholder = lodash;
      });
      arrayEach(["drop", "take"], function(methodName, index) {
        LazyWrapper.prototype[methodName] = function(n2) {
          n2 = n2 === undefined2 ? 1 : nativeMax(toInteger(n2), 0);
          var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
          if (result2.__filtered__) {
            result2.__takeCount__ = nativeMin(n2, result2.__takeCount__);
          } else {
            result2.__views__.push({
              size: nativeMin(n2, MAX_ARRAY_LENGTH),
              type: methodName + (result2.__dir__ < 0 ? "Right" : "")
            });
          }
          return result2;
        };
        LazyWrapper.prototype[methodName + "Right"] = function(n2) {
          return this.reverse()[methodName](n2).reverse();
        };
      });
      arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
        var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result2 = this.clone();
          result2.__iteratees__.push({
            iteratee: getIteratee(iteratee2, 3),
            type
          });
          result2.__filtered__ = result2.__filtered__ || isFilter;
          return result2;
        };
      });
      arrayEach(["head", "last"], function(methodName, index) {
        var takeName = "take" + (index ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach(["initial", "tail"], function(methodName, index) {
        var dropName = "drop" + (index ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity);
      };
      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
        if (typeof path == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function(value) {
          return baseInvoke(value, path, args);
        });
      });
      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function(start, end) {
        start = toInteger(start);
        var result2 = this;
        if (result2.__filtered__ && (start > 0 || end < 0)) {
          return new LazyWrapper(result2);
        }
        if (start < 0) {
          result2 = result2.takeRight(-start);
        } else if (start) {
          result2 = result2.drop(start);
        }
        if (end !== undefined2) {
          end = toInteger(end);
          result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
        }
        return result2;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      };
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash.prototype[methodName] = function() {
          var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
          var interceptor = function(value2) {
            var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
            return isTaker && chainAll ? result3[0] : result3;
          };
          if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
            isLazy = useLazy = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result2 = func.apply(value, args);
            result2.__actions__.push({ func: thru, args: [interceptor], thisArg: undefined2 });
            return new LodashWrapper(result2, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
          }
          result2 = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
        };
      });
      arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func.apply(isArray(value) ? value : [], args);
          }
          return this[chainName](function(value2) {
            return func.apply(isArray(value2) ? value2 : [], args);
          });
        };
      });
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash[methodName];
        if (lodashFunc) {
          var key = lodashFunc.name + "";
          if (!hasOwnProperty.call(realNames, key)) {
            realNames[key] = [];
          }
          realNames[key].push({ name: methodName, func: lodashFunc });
        }
      });
      realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
        name: "wrapper",
        func: undefined2
      }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash.prototype.at = wrapperAt;
      lodash.prototype.chain = wrapperChain;
      lodash.prototype.commit = wrapperCommit;
      lodash.prototype.next = wrapperNext;
      lodash.prototype.plant = wrapperPlant;
      lodash.prototype.reverse = wrapperReverse;
      lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
      lodash.prototype.first = lodash.prototype.head;
      if (symIterator) {
        lodash.prototype[symIterator] = wrapperToIterator;
      }
      return lodash;
    };
    var _2 = runInContext();
    if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
      root._ = _2;
      define(function() {
        return _2;
      });
    } else if (freeModule) {
      (freeModule.exports = _2)._ = _2;
      freeExports._ = _2;
    } else {
      root._ = _2;
    }
  }).call(exports);
});

// node_modules/commander/lib/error.js
var require_error = __commonJS((exports) => {
  class CommanderError extends Error {
    constructor(exitCode, code, message) {
      super(message);
      Error.captureStackTrace(this, this.constructor);
      this.name = this.constructor.name;
      this.code = code;
      this.exitCode = exitCode;
      this.nestedError = undefined;
    }
  }

  class InvalidArgumentError extends CommanderError {
    constructor(message) {
      super(1, "commander.invalidArgument", message);
      Error.captureStackTrace(this, this.constructor);
      this.name = this.constructor.name;
    }
  }
  exports.CommanderError = CommanderError;
  exports.InvalidArgumentError = InvalidArgumentError;
});

// node_modules/commander/lib/argument.js
var require_argument = __commonJS((exports) => {
  var humanReadableArgName = function(arg) {
    const nameOutput = arg.name() + (arg.variadic === true ? "..." : "");
    return arg.required ? "<" + nameOutput + ">" : "[" + nameOutput + "]";
  };
  var { InvalidArgumentError } = require_error();

  class Argument {
    constructor(name, description) {
      this.description = description || "";
      this.variadic = false;
      this.parseArg = undefined;
      this.defaultValue = undefined;
      this.defaultValueDescription = undefined;
      this.argChoices = undefined;
      switch (name[0]) {
        case "<":
          this.required = true;
          this._name = name.slice(1, -1);
          break;
        case "[":
          this.required = false;
          this._name = name.slice(1, -1);
          break;
        default:
          this.required = true;
          this._name = name;
          break;
      }
      if (this._name.length > 3 && this._name.slice(-3) === "...") {
        this.variadic = true;
        this._name = this._name.slice(0, -3);
      }
    }
    name() {
      return this._name;
    }
    _concatValue(value, previous) {
      if (previous === this.defaultValue || !Array.isArray(previous)) {
        return [value];
      }
      return previous.concat(value);
    }
    default(value, description) {
      this.defaultValue = value;
      this.defaultValueDescription = description;
      return this;
    }
    argParser(fn) {
      this.parseArg = fn;
      return this;
    }
    choices(values) {
      this.argChoices = values.slice();
      this.parseArg = (arg, previous) => {
        if (!this.argChoices.includes(arg)) {
          throw new InvalidArgumentError(`Allowed choices are ${this.argChoices.join(", ")}.`);
        }
        if (this.variadic) {
          return this._concatValue(arg, previous);
        }
        return arg;
      };
      return this;
    }
    argRequired() {
      this.required = true;
      return this;
    }
    argOptional() {
      this.required = false;
      return this;
    }
  }
  exports.Argument = Argument;
  exports.humanReadableArgName = humanReadableArgName;
});

// node_modules/commander/lib/help.js
var require_help = __commonJS((exports) => {
  var { humanReadableArgName } = require_argument();

  class Help {
    constructor() {
      this.helpWidth = undefined;
      this.sortSubcommands = false;
      this.sortOptions = false;
      this.showGlobalOptions = false;
    }
    visibleCommands(cmd) {
      const visibleCommands = cmd.commands.filter((cmd2) => !cmd2._hidden);
      if (cmd._hasImplicitHelpCommand()) {
        const [, helpName, helpArgs] = cmd._helpCommandnameAndArgs.match(/([^ ]+) *(.*)/);
        const helpCommand = cmd.createCommand(helpName).helpOption(false);
        helpCommand.description(cmd._helpCommandDescription);
        if (helpArgs)
          helpCommand.arguments(helpArgs);
        visibleCommands.push(helpCommand);
      }
      if (this.sortSubcommands) {
        visibleCommands.sort((a2, b2) => {
          return a2.name().localeCompare(b2.name());
        });
      }
      return visibleCommands;
    }
    compareOptions(a2, b2) {
      const getSortKey = (option) => {
        return option.short ? option.short.replace(/^-/, "") : option.long.replace(/^--/, "");
      };
      return getSortKey(a2).localeCompare(getSortKey(b2));
    }
    visibleOptions(cmd) {
      const visibleOptions = cmd.options.filter((option) => !option.hidden);
      const showShortHelpFlag = cmd._hasHelpOption && cmd._helpShortFlag && !cmd._findOption(cmd._helpShortFlag);
      const showLongHelpFlag = cmd._hasHelpOption && !cmd._findOption(cmd._helpLongFlag);
      if (showShortHelpFlag || showLongHelpFlag) {
        let helpOption;
        if (!showShortHelpFlag) {
          helpOption = cmd.createOption(cmd._helpLongFlag, cmd._helpDescription);
        } else if (!showLongHelpFlag) {
          helpOption = cmd.createOption(cmd._helpShortFlag, cmd._helpDescription);
        } else {
          helpOption = cmd.createOption(cmd._helpFlags, cmd._helpDescription);
        }
        visibleOptions.push(helpOption);
      }
      if (this.sortOptions) {
        visibleOptions.sort(this.compareOptions);
      }
      return visibleOptions;
    }
    visibleGlobalOptions(cmd) {
      if (!this.showGlobalOptions)
        return [];
      const globalOptions = [];
      for (let ancestorCmd = cmd.parent;ancestorCmd; ancestorCmd = ancestorCmd.parent) {
        const visibleOptions = ancestorCmd.options.filter((option) => !option.hidden);
        globalOptions.push(...visibleOptions);
      }
      if (this.sortOptions) {
        globalOptions.sort(this.compareOptions);
      }
      return globalOptions;
    }
    visibleArguments(cmd) {
      if (cmd._argsDescription) {
        cmd.registeredArguments.forEach((argument) => {
          argument.description = argument.description || cmd._argsDescription[argument.name()] || "";
        });
      }
      if (cmd.registeredArguments.find((argument) => argument.description)) {
        return cmd.registeredArguments;
      }
      return [];
    }
    subcommandTerm(cmd) {
      const args = cmd.registeredArguments.map((arg) => humanReadableArgName(arg)).join(" ");
      return cmd._name + (cmd._aliases[0] ? "|" + cmd._aliases[0] : "") + (cmd.options.length ? " [options]" : "") + (args ? " " + args : "");
    }
    optionTerm(option) {
      return option.flags;
    }
    argumentTerm(argument) {
      return argument.name();
    }
    longestSubcommandTermLength(cmd, helper) {
      return helper.visibleCommands(cmd).reduce((max, command) => {
        return Math.max(max, helper.subcommandTerm(command).length);
      }, 0);
    }
    longestOptionTermLength(cmd, helper) {
      return helper.visibleOptions(cmd).reduce((max, option) => {
        return Math.max(max, helper.optionTerm(option).length);
      }, 0);
    }
    longestGlobalOptionTermLength(cmd, helper) {
      return helper.visibleGlobalOptions(cmd).reduce((max, option) => {
        return Math.max(max, helper.optionTerm(option).length);
      }, 0);
    }
    longestArgumentTermLength(cmd, helper) {
      return helper.visibleArguments(cmd).reduce((max, argument) => {
        return Math.max(max, helper.argumentTerm(argument).length);
      }, 0);
    }
    commandUsage(cmd) {
      let cmdName = cmd._name;
      if (cmd._aliases[0]) {
        cmdName = cmdName + "|" + cmd._aliases[0];
      }
      let ancestorCmdNames = "";
      for (let ancestorCmd = cmd.parent;ancestorCmd; ancestorCmd = ancestorCmd.parent) {
        ancestorCmdNames = ancestorCmd.name() + " " + ancestorCmdNames;
      }
      return ancestorCmdNames + cmdName + " " + cmd.usage();
    }
    commandDescription(cmd) {
      return cmd.description();
    }
    subcommandDescription(cmd) {
      return cmd.summary() || cmd.description();
    }
    optionDescription(option) {
      const extraInfo = [];
      if (option.argChoices) {
        extraInfo.push(`choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`);
      }
      if (option.defaultValue !== undefined) {
        const showDefault = option.required || option.optional || option.isBoolean() && typeof option.defaultValue === "boolean";
        if (showDefault) {
          extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`);
        }
      }
      if (option.presetArg !== undefined && option.optional) {
        extraInfo.push(`preset: ${JSON.stringify(option.presetArg)}`);
      }
      if (option.envVar !== undefined) {
        extraInfo.push(`env: ${option.envVar}`);
      }
      if (extraInfo.length > 0) {
        return `${option.description} (${extraInfo.join(", ")})`;
      }
      return option.description;
    }
    argumentDescription(argument) {
      const extraInfo = [];
      if (argument.argChoices) {
        extraInfo.push(`choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`);
      }
      if (argument.defaultValue !== undefined) {
        extraInfo.push(`default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`);
      }
      if (extraInfo.length > 0) {
        const extraDescripton = `(${extraInfo.join(", ")})`;
        if (argument.description) {
          return `${argument.description} ${extraDescripton}`;
        }
        return extraDescripton;
      }
      return argument.description;
    }
    formatHelp(cmd, helper) {
      const termWidth = helper.padWidth(cmd, helper);
      const helpWidth = helper.helpWidth || 80;
      const itemIndentWidth = 2;
      const itemSeparatorWidth = 2;
      function formatItem(term, description) {
        if (description) {
          const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;
          return helper.wrap(fullText, helpWidth - itemIndentWidth, termWidth + itemSeparatorWidth);
        }
        return term;
      }
      function formatList(textArray) {
        return textArray.join("\n").replace(/^/gm, " ".repeat(itemIndentWidth));
      }
      let output = [`Usage: ${helper.commandUsage(cmd)}`, ""];
      const commandDescription = helper.commandDescription(cmd);
      if (commandDescription.length > 0) {
        output = output.concat([helper.wrap(commandDescription, helpWidth, 0), ""]);
      }
      const argumentList = helper.visibleArguments(cmd).map((argument) => {
        return formatItem(helper.argumentTerm(argument), helper.argumentDescription(argument));
      });
      if (argumentList.length > 0) {
        output = output.concat(["Arguments:", formatList(argumentList), ""]);
      }
      const optionList = helper.visibleOptions(cmd).map((option) => {
        return formatItem(helper.optionTerm(option), helper.optionDescription(option));
      });
      if (optionList.length > 0) {
        output = output.concat(["Options:", formatList(optionList), ""]);
      }
      if (this.showGlobalOptions) {
        const globalOptionList = helper.visibleGlobalOptions(cmd).map((option) => {
          return formatItem(helper.optionTerm(option), helper.optionDescription(option));
        });
        if (globalOptionList.length > 0) {
          output = output.concat(["Global Options:", formatList(globalOptionList), ""]);
        }
      }
      const commandList = helper.visibleCommands(cmd).map((cmd2) => {
        return formatItem(helper.subcommandTerm(cmd2), helper.subcommandDescription(cmd2));
      });
      if (commandList.length > 0) {
        output = output.concat(["Commands:", formatList(commandList), ""]);
      }
      return output.join("\n");
    }
    padWidth(cmd, helper) {
      return Math.max(helper.longestOptionTermLength(cmd, helper), helper.longestGlobalOptionTermLength(cmd, helper), helper.longestSubcommandTermLength(cmd, helper), helper.longestArgumentTermLength(cmd, helper));
    }
    wrap(str, width, indent, minColumnWidth = 40) {
      const indents = " \\f\\t\\v\xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF";
      const manualIndent = new RegExp(`[\\n][${indents}]+`);
      if (str.match(manualIndent))
        return str;
      const columnWidth = width - indent;
      if (columnWidth < minColumnWidth)
        return str;
      const leadingStr = str.slice(0, indent);
      const columnText = str.slice(indent).replace("\r\n", "\n");
      const indentString = " ".repeat(indent);
      const zeroWidthSpace = "\u200B";
      const breaks = `\\s${zeroWidthSpace}`;
      const regex = new RegExp(`\n|.{1,${columnWidth - 1}}([${breaks}]|\$)|[^${breaks}]+?([${breaks}]|\$)`, "g");
      const lines = columnText.match(regex) || [];
      return leadingStr + lines.map((line, i2) => {
        if (line === "\n")
          return "";
        return (i2 > 0 ? indentString : "") + line.trimEnd();
      }).join("\n");
    }
  }
  exports.Help = Help;
});

// node_modules/commander/lib/option.js
var require_option = __commonJS((exports) => {
  var camelcase = function(str) {
    return str.split("-").reduce((str2, word) => {
      return str2 + word[0].toUpperCase() + word.slice(1);
    });
  };
  var splitOptionFlags = function(flags) {
    let shortFlag;
    let longFlag;
    const flagParts = flags.split(/[ |,]+/);
    if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1]))
      shortFlag = flagParts.shift();
    longFlag = flagParts.shift();
    if (!shortFlag && /^-[^-]$/.test(longFlag)) {
      shortFlag = longFlag;
      longFlag = undefined;
    }
    return { shortFlag, longFlag };
  };
  var { InvalidArgumentError } = require_error();

  class Option {
    constructor(flags, description) {
      this.flags = flags;
      this.description = description || "";
      this.required = flags.includes("<");
      this.optional = flags.includes("[");
      this.variadic = /\w\.\.\.[>\]]$/.test(flags);
      this.mandatory = false;
      const optionFlags = splitOptionFlags(flags);
      this.short = optionFlags.shortFlag;
      this.long = optionFlags.longFlag;
      this.negate = false;
      if (this.long) {
        this.negate = this.long.startsWith("--no-");
      }
      this.defaultValue = undefined;
      this.defaultValueDescription = undefined;
      this.presetArg = undefined;
      this.envVar = undefined;
      this.parseArg = undefined;
      this.hidden = false;
      this.argChoices = undefined;
      this.conflictsWith = [];
      this.implied = undefined;
    }
    default(value, description) {
      this.defaultValue = value;
      this.defaultValueDescription = description;
      return this;
    }
    preset(arg) {
      this.presetArg = arg;
      return this;
    }
    conflicts(names) {
      this.conflictsWith = this.conflictsWith.concat(names);
      return this;
    }
    implies(impliedOptionValues) {
      let newImplied = impliedOptionValues;
      if (typeof impliedOptionValues === "string") {
        newImplied = { [impliedOptionValues]: true };
      }
      this.implied = Object.assign(this.implied || {}, newImplied);
      return this;
    }
    env(name) {
      this.envVar = name;
      return this;
    }
    argParser(fn) {
      this.parseArg = fn;
      return this;
    }
    makeOptionMandatory(mandatory = true) {
      this.mandatory = !!mandatory;
      return this;
    }
    hideHelp(hide = true) {
      this.hidden = !!hide;
      return this;
    }
    _concatValue(value, previous) {
      if (previous === this.defaultValue || !Array.isArray(previous)) {
        return [value];
      }
      return previous.concat(value);
    }
    choices(values) {
      this.argChoices = values.slice();
      this.parseArg = (arg, previous) => {
        if (!this.argChoices.includes(arg)) {
          throw new InvalidArgumentError(`Allowed choices are ${this.argChoices.join(", ")}.`);
        }
        if (this.variadic) {
          return this._concatValue(arg, previous);
        }
        return arg;
      };
      return this;
    }
    name() {
      if (this.long) {
        return this.long.replace(/^--/, "");
      }
      return this.short.replace(/^-/, "");
    }
    attributeName() {
      return camelcase(this.name().replace(/^no-/, ""));
    }
    is(arg) {
      return this.short === arg || this.long === arg;
    }
    isBoolean() {
      return !this.required && !this.optional && !this.negate;
    }
  }

  class DualOptions {
    constructor(options2) {
      this.positiveOptions = new Map;
      this.negativeOptions = new Map;
      this.dualOptions = new Set;
      options2.forEach((option) => {
        if (option.negate) {
          this.negativeOptions.set(option.attributeName(), option);
        } else {
          this.positiveOptions.set(option.attributeName(), option);
        }
      });
      this.negativeOptions.forEach((value, key) => {
        if (this.positiveOptions.has(key)) {
          this.dualOptions.add(key);
        }
      });
    }
    valueFromOption(value, option) {
      const optionKey = option.attributeName();
      if (!this.dualOptions.has(optionKey))
        return true;
      const preset = this.negativeOptions.get(optionKey).presetArg;
      const negativeValue = preset !== undefined ? preset : false;
      return option.negate === (negativeValue === value);
    }
  }
  exports.Option = Option;
  exports.splitOptionFlags = splitOptionFlags;
  exports.DualOptions = DualOptions;
});

// node_modules/commander/lib/suggestSimilar.js
var require_suggestSimilar = __commonJS((exports) => {
  var editDistance = function(a2, b2) {
    if (Math.abs(a2.length - b2.length) > maxDistance)
      return Math.max(a2.length, b2.length);
    const d2 = [];
    for (let i2 = 0;i2 <= a2.length; i2++) {
      d2[i2] = [i2];
    }
    for (let j2 = 0;j2 <= b2.length; j2++) {
      d2[0][j2] = j2;
    }
    for (let j2 = 1;j2 <= b2.length; j2++) {
      for (let i2 = 1;i2 <= a2.length; i2++) {
        let cost = 1;
        if (a2[i2 - 1] === b2[j2 - 1]) {
          cost = 0;
        } else {
          cost = 1;
        }
        d2[i2][j2] = Math.min(d2[i2 - 1][j2] + 1, d2[i2][j2 - 1] + 1, d2[i2 - 1][j2 - 1] + cost);
        if (i2 > 1 && j2 > 1 && a2[i2 - 1] === b2[j2 - 2] && a2[i2 - 2] === b2[j2 - 1]) {
          d2[i2][j2] = Math.min(d2[i2][j2], d2[i2 - 2][j2 - 2] + 1);
        }
      }
    }
    return d2[a2.length][b2.length];
  };
  var suggestSimilar = function(word, candidates) {
    if (!candidates || candidates.length === 0)
      return "";
    candidates = Array.from(new Set(candidates));
    const searchingOptions = word.startsWith("--");
    if (searchingOptions) {
      word = word.slice(2);
      candidates = candidates.map((candidate) => candidate.slice(2));
    }
    let similar = [];
    let bestDistance = maxDistance;
    const minSimilarity = 0.4;
    candidates.forEach((candidate) => {
      if (candidate.length <= 1)
        return;
      const distance = editDistance(word, candidate);
      const length = Math.max(word.length, candidate.length);
      const similarity = (length - distance) / length;
      if (similarity > minSimilarity) {
        if (distance < bestDistance) {
          bestDistance = distance;
          similar = [candidate];
        } else if (distance === bestDistance) {
          similar.push(candidate);
        }
      }
    });
    similar.sort((a2, b2) => a2.localeCompare(b2));
    if (searchingOptions) {
      similar = similar.map((candidate) => `--${candidate}`);
    }
    if (similar.length > 1) {
      return `\n(Did you mean one of ${similar.join(", ")}?)`;
    }
    if (similar.length === 1) {
      return `\n(Did you mean ${similar[0]}?)`;
    }
    return "";
  };
  var maxDistance = 3;
  exports.suggestSimilar = suggestSimilar;
});

// node_modules/commander/lib/command.js
var require_command = __commonJS((exports) => {
  var outputHelpIfRequested = function(cmd, args) {
    const helpOption = cmd._hasHelpOption && args.find((arg) => arg === cmd._helpLongFlag || arg === cmd._helpShortFlag);
    if (helpOption) {
      cmd.outputHelp();
      cmd._exit(0, "commander.helpDisplayed", "(outputHelp)");
    }
  };
  var incrementNodeInspectorPort = function(args) {
    return args.map((arg) => {
      if (!arg.startsWith("--inspect")) {
        return arg;
      }
      let debugOption;
      let debugHost = "127.0.0.1";
      let debugPort = "9229";
      let match;
      if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {
        debugOption = match[1];
      } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {
        debugOption = match[1];
        if (/^\d+$/.test(match[3])) {
          debugPort = match[3];
        } else {
          debugHost = match[3];
        }
      } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null) {
        debugOption = match[1];
        debugHost = match[3];
        debugPort = match[4];
      }
      if (debugOption && debugPort !== "0") {
        return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;
      }
      return arg;
    });
  };
  var EventEmitter = __require("events").EventEmitter;
  var childProcess = __require("child_process");
  var path = __require("path");
  var fs2 = __require("fs");
  var process2 = __require("process");
  var { Argument, humanReadableArgName } = require_argument();
  var { CommanderError } = require_error();
  var { Help } = require_help();
  var { Option, splitOptionFlags, DualOptions } = require_option();
  var { suggestSimilar } = require_suggestSimilar();

  class Command extends EventEmitter {
    constructor(name) {
      super();
      this.commands = [];
      this.options = [];
      this.parent = null;
      this._allowUnknownOption = false;
      this._allowExcessArguments = true;
      this.registeredArguments = [];
      this._args = this.registeredArguments;
      this.args = [];
      this.rawArgs = [];
      this.processedArgs = [];
      this._scriptPath = null;
      this._name = name || "";
      this._optionValues = {};
      this._optionValueSources = {};
      this._storeOptionsAsProperties = false;
      this._actionHandler = null;
      this._executableHandler = false;
      this._executableFile = null;
      this._executableDir = null;
      this._defaultCommandName = null;
      this._exitCallback = null;
      this._aliases = [];
      this._combineFlagAndOptionalValue = true;
      this._description = "";
      this._summary = "";
      this._argsDescription = undefined;
      this._enablePositionalOptions = false;
      this._passThroughOptions = false;
      this._lifeCycleHooks = {};
      this._showHelpAfterError = false;
      this._showSuggestionAfterError = true;
      this._outputConfiguration = {
        writeOut: (str) => process2.stdout.write(str),
        writeErr: (str) => process2.stderr.write(str),
        getOutHelpWidth: () => process2.stdout.isTTY ? process2.stdout.columns : undefined,
        getErrHelpWidth: () => process2.stderr.isTTY ? process2.stderr.columns : undefined,
        outputError: (str, write) => write(str)
      };
      this._hidden = false;
      this._hasHelpOption = true;
      this._helpFlags = "-h, --help";
      this._helpDescription = "display help for command";
      this._helpShortFlag = "-h";
      this._helpLongFlag = "--help";
      this._addImplicitHelpCommand = undefined;
      this._helpCommandName = "help";
      this._helpCommandnameAndArgs = "help [command]";
      this._helpCommandDescription = "display help for command";
      this._helpConfiguration = {};
    }
    copyInheritedSettings(sourceCommand) {
      this._outputConfiguration = sourceCommand._outputConfiguration;
      this._hasHelpOption = sourceCommand._hasHelpOption;
      this._helpFlags = sourceCommand._helpFlags;
      this._helpDescription = sourceCommand._helpDescription;
      this._helpShortFlag = sourceCommand._helpShortFlag;
      this._helpLongFlag = sourceCommand._helpLongFlag;
      this._helpCommandName = sourceCommand._helpCommandName;
      this._helpCommandnameAndArgs = sourceCommand._helpCommandnameAndArgs;
      this._helpCommandDescription = sourceCommand._helpCommandDescription;
      this._helpConfiguration = sourceCommand._helpConfiguration;
      this._exitCallback = sourceCommand._exitCallback;
      this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;
      this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;
      this._allowExcessArguments = sourceCommand._allowExcessArguments;
      this._enablePositionalOptions = sourceCommand._enablePositionalOptions;
      this._showHelpAfterError = sourceCommand._showHelpAfterError;
      this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;
      return this;
    }
    _getCommandAndAncestors() {
      const result = [];
      for (let command = this;command; command = command.parent) {
        result.push(command);
      }
      return result;
    }
    command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
      let desc = actionOptsOrExecDesc;
      let opts = execOpts;
      if (typeof desc === "object" && desc !== null) {
        opts = desc;
        desc = null;
      }
      opts = opts || {};
      const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);
      const cmd = this.createCommand(name);
      if (desc) {
        cmd.description(desc);
        cmd._executableHandler = true;
      }
      if (opts.isDefault)
        this._defaultCommandName = cmd._name;
      cmd._hidden = !!(opts.noHelp || opts.hidden);
      cmd._executableFile = opts.executableFile || null;
      if (args)
        cmd.arguments(args);
      this.commands.push(cmd);
      cmd.parent = this;
      cmd.copyInheritedSettings(this);
      if (desc)
        return this;
      return cmd;
    }
    createCommand(name) {
      return new Command(name);
    }
    createHelp() {
      return Object.assign(new Help, this.configureHelp());
    }
    configureHelp(configuration) {
      if (configuration === undefined)
        return this._helpConfiguration;
      this._helpConfiguration = configuration;
      return this;
    }
    configureOutput(configuration) {
      if (configuration === undefined)
        return this._outputConfiguration;
      Object.assign(this._outputConfiguration, configuration);
      return this;
    }
    showHelpAfterError(displayHelp = true) {
      if (typeof displayHelp !== "string")
        displayHelp = !!displayHelp;
      this._showHelpAfterError = displayHelp;
      return this;
    }
    showSuggestionAfterError(displaySuggestion = true) {
      this._showSuggestionAfterError = !!displaySuggestion;
      return this;
    }
    addCommand(cmd, opts) {
      if (!cmd._name) {
        throw new Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);
      }
      opts = opts || {};
      if (opts.isDefault)
        this._defaultCommandName = cmd._name;
      if (opts.noHelp || opts.hidden)
        cmd._hidden = true;
      this.commands.push(cmd);
      cmd.parent = this;
      return this;
    }
    createArgument(name, description) {
      return new Argument(name, description);
    }
    argument(name, description, fn, defaultValue) {
      const argument = this.createArgument(name, description);
      if (typeof fn === "function") {
        argument.default(defaultValue).argParser(fn);
      } else {
        argument.default(fn);
      }
      this.addArgument(argument);
      return this;
    }
    arguments(names) {
      names.trim().split(/ +/).forEach((detail) => {
        this.argument(detail);
      });
      return this;
    }
    addArgument(argument) {
      const previousArgument = this.registeredArguments.slice(-1)[0];
      if (previousArgument && previousArgument.variadic) {
        throw new Error(`only the last argument can be variadic '${previousArgument.name()}'`);
      }
      if (argument.required && argument.defaultValue !== undefined && argument.parseArg === undefined) {
        throw new Error(`a default value for a required argument is never used: '${argument.name()}'`);
      }
      this.registeredArguments.push(argument);
      return this;
    }
    addHelpCommand(enableOrNameAndArgs, description) {
      if (enableOrNameAndArgs === false) {
        this._addImplicitHelpCommand = false;
      } else {
        this._addImplicitHelpCommand = true;
        if (typeof enableOrNameAndArgs === "string") {
          this._helpCommandName = enableOrNameAndArgs.split(" ")[0];
          this._helpCommandnameAndArgs = enableOrNameAndArgs;
        }
        this._helpCommandDescription = description || this._helpCommandDescription;
      }
      return this;
    }
    _hasImplicitHelpCommand() {
      if (this._addImplicitHelpCommand === undefined) {
        return this.commands.length && !this._actionHandler && !this._findCommand("help");
      }
      return this._addImplicitHelpCommand;
    }
    hook(event, listener) {
      const allowedValues = ["preSubcommand", "preAction", "postAction"];
      if (!allowedValues.includes(event)) {
        throw new Error(`Unexpected value for event passed to hook : '${event}'.
Expecting one of '${allowedValues.join("', '")}'`);
      }
      if (this._lifeCycleHooks[event]) {
        this._lifeCycleHooks[event].push(listener);
      } else {
        this._lifeCycleHooks[event] = [listener];
      }
      return this;
    }
    exitOverride(fn) {
      if (fn) {
        this._exitCallback = fn;
      } else {
        this._exitCallback = (err) => {
          if (err.code !== "commander.executeSubCommandAsync") {
            throw err;
          } else {
          }
        };
      }
      return this;
    }
    _exit(exitCode, code, message) {
      if (this._exitCallback) {
        this._exitCallback(new CommanderError(exitCode, code, message));
      }
      process2.exit(exitCode);
    }
    action(fn) {
      const listener = (args) => {
        const expectedArgsCount = this.registeredArguments.length;
        const actionArgs = args.slice(0, expectedArgsCount);
        if (this._storeOptionsAsProperties) {
          actionArgs[expectedArgsCount] = this;
        } else {
          actionArgs[expectedArgsCount] = this.opts();
        }
        actionArgs.push(this);
        return fn.apply(this, actionArgs);
      };
      this._actionHandler = listener;
      return this;
    }
    createOption(flags, description) {
      return new Option(flags, description);
    }
    _callParseArg(target, value, previous, invalidArgumentMessage) {
      try {
        return target.parseArg(value, previous);
      } catch (err) {
        if (err.code === "commander.invalidArgument") {
          const message = `${invalidArgumentMessage} ${err.message}`;
          this.error(message, { exitCode: err.exitCode, code: err.code });
        }
        throw err;
      }
    }
    addOption(option) {
      const oname = option.name();
      const name = option.attributeName();
      if (option.negate) {
        const positiveLongFlag = option.long.replace(/^--no-/, "--");
        if (!this._findOption(positiveLongFlag)) {
          this.setOptionValueWithSource(name, option.defaultValue === undefined ? true : option.defaultValue, "default");
        }
      } else if (option.defaultValue !== undefined) {
        this.setOptionValueWithSource(name, option.defaultValue, "default");
      }
      this.options.push(option);
      const handleOptionValue = (val, invalidValueMessage, valueSource) => {
        if (val == null && option.presetArg !== undefined) {
          val = option.presetArg;
        }
        const oldValue = this.getOptionValue(name);
        if (val !== null && option.parseArg) {
          val = this._callParseArg(option, val, oldValue, invalidValueMessage);
        } else if (val !== null && option.variadic) {
          val = option._concatValue(val, oldValue);
        }
        if (val == null) {
          if (option.negate) {
            val = false;
          } else if (option.isBoolean() || option.optional) {
            val = true;
          } else {
            val = "";
          }
        }
        this.setOptionValueWithSource(name, val, valueSource);
      };
      this.on("option:" + oname, (val) => {
        const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;
        handleOptionValue(val, invalidValueMessage, "cli");
      });
      if (option.envVar) {
        this.on("optionEnv:" + oname, (val) => {
          const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;
          handleOptionValue(val, invalidValueMessage, "env");
        });
      }
      return this;
    }
    _optionEx(config, flags, description, fn, defaultValue) {
      if (typeof flags === "object" && flags instanceof Option) {
        throw new Error("To add an Option object use addOption() instead of option() or requiredOption()");
      }
      const option = this.createOption(flags, description);
      option.makeOptionMandatory(!!config.mandatory);
      if (typeof fn === "function") {
        option.default(defaultValue).argParser(fn);
      } else if (fn instanceof RegExp) {
        const regex = fn;
        fn = (val, def) => {
          const m2 = regex.exec(val);
          return m2 ? m2[0] : def;
        };
        option.default(defaultValue).argParser(fn);
      } else {
        option.default(fn);
      }
      return this.addOption(option);
    }
    option(flags, description, parseArg, defaultValue) {
      return this._optionEx({}, flags, description, parseArg, defaultValue);
    }
    requiredOption(flags, description, parseArg, defaultValue) {
      return this._optionEx({ mandatory: true }, flags, description, parseArg, defaultValue);
    }
    combineFlagAndOptionalValue(combine = true) {
      this._combineFlagAndOptionalValue = !!combine;
      return this;
    }
    allowUnknownOption(allowUnknown = true) {
      this._allowUnknownOption = !!allowUnknown;
      return this;
    }
    allowExcessArguments(allowExcess = true) {
      this._allowExcessArguments = !!allowExcess;
      return this;
    }
    enablePositionalOptions(positional = true) {
      this._enablePositionalOptions = !!positional;
      return this;
    }
    passThroughOptions(passThrough = true) {
      this._passThroughOptions = !!passThrough;
      if (!!this.parent && passThrough && !this.parent._enablePositionalOptions) {
        throw new Error("passThroughOptions can not be used without turning on enablePositionalOptions for parent command(s)");
      }
      return this;
    }
    storeOptionsAsProperties(storeAsProperties = true) {
      if (this.options.length) {
        throw new Error("call .storeOptionsAsProperties() before adding options");
      }
      this._storeOptionsAsProperties = !!storeAsProperties;
      return this;
    }
    getOptionValue(key) {
      if (this._storeOptionsAsProperties) {
        return this[key];
      }
      return this._optionValues[key];
    }
    setOptionValue(key, value) {
      return this.setOptionValueWithSource(key, value, undefined);
    }
    setOptionValueWithSource(key, value, source) {
      if (this._storeOptionsAsProperties) {
        this[key] = value;
      } else {
        this._optionValues[key] = value;
      }
      this._optionValueSources[key] = source;
      return this;
    }
    getOptionValueSource(key) {
      return this._optionValueSources[key];
    }
    getOptionValueSourceWithGlobals(key) {
      let source;
      this._getCommandAndAncestors().forEach((cmd) => {
        if (cmd.getOptionValueSource(key) !== undefined) {
          source = cmd.getOptionValueSource(key);
        }
      });
      return source;
    }
    _prepareUserArgs(argv, parseOptions) {
      if (argv !== undefined && !Array.isArray(argv)) {
        throw new Error("first parameter to parse must be array or undefined");
      }
      parseOptions = parseOptions || {};
      if (argv === undefined) {
        argv = process2.argv;
        if (process2.versions && process2.versions.electron) {
          parseOptions.from = "electron";
        }
      }
      this.rawArgs = argv.slice();
      let userArgs;
      switch (parseOptions.from) {
        case undefined:
        case "node":
          this._scriptPath = argv[1];
          userArgs = argv.slice(2);
          break;
        case "electron":
          if (process2.defaultApp) {
            this._scriptPath = argv[1];
            userArgs = argv.slice(2);
          } else {
            userArgs = argv.slice(1);
          }
          break;
        case "user":
          userArgs = argv.slice(0);
          break;
        default:
          throw new Error(`unexpected parse option { from: '${parseOptions.from}' }`);
      }
      if (!this._name && this._scriptPath)
        this.nameFromFilename(this._scriptPath);
      this._name = this._name || "program";
      return userArgs;
    }
    parse(argv, parseOptions) {
      const userArgs = this._prepareUserArgs(argv, parseOptions);
      this._parseCommand([], userArgs);
      return this;
    }
    async parseAsync(argv, parseOptions) {
      const userArgs = this._prepareUserArgs(argv, parseOptions);
      await this._parseCommand([], userArgs);
      return this;
    }
    _executeSubCommand(subcommand, args) {
      args = args.slice();
      let launchWithNode = false;
      const sourceExt = [".js", ".ts", ".tsx", ".mjs", ".cjs"];
      function findFile(baseDir, baseName) {
        const localBin = path.resolve(baseDir, baseName);
        if (fs2.existsSync(localBin))
          return localBin;
        if (sourceExt.includes(path.extname(baseName)))
          return;
        const foundExt = sourceExt.find((ext) => fs2.existsSync(`${localBin}${ext}`));
        if (foundExt)
          return `${localBin}${foundExt}`;
        return;
      }
      this._checkForMissingMandatoryOptions();
      this._checkForConflictingOptions();
      let executableFile = subcommand._executableFile || `${this._name}-${subcommand._name}`;
      let executableDir = this._executableDir || "";
      if (this._scriptPath) {
        let resolvedScriptPath;
        try {
          resolvedScriptPath = fs2.realpathSync(this._scriptPath);
        } catch (err) {
          resolvedScriptPath = this._scriptPath;
        }
        executableDir = path.resolve(path.dirname(resolvedScriptPath), executableDir);
      }
      if (executableDir) {
        let localFile = findFile(executableDir, executableFile);
        if (!localFile && !subcommand._executableFile && this._scriptPath) {
          const legacyName = path.basename(this._scriptPath, path.extname(this._scriptPath));
          if (legacyName !== this._name) {
            localFile = findFile(executableDir, `${legacyName}-${subcommand._name}`);
          }
        }
        executableFile = localFile || executableFile;
      }
      launchWithNode = sourceExt.includes(path.extname(executableFile));
      let proc;
      if (process2.platform !== "win32") {
        if (launchWithNode) {
          args.unshift(executableFile);
          args = incrementNodeInspectorPort(process2.execArgv).concat(args);
          proc = childProcess.spawn(process2.argv[0], args, { stdio: "inherit" });
        } else {
          proc = childProcess.spawn(executableFile, args, { stdio: "inherit" });
        }
      } else {
        args.unshift(executableFile);
        args = incrementNodeInspectorPort(process2.execArgv).concat(args);
        proc = childProcess.spawn(process2.execPath, args, { stdio: "inherit" });
      }
      if (!proc.killed) {
        const signals = ["SIGUSR1", "SIGUSR2", "SIGTERM", "SIGINT", "SIGHUP"];
        signals.forEach((signal) => {
          process2.on(signal, () => {
            if (proc.killed === false && proc.exitCode === null) {
              proc.kill(signal);
            }
          });
        });
      }
      const exitCallback = this._exitCallback;
      if (!exitCallback) {
        proc.on("close", process2.exit.bind(process2));
      } else {
        proc.on("close", () => {
          exitCallback(new CommanderError(process2.exitCode || 0, "commander.executeSubCommandAsync", "(close)"));
        });
      }
      proc.on("error", (err) => {
        if (err.code === "ENOENT") {
          const executableDirMessage = executableDir ? `searched for local subcommand relative to directory '${executableDir}'` : "no directory for search for local subcommand, use .executableDir() to supply a custom directory";
          const executableMissing = `'${executableFile}' does not exist
 - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${executableDirMessage}`;
          throw new Error(executableMissing);
        } else if (err.code === "EACCES") {
          throw new Error(`'${executableFile}' not executable`);
        }
        if (!exitCallback) {
          process2.exit(1);
        } else {
          const wrappedError = new CommanderError(1, "commander.executeSubCommandAsync", "(error)");
          wrappedError.nestedError = err;
          exitCallback(wrappedError);
        }
      });
      this.runningCommand = proc;
    }
    _dispatchSubcommand(commandName, operands, unknown) {
      const subCommand = this._findCommand(commandName);
      if (!subCommand)
        this.help({ error: true });
      let promiseChain;
      promiseChain = this._chainOrCallSubCommandHook(promiseChain, subCommand, "preSubcommand");
      promiseChain = this._chainOrCall(promiseChain, () => {
        if (subCommand._executableHandler) {
          this._executeSubCommand(subCommand, operands.concat(unknown));
        } else {
          return subCommand._parseCommand(operands, unknown);
        }
      });
      return promiseChain;
    }
    _dispatchHelpCommand(subcommandName) {
      if (!subcommandName) {
        this.help();
      }
      const subCommand = this._findCommand(subcommandName);
      if (subCommand && !subCommand._executableHandler) {
        subCommand.help();
      }
      return this._dispatchSubcommand(subcommandName, [], [
        this._helpLongFlag || this._helpShortFlag
      ]);
    }
    _checkNumberOfArguments() {
      this.registeredArguments.forEach((arg, i2) => {
        if (arg.required && this.args[i2] == null) {
          this.missingArgument(arg.name());
        }
      });
      if (this.registeredArguments.length > 0 && this.registeredArguments[this.registeredArguments.length - 1].variadic) {
        return;
      }
      if (this.args.length > this.registeredArguments.length) {
        this._excessArguments(this.args);
      }
    }
    _processArguments() {
      const myParseArg = (argument, value, previous) => {
        let parsedValue = value;
        if (value !== null && argument.parseArg) {
          const invalidValueMessage = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'.`;
          parsedValue = this._callParseArg(argument, value, previous, invalidValueMessage);
        }
        return parsedValue;
      };
      this._checkNumberOfArguments();
      const processedArgs = [];
      this.registeredArguments.forEach((declaredArg, index) => {
        let value = declaredArg.defaultValue;
        if (declaredArg.variadic) {
          if (index < this.args.length) {
            value = this.args.slice(index);
            if (declaredArg.parseArg) {
              value = value.reduce((processed, v2) => {
                return myParseArg(declaredArg, v2, processed);
              }, declaredArg.defaultValue);
            }
          } else if (value === undefined) {
            value = [];
          }
        } else if (index < this.args.length) {
          value = this.args[index];
          if (declaredArg.parseArg) {
            value = myParseArg(declaredArg, value, declaredArg.defaultValue);
          }
        }
        processedArgs[index] = value;
      });
      this.processedArgs = processedArgs;
    }
    _chainOrCall(promise, fn) {
      if (promise && promise.then && typeof promise.then === "function") {
        return promise.then(() => fn());
      }
      return fn();
    }
    _chainOrCallHooks(promise, event) {
      let result = promise;
      const hooks = [];
      this._getCommandAndAncestors().reverse().filter((cmd) => cmd._lifeCycleHooks[event] !== undefined).forEach((hookedCommand) => {
        hookedCommand._lifeCycleHooks[event].forEach((callback) => {
          hooks.push({ hookedCommand, callback });
        });
      });
      if (event === "postAction") {
        hooks.reverse();
      }
      hooks.forEach((hookDetail) => {
        result = this._chainOrCall(result, () => {
          return hookDetail.callback(hookDetail.hookedCommand, this);
        });
      });
      return result;
    }
    _chainOrCallSubCommandHook(promise, subCommand, event) {
      let result = promise;
      if (this._lifeCycleHooks[event] !== undefined) {
        this._lifeCycleHooks[event].forEach((hook) => {
          result = this._chainOrCall(result, () => {
            return hook(this, subCommand);
          });
        });
      }
      return result;
    }
    _parseCommand(operands, unknown) {
      const parsed = this.parseOptions(unknown);
      this._parseOptionsEnv();
      this._parseOptionsImplied();
      operands = operands.concat(parsed.operands);
      unknown = parsed.unknown;
      this.args = operands.concat(unknown);
      if (operands && this._findCommand(operands[0])) {
        return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);
      }
      if (this._hasImplicitHelpCommand() && operands[0] === this._helpCommandName) {
        return this._dispatchHelpCommand(operands[1]);
      }
      if (this._defaultCommandName) {
        outputHelpIfRequested(this, unknown);
        return this._dispatchSubcommand(this._defaultCommandName, operands, unknown);
      }
      if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {
        this.help({ error: true });
      }
      outputHelpIfRequested(this, parsed.unknown);
      this._checkForMissingMandatoryOptions();
      this._checkForConflictingOptions();
      const checkForUnknownOptions = () => {
        if (parsed.unknown.length > 0) {
          this.unknownOption(parsed.unknown[0]);
        }
      };
      const commandEvent = `command:${this.name()}`;
      if (this._actionHandler) {
        checkForUnknownOptions();
        this._processArguments();
        let promiseChain;
        promiseChain = this._chainOrCallHooks(promiseChain, "preAction");
        promiseChain = this._chainOrCall(promiseChain, () => this._actionHandler(this.processedArgs));
        if (this.parent) {
          promiseChain = this._chainOrCall(promiseChain, () => {
            this.parent.emit(commandEvent, operands, unknown);
          });
        }
        promiseChain = this._chainOrCallHooks(promiseChain, "postAction");
        return promiseChain;
      }
      if (this.parent && this.parent.listenerCount(commandEvent)) {
        checkForUnknownOptions();
        this._processArguments();
        this.parent.emit(commandEvent, operands, unknown);
      } else if (operands.length) {
        if (this._findCommand("*")) {
          return this._dispatchSubcommand("*", operands, unknown);
        }
        if (this.listenerCount("command:*")) {
          this.emit("command:*", operands, unknown);
        } else if (this.commands.length) {
          this.unknownCommand();
        } else {
          checkForUnknownOptions();
          this._processArguments();
        }
      } else if (this.commands.length) {
        checkForUnknownOptions();
        this.help({ error: true });
      } else {
        checkForUnknownOptions();
        this._processArguments();
      }
    }
    _findCommand(name) {
      if (!name)
        return;
      return this.commands.find((cmd) => cmd._name === name || cmd._aliases.includes(name));
    }
    _findOption(arg) {
      return this.options.find((option) => option.is(arg));
    }
    _checkForMissingMandatoryOptions() {
      this._getCommandAndAncestors().forEach((cmd) => {
        cmd.options.forEach((anOption) => {
          if (anOption.mandatory && cmd.getOptionValue(anOption.attributeName()) === undefined) {
            cmd.missingMandatoryOptionValue(anOption);
          }
        });
      });
    }
    _checkForConflictingLocalOptions() {
      const definedNonDefaultOptions = this.options.filter((option) => {
        const optionKey = option.attributeName();
        if (this.getOptionValue(optionKey) === undefined) {
          return false;
        }
        return this.getOptionValueSource(optionKey) !== "default";
      });
      const optionsWithConflicting = definedNonDefaultOptions.filter((option) => option.conflictsWith.length > 0);
      optionsWithConflicting.forEach((option) => {
        const conflictingAndDefined = definedNonDefaultOptions.find((defined) => option.conflictsWith.includes(defined.attributeName()));
        if (conflictingAndDefined) {
          this._conflictingOption(option, conflictingAndDefined);
        }
      });
    }
    _checkForConflictingOptions() {
      this._getCommandAndAncestors().forEach((cmd) => {
        cmd._checkForConflictingLocalOptions();
      });
    }
    parseOptions(argv) {
      const operands = [];
      const unknown = [];
      let dest = operands;
      const args = argv.slice();
      function maybeOption(arg) {
        return arg.length > 1 && arg[0] === "-";
      }
      let activeVariadicOption = null;
      while (args.length) {
        const arg = args.shift();
        if (arg === "--") {
          if (dest === unknown)
            dest.push(arg);
          dest.push(...args);
          break;
        }
        if (activeVariadicOption && !maybeOption(arg)) {
          this.emit(`option:${activeVariadicOption.name()}`, arg);
          continue;
        }
        activeVariadicOption = null;
        if (maybeOption(arg)) {
          const option = this._findOption(arg);
          if (option) {
            if (option.required) {
              const value = args.shift();
              if (value === undefined)
                this.optionMissingArgument(option);
              this.emit(`option:${option.name()}`, value);
            } else if (option.optional) {
              let value = null;
              if (args.length > 0 && !maybeOption(args[0])) {
                value = args.shift();
              }
              this.emit(`option:${option.name()}`, value);
            } else {
              this.emit(`option:${option.name()}`);
            }
            activeVariadicOption = option.variadic ? option : null;
            continue;
          }
        }
        if (arg.length > 2 && arg[0] === "-" && arg[1] !== "-") {
          const option = this._findOption(`-${arg[1]}`);
          if (option) {
            if (option.required || option.optional && this._combineFlagAndOptionalValue) {
              this.emit(`option:${option.name()}`, arg.slice(2));
            } else {
              this.emit(`option:${option.name()}`);
              args.unshift(`-${arg.slice(2)}`);
            }
            continue;
          }
        }
        if (/^--[^=]+=/.test(arg)) {
          const index = arg.indexOf("=");
          const option = this._findOption(arg.slice(0, index));
          if (option && (option.required || option.optional)) {
            this.emit(`option:${option.name()}`, arg.slice(index + 1));
            continue;
          }
        }
        if (maybeOption(arg)) {
          dest = unknown;
        }
        if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown.length === 0) {
          if (this._findCommand(arg)) {
            operands.push(arg);
            if (args.length > 0)
              unknown.push(...args);
            break;
          } else if (arg === this._helpCommandName && this._hasImplicitHelpCommand()) {
            operands.push(arg);
            if (args.length > 0)
              operands.push(...args);
            break;
          } else if (this._defaultCommandName) {
            unknown.push(arg);
            if (args.length > 0)
              unknown.push(...args);
            break;
          }
        }
        if (this._passThroughOptions) {
          dest.push(arg);
          if (args.length > 0)
            dest.push(...args);
          break;
        }
        dest.push(arg);
      }
      return { operands, unknown };
    }
    opts() {
      if (this._storeOptionsAsProperties) {
        const result = {};
        const len = this.options.length;
        for (let i2 = 0;i2 < len; i2++) {
          const key = this.options[i2].attributeName();
          result[key] = key === this._versionOptionName ? this._version : this[key];
        }
        return result;
      }
      return this._optionValues;
    }
    optsWithGlobals() {
      return this._getCommandAndAncestors().reduce((combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts()), {});
    }
    error(message, errorOptions) {
      this._outputConfiguration.outputError(`${message}\n`, this._outputConfiguration.writeErr);
      if (typeof this._showHelpAfterError === "string") {
        this._outputConfiguration.writeErr(`${this._showHelpAfterError}\n`);
      } else if (this._showHelpAfterError) {
        this._outputConfiguration.writeErr("\n");
        this.outputHelp({ error: true });
      }
      const config = errorOptions || {};
      const exitCode = config.exitCode || 1;
      const code = config.code || "commander.error";
      this._exit(exitCode, code, message);
    }
    _parseOptionsEnv() {
      this.options.forEach((option) => {
        if (option.envVar && (option.envVar in process2.env)) {
          const optionKey = option.attributeName();
          if (this.getOptionValue(optionKey) === undefined || ["default", "config", "env"].includes(this.getOptionValueSource(optionKey))) {
            if (option.required || option.optional) {
              this.emit(`optionEnv:${option.name()}`, process2.env[option.envVar]);
            } else {
              this.emit(`optionEnv:${option.name()}`);
            }
          }
        }
      });
    }
    _parseOptionsImplied() {
      const dualHelper = new DualOptions(this.options);
      const hasCustomOptionValue = (optionKey) => {
        return this.getOptionValue(optionKey) !== undefined && !["default", "implied"].includes(this.getOptionValueSource(optionKey));
      };
      this.options.filter((option) => option.implied !== undefined && hasCustomOptionValue(option.attributeName()) && dualHelper.valueFromOption(this.getOptionValue(option.attributeName()), option)).forEach((option) => {
        Object.keys(option.implied).filter((impliedKey) => !hasCustomOptionValue(impliedKey)).forEach((impliedKey) => {
          this.setOptionValueWithSource(impliedKey, option.implied[impliedKey], "implied");
        });
      });
    }
    missingArgument(name) {
      const message = `error: missing required argument '${name}'`;
      this.error(message, { code: "commander.missingArgument" });
    }
    optionMissingArgument(option) {
      const message = `error: option '${option.flags}' argument missing`;
      this.error(message, { code: "commander.optionMissingArgument" });
    }
    missingMandatoryOptionValue(option) {
      const message = `error: required option '${option.flags}' not specified`;
      this.error(message, { code: "commander.missingMandatoryOptionValue" });
    }
    _conflictingOption(option, conflictingOption) {
      const findBestOptionFromValue = (option2) => {
        const optionKey = option2.attributeName();
        const optionValue = this.getOptionValue(optionKey);
        const negativeOption = this.options.find((target) => target.negate && optionKey === target.attributeName());
        const positiveOption = this.options.find((target) => !target.negate && optionKey === target.attributeName());
        if (negativeOption && (negativeOption.presetArg === undefined && optionValue === false || negativeOption.presetArg !== undefined && optionValue === negativeOption.presetArg)) {
          return negativeOption;
        }
        return positiveOption || option2;
      };
      const getErrorMessage = (option2) => {
        const bestOption = findBestOptionFromValue(option2);
        const optionKey = bestOption.attributeName();
        const source = this.getOptionValueSource(optionKey);
        if (source === "env") {
          return `environment variable '${bestOption.envVar}'`;
        }
        return `option '${bestOption.flags}'`;
      };
      const message = `error: ${getErrorMessage(option)} cannot be used with ${getErrorMessage(conflictingOption)}`;
      this.error(message, { code: "commander.conflictingOption" });
    }
    unknownOption(flag) {
      if (this._allowUnknownOption)
        return;
      let suggestion = "";
      if (flag.startsWith("--") && this._showSuggestionAfterError) {
        let candidateFlags = [];
        let command = this;
        do {
          const moreFlags = command.createHelp().visibleOptions(command).filter((option) => option.long).map((option) => option.long);
          candidateFlags = candidateFlags.concat(moreFlags);
          command = command.parent;
        } while (command && !command._enablePositionalOptions);
        suggestion = suggestSimilar(flag, candidateFlags);
      }
      const message = `error: unknown option '${flag}'${suggestion}`;
      this.error(message, { code: "commander.unknownOption" });
    }
    _excessArguments(receivedArgs) {
      if (this._allowExcessArguments)
        return;
      const expected = this.registeredArguments.length;
      const s2 = expected === 1 ? "" : "s";
      const forSubcommand = this.parent ? ` for '${this.name()}'` : "";
      const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s2} but got ${receivedArgs.length}.`;
      this.error(message, { code: "commander.excessArguments" });
    }
    unknownCommand() {
      const unknownName = this.args[0];
      let suggestion = "";
      if (this._showSuggestionAfterError) {
        const candidateNames = [];
        this.createHelp().visibleCommands(this).forEach((command) => {
          candidateNames.push(command.name());
          if (command.alias())
            candidateNames.push(command.alias());
        });
        suggestion = suggestSimilar(unknownName, candidateNames);
      }
      const message = `error: unknown command '${unknownName}'${suggestion}`;
      this.error(message, { code: "commander.unknownCommand" });
    }
    version(str, flags, description) {
      if (str === undefined)
        return this._version;
      this._version = str;
      flags = flags || "-V, --version";
      description = description || "output the version number";
      const versionOption = this.createOption(flags, description);
      this._versionOptionName = versionOption.attributeName();
      this.options.push(versionOption);
      this.on("option:" + versionOption.name(), () => {
        this._outputConfiguration.writeOut(`${str}\n`);
        this._exit(0, "commander.version", str);
      });
      return this;
    }
    description(str, argsDescription) {
      if (str === undefined && argsDescription === undefined)
        return this._description;
      this._description = str;
      if (argsDescription) {
        this._argsDescription = argsDescription;
      }
      return this;
    }
    summary(str) {
      if (str === undefined)
        return this._summary;
      this._summary = str;
      return this;
    }
    alias(alias) {
      if (alias === undefined)
        return this._aliases[0];
      let command = this;
      if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {
        command = this.commands[this.commands.length - 1];
      }
      if (alias === command._name)
        throw new Error("Command alias can\'t be the same as its name");
      command._aliases.push(alias);
      return this;
    }
    aliases(aliases) {
      if (aliases === undefined)
        return this._aliases;
      aliases.forEach((alias) => this.alias(alias));
      return this;
    }
    usage(str) {
      if (str === undefined) {
        if (this._usage)
          return this._usage;
        const args = this.registeredArguments.map((arg) => {
          return humanReadableArgName(arg);
        });
        return [].concat(this.options.length || this._hasHelpOption ? "[options]" : [], this.commands.length ? "[command]" : [], this.registeredArguments.length ? args : []).join(" ");
      }
      this._usage = str;
      return this;
    }
    name(str) {
      if (str === undefined)
        return this._name;
      this._name = str;
      return this;
    }
    nameFromFilename(filename) {
      this._name = path.basename(filename, path.extname(filename));
      return this;
    }
    executableDir(path2) {
      if (path2 === undefined)
        return this._executableDir;
      this._executableDir = path2;
      return this;
    }
    helpInformation(contextOptions) {
      const helper = this.createHelp();
      if (helper.helpWidth === undefined) {
        helper.helpWidth = contextOptions && contextOptions.error ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth();
      }
      return helper.formatHelp(this, helper);
    }
    _getHelpContext(contextOptions) {
      contextOptions = contextOptions || {};
      const context = { error: !!contextOptions.error };
      let write;
      if (context.error) {
        write = (arg) => this._outputConfiguration.writeErr(arg);
      } else {
        write = (arg) => this._outputConfiguration.writeOut(arg);
      }
      context.write = contextOptions.write || write;
      context.command = this;
      return context;
    }
    outputHelp(contextOptions) {
      let deprecatedCallback;
      if (typeof contextOptions === "function") {
        deprecatedCallback = contextOptions;
        contextOptions = undefined;
      }
      const context = this._getHelpContext(contextOptions);
      this._getCommandAndAncestors().reverse().forEach((command) => command.emit("beforeAllHelp", context));
      this.emit("beforeHelp", context);
      let helpInformation = this.helpInformation(context);
      if (deprecatedCallback) {
        helpInformation = deprecatedCallback(helpInformation);
        if (typeof helpInformation !== "string" && !Buffer.isBuffer(helpInformation)) {
          throw new Error("outputHelp callback must return a string or a Buffer");
        }
      }
      context.write(helpInformation);
      if (this._helpLongFlag) {
        this.emit(this._helpLongFlag);
      }
      this.emit("afterHelp", context);
      this._getCommandAndAncestors().forEach((command) => command.emit("afterAllHelp", context));
    }
    helpOption(flags, description) {
      if (typeof flags === "boolean") {
        this._hasHelpOption = flags;
        return this;
      }
      this._helpFlags = flags || this._helpFlags;
      this._helpDescription = description || this._helpDescription;
      const helpFlags = splitOptionFlags(this._helpFlags);
      this._helpShortFlag = helpFlags.shortFlag;
      this._helpLongFlag = helpFlags.longFlag;
      return this;
    }
    help(contextOptions) {
      this.outputHelp(contextOptions);
      let exitCode = process2.exitCode || 0;
      if (exitCode === 0 && contextOptions && typeof contextOptions !== "function" && contextOptions.error) {
        exitCode = 1;
      }
      this._exit(exitCode, "commander.help", "(outputHelp)");
    }
    addHelpText(position, text) {
      const allowedValues = ["beforeAll", "before", "after", "afterAll"];
      if (!allowedValues.includes(position)) {
        throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${allowedValues.join("', '")}'`);
      }
      const helpEvent = `${position}Help`;
      this.on(helpEvent, (context) => {
        let helpStr;
        if (typeof text === "function") {
          helpStr = text({ error: context.error, command: context.command });
        } else {
          helpStr = text;
        }
        if (helpStr) {
          context.write(`${helpStr}\n`);
        }
      });
      return this;
    }
  }
  exports.Command = Command;
});

// node_modules/commander/index.js
var require_commander = __commonJS((exports, module) => {
  var { Argument } = require_argument();
  var { Command } = require_command();
  var { CommanderError, InvalidArgumentError } = require_error();
  var { Help } = require_help();
  var { Option } = require_option();
  exports = module.exports = new Command;
  exports.program = exports;
  exports.Command = Command;
  exports.Option = Option;
  exports.Argument = Argument;
  exports.Help = Help;
  exports.CommanderError = CommanderError;
  exports.InvalidArgumentError = InvalidArgumentError;
  exports.InvalidOptionArgumentError = InvalidArgumentError;
});

// node_modules/cli-table3/src/debug.js
var require_debug = __commonJS((exports, module) => {
  var messages = [];
  var level = 0;
  var debug2 = (msg, min) => {
    if (level >= min) {
      messages.push(msg);
    }
  };
  debug2.WARN = 1;
  debug2.INFO = 2;
  debug2.DEBUG = 3;
  debug2.reset = () => {
    messages = [];
  };
  debug2.setDebugLevel = (v2) => {
    level = v2;
  };
  debug2.warn = (msg) => debug2(msg, debug2.WARN);
  debug2.info = (msg) => debug2(msg, debug2.INFO);
  debug2.debug = (msg) => debug2(msg, debug2.DEBUG);
  debug2.debugMessages = () => messages;
  module.exports = debug2;
});

// node_modules/ansi-regex/index.js
var require_ansi_regex = __commonJS((exports, module) => {
  module.exports = ({ onlyFirst = false } = {}) => {
    const pattern = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
    ].join("|");
    return new RegExp(pattern, onlyFirst ? undefined : "g");
  };
});

// node_modules/strip-ansi/index.js
var require_strip_ansi = __commonJS((exports, module) => {
  var ansiRegex = require_ansi_regex();
  module.exports = (string) => typeof string === "string" ? string.replace(ansiRegex(), "") : string;
});

// node_modules/is-fullwidth-code-point/index.js
var require_is_fullwidth_code_point = __commonJS((exports, module) => {
  var isFullwidthCodePoint = (codePoint) => {
    if (Number.isNaN(codePoint)) {
      return false;
    }
    if (codePoint >= 4352 && (codePoint <= 4447 || codePoint === 9001 || codePoint === 9002 || 11904 <= codePoint && codePoint <= 12871 && codePoint !== 12351 || 12880 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65131 || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 262141)) {
      return true;
    }
    return false;
  };
  module.exports = isFullwidthCodePoint;
  module.exports.default = isFullwidthCodePoint;
});

// node_modules/emoji-regex/index.js
var require_emoji_regex = __commonJS((exports, module) => {
  module.exports = function() {
    return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
  };
});

// node_modules/string-width/index.js
var require_string_width = __commonJS((exports, module) => {
  var stripAnsi = require_strip_ansi();
  var isFullwidthCodePoint = require_is_fullwidth_code_point();
  var emojiRegex = require_emoji_regex();
  var stringWidth = (string) => {
    if (typeof string !== "string" || string.length === 0) {
      return 0;
    }
    string = stripAnsi(string);
    if (string.length === 0) {
      return 0;
    }
    string = string.replace(emojiRegex(), "  ");
    let width = 0;
    for (let i2 = 0;i2 < string.length; i2++) {
      const code = string.codePointAt(i2);
      if (code <= 31 || code >= 127 && code <= 159) {
        continue;
      }
      if (code >= 768 && code <= 879) {
        continue;
      }
      if (code > 65535) {
        i2++;
      }
      width += isFullwidthCodePoint(code) ? 2 : 1;
    }
    return width;
  };
  module.exports = stringWidth;
  module.exports.default = stringWidth;
});

// node_modules/cli-table3/src/utils.js
var require_utils2 = __commonJS((exports, module) => {
  var codeRegex = function(capture) {
    return capture ? /\u001b\[((?:\d*;){0,5}\d*)m/g : /\u001b\[(?:\d*;){0,5}\d*m/g;
  };
  var strlen = function(str) {
    let code = codeRegex();
    let stripped = ("" + str).replace(code, "");
    let split = stripped.split("\n");
    return split.reduce(function(memo, s2) {
      return stringWidth(s2) > memo ? stringWidth(s2) : memo;
    }, 0);
  };
  var repeat = function(str, times) {
    return Array(times + 1).join(str);
  };
  var pad = function(str, len, pad2, dir) {
    let length = strlen(str);
    if (len + 1 >= length) {
      let padlen = len - length;
      switch (dir) {
        case "right": {
          str = repeat(pad2, padlen) + str;
          break;
        }
        case "center": {
          let right = Math.ceil(padlen / 2);
          let left = padlen - right;
          str = repeat(pad2, left) + str + repeat(pad2, right);
          break;
        }
        default: {
          str = str + repeat(pad2, padlen);
          break;
        }
      }
    }
    return str;
  };
  var addToCodeCache = function(name, on, off) {
    on = "\x1B[" + on + "m";
    off = "\x1B[" + off + "m";
    codeCache[on] = { set: name, to: true };
    codeCache[off] = { set: name, to: false };
    codeCache[name] = { on, off };
  };
  var updateState = function(state, controlChars) {
    let controlCode = controlChars[1] ? parseInt(controlChars[1].split(";")[0]) : 0;
    if (controlCode >= 30 && controlCode <= 39 || controlCode >= 90 && controlCode <= 97) {
      state.lastForegroundAdded = controlChars[0];
      return;
    }
    if (controlCode >= 40 && controlCode <= 49 || controlCode >= 100 && controlCode <= 107) {
      state.lastBackgroundAdded = controlChars[0];
      return;
    }
    if (controlCode === 0) {
      for (let i2 in state) {
        if (Object.prototype.hasOwnProperty.call(state, i2)) {
          delete state[i2];
        }
      }
      return;
    }
    let info = codeCache[controlChars[0]];
    if (info) {
      state[info.set] = info.to;
    }
  };
  var readState = function(line) {
    let code = codeRegex(true);
    let controlChars = code.exec(line);
    let state = {};
    while (controlChars !== null) {
      updateState(state, controlChars);
      controlChars = code.exec(line);
    }
    return state;
  };
  var unwindState = function(state, ret) {
    let lastBackgroundAdded = state.lastBackgroundAdded;
    let lastForegroundAdded = state.lastForegroundAdded;
    delete state.lastBackgroundAdded;
    delete state.lastForegroundAdded;
    Object.keys(state).forEach(function(key) {
      if (state[key]) {
        ret += codeCache[key].off;
      }
    });
    if (lastBackgroundAdded && lastBackgroundAdded != "\x1B[49m") {
      ret += "\x1B[49m";
    }
    if (lastForegroundAdded && lastForegroundAdded != "\x1B[39m") {
      ret += "\x1B[39m";
    }
    return ret;
  };
  var rewindState = function(state, ret) {
    let lastBackgroundAdded = state.lastBackgroundAdded;
    let lastForegroundAdded = state.lastForegroundAdded;
    delete state.lastBackgroundAdded;
    delete state.lastForegroundAdded;
    Object.keys(state).forEach(function(key) {
      if (state[key]) {
        ret = codeCache[key].on + ret;
      }
    });
    if (lastBackgroundAdded && lastBackgroundAdded != "\x1B[49m") {
      ret = lastBackgroundAdded + ret;
    }
    if (lastForegroundAdded && lastForegroundAdded != "\x1B[39m") {
      ret = lastForegroundAdded + ret;
    }
    return ret;
  };
  var truncateWidth = function(str, desiredLength) {
    if (str.length === strlen(str)) {
      return str.substr(0, desiredLength);
    }
    while (strlen(str) > desiredLength) {
      str = str.slice(0, -1);
    }
    return str;
  };
  var truncateWidthWithAnsi = function(str, desiredLength) {
    let code = codeRegex(true);
    let split = str.split(codeRegex());
    let splitIndex = 0;
    let retLen = 0;
    let ret = "";
    let myArray;
    let state = {};
    while (retLen < desiredLength) {
      myArray = code.exec(str);
      let toAdd = split[splitIndex];
      splitIndex++;
      if (retLen + strlen(toAdd) > desiredLength) {
        toAdd = truncateWidth(toAdd, desiredLength - retLen);
      }
      ret += toAdd;
      retLen += strlen(toAdd);
      if (retLen < desiredLength) {
        if (!myArray) {
          break;
        }
        ret += myArray[0];
        updateState(state, myArray);
      }
    }
    return unwindState(state, ret);
  };
  var truncate = function(str, desiredLength, truncateChar) {
    truncateChar = truncateChar || "\u2026";
    let lengthOfStr = strlen(str);
    if (lengthOfStr <= desiredLength) {
      return str;
    }
    desiredLength -= strlen(truncateChar);
    let ret = truncateWidthWithAnsi(str, desiredLength);
    return ret + truncateChar;
  };
  var defaultOptions2 = function() {
    return {
      chars: {
        top: "\u2500",
        "top-mid": "\u252C",
        "top-left": "\u250C",
        "top-right": "\u2510",
        bottom: "\u2500",
        "bottom-mid": "\u2534",
        "bottom-left": "\u2514",
        "bottom-right": "\u2518",
        left: "\u2502",
        "left-mid": "\u251C",
        mid: "\u2500",
        "mid-mid": "\u253C",
        right: "\u2502",
        "right-mid": "\u2524",
        middle: "\u2502"
      },
      truncate: "\u2026",
      colWidths: [],
      rowHeights: [],
      colAligns: [],
      rowAligns: [],
      style: {
        "padding-left": 1,
        "padding-right": 1,
        head: ["red"],
        border: ["grey"],
        compact: false
      },
      head: []
    };
  };
  var mergeOptions = function(options2, defaults) {
    options2 = options2 || {};
    defaults = defaults || defaultOptions2();
    let ret = Object.assign({}, defaults, options2);
    ret.chars = Object.assign({}, defaults.chars, options2.chars);
    ret.style = Object.assign({}, defaults.style, options2.style);
    return ret;
  };
  var wordWrap = function(maxLength, input) {
    let lines = [];
    let split = input.split(/(\s+)/g);
    let line = [];
    let lineLength = 0;
    let whitespace;
    for (let i2 = 0;i2 < split.length; i2 += 2) {
      let word = split[i2];
      let newLength = lineLength + strlen(word);
      if (lineLength > 0 && whitespace) {
        newLength += whitespace.length;
      }
      if (newLength > maxLength) {
        if (lineLength !== 0) {
          lines.push(line.join(""));
        }
        line = [word];
        lineLength = strlen(word);
      } else {
        line.push(whitespace || "", word);
        lineLength = newLength;
      }
      whitespace = split[i2 + 1];
    }
    if (lineLength) {
      lines.push(line.join(""));
    }
    return lines;
  };
  var textWrap = function(maxLength, input) {
    let lines = [];
    let line = "";
    function pushLine(str, ws) {
      if (line.length && ws)
        line += ws;
      line += str;
      while (line.length > maxLength) {
        lines.push(line.slice(0, maxLength));
        line = line.slice(maxLength);
      }
    }
    let split = input.split(/(\s+)/g);
    for (let i2 = 0;i2 < split.length; i2 += 2) {
      pushLine(split[i2], i2 && split[i2 - 1]);
    }
    if (line.length)
      lines.push(line);
    return lines;
  };
  var multiLineWordWrap = function(maxLength, input, wrapOnWordBoundary = true) {
    let output = [];
    input = input.split("\n");
    const handler = wrapOnWordBoundary ? wordWrap : textWrap;
    for (let i2 = 0;i2 < input.length; i2++) {
      output.push.apply(output, handler(maxLength, input[i2]));
    }
    return output;
  };
  var colorizeLines = function(input) {
    let state = {};
    let output = [];
    for (let i2 = 0;i2 < input.length; i2++) {
      let line = rewindState(state, input[i2]);
      state = readState(line);
      let temp = Object.assign({}, state);
      output.push(unwindState(temp, line));
    }
    return output;
  };
  var hyperlink = function(url, text) {
    const OSC = "\x1B]";
    const BEL = "\x07";
    const SEP = ";";
    return [OSC, "8", SEP, SEP, url || text, BEL, text, OSC, "8", SEP, SEP, BEL].join("");
  };
  var stringWidth = require_string_width();
  var codeCache = {};
  addToCodeCache("bold", 1, 22);
  addToCodeCache("italics", 3, 23);
  addToCodeCache("underline", 4, 24);
  addToCodeCache("inverse", 7, 27);
  addToCodeCache("strikethrough", 9, 29);
  module.exports = {
    strlen,
    repeat,
    pad,
    truncate,
    mergeOptions,
    wordWrap: multiLineWordWrap,
    colorizeLines,
    hyperlink
  };
});

// node_modules/@colors/colors/lib/styles.js
var require_styles = __commonJS((exports, module) => {
  var styles3 = {};
  module["exports"] = styles3;
  var codes = {
    reset: [0, 0],
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29],
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    gray: [90, 39],
    grey: [90, 39],
    brightRed: [91, 39],
    brightGreen: [92, 39],
    brightYellow: [93, 39],
    brightBlue: [94, 39],
    brightMagenta: [95, 39],
    brightCyan: [96, 39],
    brightWhite: [97, 39],
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    bgGray: [100, 49],
    bgGrey: [100, 49],
    bgBrightRed: [101, 49],
    bgBrightGreen: [102, 49],
    bgBrightYellow: [103, 49],
    bgBrightBlue: [104, 49],
    bgBrightMagenta: [105, 49],
    bgBrightCyan: [106, 49],
    bgBrightWhite: [107, 49],
    blackBG: [40, 49],
    redBG: [41, 49],
    greenBG: [42, 49],
    yellowBG: [43, 49],
    blueBG: [44, 49],
    magentaBG: [45, 49],
    cyanBG: [46, 49],
    whiteBG: [47, 49]
  };
  Object.keys(codes).forEach(function(key) {
    var val = codes[key];
    var style = styles3[key] = [];
    style.open = "\x1B[" + val[0] + "m";
    style.close = "\x1B[" + val[1] + "m";
  });
});

// node_modules/@colors/colors/lib/system/has-flag.js
var require_has_flag = __commonJS((exports, module) => {
  module.exports = function(flag, argv) {
    argv = argv || process.argv;
    var terminatorPos = argv.indexOf("--");
    var prefix = /^-{1,2}/.test(flag) ? "" : "--";
    var pos = argv.indexOf(prefix + flag);
    return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
  };
});

// node_modules/@colors/colors/lib/system/supports-colors.js
var require_supports_colors = __commonJS((exports, module) => {
  var translateLevel2 = function(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  };
  var supportsColor2 = function(stream) {
    if (forceColor === false) {
      return 0;
    }
    if (hasFlag2("color=16m") || hasFlag2("color=full") || hasFlag2("color=truecolor")) {
      return 3;
    }
    if (hasFlag2("color=256")) {
      return 2;
    }
    if (stream && !stream.isTTY && forceColor !== true) {
      return 0;
    }
    var min = forceColor ? 1 : 0;
    if (process.platform === "win32") {
      var osRelease = os2.release().split(".");
      if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env2) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some(function(sign) {
        return sign in env2;
      }) || env2.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env2) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
    }
    if ("TERM_PROGRAM" in env2) {
      var version2 = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env2.TERM_PROGRAM) {
        case "iTerm.app":
          return version2 >= 3 ? 3 : 2;
        case "Hyper":
          return 3;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env2.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env2) {
      return 1;
    }
    if (env2.TERM === "dumb") {
      return min;
    }
    return min;
  };
  var getSupportLevel = function(stream) {
    var level = supportsColor2(stream);
    return translateLevel2(level);
  };
  var os2 = __require("os");
  var hasFlag2 = require_has_flag();
  var env2 = process.env;
  var forceColor = undefined;
  if (hasFlag2("no-color") || hasFlag2("no-colors") || hasFlag2("color=false")) {
    forceColor = false;
  } else if (hasFlag2("color") || hasFlag2("colors") || hasFlag2("color=true") || hasFlag2("color=always")) {
    forceColor = true;
  }
  if ("FORCE_COLOR" in env2) {
    forceColor = env2.FORCE_COLOR.length === 0 || parseInt(env2.FORCE_COLOR, 10) !== 0;
  }
  module.exports = {
    supportsColor: getSupportLevel,
    stdout: getSupportLevel(process.stdout),
    stderr: getSupportLevel(process.stderr)
  };
});

// node_modules/@colors/colors/lib/custom/trap.js
var require_trap = __commonJS((exports, module) => {
  module["exports"] = function runTheTrap(text, options2) {
    var result = "";
    text = text || "Run the trap, drop the bass";
    text = text.split("");
    var trap = {
      a: ["@", "\u0104", "\u023A", "\u0245", "\u0394", "\u039B", "\u0414"],
      b: ["\xDF", "\u0181", "\u0243", "\u026E", "\u03B2", "\u0E3F"],
      c: ["\xA9", "\u023B", "\u03FE"],
      d: ["\xD0", "\u018A", "\u0500", "\u0501", "\u0502", "\u0503"],
      e: [
        "\xCB",
        "\u0115",
        "\u018E",
        "\u0258",
        "\u03A3",
        "\u03BE",
        "\u04BC",
        "\u0A6C"
      ],
      f: ["\u04FA"],
      g: ["\u0262"],
      h: ["\u0126", "\u0195", "\u04A2", "\u04BA", "\u04C7", "\u050A"],
      i: ["\u0F0F"],
      j: ["\u0134"],
      k: ["\u0138", "\u04A0", "\u04C3", "\u051E"],
      l: ["\u0139"],
      m: ["\u028D", "\u04CD", "\u04CE", "\u0520", "\u0521", "\u0D69"],
      n: ["\xD1", "\u014B", "\u019D", "\u0376", "\u03A0", "\u048A"],
      o: [
        "\xD8",
        "\xF5",
        "\xF8",
        "\u01FE",
        "\u0298",
        "\u047A",
        "\u05DD",
        "\u06DD",
        "\u0E4F"
      ],
      p: ["\u01F7", "\u048E"],
      q: ["\u09CD"],
      r: ["\xAE", "\u01A6", "\u0210", "\u024C", "\u0280", "\u042F"],
      s: ["\xA7", "\u03DE", "\u03DF", "\u03E8"],
      t: ["\u0141", "\u0166", "\u0373"],
      u: ["\u01B1", "\u054D"],
      v: ["\u05D8"],
      w: ["\u0428", "\u0460", "\u047C", "\u0D70"],
      x: ["\u04B2", "\u04FE", "\u04FC", "\u04FD"],
      y: ["\xA5", "\u04B0", "\u04CB"],
      z: ["\u01B5", "\u0240"]
    };
    text.forEach(function(c2) {
      c2 = c2.toLowerCase();
      var chars = trap[c2] || [" "];
      var rand = Math.floor(Math.random() * chars.length);
      if (typeof trap[c2] !== "undefined") {
        result += trap[c2][rand];
      } else {
        result += c2;
      }
    });
    return result;
  };
});

// node_modules/@colors/colors/lib/custom/zalgo.js
var require_zalgo = __commonJS((exports, module) => {
  module["exports"] = function zalgo(text, options2) {
    text = text || "   he is here   ";
    var soul = {
      up: [
        "\u030D",
        "\u030E",
        "\u0304",
        "\u0305",
        "\u033F",
        "\u0311",
        "\u0306",
        "\u0310",
        "\u0352",
        "\u0357",
        "\u0351",
        "\u0307",
        "\u0308",
        "\u030A",
        "\u0342",
        "\u0313",
        "\u0308",
        "\u034A",
        "\u034B",
        "\u034C",
        "\u0303",
        "\u0302",
        "\u030C",
        "\u0350",
        "\u0300",
        "\u0301",
        "\u030B",
        "\u030F",
        "\u0312",
        "\u0313",
        "\u0314",
        "\u033D",
        "\u0309",
        "\u0363",
        "\u0364",
        "\u0365",
        "\u0366",
        "\u0367",
        "\u0368",
        "\u0369",
        "\u036A",
        "\u036B",
        "\u036C",
        "\u036D",
        "\u036E",
        "\u036F",
        "\u033E",
        "\u035B",
        "\u0346",
        "\u031A"
      ],
      down: [
        "\u0316",
        "\u0317",
        "\u0318",
        "\u0319",
        "\u031C",
        "\u031D",
        "\u031E",
        "\u031F",
        "\u0320",
        "\u0324",
        "\u0325",
        "\u0326",
        "\u0329",
        "\u032A",
        "\u032B",
        "\u032C",
        "\u032D",
        "\u032E",
        "\u032F",
        "\u0330",
        "\u0331",
        "\u0332",
        "\u0333",
        "\u0339",
        "\u033A",
        "\u033B",
        "\u033C",
        "\u0345",
        "\u0347",
        "\u0348",
        "\u0349",
        "\u034D",
        "\u034E",
        "\u0353",
        "\u0354",
        "\u0355",
        "\u0356",
        "\u0359",
        "\u035A",
        "\u0323"
      ],
      mid: [
        "\u0315",
        "\u031B",
        "\u0300",
        "\u0301",
        "\u0358",
        "\u0321",
        "\u0322",
        "\u0327",
        "\u0328",
        "\u0334",
        "\u0335",
        "\u0336",
        "\u035C",
        "\u035D",
        "\u035E",
        "\u035F",
        "\u0360",
        "\u0362",
        "\u0338",
        "\u0337",
        "\u0361",
        " \u0489"
      ]
    };
    var all = [].concat(soul.up, soul.down, soul.mid);
    function randomNumber(range) {
      var r2 = Math.floor(Math.random() * range);
      return r2;
    }
    function isChar(character) {
      var bool = false;
      all.filter(function(i2) {
        bool = i2 === character;
      });
      return bool;
    }
    function heComes(text2, options3) {
      var result = "";
      var counts;
      var l2;
      options3 = options3 || {};
      options3["up"] = typeof options3["up"] !== "undefined" ? options3["up"] : true;
      options3["mid"] = typeof options3["mid"] !== "undefined" ? options3["mid"] : true;
      options3["down"] = typeof options3["down"] !== "undefined" ? options3["down"] : true;
      options3["size"] = typeof options3["size"] !== "undefined" ? options3["size"] : "maxi";
      text2 = text2.split("");
      for (l2 in text2) {
        if (isChar(l2)) {
          continue;
        }
        result = result + text2[l2];
        counts = { up: 0, down: 0, mid: 0 };
        switch (options3.size) {
          case "mini":
            counts.up = randomNumber(8);
            counts.mid = randomNumber(2);
            counts.down = randomNumber(8);
            break;
          case "maxi":
            counts.up = randomNumber(16) + 3;
            counts.mid = randomNumber(4) + 1;
            counts.down = randomNumber(64) + 3;
            break;
          default:
            counts.up = randomNumber(8) + 1;
            counts.mid = randomNumber(6) / 2;
            counts.down = randomNumber(8) + 1;
            break;
        }
        var arr = ["up", "mid", "down"];
        for (var d2 in arr) {
          var index = arr[d2];
          for (var i2 = 0;i2 <= counts[index]; i2++) {
            if (options3[index]) {
              result = result + soul[index][randomNumber(soul[index].length)];
            }
          }
        }
      }
      return result;
    }
    return heComes(text, options2);
  };
});

// node_modules/@colors/colors/lib/maps/america.js
var require_america = __commonJS((exports, module) => {
  module["exports"] = function(colors) {
    return function(letter, i2, exploded) {
      if (letter === " ")
        return letter;
      switch (i2 % 3) {
        case 0:
          return colors.red(letter);
        case 1:
          return colors.white(letter);
        case 2:
          return colors.blue(letter);
      }
    };
  };
});

// node_modules/@colors/colors/lib/maps/zebra.js
var require_zebra = __commonJS((exports, module) => {
  module["exports"] = function(colors) {
    return function(letter, i2, exploded) {
      return i2 % 2 === 0 ? letter : colors.inverse(letter);
    };
  };
});

// node_modules/@colors/colors/lib/maps/rainbow.js
var require_rainbow = __commonJS((exports, module) => {
  module["exports"] = function(colors) {
    var rainbowColors = ["red", "yellow", "green", "blue", "magenta"];
    return function(letter, i2, exploded) {
      if (letter === " ") {
        return letter;
      } else {
        return colors[rainbowColors[i2++ % rainbowColors.length]](letter);
      }
    };
  };
});

// node_modules/@colors/colors/lib/maps/random.js
var require_random = __commonJS((exports, module) => {
  module["exports"] = function(colors) {
    var available = [
      "underline",
      "inverse",
      "grey",
      "yellow",
      "red",
      "green",
      "blue",
      "white",
      "cyan",
      "magenta",
      "brightYellow",
      "brightRed",
      "brightGreen",
      "brightBlue",
      "brightWhite",
      "brightCyan",
      "brightMagenta"
    ];
    return function(letter, i2, exploded) {
      return letter === " " ? letter : colors[available[Math.round(Math.random() * (available.length - 2))]](letter);
    };
  };
});

// node_modules/@colors/colors/lib/colors.js
var require_colors = __commonJS((exports, module) => {
  var build = function(_styles) {
    var builder = function builder() {
      return applyStyle2.apply(builder, arguments);
    };
    builder._styles = _styles;
    builder.__proto__ = proto2;
    return builder;
  };
  var applyStyle2 = function() {
    var args = Array.prototype.slice.call(arguments);
    var str = args.map(function(arg) {
      if (arg != null && arg.constructor === String) {
        return arg;
      } else {
        return util.inspect(arg);
      }
    }).join(" ");
    if (!colors.enabled || !str) {
      return str;
    }
    var newLinesPresent = str.indexOf("\n") != -1;
    var nestedStyles = this._styles;
    var i2 = nestedStyles.length;
    while (i2--) {
      var code = ansiStyles2[nestedStyles[i2]];
      str = code.open + str.replace(code.closeRe, code.open) + code.close;
      if (newLinesPresent) {
        str = str.replace(newLineRegex, function(match) {
          return code.close + match + code.open;
        });
      }
    }
    return str;
  };
  var init = function() {
    var ret = {};
    Object.keys(styles3).forEach(function(name) {
      ret[name] = {
        get: function() {
          return build([name]);
        }
      };
    });
    return ret;
  };
  var colors = {};
  module["exports"] = colors;
  colors.themes = {};
  var util = __require("util");
  var ansiStyles2 = colors.styles = require_styles();
  var defineProps = Object.defineProperties;
  var newLineRegex = new RegExp(/[\r\n]+/g);
  colors.supportsColor = require_supports_colors().supportsColor;
  if (typeof colors.enabled === "undefined") {
    colors.enabled = colors.supportsColor() !== false;
  }
  colors.enable = function() {
    colors.enabled = true;
  };
  colors.disable = function() {
    colors.enabled = false;
  };
  colors.stripColors = colors.strip = function(str) {
    return ("" + str).replace(/\x1B\[\d+m/g, "");
  };
  var stylize = colors.stylize = function stylize(str, style) {
    if (!colors.enabled) {
      return str + "";
    }
    var styleMap = ansiStyles2[style];
    if (!styleMap && (style in colors)) {
      return colors[style](str);
    }
    return styleMap.open + str + styleMap.close;
  };
  var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
  var escapeStringRegexp = function(str) {
    if (typeof str !== "string") {
      throw new TypeError("Expected a string");
    }
    return str.replace(matchOperatorsRe, "\\$&");
  };
  var styles3 = function() {
    var ret = {};
    ansiStyles2.grey = ansiStyles2.gray;
    Object.keys(ansiStyles2).forEach(function(key) {
      ansiStyles2[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles2[key].close), "g");
      ret[key] = {
        get: function() {
          return build(this._styles.concat(key));
        }
      };
    });
    return ret;
  }();
  var proto2 = defineProps(function colors() {
  }, styles3);
  colors.setTheme = function(theme) {
    if (typeof theme === "string") {
      console.log("colors.setTheme now only accepts an object, not a string.  If you are trying to set a theme from a file, it is now your (the caller\'s) responsibility to require the file.  The old syntax looked like colors.setTheme(__dirname + \'/../themes/generic-logging.js\'); The new syntax looks like colors.setTheme(require(__dirname + \'/../themes/generic-logging.js\'));");
      return;
    }
    for (var style in theme) {
      (function(style2) {
        colors[style2] = function(str) {
          if (typeof theme[style2] === "object") {
            var out = str;
            for (var i2 in theme[style2]) {
              out = colors[theme[style2][i2]](out);
            }
            return out;
          }
          return colors[theme[style2]](str);
        };
      })(style);
    }
  };
  var sequencer = function sequencer(map2, str) {
    var exploded = str.split("");
    exploded = exploded.map(map2);
    return exploded.join("");
  };
  colors.trap = require_trap();
  colors.zalgo = require_zalgo();
  colors.maps = {};
  colors.maps.america = require_america()(colors);
  colors.maps.zebra = require_zebra()(colors);
  colors.maps.rainbow = require_rainbow()(colors);
  colors.maps.random = require_random()(colors);
  for (map in colors.maps) {
    (function(map2) {
      colors[map2] = function(str) {
        return sequencer(colors.maps[map2], str);
      };
    })(map);
  }
  var map;
  defineProps(colors, init());
});

// node_modules/@colors/colors/safe.js
var require_safe = __commonJS((exports, module) => {
  var colors = require_colors();
  module["exports"] = colors;
});

// node_modules/cli-table3/src/cell.js
var require_cell = __commonJS((exports, module) => {
  var firstDefined = function(...args) {
    return args.filter((v2) => v2 !== undefined && v2 !== null).shift();
  };
  var setOption = function(objA, objB, nameB, targetObj) {
    let nameA = nameB.split("-");
    if (nameA.length > 1) {
      nameA[1] = nameA[1].charAt(0).toUpperCase() + nameA[1].substr(1);
      nameA = nameA.join("");
      targetObj[nameA] = firstDefined(objA[nameA], objA[nameB], objB[nameA], objB[nameB]);
    } else {
      targetObj[nameB] = firstDefined(objA[nameB], objB[nameB]);
    }
  };
  var findDimension = function(dimensionTable, startingIndex, span) {
    let ret = dimensionTable[startingIndex];
    for (let i2 = 1;i2 < span; i2++) {
      ret += 1 + dimensionTable[startingIndex + i2];
    }
    return ret;
  };
  var sumPlusOne = function(a2, b2) {
    return a2 + b2 + 1;
  };
  var { info, debug: debug2 } = require_debug();
  var utils = require_utils2();

  class Cell {
    constructor(options2) {
      this.setOptions(options2);
      this.x = null;
      this.y = null;
    }
    setOptions(options2) {
      if (["boolean", "number", "string"].indexOf(typeof options2) !== -1) {
        options2 = { content: "" + options2 };
      }
      options2 = options2 || {};
      this.options = options2;
      let content = options2.content;
      if (["boolean", "number", "string"].indexOf(typeof content) !== -1) {
        this.content = String(content);
      } else if (!content) {
        this.content = this.options.href || "";
      } else {
        throw new Error("Content needs to be a primitive, got: " + typeof content);
      }
      this.colSpan = options2.colSpan || 1;
      this.rowSpan = options2.rowSpan || 1;
      if (this.options.href) {
        Object.defineProperty(this, "href", {
          get() {
            return this.options.href;
          }
        });
      }
    }
    mergeTableOptions(tableOptions, cells) {
      this.cells = cells;
      let optionsChars = this.options.chars || {};
      let tableChars = tableOptions.chars;
      let chars = this.chars = {};
      CHAR_NAMES.forEach(function(name) {
        setOption(optionsChars, tableChars, name, chars);
      });
      this.truncate = this.options.truncate || tableOptions.truncate;
      let style = this.options.style = this.options.style || {};
      let tableStyle = tableOptions.style;
      setOption(style, tableStyle, "padding-left", this);
      setOption(style, tableStyle, "padding-right", this);
      this.head = style.head || tableStyle.head;
      this.border = style.border || tableStyle.border;
      this.fixedWidth = tableOptions.colWidths[this.x];
      this.lines = this.computeLines(tableOptions);
      this.desiredWidth = utils.strlen(this.content) + this.paddingLeft + this.paddingRight;
      this.desiredHeight = this.lines.length;
    }
    computeLines(tableOptions) {
      const tableWordWrap = tableOptions.wordWrap || tableOptions.textWrap;
      const { wordWrap = tableWordWrap } = this.options;
      if (this.fixedWidth && wordWrap) {
        this.fixedWidth -= this.paddingLeft + this.paddingRight;
        if (this.colSpan) {
          let i2 = 1;
          while (i2 < this.colSpan) {
            this.fixedWidth += tableOptions.colWidths[this.x + i2];
            i2++;
          }
        }
        const { wrapOnWordBoundary: tableWrapOnWordBoundary = true } = tableOptions;
        const { wrapOnWordBoundary = tableWrapOnWordBoundary } = this.options;
        return this.wrapLines(utils.wordWrap(this.fixedWidth, this.content, wrapOnWordBoundary));
      }
      return this.wrapLines(this.content.split("\n"));
    }
    wrapLines(computedLines) {
      const lines = utils.colorizeLines(computedLines);
      if (this.href) {
        return lines.map((line) => utils.hyperlink(this.href, line));
      }
      return lines;
    }
    init(tableOptions) {
      let x2 = this.x;
      let y2 = this.y;
      this.widths = tableOptions.colWidths.slice(x2, x2 + this.colSpan);
      this.heights = tableOptions.rowHeights.slice(y2, y2 + this.rowSpan);
      this.width = this.widths.reduce(sumPlusOne, -1);
      this.height = this.heights.reduce(sumPlusOne, -1);
      this.hAlign = this.options.hAlign || tableOptions.colAligns[x2];
      this.vAlign = this.options.vAlign || tableOptions.rowAligns[y2];
      this.drawRight = x2 + this.colSpan == tableOptions.colWidths.length;
    }
    draw(lineNum, spanningCell) {
      if (lineNum == "top")
        return this.drawTop(this.drawRight);
      if (lineNum == "bottom")
        return this.drawBottom(this.drawRight);
      let content = utils.truncate(this.content, 10, this.truncate);
      if (!lineNum) {
        info(`${this.y}-${this.x}: ${this.rowSpan - lineNum}x${this.colSpan} Cell ${content}`);
      } else {
      }
      let padLen = Math.max(this.height - this.lines.length, 0);
      let padTop;
      switch (this.vAlign) {
        case "center":
          padTop = Math.ceil(padLen / 2);
          break;
        case "bottom":
          padTop = padLen;
          break;
        default:
          padTop = 0;
      }
      if (lineNum < padTop || lineNum >= padTop + this.lines.length) {
        return this.drawEmpty(this.drawRight, spanningCell);
      }
      let forceTruncation = this.lines.length > this.height && lineNum + 1 >= this.height;
      return this.drawLine(lineNum - padTop, this.drawRight, forceTruncation, spanningCell);
    }
    drawTop(drawRight) {
      let content = [];
      if (this.cells) {
        this.widths.forEach(function(width, index) {
          content.push(this._topLeftChar(index));
          content.push(utils.repeat(this.chars[this.y == 0 ? "top" : "mid"], width));
        }, this);
      } else {
        content.push(this._topLeftChar(0));
        content.push(utils.repeat(this.chars[this.y == 0 ? "top" : "mid"], this.width));
      }
      if (drawRight) {
        content.push(this.chars[this.y == 0 ? "topRight" : "rightMid"]);
      }
      return this.wrapWithStyleColors("border", content.join(""));
    }
    _topLeftChar(offset) {
      let x2 = this.x + offset;
      let leftChar;
      if (this.y == 0) {
        leftChar = x2 == 0 ? "topLeft" : offset == 0 ? "topMid" : "top";
      } else {
        if (x2 == 0) {
          leftChar = "leftMid";
        } else {
          leftChar = offset == 0 ? "midMid" : "bottomMid";
          if (this.cells) {
            let spanAbove = this.cells[this.y - 1][x2] instanceof Cell.ColSpanCell;
            if (spanAbove) {
              leftChar = offset == 0 ? "topMid" : "mid";
            }
            if (offset == 0) {
              let i2 = 1;
              while (this.cells[this.y][x2 - i2] instanceof Cell.ColSpanCell) {
                i2++;
              }
              if (this.cells[this.y][x2 - i2] instanceof Cell.RowSpanCell) {
                leftChar = "leftMid";
              }
            }
          }
        }
      }
      return this.chars[leftChar];
    }
    wrapWithStyleColors(styleProperty, content) {
      if (this[styleProperty] && this[styleProperty].length) {
        try {
          let colors = require_safe();
          for (let i2 = this[styleProperty].length - 1;i2 >= 0; i2--) {
            colors = colors[this[styleProperty][i2]];
          }
          return colors(content);
        } catch (e2) {
          return content;
        }
      } else {
        return content;
      }
    }
    drawLine(lineNum, drawRight, forceTruncationSymbol, spanningCell) {
      let left = this.chars[this.x == 0 ? "left" : "middle"];
      if (this.x && spanningCell && this.cells) {
        let cellLeft = this.cells[this.y + spanningCell][this.x - 1];
        while (cellLeft instanceof ColSpanCell) {
          cellLeft = this.cells[cellLeft.y][cellLeft.x - 1];
        }
        if (!(cellLeft instanceof RowSpanCell)) {
          left = this.chars["rightMid"];
        }
      }
      let leftPadding = utils.repeat(" ", this.paddingLeft);
      let right = drawRight ? this.chars["right"] : "";
      let rightPadding = utils.repeat(" ", this.paddingRight);
      let line = this.lines[lineNum];
      let len = this.width - (this.paddingLeft + this.paddingRight);
      if (forceTruncationSymbol)
        line += this.truncate || "\u2026";
      let content = utils.truncate(line, len, this.truncate);
      content = utils.pad(content, len, " ", this.hAlign);
      content = leftPadding + content + rightPadding;
      return this.stylizeLine(left, content, right);
    }
    stylizeLine(left, content, right) {
      left = this.wrapWithStyleColors("border", left);
      right = this.wrapWithStyleColors("border", right);
      if (this.y === 0) {
        content = this.wrapWithStyleColors("head", content);
      }
      return left + content + right;
    }
    drawBottom(drawRight) {
      let left = this.chars[this.x == 0 ? "bottomLeft" : "bottomMid"];
      let content = utils.repeat(this.chars.bottom, this.width);
      let right = drawRight ? this.chars["bottomRight"] : "";
      return this.wrapWithStyleColors("border", left + content + right);
    }
    drawEmpty(drawRight, spanningCell) {
      let left = this.chars[this.x == 0 ? "left" : "middle"];
      if (this.x && spanningCell && this.cells) {
        let cellLeft = this.cells[this.y + spanningCell][this.x - 1];
        while (cellLeft instanceof ColSpanCell) {
          cellLeft = this.cells[cellLeft.y][cellLeft.x - 1];
        }
        if (!(cellLeft instanceof RowSpanCell)) {
          left = this.chars["rightMid"];
        }
      }
      let right = drawRight ? this.chars["right"] : "";
      let content = utils.repeat(" ", this.width);
      return this.stylizeLine(left, content, right);
    }
  }

  class ColSpanCell {
    constructor() {
    }
    draw(lineNum) {
      if (typeof lineNum === "number") {
        debug2(`${this.y}-${this.x}: 1x1 ColSpanCell`);
      }
      return "";
    }
    init() {
    }
    mergeTableOptions() {
    }
  }

  class RowSpanCell {
    constructor(originalCell) {
      this.originalCell = originalCell;
    }
    init(tableOptions) {
      let y2 = this.y;
      let originalY = this.originalCell.y;
      this.cellOffset = y2 - originalY;
      this.offset = findDimension(tableOptions.rowHeights, originalY, this.cellOffset);
    }
    draw(lineNum) {
      if (lineNum == "top") {
        return this.originalCell.draw(this.offset, this.cellOffset);
      }
      if (lineNum == "bottom") {
        return this.originalCell.draw("bottom");
      }
      debug2(`${this.y}-${this.x}: 1x${this.colSpan} RowSpanCell for ${this.originalCell.content}`);
      return this.originalCell.draw(this.offset + 1 + lineNum);
    }
    mergeTableOptions() {
    }
  }
  var CHAR_NAMES = [
    "top",
    "top-mid",
    "top-left",
    "top-right",
    "bottom",
    "bottom-mid",
    "bottom-left",
    "bottom-right",
    "left",
    "left-mid",
    "mid",
    "mid-mid",
    "right",
    "right-mid",
    "middle"
  ];
  module.exports = Cell;
  module.exports.ColSpanCell = ColSpanCell;
  module.exports.RowSpanCell = RowSpanCell;
});

// node_modules/cli-table3/src/layout-manager.js
var require_layout_manager = __commonJS((exports, module) => {
  var makeComputeWidths = function(colSpan, desiredWidth, x2, forcedMin) {
    return function(vals, table) {
      let result = [];
      let spanners = [];
      let auto2 = {};
      table.forEach(function(row) {
        row.forEach(function(cell) {
          if ((cell[colSpan] || 1) > 1) {
            spanners.push(cell);
          } else {
            result[cell[x2]] = Math.max(result[cell[x2]] || 0, cell[desiredWidth] || 0, forcedMin);
          }
        });
      });
      vals.forEach(function(val, index) {
        if (typeof val === "number") {
          result[index] = val;
        }
      });
      for (let k2 = spanners.length - 1;k2 >= 0; k2--) {
        let cell = spanners[k2];
        let span = cell[colSpan];
        let col = cell[x2];
        let existingWidth = result[col];
        let editableCols = typeof vals[col] === "number" ? 0 : 1;
        if (typeof existingWidth === "number") {
          for (let i2 = 1;i2 < span; i2++) {
            existingWidth += 1 + result[col + i2];
            if (typeof vals[col + i2] !== "number") {
              editableCols++;
            }
          }
        } else {
          existingWidth = desiredWidth === "desiredWidth" ? cell.desiredWidth - 1 : 1;
          if (!auto2[col] || auto2[col] < existingWidth) {
            auto2[col] = existingWidth;
          }
        }
        if (cell[desiredWidth] > existingWidth) {
          let i2 = 0;
          while (editableCols > 0 && cell[desiredWidth] > existingWidth) {
            if (typeof vals[col + i2] !== "number") {
              let dif = Math.round((cell[desiredWidth] - existingWidth) / editableCols);
              existingWidth += dif;
              result[col + i2] += dif;
              editableCols--;
            }
            i2++;
          }
        }
      }
      Object.assign(vals, result, auto2);
      for (let j2 = 0;j2 < vals.length; j2++) {
        vals[j2] = Math.max(forcedMin, vals[j2] || 0);
      }
    };
  };
  var { warn, debug: debug2 } = require_debug();
  var Cell = require_cell();
  var { ColSpanCell, RowSpanCell } = Cell;
  (function() {
    function next(alloc, col) {
      if (alloc[col] > 0) {
        return next(alloc, col + 1);
      }
      return col;
    }
    function layoutTable(table) {
      let alloc = {};
      table.forEach(function(row, rowIndex) {
        let col = 0;
        row.forEach(function(cell) {
          cell.y = rowIndex;
          cell.x = rowIndex ? next(alloc, col) : col;
          const rowSpan = cell.rowSpan || 1;
          const colSpan = cell.colSpan || 1;
          if (rowSpan > 1) {
            for (let cs = 0;cs < colSpan; cs++) {
              alloc[cell.x + cs] = rowSpan;
            }
          }
          col = cell.x + colSpan;
        });
        Object.keys(alloc).forEach((idx) => {
          alloc[idx]--;
          if (alloc[idx] < 1)
            delete alloc[idx];
        });
      });
    }
    function maxWidth(table) {
      let mw = 0;
      table.forEach(function(row) {
        row.forEach(function(cell) {
          mw = Math.max(mw, cell.x + (cell.colSpan || 1));
        });
      });
      return mw;
    }
    function maxHeight(table) {
      return table.length;
    }
    function cellsConflict(cell1, cell2) {
      let yMin1 = cell1.y;
      let yMax1 = cell1.y - 1 + (cell1.rowSpan || 1);
      let yMin2 = cell2.y;
      let yMax2 = cell2.y - 1 + (cell2.rowSpan || 1);
      let yConflict = !(yMin1 > yMax2 || yMin2 > yMax1);
      let xMin1 = cell1.x;
      let xMax1 = cell1.x - 1 + (cell1.colSpan || 1);
      let xMin2 = cell2.x;
      let xMax2 = cell2.x - 1 + (cell2.colSpan || 1);
      let xConflict = !(xMin1 > xMax2 || xMin2 > xMax1);
      return yConflict && xConflict;
    }
    function conflictExists(rows, x2, y2) {
      let i_max = Math.min(rows.length - 1, y2);
      let cell = { x: x2, y: y2 };
      for (let i2 = 0;i2 <= i_max; i2++) {
        let row = rows[i2];
        for (let j2 = 0;j2 < row.length; j2++) {
          if (cellsConflict(cell, row[j2])) {
            return true;
          }
        }
      }
      return false;
    }
    function allBlank(rows, y2, xMin, xMax) {
      for (let x2 = xMin;x2 < xMax; x2++) {
        if (conflictExists(rows, x2, y2)) {
          return false;
        }
      }
      return true;
    }
    function addRowSpanCells(table) {
      table.forEach(function(row, rowIndex) {
        row.forEach(function(cell) {
          for (let i2 = 1;i2 < cell.rowSpan; i2++) {
            let rowSpanCell = new RowSpanCell(cell);
            rowSpanCell.x = cell.x;
            rowSpanCell.y = cell.y + i2;
            rowSpanCell.colSpan = cell.colSpan;
            insertCell(rowSpanCell, table[rowIndex + i2]);
          }
        });
      });
    }
    function addColSpanCells(cellRows) {
      for (let rowIndex = cellRows.length - 1;rowIndex >= 0; rowIndex--) {
        let cellColumns = cellRows[rowIndex];
        for (let columnIndex = 0;columnIndex < cellColumns.length; columnIndex++) {
          let cell = cellColumns[columnIndex];
          for (let k2 = 1;k2 < cell.colSpan; k2++) {
            let colSpanCell = new ColSpanCell;
            colSpanCell.x = cell.x + k2;
            colSpanCell.y = cell.y;
            cellColumns.splice(columnIndex + 1, 0, colSpanCell);
          }
        }
      }
    }
    function insertCell(cell, row) {
      let x2 = 0;
      while (x2 < row.length && row[x2].x < cell.x) {
        x2++;
      }
      row.splice(x2, 0, cell);
    }
    function fillInTable(table) {
      let h_max = maxHeight(table);
      let w_max = maxWidth(table);
      debug2(`Max rows: ${h_max}; Max cols: ${w_max}`);
      for (let y2 = 0;y2 < h_max; y2++) {
        for (let x2 = 0;x2 < w_max; x2++) {
          if (!conflictExists(table, x2, y2)) {
            let opts = { x: x2, y: y2, colSpan: 1, rowSpan: 1 };
            x2++;
            while (x2 < w_max && !conflictExists(table, x2, y2)) {
              opts.colSpan++;
              x2++;
            }
            let y22 = y2 + 1;
            while (y22 < h_max && allBlank(table, y22, opts.x, opts.x + opts.colSpan)) {
              opts.rowSpan++;
              y22++;
            }
            let cell = new Cell(opts);
            cell.x = opts.x;
            cell.y = opts.y;
            warn(`Missing cell at ${cell.y}-${cell.x}.`);
            insertCell(cell, table[y2]);
          }
        }
      }
    }
    function generateCells(rows) {
      return rows.map(function(row) {
        if (!Array.isArray(row)) {
          let key = Object.keys(row)[0];
          row = row[key];
          if (Array.isArray(row)) {
            row = row.slice();
            row.unshift(key);
          } else {
            row = [key, row];
          }
        }
        return row.map(function(cell) {
          return new Cell(cell);
        });
      });
    }
    function makeTableLayout(rows) {
      let cellRows = generateCells(rows);
      layoutTable(cellRows);
      fillInTable(cellRows);
      addRowSpanCells(cellRows);
      addColSpanCells(cellRows);
      return cellRows;
    }
    module.exports = {
      makeTableLayout,
      layoutTable,
      addRowSpanCells,
      maxWidth,
      fillInTable,
      computeWidths: makeComputeWidths("colSpan", "desiredWidth", "x", 1),
      computeHeights: makeComputeWidths("rowSpan", "desiredHeight", "y", 1)
    };
  })();
});

// node_modules/cli-table3/src/table.js
var require_table = __commonJS((exports, module) => {
  var doDraw = function(row, lineNum, result) {
    let line = [];
    row.forEach(function(cell) {
      line.push(cell.draw(lineNum));
    });
    let str = line.join("");
    if (str.length)
      result.push(str);
  };
  var debug2 = require_debug();
  var utils = require_utils2();
  var tableLayout = require_layout_manager();

  class Table extends Array {
    constructor(opts) {
      super();
      const options2 = utils.mergeOptions(opts);
      Object.defineProperty(this, "options", {
        value: options2,
        enumerable: options2.debug
      });
      if (options2.debug) {
        switch (typeof options2.debug) {
          case "boolean":
            debug2.setDebugLevel(debug2.WARN);
            break;
          case "number":
            debug2.setDebugLevel(options2.debug);
            break;
          case "string":
            debug2.setDebugLevel(parseInt(options2.debug, 10));
            break;
          default:
            debug2.setDebugLevel(debug2.WARN);
            debug2.warn(`Debug option is expected to be boolean, number, or string. Received a ${typeof options2.debug}`);
        }
        Object.defineProperty(this, "messages", {
          get() {
            return debug2.debugMessages();
          }
        });
      }
    }
    toString() {
      let array = this;
      let headersPresent = this.options.head && this.options.head.length;
      if (headersPresent) {
        array = [this.options.head];
        if (this.length) {
          array.push.apply(array, this);
        }
      } else {
        this.options.style.head = [];
      }
      let cells = tableLayout.makeTableLayout(array);
      cells.forEach(function(row) {
        row.forEach(function(cell) {
          cell.mergeTableOptions(this.options, cells);
        }, this);
      }, this);
      tableLayout.computeWidths(this.options.colWidths, cells);
      tableLayout.computeHeights(this.options.rowHeights, cells);
      cells.forEach(function(row) {
        row.forEach(function(cell) {
          cell.init(this.options);
        }, this);
      }, this);
      let result = [];
      for (let rowIndex = 0;rowIndex < cells.length; rowIndex++) {
        let row = cells[rowIndex];
        let heightOfRow = this.options.rowHeights[rowIndex];
        if (rowIndex === 0 || !this.options.style.compact || rowIndex == 1 && headersPresent) {
          doDraw(row, "top", result);
        }
        for (let lineNum = 0;lineNum < heightOfRow; lineNum++) {
          doDraw(row, lineNum, result);
        }
        if (rowIndex + 1 == cells.length) {
          doDraw(row, "bottom", result);
        }
      }
      return result.join("\n");
    }
    get width() {
      let str = this.toString().split("\n");
      return str[0].length;
    }
  }
  Table.reset = () => debug2.reset();
  module.exports = Table;
});

// node_modules/esprima/dist/esprima.js
var require_esprima = __commonJS((exports, module) => {
  (function webpackUniversalModuleDefinition(root, factory) {
    if (typeof exports === "object" && typeof module === "object")
      module.exports = factory();
    else if (typeof define === "function" && define.amd)
      define([], factory);
    else if (typeof exports === "object")
      exports["esprima"] = factory();
    else
      root["esprima"] = factory();
  })(exports, function() {
    return function(modules) {
      var installedModules = {};
      function __webpack_require__(moduleId) {
        if (installedModules[moduleId])
          return installedModules[moduleId].exports;
        var module2 = installedModules[moduleId] = {
          exports: {},
          id: moduleId,
          loaded: false
        };
        modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
        module2.loaded = true;
        return module2.exports;
      }
      __webpack_require__.m = modules;
      __webpack_require__.c = installedModules;
      __webpack_require__.p = "";
      return __webpack_require__(0);
    }([
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var comment_handler_1 = __webpack_require__(1);
        var jsx_parser_1 = __webpack_require__(3);
        var parser_1 = __webpack_require__(8);
        var tokenizer_1 = __webpack_require__(15);
        function parse(code, options2, delegate) {
          var commentHandler = null;
          var proxyDelegate = function(node, metadata) {
            if (delegate) {
              delegate(node, metadata);
            }
            if (commentHandler) {
              commentHandler.visit(node, metadata);
            }
          };
          var parserDelegate = typeof delegate === "function" ? proxyDelegate : null;
          var collectComment = false;
          if (options2) {
            collectComment = typeof options2.comment === "boolean" && options2.comment;
            var attachComment = typeof options2.attachComment === "boolean" && options2.attachComment;
            if (collectComment || attachComment) {
              commentHandler = new comment_handler_1.CommentHandler;
              commentHandler.attach = attachComment;
              options2.comment = true;
              parserDelegate = proxyDelegate;
            }
          }
          var isModule = false;
          if (options2 && typeof options2.sourceType === "string") {
            isModule = options2.sourceType === "module";
          }
          var parser2;
          if (options2 && typeof options2.jsx === "boolean" && options2.jsx) {
            parser2 = new jsx_parser_1.JSXParser(code, options2, parserDelegate);
          } else {
            parser2 = new parser_1.Parser(code, options2, parserDelegate);
          }
          var program2 = isModule ? parser2.parseModule() : parser2.parseScript();
          var ast = program2;
          if (collectComment && commentHandler) {
            ast.comments = commentHandler.comments;
          }
          if (parser2.config.tokens) {
            ast.tokens = parser2.tokens;
          }
          if (parser2.config.tolerant) {
            ast.errors = parser2.errorHandler.errors;
          }
          return ast;
        }
        exports2.parse = parse;
        function parseModule(code, options2, delegate) {
          var parsingOptions = options2 || {};
          parsingOptions.sourceType = "module";
          return parse(code, parsingOptions, delegate);
        }
        exports2.parseModule = parseModule;
        function parseScript(code, options2, delegate) {
          var parsingOptions = options2 || {};
          parsingOptions.sourceType = "script";
          return parse(code, parsingOptions, delegate);
        }
        exports2.parseScript = parseScript;
        function tokenize(code, options2, delegate) {
          var tokenizer = new tokenizer_1.Tokenizer(code, options2);
          var tokens;
          tokens = [];
          try {
            while (true) {
              var token = tokenizer.getNextToken();
              if (!token) {
                break;
              }
              if (delegate) {
                token = delegate(token);
              }
              tokens.push(token);
            }
          } catch (e2) {
            tokenizer.errorHandler.tolerate(e2);
          }
          if (tokenizer.errorHandler.tolerant) {
            tokens.errors = tokenizer.errors();
          }
          return tokens;
        }
        exports2.tokenize = tokenize;
        var syntax_1 = __webpack_require__(2);
        exports2.Syntax = syntax_1.Syntax;
        exports2.version = "4.0.1";
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var syntax_1 = __webpack_require__(2);
        var CommentHandler = function() {
          function CommentHandler2() {
            this.attach = false;
            this.comments = [];
            this.stack = [];
            this.leading = [];
            this.trailing = [];
          }
          CommentHandler2.prototype.insertInnerComments = function(node, metadata) {
            if (node.type === syntax_1.Syntax.BlockStatement && node.body.length === 0) {
              var innerComments = [];
              for (var i2 = this.leading.length - 1;i2 >= 0; --i2) {
                var entry = this.leading[i2];
                if (metadata.end.offset >= entry.start) {
                  innerComments.unshift(entry.comment);
                  this.leading.splice(i2, 1);
                  this.trailing.splice(i2, 1);
                }
              }
              if (innerComments.length) {
                node.innerComments = innerComments;
              }
            }
          };
          CommentHandler2.prototype.findTrailingComments = function(metadata) {
            var trailingComments = [];
            if (this.trailing.length > 0) {
              for (var i2 = this.trailing.length - 1;i2 >= 0; --i2) {
                var entry_1 = this.trailing[i2];
                if (entry_1.start >= metadata.end.offset) {
                  trailingComments.unshift(entry_1.comment);
                }
              }
              this.trailing.length = 0;
              return trailingComments;
            }
            var entry = this.stack[this.stack.length - 1];
            if (entry && entry.node.trailingComments) {
              var firstComment = entry.node.trailingComments[0];
              if (firstComment && firstComment.range[0] >= metadata.end.offset) {
                trailingComments = entry.node.trailingComments;
                delete entry.node.trailingComments;
              }
            }
            return trailingComments;
          };
          CommentHandler2.prototype.findLeadingComments = function(metadata) {
            var leadingComments = [];
            var target;
            while (this.stack.length > 0) {
              var entry = this.stack[this.stack.length - 1];
              if (entry && entry.start >= metadata.start.offset) {
                target = entry.node;
                this.stack.pop();
              } else {
                break;
              }
            }
            if (target) {
              var count = target.leadingComments ? target.leadingComments.length : 0;
              for (var i2 = count - 1;i2 >= 0; --i2) {
                var comment = target.leadingComments[i2];
                if (comment.range[1] <= metadata.start.offset) {
                  leadingComments.unshift(comment);
                  target.leadingComments.splice(i2, 1);
                }
              }
              if (target.leadingComments && target.leadingComments.length === 0) {
                delete target.leadingComments;
              }
              return leadingComments;
            }
            for (var i2 = this.leading.length - 1;i2 >= 0; --i2) {
              var entry = this.leading[i2];
              if (entry.start <= metadata.start.offset) {
                leadingComments.unshift(entry.comment);
                this.leading.splice(i2, 1);
              }
            }
            return leadingComments;
          };
          CommentHandler2.prototype.visitNode = function(node, metadata) {
            if (node.type === syntax_1.Syntax.Program && node.body.length > 0) {
              return;
            }
            this.insertInnerComments(node, metadata);
            var trailingComments = this.findTrailingComments(metadata);
            var leadingComments = this.findLeadingComments(metadata);
            if (leadingComments.length > 0) {
              node.leadingComments = leadingComments;
            }
            if (trailingComments.length > 0) {
              node.trailingComments = trailingComments;
            }
            this.stack.push({
              node,
              start: metadata.start.offset
            });
          };
          CommentHandler2.prototype.visitComment = function(node, metadata) {
            var type = node.type[0] === "L" ? "Line" : "Block";
            var comment = {
              type,
              value: node.value
            };
            if (node.range) {
              comment.range = node.range;
            }
            if (node.loc) {
              comment.loc = node.loc;
            }
            this.comments.push(comment);
            if (this.attach) {
              var entry = {
                comment: {
                  type,
                  value: node.value,
                  range: [metadata.start.offset, metadata.end.offset]
                },
                start: metadata.start.offset
              };
              if (node.loc) {
                entry.comment.loc = node.loc;
              }
              node.type = type;
              this.leading.push(entry);
              this.trailing.push(entry);
            }
          };
          CommentHandler2.prototype.visit = function(node, metadata) {
            if (node.type === "LineComment") {
              this.visitComment(node, metadata);
            } else if (node.type === "BlockComment") {
              this.visitComment(node, metadata);
            } else if (this.attach) {
              this.visitNode(node, metadata);
            }
          };
          return CommentHandler2;
        }();
        exports2.CommentHandler = CommentHandler;
      },
      function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.Syntax = {
          AssignmentExpression: "AssignmentExpression",
          AssignmentPattern: "AssignmentPattern",
          ArrayExpression: "ArrayExpression",
          ArrayPattern: "ArrayPattern",
          ArrowFunctionExpression: "ArrowFunctionExpression",
          AwaitExpression: "AwaitExpression",
          BlockStatement: "BlockStatement",
          BinaryExpression: "BinaryExpression",
          BreakStatement: "BreakStatement",
          CallExpression: "CallExpression",
          CatchClause: "CatchClause",
          ClassBody: "ClassBody",
          ClassDeclaration: "ClassDeclaration",
          ClassExpression: "ClassExpression",
          ConditionalExpression: "ConditionalExpression",
          ContinueStatement: "ContinueStatement",
          DoWhileStatement: "DoWhileStatement",
          DebuggerStatement: "DebuggerStatement",
          EmptyStatement: "EmptyStatement",
          ExportAllDeclaration: "ExportAllDeclaration",
          ExportDefaultDeclaration: "ExportDefaultDeclaration",
          ExportNamedDeclaration: "ExportNamedDeclaration",
          ExportSpecifier: "ExportSpecifier",
          ExpressionStatement: "ExpressionStatement",
          ForStatement: "ForStatement",
          ForOfStatement: "ForOfStatement",
          ForInStatement: "ForInStatement",
          FunctionDeclaration: "FunctionDeclaration",
          FunctionExpression: "FunctionExpression",
          Identifier: "Identifier",
          IfStatement: "IfStatement",
          ImportDeclaration: "ImportDeclaration",
          ImportDefaultSpecifier: "ImportDefaultSpecifier",
          ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
          ImportSpecifier: "ImportSpecifier",
          Literal: "Literal",
          LabeledStatement: "LabeledStatement",
          LogicalExpression: "LogicalExpression",
          MemberExpression: "MemberExpression",
          MetaProperty: "MetaProperty",
          MethodDefinition: "MethodDefinition",
          NewExpression: "NewExpression",
          ObjectExpression: "ObjectExpression",
          ObjectPattern: "ObjectPattern",
          Program: "Program",
          Property: "Property",
          RestElement: "RestElement",
          ReturnStatement: "ReturnStatement",
          SequenceExpression: "SequenceExpression",
          SpreadElement: "SpreadElement",
          Super: "Super",
          SwitchCase: "SwitchCase",
          SwitchStatement: "SwitchStatement",
          TaggedTemplateExpression: "TaggedTemplateExpression",
          TemplateElement: "TemplateElement",
          TemplateLiteral: "TemplateLiteral",
          ThisExpression: "ThisExpression",
          ThrowStatement: "ThrowStatement",
          TryStatement: "TryStatement",
          UnaryExpression: "UnaryExpression",
          UpdateExpression: "UpdateExpression",
          VariableDeclaration: "VariableDeclaration",
          VariableDeclarator: "VariableDeclarator",
          WhileStatement: "WhileStatement",
          WithStatement: "WithStatement",
          YieldExpression: "YieldExpression"
        };
      },
      function(module2, exports2, __webpack_require__) {
        var __extends = this && this.__extends || function() {
          var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p2 in b2)
              if (b2.hasOwnProperty(p2))
                d2[p2] = b2[p2];
          };
          return function(d2, b2) {
            extendStatics(d2, b2);
            function __() {
              this.constructor = d2;
            }
            d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
          };
        }();
        Object.defineProperty(exports2, "__esModule", { value: true });
        var character_1 = __webpack_require__(4);
        var JSXNode = __webpack_require__(5);
        var jsx_syntax_1 = __webpack_require__(6);
        var Node = __webpack_require__(7);
        var parser_1 = __webpack_require__(8);
        var token_1 = __webpack_require__(13);
        var xhtml_entities_1 = __webpack_require__(14);
        token_1.TokenName[100] = "JSXIdentifier";
        token_1.TokenName[101] = "JSXText";
        function getQualifiedElementName(elementName) {
          var qualifiedName;
          switch (elementName.type) {
            case jsx_syntax_1.JSXSyntax.JSXIdentifier:
              var id = elementName;
              qualifiedName = id.name;
              break;
            case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
              var ns = elementName;
              qualifiedName = getQualifiedElementName(ns.namespace) + ":" + getQualifiedElementName(ns.name);
              break;
            case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
              var expr = elementName;
              qualifiedName = getQualifiedElementName(expr.object) + "." + getQualifiedElementName(expr.property);
              break;
            default:
              break;
          }
          return qualifiedName;
        }
        var JSXParser = function(_super) {
          __extends(JSXParser2, _super);
          function JSXParser2(code, options2, delegate) {
            return _super.call(this, code, options2, delegate) || this;
          }
          JSXParser2.prototype.parsePrimaryExpression = function() {
            return this.match("<") ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
          };
          JSXParser2.prototype.startJSX = function() {
            this.scanner.index = this.startMarker.index;
            this.scanner.lineNumber = this.startMarker.line;
            this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
          };
          JSXParser2.prototype.finishJSX = function() {
            this.nextToken();
          };
          JSXParser2.prototype.reenterJSX = function() {
            this.startJSX();
            this.expectJSX("}");
            if (this.config.tokens) {
              this.tokens.pop();
            }
          };
          JSXParser2.prototype.createJSXNode = function() {
            this.collectComments();
            return {
              index: this.scanner.index,
              line: this.scanner.lineNumber,
              column: this.scanner.index - this.scanner.lineStart
            };
          };
          JSXParser2.prototype.createJSXChildNode = function() {
            return {
              index: this.scanner.index,
              line: this.scanner.lineNumber,
              column: this.scanner.index - this.scanner.lineStart
            };
          };
          JSXParser2.prototype.scanXHTMLEntity = function(quote) {
            var result = "&";
            var valid = true;
            var terminated = false;
            var numeric = false;
            var hex = false;
            while (!this.scanner.eof() && valid && !terminated) {
              var ch = this.scanner.source[this.scanner.index];
              if (ch === quote) {
                break;
              }
              terminated = ch === ";";
              result += ch;
              ++this.scanner.index;
              if (!terminated) {
                switch (result.length) {
                  case 2:
                    numeric = ch === "#";
                    break;
                  case 3:
                    if (numeric) {
                      hex = ch === "x";
                      valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));
                      numeric = numeric && !hex;
                    }
                    break;
                  default:
                    valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));
                    valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
                    break;
                }
              }
            }
            if (valid && terminated && result.length > 2) {
              var str = result.substr(1, result.length - 2);
              if (numeric && str.length > 1) {
                result = String.fromCharCode(parseInt(str.substr(1), 10));
              } else if (hex && str.length > 2) {
                result = String.fromCharCode(parseInt("0" + str.substr(1), 16));
              } else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str]) {
                result = xhtml_entities_1.XHTMLEntities[str];
              }
            }
            return result;
          };
          JSXParser2.prototype.lexJSX = function() {
            var cp = this.scanner.source.charCodeAt(this.scanner.index);
            if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
              var value = this.scanner.source[this.scanner.index++];
              return {
                type: 7,
                value,
                lineNumber: this.scanner.lineNumber,
                lineStart: this.scanner.lineStart,
                start: this.scanner.index - 1,
                end: this.scanner.index
              };
            }
            if (cp === 34 || cp === 39) {
              var start = this.scanner.index;
              var quote = this.scanner.source[this.scanner.index++];
              var str = "";
              while (!this.scanner.eof()) {
                var ch = this.scanner.source[this.scanner.index++];
                if (ch === quote) {
                  break;
                } else if (ch === "&") {
                  str += this.scanXHTMLEntity(quote);
                } else {
                  str += ch;
                }
              }
              return {
                type: 8,
                value: str,
                lineNumber: this.scanner.lineNumber,
                lineStart: this.scanner.lineStart,
                start,
                end: this.scanner.index
              };
            }
            if (cp === 46) {
              var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);
              var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
              var value = n1 === 46 && n2 === 46 ? "..." : ".";
              var start = this.scanner.index;
              this.scanner.index += value.length;
              return {
                type: 7,
                value,
                lineNumber: this.scanner.lineNumber,
                lineStart: this.scanner.lineStart,
                start,
                end: this.scanner.index
              };
            }
            if (cp === 96) {
              return {
                type: 10,
                value: "",
                lineNumber: this.scanner.lineNumber,
                lineStart: this.scanner.lineStart,
                start: this.scanner.index,
                end: this.scanner.index
              };
            }
            if (character_1.Character.isIdentifierStart(cp) && cp !== 92) {
              var start = this.scanner.index;
              ++this.scanner.index;
              while (!this.scanner.eof()) {
                var ch = this.scanner.source.charCodeAt(this.scanner.index);
                if (character_1.Character.isIdentifierPart(ch) && ch !== 92) {
                  ++this.scanner.index;
                } else if (ch === 45) {
                  ++this.scanner.index;
                } else {
                  break;
                }
              }
              var id = this.scanner.source.slice(start, this.scanner.index);
              return {
                type: 100,
                value: id,
                lineNumber: this.scanner.lineNumber,
                lineStart: this.scanner.lineStart,
                start,
                end: this.scanner.index
              };
            }
            return this.scanner.lex();
          };
          JSXParser2.prototype.nextJSXToken = function() {
            this.collectComments();
            this.startMarker.index = this.scanner.index;
            this.startMarker.line = this.scanner.lineNumber;
            this.startMarker.column = this.scanner.index - this.scanner.lineStart;
            var token = this.lexJSX();
            this.lastMarker.index = this.scanner.index;
            this.lastMarker.line = this.scanner.lineNumber;
            this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
            if (this.config.tokens) {
              this.tokens.push(this.convertToken(token));
            }
            return token;
          };
          JSXParser2.prototype.nextJSXText = function() {
            this.startMarker.index = this.scanner.index;
            this.startMarker.line = this.scanner.lineNumber;
            this.startMarker.column = this.scanner.index - this.scanner.lineStart;
            var start = this.scanner.index;
            var text = "";
            while (!this.scanner.eof()) {
              var ch = this.scanner.source[this.scanner.index];
              if (ch === "{" || ch === "<") {
                break;
              }
              ++this.scanner.index;
              text += ch;
              if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                ++this.scanner.lineNumber;
                if (ch === "\r" && this.scanner.source[this.scanner.index] === "\n") {
                  ++this.scanner.index;
                }
                this.scanner.lineStart = this.scanner.index;
              }
            }
            this.lastMarker.index = this.scanner.index;
            this.lastMarker.line = this.scanner.lineNumber;
            this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
            var token = {
              type: 101,
              value: text,
              lineNumber: this.scanner.lineNumber,
              lineStart: this.scanner.lineStart,
              start,
              end: this.scanner.index
            };
            if (text.length > 0 && this.config.tokens) {
              this.tokens.push(this.convertToken(token));
            }
            return token;
          };
          JSXParser2.prototype.peekJSXToken = function() {
            var state = this.scanner.saveState();
            this.scanner.scanComments();
            var next = this.lexJSX();
            this.scanner.restoreState(state);
            return next;
          };
          JSXParser2.prototype.expectJSX = function(value) {
            var token = this.nextJSXToken();
            if (token.type !== 7 || token.value !== value) {
              this.throwUnexpectedToken(token);
            }
          };
          JSXParser2.prototype.matchJSX = function(value) {
            var next = this.peekJSXToken();
            return next.type === 7 && next.value === value;
          };
          JSXParser2.prototype.parseJSXIdentifier = function() {
            var node = this.createJSXNode();
            var token = this.nextJSXToken();
            if (token.type !== 100) {
              this.throwUnexpectedToken(token);
            }
            return this.finalize(node, new JSXNode.JSXIdentifier(token.value));
          };
          JSXParser2.prototype.parseJSXElementName = function() {
            var node = this.createJSXNode();
            var elementName = this.parseJSXIdentifier();
            if (this.matchJSX(":")) {
              var namespace = elementName;
              this.expectJSX(":");
              var name_1 = this.parseJSXIdentifier();
              elementName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_1));
            } else if (this.matchJSX(".")) {
              while (this.matchJSX(".")) {
                var object = elementName;
                this.expectJSX(".");
                var property = this.parseJSXIdentifier();
                elementName = this.finalize(node, new JSXNode.JSXMemberExpression(object, property));
              }
            }
            return elementName;
          };
          JSXParser2.prototype.parseJSXAttributeName = function() {
            var node = this.createJSXNode();
            var attributeName;
            var identifier = this.parseJSXIdentifier();
            if (this.matchJSX(":")) {
              var namespace = identifier;
              this.expectJSX(":");
              var name_2 = this.parseJSXIdentifier();
              attributeName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_2));
            } else {
              attributeName = identifier;
            }
            return attributeName;
          };
          JSXParser2.prototype.parseJSXStringLiteralAttribute = function() {
            var node = this.createJSXNode();
            var token = this.nextJSXToken();
            if (token.type !== 8) {
              this.throwUnexpectedToken(token);
            }
            var raw = this.getTokenRaw(token);
            return this.finalize(node, new Node.Literal(token.value, raw));
          };
          JSXParser2.prototype.parseJSXExpressionAttribute = function() {
            var node = this.createJSXNode();
            this.expectJSX("{");
            this.finishJSX();
            if (this.match("}")) {
              this.tolerateError("JSX attributes must only be assigned a non-empty expression");
            }
            var expression = this.parseAssignmentExpression();
            this.reenterJSX();
            return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
          };
          JSXParser2.prototype.parseJSXAttributeValue = function() {
            return this.matchJSX("{") ? this.parseJSXExpressionAttribute() : this.matchJSX("<") ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
          };
          JSXParser2.prototype.parseJSXNameValueAttribute = function() {
            var node = this.createJSXNode();
            var name = this.parseJSXAttributeName();
            var value = null;
            if (this.matchJSX("=")) {
              this.expectJSX("=");
              value = this.parseJSXAttributeValue();
            }
            return this.finalize(node, new JSXNode.JSXAttribute(name, value));
          };
          JSXParser2.prototype.parseJSXSpreadAttribute = function() {
            var node = this.createJSXNode();
            this.expectJSX("{");
            this.expectJSX("...");
            this.finishJSX();
            var argument = this.parseAssignmentExpression();
            this.reenterJSX();
            return this.finalize(node, new JSXNode.JSXSpreadAttribute(argument));
          };
          JSXParser2.prototype.parseJSXAttributes = function() {
            var attributes = [];
            while (!this.matchJSX("/") && !this.matchJSX(">")) {
              var attribute = this.matchJSX("{") ? this.parseJSXSpreadAttribute() : this.parseJSXNameValueAttribute();
              attributes.push(attribute);
            }
            return attributes;
          };
          JSXParser2.prototype.parseJSXOpeningElement = function() {
            var node = this.createJSXNode();
            this.expectJSX("<");
            var name = this.parseJSXElementName();
            var attributes = this.parseJSXAttributes();
            var selfClosing = this.matchJSX("/");
            if (selfClosing) {
              this.expectJSX("/");
            }
            this.expectJSX(">");
            return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
          };
          JSXParser2.prototype.parseJSXBoundaryElement = function() {
            var node = this.createJSXNode();
            this.expectJSX("<");
            if (this.matchJSX("/")) {
              this.expectJSX("/");
              var name_3 = this.parseJSXElementName();
              this.expectJSX(">");
              return this.finalize(node, new JSXNode.JSXClosingElement(name_3));
            }
            var name = this.parseJSXElementName();
            var attributes = this.parseJSXAttributes();
            var selfClosing = this.matchJSX("/");
            if (selfClosing) {
              this.expectJSX("/");
            }
            this.expectJSX(">");
            return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
          };
          JSXParser2.prototype.parseJSXEmptyExpression = function() {
            var node = this.createJSXChildNode();
            this.collectComments();
            this.lastMarker.index = this.scanner.index;
            this.lastMarker.line = this.scanner.lineNumber;
            this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
            return this.finalize(node, new JSXNode.JSXEmptyExpression);
          };
          JSXParser2.prototype.parseJSXExpressionContainer = function() {
            var node = this.createJSXNode();
            this.expectJSX("{");
            var expression;
            if (this.matchJSX("}")) {
              expression = this.parseJSXEmptyExpression();
              this.expectJSX("}");
            } else {
              this.finishJSX();
              expression = this.parseAssignmentExpression();
              this.reenterJSX();
            }
            return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
          };
          JSXParser2.prototype.parseJSXChildren = function() {
            var children = [];
            while (!this.scanner.eof()) {
              var node = this.createJSXChildNode();
              var token = this.nextJSXText();
              if (token.start < token.end) {
                var raw = this.getTokenRaw(token);
                var child = this.finalize(node, new JSXNode.JSXText(token.value, raw));
                children.push(child);
              }
              if (this.scanner.source[this.scanner.index] === "{") {
                var container = this.parseJSXExpressionContainer();
                children.push(container);
              } else {
                break;
              }
            }
            return children;
          };
          JSXParser2.prototype.parseComplexJSXElement = function(el) {
            var stack = [];
            while (!this.scanner.eof()) {
              el.children = el.children.concat(this.parseJSXChildren());
              var node = this.createJSXChildNode();
              var element = this.parseJSXBoundaryElement();
              if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
                var opening = element;
                if (opening.selfClosing) {
                  var child = this.finalize(node, new JSXNode.JSXElement(opening, [], null));
                  el.children.push(child);
                } else {
                  stack.push(el);
                  el = { node, opening, closing: null, children: [] };
                }
              }
              if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
                el.closing = element;
                var open_1 = getQualifiedElementName(el.opening.name);
                var close_1 = getQualifiedElementName(el.closing.name);
                if (open_1 !== close_1) {
                  this.tolerateError("Expected corresponding JSX closing tag for %0", open_1);
                }
                if (stack.length > 0) {
                  var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
                  el = stack[stack.length - 1];
                  el.children.push(child);
                  stack.pop();
                } else {
                  break;
                }
              }
            }
            return el;
          };
          JSXParser2.prototype.parseJSXElement = function() {
            var node = this.createJSXNode();
            var opening = this.parseJSXOpeningElement();
            var children = [];
            var closing = null;
            if (!opening.selfClosing) {
              var el = this.parseComplexJSXElement({ node, opening, closing, children });
              children = el.children;
              closing = el.closing;
            }
            return this.finalize(node, new JSXNode.JSXElement(opening, children, closing));
          };
          JSXParser2.prototype.parseJSXRoot = function() {
            if (this.config.tokens) {
              this.tokens.pop();
            }
            this.startJSX();
            var element = this.parseJSXElement();
            this.finishJSX();
            return element;
          };
          JSXParser2.prototype.isStartOfExpression = function() {
            return _super.prototype.isStartOfExpression.call(this) || this.match("<");
          };
          return JSXParser2;
        }(parser_1.Parser);
        exports2.JSXParser = JSXParser;
      },
      function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var Regex = {
          NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
          NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
        };
        exports2.Character = {
          fromCodePoint: function(cp) {
            return cp < 65536 ? String.fromCharCode(cp) : String.fromCharCode(55296 + (cp - 65536 >> 10)) + String.fromCharCode(56320 + (cp - 65536 & 1023));
          },
          isWhiteSpace: function(cp) {
            return cp === 32 || cp === 9 || cp === 11 || cp === 12 || cp === 160 || cp >= 5760 && [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(cp) >= 0;
          },
          isLineTerminator: function(cp) {
            return cp === 10 || cp === 13 || cp === 8232 || cp === 8233;
          },
          isIdentifierStart: function(cp) {
            return cp === 36 || cp === 95 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp === 92 || cp >= 128 && Regex.NonAsciiIdentifierStart.test(exports2.Character.fromCodePoint(cp));
          },
          isIdentifierPart: function(cp) {
            return cp === 36 || cp === 95 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp >= 48 && cp <= 57 || cp === 92 || cp >= 128 && Regex.NonAsciiIdentifierPart.test(exports2.Character.fromCodePoint(cp));
          },
          isDecimalDigit: function(cp) {
            return cp >= 48 && cp <= 57;
          },
          isHexDigit: function(cp) {
            return cp >= 48 && cp <= 57 || cp >= 65 && cp <= 70 || cp >= 97 && cp <= 102;
          },
          isOctalDigit: function(cp) {
            return cp >= 48 && cp <= 55;
          }
        };
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var jsx_syntax_1 = __webpack_require__(6);
        var JSXClosingElement = function() {
          function JSXClosingElement2(name) {
            this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;
            this.name = name;
          }
          return JSXClosingElement2;
        }();
        exports2.JSXClosingElement = JSXClosingElement;
        var JSXElement = function() {
          function JSXElement2(openingElement, children, closingElement) {
            this.type = jsx_syntax_1.JSXSyntax.JSXElement;
            this.openingElement = openingElement;
            this.children = children;
            this.closingElement = closingElement;
          }
          return JSXElement2;
        }();
        exports2.JSXElement = JSXElement;
        var JSXEmptyExpression = function() {
          function JSXEmptyExpression2() {
            this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
          }
          return JSXEmptyExpression2;
        }();
        exports2.JSXEmptyExpression = JSXEmptyExpression;
        var JSXExpressionContainer = function() {
          function JSXExpressionContainer2(expression) {
            this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;
            this.expression = expression;
          }
          return JSXExpressionContainer2;
        }();
        exports2.JSXExpressionContainer = JSXExpressionContainer;
        var JSXIdentifier = function() {
          function JSXIdentifier2(name) {
            this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;
            this.name = name;
          }
          return JSXIdentifier2;
        }();
        exports2.JSXIdentifier = JSXIdentifier;
        var JSXMemberExpression = function() {
          function JSXMemberExpression2(object, property) {
            this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;
            this.object = object;
            this.property = property;
          }
          return JSXMemberExpression2;
        }();
        exports2.JSXMemberExpression = JSXMemberExpression;
        var JSXAttribute = function() {
          function JSXAttribute2(name, value) {
            this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;
            this.name = name;
            this.value = value;
          }
          return JSXAttribute2;
        }();
        exports2.JSXAttribute = JSXAttribute;
        var JSXNamespacedName = function() {
          function JSXNamespacedName2(namespace, name) {
            this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;
            this.namespace = namespace;
            this.name = name;
          }
          return JSXNamespacedName2;
        }();
        exports2.JSXNamespacedName = JSXNamespacedName;
        var JSXOpeningElement = function() {
          function JSXOpeningElement2(name, selfClosing, attributes) {
            this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;
            this.name = name;
            this.selfClosing = selfClosing;
            this.attributes = attributes;
          }
          return JSXOpeningElement2;
        }();
        exports2.JSXOpeningElement = JSXOpeningElement;
        var JSXSpreadAttribute = function() {
          function JSXSpreadAttribute2(argument) {
            this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;
            this.argument = argument;
          }
          return JSXSpreadAttribute2;
        }();
        exports2.JSXSpreadAttribute = JSXSpreadAttribute;
        var JSXText = function() {
          function JSXText2(value, raw) {
            this.type = jsx_syntax_1.JSXSyntax.JSXText;
            this.value = value;
            this.raw = raw;
          }
          return JSXText2;
        }();
        exports2.JSXText = JSXText;
      },
      function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.JSXSyntax = {
          JSXAttribute: "JSXAttribute",
          JSXClosingElement: "JSXClosingElement",
          JSXElement: "JSXElement",
          JSXEmptyExpression: "JSXEmptyExpression",
          JSXExpressionContainer: "JSXExpressionContainer",
          JSXIdentifier: "JSXIdentifier",
          JSXMemberExpression: "JSXMemberExpression",
          JSXNamespacedName: "JSXNamespacedName",
          JSXOpeningElement: "JSXOpeningElement",
          JSXSpreadAttribute: "JSXSpreadAttribute",
          JSXText: "JSXText"
        };
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var syntax_1 = __webpack_require__(2);
        var ArrayExpression = function() {
          function ArrayExpression2(elements) {
            this.type = syntax_1.Syntax.ArrayExpression;
            this.elements = elements;
          }
          return ArrayExpression2;
        }();
        exports2.ArrayExpression = ArrayExpression;
        var ArrayPattern = function() {
          function ArrayPattern2(elements) {
            this.type = syntax_1.Syntax.ArrayPattern;
            this.elements = elements;
          }
          return ArrayPattern2;
        }();
        exports2.ArrayPattern = ArrayPattern;
        var ArrowFunctionExpression = function() {
          function ArrowFunctionExpression2(params, body, expression) {
            this.type = syntax_1.Syntax.ArrowFunctionExpression;
            this.id = null;
            this.params = params;
            this.body = body;
            this.generator = false;
            this.expression = expression;
            this.async = false;
          }
          return ArrowFunctionExpression2;
        }();
        exports2.ArrowFunctionExpression = ArrowFunctionExpression;
        var AssignmentExpression = function() {
          function AssignmentExpression2(operator, left, right) {
            this.type = syntax_1.Syntax.AssignmentExpression;
            this.operator = operator;
            this.left = left;
            this.right = right;
          }
          return AssignmentExpression2;
        }();
        exports2.AssignmentExpression = AssignmentExpression;
        var AssignmentPattern = function() {
          function AssignmentPattern2(left, right) {
            this.type = syntax_1.Syntax.AssignmentPattern;
            this.left = left;
            this.right = right;
          }
          return AssignmentPattern2;
        }();
        exports2.AssignmentPattern = AssignmentPattern;
        var AsyncArrowFunctionExpression = function() {
          function AsyncArrowFunctionExpression2(params, body, expression) {
            this.type = syntax_1.Syntax.ArrowFunctionExpression;
            this.id = null;
            this.params = params;
            this.body = body;
            this.generator = false;
            this.expression = expression;
            this.async = true;
          }
          return AsyncArrowFunctionExpression2;
        }();
        exports2.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;
        var AsyncFunctionDeclaration = function() {
          function AsyncFunctionDeclaration2(id, params, body) {
            this.type = syntax_1.Syntax.FunctionDeclaration;
            this.id = id;
            this.params = params;
            this.body = body;
            this.generator = false;
            this.expression = false;
            this.async = true;
          }
          return AsyncFunctionDeclaration2;
        }();
        exports2.AsyncFunctionDeclaration = AsyncFunctionDeclaration;
        var AsyncFunctionExpression = function() {
          function AsyncFunctionExpression2(id, params, body) {
            this.type = syntax_1.Syntax.FunctionExpression;
            this.id = id;
            this.params = params;
            this.body = body;
            this.generator = false;
            this.expression = false;
            this.async = true;
          }
          return AsyncFunctionExpression2;
        }();
        exports2.AsyncFunctionExpression = AsyncFunctionExpression;
        var AwaitExpression = function() {
          function AwaitExpression2(argument) {
            this.type = syntax_1.Syntax.AwaitExpression;
            this.argument = argument;
          }
          return AwaitExpression2;
        }();
        exports2.AwaitExpression = AwaitExpression;
        var BinaryExpression = function() {
          function BinaryExpression2(operator, left, right) {
            var logical = operator === "||" || operator === "&&";
            this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;
            this.operator = operator;
            this.left = left;
            this.right = right;
          }
          return BinaryExpression2;
        }();
        exports2.BinaryExpression = BinaryExpression;
        var BlockStatement = function() {
          function BlockStatement2(body) {
            this.type = syntax_1.Syntax.BlockStatement;
            this.body = body;
          }
          return BlockStatement2;
        }();
        exports2.BlockStatement = BlockStatement;
        var BreakStatement = function() {
          function BreakStatement2(label) {
            this.type = syntax_1.Syntax.BreakStatement;
            this.label = label;
          }
          return BreakStatement2;
        }();
        exports2.BreakStatement = BreakStatement;
        var CallExpression = function() {
          function CallExpression2(callee, args) {
            this.type = syntax_1.Syntax.CallExpression;
            this.callee = callee;
            this.arguments = args;
          }
          return CallExpression2;
        }();
        exports2.CallExpression = CallExpression;
        var CatchClause = function() {
          function CatchClause2(param, body) {
            this.type = syntax_1.Syntax.CatchClause;
            this.param = param;
            this.body = body;
          }
          return CatchClause2;
        }();
        exports2.CatchClause = CatchClause;
        var ClassBody = function() {
          function ClassBody2(body) {
            this.type = syntax_1.Syntax.ClassBody;
            this.body = body;
          }
          return ClassBody2;
        }();
        exports2.ClassBody = ClassBody;
        var ClassDeclaration = function() {
          function ClassDeclaration2(id, superClass, body) {
            this.type = syntax_1.Syntax.ClassDeclaration;
            this.id = id;
            this.superClass = superClass;
            this.body = body;
          }
          return ClassDeclaration2;
        }();
        exports2.ClassDeclaration = ClassDeclaration;
        var ClassExpression = function() {
          function ClassExpression2(id, superClass, body) {
            this.type = syntax_1.Syntax.ClassExpression;
            this.id = id;
            this.superClass = superClass;
            this.body = body;
          }
          return ClassExpression2;
        }();
        exports2.ClassExpression = ClassExpression;
        var ComputedMemberExpression = function() {
          function ComputedMemberExpression2(object, property) {
            this.type = syntax_1.Syntax.MemberExpression;
            this.computed = true;
            this.object = object;
            this.property = property;
          }
          return ComputedMemberExpression2;
        }();
        exports2.ComputedMemberExpression = ComputedMemberExpression;
        var ConditionalExpression = function() {
          function ConditionalExpression2(test, consequent, alternate) {
            this.type = syntax_1.Syntax.ConditionalExpression;
            this.test = test;
            this.consequent = consequent;
            this.alternate = alternate;
          }
          return ConditionalExpression2;
        }();
        exports2.ConditionalExpression = ConditionalExpression;
        var ContinueStatement = function() {
          function ContinueStatement2(label) {
            this.type = syntax_1.Syntax.ContinueStatement;
            this.label = label;
          }
          return ContinueStatement2;
        }();
        exports2.ContinueStatement = ContinueStatement;
        var DebuggerStatement = function() {
          function DebuggerStatement2() {
            this.type = syntax_1.Syntax.DebuggerStatement;
          }
          return DebuggerStatement2;
        }();
        exports2.DebuggerStatement = DebuggerStatement;
        var Directive = function() {
          function Directive2(expression, directive) {
            this.type = syntax_1.Syntax.ExpressionStatement;
            this.expression = expression;
            this.directive = directive;
          }
          return Directive2;
        }();
        exports2.Directive = Directive;
        var DoWhileStatement = function() {
          function DoWhileStatement2(body, test) {
            this.type = syntax_1.Syntax.DoWhileStatement;
            this.body = body;
            this.test = test;
          }
          return DoWhileStatement2;
        }();
        exports2.DoWhileStatement = DoWhileStatement;
        var EmptyStatement = function() {
          function EmptyStatement2() {
            this.type = syntax_1.Syntax.EmptyStatement;
          }
          return EmptyStatement2;
        }();
        exports2.EmptyStatement = EmptyStatement;
        var ExportAllDeclaration = function() {
          function ExportAllDeclaration2(source) {
            this.type = syntax_1.Syntax.ExportAllDeclaration;
            this.source = source;
          }
          return ExportAllDeclaration2;
        }();
        exports2.ExportAllDeclaration = ExportAllDeclaration;
        var ExportDefaultDeclaration = function() {
          function ExportDefaultDeclaration2(declaration) {
            this.type = syntax_1.Syntax.ExportDefaultDeclaration;
            this.declaration = declaration;
          }
          return ExportDefaultDeclaration2;
        }();
        exports2.ExportDefaultDeclaration = ExportDefaultDeclaration;
        var ExportNamedDeclaration = function() {
          function ExportNamedDeclaration2(declaration, specifiers, source) {
            this.type = syntax_1.Syntax.ExportNamedDeclaration;
            this.declaration = declaration;
            this.specifiers = specifiers;
            this.source = source;
          }
          return ExportNamedDeclaration2;
        }();
        exports2.ExportNamedDeclaration = ExportNamedDeclaration;
        var ExportSpecifier = function() {
          function ExportSpecifier2(local, exported) {
            this.type = syntax_1.Syntax.ExportSpecifier;
            this.exported = exported;
            this.local = local;
          }
          return ExportSpecifier2;
        }();
        exports2.ExportSpecifier = ExportSpecifier;
        var ExpressionStatement = function() {
          function ExpressionStatement2(expression) {
            this.type = syntax_1.Syntax.ExpressionStatement;
            this.expression = expression;
          }
          return ExpressionStatement2;
        }();
        exports2.ExpressionStatement = ExpressionStatement;
        var ForInStatement = function() {
          function ForInStatement2(left, right, body) {
            this.type = syntax_1.Syntax.ForInStatement;
            this.left = left;
            this.right = right;
            this.body = body;
            this.each = false;
          }
          return ForInStatement2;
        }();
        exports2.ForInStatement = ForInStatement;
        var ForOfStatement = function() {
          function ForOfStatement2(left, right, body) {
            this.type = syntax_1.Syntax.ForOfStatement;
            this.left = left;
            this.right = right;
            this.body = body;
          }
          return ForOfStatement2;
        }();
        exports2.ForOfStatement = ForOfStatement;
        var ForStatement = function() {
          function ForStatement2(init, test, update, body) {
            this.type = syntax_1.Syntax.ForStatement;
            this.init = init;
            this.test = test;
            this.update = update;
            this.body = body;
          }
          return ForStatement2;
        }();
        exports2.ForStatement = ForStatement;
        var FunctionDeclaration = function() {
          function FunctionDeclaration2(id, params, body, generator) {
            this.type = syntax_1.Syntax.FunctionDeclaration;
            this.id = id;
            this.params = params;
            this.body = body;
            this.generator = generator;
            this.expression = false;
            this.async = false;
          }
          return FunctionDeclaration2;
        }();
        exports2.FunctionDeclaration = FunctionDeclaration;
        var FunctionExpression = function() {
          function FunctionExpression2(id, params, body, generator) {
            this.type = syntax_1.Syntax.FunctionExpression;
            this.id = id;
            this.params = params;
            this.body = body;
            this.generator = generator;
            this.expression = false;
            this.async = false;
          }
          return FunctionExpression2;
        }();
        exports2.FunctionExpression = FunctionExpression;
        var Identifier = function() {
          function Identifier2(name) {
            this.type = syntax_1.Syntax.Identifier;
            this.name = name;
          }
          return Identifier2;
        }();
        exports2.Identifier = Identifier;
        var IfStatement = function() {
          function IfStatement2(test, consequent, alternate) {
            this.type = syntax_1.Syntax.IfStatement;
            this.test = test;
            this.consequent = consequent;
            this.alternate = alternate;
          }
          return IfStatement2;
        }();
        exports2.IfStatement = IfStatement;
        var ImportDeclaration = function() {
          function ImportDeclaration2(specifiers, source) {
            this.type = syntax_1.Syntax.ImportDeclaration;
            this.specifiers = specifiers;
            this.source = source;
          }
          return ImportDeclaration2;
        }();
        exports2.ImportDeclaration = ImportDeclaration;
        var ImportDefaultSpecifier = function() {
          function ImportDefaultSpecifier2(local) {
            this.type = syntax_1.Syntax.ImportDefaultSpecifier;
            this.local = local;
          }
          return ImportDefaultSpecifier2;
        }();
        exports2.ImportDefaultSpecifier = ImportDefaultSpecifier;
        var ImportNamespaceSpecifier = function() {
          function ImportNamespaceSpecifier2(local) {
            this.type = syntax_1.Syntax.ImportNamespaceSpecifier;
            this.local = local;
          }
          return ImportNamespaceSpecifier2;
        }();
        exports2.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
        var ImportSpecifier = function() {
          function ImportSpecifier2(local, imported) {
            this.type = syntax_1.Syntax.ImportSpecifier;
            this.local = local;
            this.imported = imported;
          }
          return ImportSpecifier2;
        }();
        exports2.ImportSpecifier = ImportSpecifier;
        var LabeledStatement = function() {
          function LabeledStatement2(label, body) {
            this.type = syntax_1.Syntax.LabeledStatement;
            this.label = label;
            this.body = body;
          }
          return LabeledStatement2;
        }();
        exports2.LabeledStatement = LabeledStatement;
        var Literal = function() {
          function Literal2(value, raw) {
            this.type = syntax_1.Syntax.Literal;
            this.value = value;
            this.raw = raw;
          }
          return Literal2;
        }();
        exports2.Literal = Literal;
        var MetaProperty = function() {
          function MetaProperty2(meta, property) {
            this.type = syntax_1.Syntax.MetaProperty;
            this.meta = meta;
            this.property = property;
          }
          return MetaProperty2;
        }();
        exports2.MetaProperty = MetaProperty;
        var MethodDefinition = function() {
          function MethodDefinition2(key, computed, value, kind2, isStatic) {
            this.type = syntax_1.Syntax.MethodDefinition;
            this.key = key;
            this.computed = computed;
            this.value = value;
            this.kind = kind2;
            this.static = isStatic;
          }
          return MethodDefinition2;
        }();
        exports2.MethodDefinition = MethodDefinition;
        var Module = function() {
          function Module2(body) {
            this.type = syntax_1.Syntax.Program;
            this.body = body;
            this.sourceType = "module";
          }
          return Module2;
        }();
        exports2.Module = Module;
        var NewExpression = function() {
          function NewExpression2(callee, args) {
            this.type = syntax_1.Syntax.NewExpression;
            this.callee = callee;
            this.arguments = args;
          }
          return NewExpression2;
        }();
        exports2.NewExpression = NewExpression;
        var ObjectExpression = function() {
          function ObjectExpression2(properties) {
            this.type = syntax_1.Syntax.ObjectExpression;
            this.properties = properties;
          }
          return ObjectExpression2;
        }();
        exports2.ObjectExpression = ObjectExpression;
        var ObjectPattern = function() {
          function ObjectPattern2(properties) {
            this.type = syntax_1.Syntax.ObjectPattern;
            this.properties = properties;
          }
          return ObjectPattern2;
        }();
        exports2.ObjectPattern = ObjectPattern;
        var Property = function() {
          function Property2(kind2, key, computed, value, method, shorthand) {
            this.type = syntax_1.Syntax.Property;
            this.key = key;
            this.computed = computed;
            this.value = value;
            this.kind = kind2;
            this.method = method;
            this.shorthand = shorthand;
          }
          return Property2;
        }();
        exports2.Property = Property;
        var RegexLiteral = function() {
          function RegexLiteral2(value, raw, pattern, flags) {
            this.type = syntax_1.Syntax.Literal;
            this.value = value;
            this.raw = raw;
            this.regex = { pattern, flags };
          }
          return RegexLiteral2;
        }();
        exports2.RegexLiteral = RegexLiteral;
        var RestElement = function() {
          function RestElement2(argument) {
            this.type = syntax_1.Syntax.RestElement;
            this.argument = argument;
          }
          return RestElement2;
        }();
        exports2.RestElement = RestElement;
        var ReturnStatement = function() {
          function ReturnStatement2(argument) {
            this.type = syntax_1.Syntax.ReturnStatement;
            this.argument = argument;
          }
          return ReturnStatement2;
        }();
        exports2.ReturnStatement = ReturnStatement;
        var Script = function() {
          function Script2(body) {
            this.type = syntax_1.Syntax.Program;
            this.body = body;
            this.sourceType = "script";
          }
          return Script2;
        }();
        exports2.Script = Script;
        var SequenceExpression = function() {
          function SequenceExpression2(expressions) {
            this.type = syntax_1.Syntax.SequenceExpression;
            this.expressions = expressions;
          }
          return SequenceExpression2;
        }();
        exports2.SequenceExpression = SequenceExpression;
        var SpreadElement = function() {
          function SpreadElement2(argument) {
            this.type = syntax_1.Syntax.SpreadElement;
            this.argument = argument;
          }
          return SpreadElement2;
        }();
        exports2.SpreadElement = SpreadElement;
        var StaticMemberExpression = function() {
          function StaticMemberExpression2(object, property) {
            this.type = syntax_1.Syntax.MemberExpression;
            this.computed = false;
            this.object = object;
            this.property = property;
          }
          return StaticMemberExpression2;
        }();
        exports2.StaticMemberExpression = StaticMemberExpression;
        var Super = function() {
          function Super2() {
            this.type = syntax_1.Syntax.Super;
          }
          return Super2;
        }();
        exports2.Super = Super;
        var SwitchCase = function() {
          function SwitchCase2(test, consequent) {
            this.type = syntax_1.Syntax.SwitchCase;
            this.test = test;
            this.consequent = consequent;
          }
          return SwitchCase2;
        }();
        exports2.SwitchCase = SwitchCase;
        var SwitchStatement = function() {
          function SwitchStatement2(discriminant, cases) {
            this.type = syntax_1.Syntax.SwitchStatement;
            this.discriminant = discriminant;
            this.cases = cases;
          }
          return SwitchStatement2;
        }();
        exports2.SwitchStatement = SwitchStatement;
        var TaggedTemplateExpression = function() {
          function TaggedTemplateExpression2(tag, quasi) {
            this.type = syntax_1.Syntax.TaggedTemplateExpression;
            this.tag = tag;
            this.quasi = quasi;
          }
          return TaggedTemplateExpression2;
        }();
        exports2.TaggedTemplateExpression = TaggedTemplateExpression;
        var TemplateElement = function() {
          function TemplateElement2(value, tail) {
            this.type = syntax_1.Syntax.TemplateElement;
            this.value = value;
            this.tail = tail;
          }
          return TemplateElement2;
        }();
        exports2.TemplateElement = TemplateElement;
        var TemplateLiteral = function() {
          function TemplateLiteral2(quasis, expressions) {
            this.type = syntax_1.Syntax.TemplateLiteral;
            this.quasis = quasis;
            this.expressions = expressions;
          }
          return TemplateLiteral2;
        }();
        exports2.TemplateLiteral = TemplateLiteral;
        var ThisExpression = function() {
          function ThisExpression2() {
            this.type = syntax_1.Syntax.ThisExpression;
          }
          return ThisExpression2;
        }();
        exports2.ThisExpression = ThisExpression;
        var ThrowStatement = function() {
          function ThrowStatement2(argument) {
            this.type = syntax_1.Syntax.ThrowStatement;
            this.argument = argument;
          }
          return ThrowStatement2;
        }();
        exports2.ThrowStatement = ThrowStatement;
        var TryStatement = function() {
          function TryStatement2(block2, handler, finalizer) {
            this.type = syntax_1.Syntax.TryStatement;
            this.block = block2;
            this.handler = handler;
            this.finalizer = finalizer;
          }
          return TryStatement2;
        }();
        exports2.TryStatement = TryStatement;
        var UnaryExpression = function() {
          function UnaryExpression2(operator, argument) {
            this.type = syntax_1.Syntax.UnaryExpression;
            this.operator = operator;
            this.argument = argument;
            this.prefix = true;
          }
          return UnaryExpression2;
        }();
        exports2.UnaryExpression = UnaryExpression;
        var UpdateExpression = function() {
          function UpdateExpression2(operator, argument, prefix) {
            this.type = syntax_1.Syntax.UpdateExpression;
            this.operator = operator;
            this.argument = argument;
            this.prefix = prefix;
          }
          return UpdateExpression2;
        }();
        exports2.UpdateExpression = UpdateExpression;
        var VariableDeclaration = function() {
          function VariableDeclaration2(declarations, kind2) {
            this.type = syntax_1.Syntax.VariableDeclaration;
            this.declarations = declarations;
            this.kind = kind2;
          }
          return VariableDeclaration2;
        }();
        exports2.VariableDeclaration = VariableDeclaration;
        var VariableDeclarator = function() {
          function VariableDeclarator2(id, init) {
            this.type = syntax_1.Syntax.VariableDeclarator;
            this.id = id;
            this.init = init;
          }
          return VariableDeclarator2;
        }();
        exports2.VariableDeclarator = VariableDeclarator;
        var WhileStatement = function() {
          function WhileStatement2(test, body) {
            this.type = syntax_1.Syntax.WhileStatement;
            this.test = test;
            this.body = body;
          }
          return WhileStatement2;
        }();
        exports2.WhileStatement = WhileStatement;
        var WithStatement = function() {
          function WithStatement2(object, body) {
            this.type = syntax_1.Syntax.WithStatement;
            this.object = object;
            this.body = body;
          }
          return WithStatement2;
        }();
        exports2.WithStatement = WithStatement;
        var YieldExpression = function() {
          function YieldExpression2(argument, delegate) {
            this.type = syntax_1.Syntax.YieldExpression;
            this.argument = argument;
            this.delegate = delegate;
          }
          return YieldExpression2;
        }();
        exports2.YieldExpression = YieldExpression;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var assert_1 = __webpack_require__(9);
        var error_handler_1 = __webpack_require__(10);
        var messages_1 = __webpack_require__(11);
        var Node = __webpack_require__(7);
        var scanner_1 = __webpack_require__(12);
        var syntax_1 = __webpack_require__(2);
        var token_1 = __webpack_require__(13);
        var ArrowParameterPlaceHolder = "ArrowParameterPlaceHolder";
        var Parser = function() {
          function Parser2(code, options2, delegate) {
            if (options2 === undefined) {
              options2 = {};
            }
            this.config = {
              range: typeof options2.range === "boolean" && options2.range,
              loc: typeof options2.loc === "boolean" && options2.loc,
              source: null,
              tokens: typeof options2.tokens === "boolean" && options2.tokens,
              comment: typeof options2.comment === "boolean" && options2.comment,
              tolerant: typeof options2.tolerant === "boolean" && options2.tolerant
            };
            if (this.config.loc && options2.source && options2.source !== null) {
              this.config.source = String(options2.source);
            }
            this.delegate = delegate;
            this.errorHandler = new error_handler_1.ErrorHandler;
            this.errorHandler.tolerant = this.config.tolerant;
            this.scanner = new scanner_1.Scanner(code, this.errorHandler);
            this.scanner.trackComment = this.config.comment;
            this.operatorPrecedence = {
              ")": 0,
              ";": 0,
              ",": 0,
              "=": 0,
              "]": 0,
              "||": 1,
              "&&": 2,
              "|": 3,
              "^": 4,
              "&": 5,
              "==": 6,
              "!=": 6,
              "===": 6,
              "!==": 6,
              "<": 7,
              ">": 7,
              "<=": 7,
              ">=": 7,
              "<<": 8,
              ">>": 8,
              ">>>": 8,
              "+": 9,
              "-": 9,
              "*": 11,
              "/": 11,
              "%": 11
            };
            this.lookahead = {
              type: 2,
              value: "",
              lineNumber: this.scanner.lineNumber,
              lineStart: 0,
              start: 0,
              end: 0
            };
            this.hasLineTerminator = false;
            this.context = {
              isModule: false,
              await: false,
              allowIn: true,
              allowStrictDirective: true,
              allowYield: true,
              firstCoverInitializedNameError: null,
              isAssignmentTarget: false,
              isBindingElement: false,
              inFunctionBody: false,
              inIteration: false,
              inSwitch: false,
              labelSet: {},
              strict: false
            };
            this.tokens = [];
            this.startMarker = {
              index: 0,
              line: this.scanner.lineNumber,
              column: 0
            };
            this.lastMarker = {
              index: 0,
              line: this.scanner.lineNumber,
              column: 0
            };
            this.nextToken();
            this.lastMarker = {
              index: this.scanner.index,
              line: this.scanner.lineNumber,
              column: this.scanner.index - this.scanner.lineStart
            };
          }
          Parser2.prototype.throwError = function(messageFormat) {
            var values = [];
            for (var _i = 1;_i < arguments.length; _i++) {
              values[_i - 1] = arguments[_i];
            }
            var args = Array.prototype.slice.call(arguments, 1);
            var msg = messageFormat.replace(/%(\d)/g, function(whole, idx) {
              assert_1.assert(idx < args.length, "Message reference must be in range");
              return args[idx];
            });
            var index = this.lastMarker.index;
            var line = this.lastMarker.line;
            var column = this.lastMarker.column + 1;
            throw this.errorHandler.createError(index, line, column, msg);
          };
          Parser2.prototype.tolerateError = function(messageFormat) {
            var values = [];
            for (var _i = 1;_i < arguments.length; _i++) {
              values[_i - 1] = arguments[_i];
            }
            var args = Array.prototype.slice.call(arguments, 1);
            var msg = messageFormat.replace(/%(\d)/g, function(whole, idx) {
              assert_1.assert(idx < args.length, "Message reference must be in range");
              return args[idx];
            });
            var index = this.lastMarker.index;
            var line = this.scanner.lineNumber;
            var column = this.lastMarker.column + 1;
            this.errorHandler.tolerateError(index, line, column, msg);
          };
          Parser2.prototype.unexpectedTokenError = function(token, message) {
            var msg = message || messages_1.Messages.UnexpectedToken;
            var value;
            if (token) {
              if (!message) {
                msg = token.type === 2 ? messages_1.Messages.UnexpectedEOS : token.type === 3 ? messages_1.Messages.UnexpectedIdentifier : token.type === 6 ? messages_1.Messages.UnexpectedNumber : token.type === 8 ? messages_1.Messages.UnexpectedString : token.type === 10 ? messages_1.Messages.UnexpectedTemplate : messages_1.Messages.UnexpectedToken;
                if (token.type === 4) {
                  if (this.scanner.isFutureReservedWord(token.value)) {
                    msg = messages_1.Messages.UnexpectedReserved;
                  } else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {
                    msg = messages_1.Messages.StrictReservedWord;
                  }
                }
              }
              value = token.value;
            } else {
              value = "ILLEGAL";
            }
            msg = msg.replace("%0", value);
            if (token && typeof token.lineNumber === "number") {
              var index = token.start;
              var line = token.lineNumber;
              var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;
              var column = token.start - lastMarkerLineStart + 1;
              return this.errorHandler.createError(index, line, column, msg);
            } else {
              var index = this.lastMarker.index;
              var line = this.lastMarker.line;
              var column = this.lastMarker.column + 1;
              return this.errorHandler.createError(index, line, column, msg);
            }
          };
          Parser2.prototype.throwUnexpectedToken = function(token, message) {
            throw this.unexpectedTokenError(token, message);
          };
          Parser2.prototype.tolerateUnexpectedToken = function(token, message) {
            this.errorHandler.tolerate(this.unexpectedTokenError(token, message));
          };
          Parser2.prototype.collectComments = function() {
            if (!this.config.comment) {
              this.scanner.scanComments();
            } else {
              var comments = this.scanner.scanComments();
              if (comments.length > 0 && this.delegate) {
                for (var i2 = 0;i2 < comments.length; ++i2) {
                  var e2 = comments[i2];
                  var node = undefined;
                  node = {
                    type: e2.multiLine ? "BlockComment" : "LineComment",
                    value: this.scanner.source.slice(e2.slice[0], e2.slice[1])
                  };
                  if (this.config.range) {
                    node.range = e2.range;
                  }
                  if (this.config.loc) {
                    node.loc = e2.loc;
                  }
                  var metadata = {
                    start: {
                      line: e2.loc.start.line,
                      column: e2.loc.start.column,
                      offset: e2.range[0]
                    },
                    end: {
                      line: e2.loc.end.line,
                      column: e2.loc.end.column,
                      offset: e2.range[1]
                    }
                  };
                  this.delegate(node, metadata);
                }
              }
            }
          };
          Parser2.prototype.getTokenRaw = function(token) {
            return this.scanner.source.slice(token.start, token.end);
          };
          Parser2.prototype.convertToken = function(token) {
            var t2 = {
              type: token_1.TokenName[token.type],
              value: this.getTokenRaw(token)
            };
            if (this.config.range) {
              t2.range = [token.start, token.end];
            }
            if (this.config.loc) {
              t2.loc = {
                start: {
                  line: this.startMarker.line,
                  column: this.startMarker.column
                },
                end: {
                  line: this.scanner.lineNumber,
                  column: this.scanner.index - this.scanner.lineStart
                }
              };
            }
            if (token.type === 9) {
              var pattern = token.pattern;
              var flags = token.flags;
              t2.regex = { pattern, flags };
            }
            return t2;
          };
          Parser2.prototype.nextToken = function() {
            var token = this.lookahead;
            this.lastMarker.index = this.scanner.index;
            this.lastMarker.line = this.scanner.lineNumber;
            this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
            this.collectComments();
            if (this.scanner.index !== this.startMarker.index) {
              this.startMarker.index = this.scanner.index;
              this.startMarker.line = this.scanner.lineNumber;
              this.startMarker.column = this.scanner.index - this.scanner.lineStart;
            }
            var next = this.scanner.lex();
            this.hasLineTerminator = token.lineNumber !== next.lineNumber;
            if (next && this.context.strict && next.type === 3) {
              if (this.scanner.isStrictModeReservedWord(next.value)) {
                next.type = 4;
              }
            }
            this.lookahead = next;
            if (this.config.tokens && next.type !== 2) {
              this.tokens.push(this.convertToken(next));
            }
            return token;
          };
          Parser2.prototype.nextRegexToken = function() {
            this.collectComments();
            var token = this.scanner.scanRegExp();
            if (this.config.tokens) {
              this.tokens.pop();
              this.tokens.push(this.convertToken(token));
            }
            this.lookahead = token;
            this.nextToken();
            return token;
          };
          Parser2.prototype.createNode = function() {
            return {
              index: this.startMarker.index,
              line: this.startMarker.line,
              column: this.startMarker.column
            };
          };
          Parser2.prototype.startNode = function(token, lastLineStart) {
            if (lastLineStart === undefined) {
              lastLineStart = 0;
            }
            var column = token.start - token.lineStart;
            var line = token.lineNumber;
            if (column < 0) {
              column += lastLineStart;
              line--;
            }
            return {
              index: token.start,
              line,
              column
            };
          };
          Parser2.prototype.finalize = function(marker, node) {
            if (this.config.range) {
              node.range = [marker.index, this.lastMarker.index];
            }
            if (this.config.loc) {
              node.loc = {
                start: {
                  line: marker.line,
                  column: marker.column
                },
                end: {
                  line: this.lastMarker.line,
                  column: this.lastMarker.column
                }
              };
              if (this.config.source) {
                node.loc.source = this.config.source;
              }
            }
            if (this.delegate) {
              var metadata = {
                start: {
                  line: marker.line,
                  column: marker.column,
                  offset: marker.index
                },
                end: {
                  line: this.lastMarker.line,
                  column: this.lastMarker.column,
                  offset: this.lastMarker.index
                }
              };
              this.delegate(node, metadata);
            }
            return node;
          };
          Parser2.prototype.expect = function(value) {
            var token = this.nextToken();
            if (token.type !== 7 || token.value !== value) {
              this.throwUnexpectedToken(token);
            }
          };
          Parser2.prototype.expectCommaSeparator = function() {
            if (this.config.tolerant) {
              var token = this.lookahead;
              if (token.type === 7 && token.value === ",") {
                this.nextToken();
              } else if (token.type === 7 && token.value === ";") {
                this.nextToken();
                this.tolerateUnexpectedToken(token);
              } else {
                this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);
              }
            } else {
              this.expect(",");
            }
          };
          Parser2.prototype.expectKeyword = function(keyword) {
            var token = this.nextToken();
            if (token.type !== 4 || token.value !== keyword) {
              this.throwUnexpectedToken(token);
            }
          };
          Parser2.prototype.match = function(value) {
            return this.lookahead.type === 7 && this.lookahead.value === value;
          };
          Parser2.prototype.matchKeyword = function(keyword) {
            return this.lookahead.type === 4 && this.lookahead.value === keyword;
          };
          Parser2.prototype.matchContextualKeyword = function(keyword) {
            return this.lookahead.type === 3 && this.lookahead.value === keyword;
          };
          Parser2.prototype.matchAssign = function() {
            if (this.lookahead.type !== 7) {
              return false;
            }
            var op = this.lookahead.value;
            return op === "=" || op === "*=" || op === "**=" || op === "/=" || op === "%=" || op === "+=" || op === "-=" || op === "<<=" || op === ">>=" || op === ">>>=" || op === "&=" || op === "^=" || op === "|=";
          };
          Parser2.prototype.isolateCoverGrammar = function(parseFunction) {
            var previousIsBindingElement = this.context.isBindingElement;
            var previousIsAssignmentTarget = this.context.isAssignmentTarget;
            var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
            this.context.isBindingElement = true;
            this.context.isAssignmentTarget = true;
            this.context.firstCoverInitializedNameError = null;
            var result = parseFunction.call(this);
            if (this.context.firstCoverInitializedNameError !== null) {
              this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
            }
            this.context.isBindingElement = previousIsBindingElement;
            this.context.isAssignmentTarget = previousIsAssignmentTarget;
            this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
            return result;
          };
          Parser2.prototype.inheritCoverGrammar = function(parseFunction) {
            var previousIsBindingElement = this.context.isBindingElement;
            var previousIsAssignmentTarget = this.context.isAssignmentTarget;
            var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
            this.context.isBindingElement = true;
            this.context.isAssignmentTarget = true;
            this.context.firstCoverInitializedNameError = null;
            var result = parseFunction.call(this);
            this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
            this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
            this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
            return result;
          };
          Parser2.prototype.consumeSemicolon = function() {
            if (this.match(";")) {
              this.nextToken();
            } else if (!this.hasLineTerminator) {
              if (this.lookahead.type !== 2 && !this.match("}")) {
                this.throwUnexpectedToken(this.lookahead);
              }
              this.lastMarker.index = this.startMarker.index;
              this.lastMarker.line = this.startMarker.line;
              this.lastMarker.column = this.startMarker.column;
            }
          };
          Parser2.prototype.parsePrimaryExpression = function() {
            var node = this.createNode();
            var expr;
            var token, raw;
            switch (this.lookahead.type) {
              case 3:
                if ((this.context.isModule || this.context.await) && this.lookahead.value === "await") {
                  this.tolerateUnexpectedToken(this.lookahead);
                }
                expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node, new Node.Identifier(this.nextToken().value));
                break;
              case 6:
              case 8:
                if (this.context.strict && this.lookahead.octal) {
                  this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);
                }
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
                token = this.nextToken();
                raw = this.getTokenRaw(token);
                expr = this.finalize(node, new Node.Literal(token.value, raw));
                break;
              case 1:
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
                token = this.nextToken();
                raw = this.getTokenRaw(token);
                expr = this.finalize(node, new Node.Literal(token.value === "true", raw));
                break;
              case 5:
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
                token = this.nextToken();
                raw = this.getTokenRaw(token);
                expr = this.finalize(node, new Node.Literal(null, raw));
                break;
              case 10:
                expr = this.parseTemplateLiteral();
                break;
              case 7:
                switch (this.lookahead.value) {
                  case "(":
                    this.context.isBindingElement = false;
                    expr = this.inheritCoverGrammar(this.parseGroupExpression);
                    break;
                  case "[":
                    expr = this.inheritCoverGrammar(this.parseArrayInitializer);
                    break;
                  case "{":
                    expr = this.inheritCoverGrammar(this.parseObjectInitializer);
                    break;
                  case "/":
                  case "/=":
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                    this.scanner.index = this.startMarker.index;
                    token = this.nextRegexToken();
                    raw = this.getTokenRaw(token);
                    expr = this.finalize(node, new Node.RegexLiteral(token.regex, raw, token.pattern, token.flags));
                    break;
                  default:
                    expr = this.throwUnexpectedToken(this.nextToken());
                }
                break;
              case 4:
                if (!this.context.strict && this.context.allowYield && this.matchKeyword("yield")) {
                  expr = this.parseIdentifierName();
                } else if (!this.context.strict && this.matchKeyword("let")) {
                  expr = this.finalize(node, new Node.Identifier(this.nextToken().value));
                } else {
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                  if (this.matchKeyword("function")) {
                    expr = this.parseFunctionExpression();
                  } else if (this.matchKeyword("this")) {
                    this.nextToken();
                    expr = this.finalize(node, new Node.ThisExpression);
                  } else if (this.matchKeyword("class")) {
                    expr = this.parseClassExpression();
                  } else {
                    expr = this.throwUnexpectedToken(this.nextToken());
                  }
                }
                break;
              default:
                expr = this.throwUnexpectedToken(this.nextToken());
            }
            return expr;
          };
          Parser2.prototype.parseSpreadElement = function() {
            var node = this.createNode();
            this.expect("...");
            var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
            return this.finalize(node, new Node.SpreadElement(arg));
          };
          Parser2.prototype.parseArrayInitializer = function() {
            var node = this.createNode();
            var elements = [];
            this.expect("[");
            while (!this.match("]")) {
              if (this.match(",")) {
                this.nextToken();
                elements.push(null);
              } else if (this.match("...")) {
                var element = this.parseSpreadElement();
                if (!this.match("]")) {
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                  this.expect(",");
                }
                elements.push(element);
              } else {
                elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                if (!this.match("]")) {
                  this.expect(",");
                }
              }
            }
            this.expect("]");
            return this.finalize(node, new Node.ArrayExpression(elements));
          };
          Parser2.prototype.parsePropertyMethod = function(params) {
            this.context.isAssignmentTarget = false;
            this.context.isBindingElement = false;
            var previousStrict = this.context.strict;
            var previousAllowStrictDirective = this.context.allowStrictDirective;
            this.context.allowStrictDirective = params.simple;
            var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
            if (this.context.strict && params.firstRestricted) {
              this.tolerateUnexpectedToken(params.firstRestricted, params.message);
            }
            if (this.context.strict && params.stricted) {
              this.tolerateUnexpectedToken(params.stricted, params.message);
            }
            this.context.strict = previousStrict;
            this.context.allowStrictDirective = previousAllowStrictDirective;
            return body;
          };
          Parser2.prototype.parsePropertyMethodFunction = function() {
            var isGenerator = false;
            var node = this.createNode();
            var previousAllowYield = this.context.allowYield;
            this.context.allowYield = true;
            var params = this.parseFormalParameters();
            var method = this.parsePropertyMethod(params);
            this.context.allowYield = previousAllowYield;
            return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
          };
          Parser2.prototype.parsePropertyMethodAsyncFunction = function() {
            var node = this.createNode();
            var previousAllowYield = this.context.allowYield;
            var previousAwait = this.context.await;
            this.context.allowYield = false;
            this.context.await = true;
            var params = this.parseFormalParameters();
            var method = this.parsePropertyMethod(params);
            this.context.allowYield = previousAllowYield;
            this.context.await = previousAwait;
            return this.finalize(node, new Node.AsyncFunctionExpression(null, params.params, method));
          };
          Parser2.prototype.parseObjectPropertyKey = function() {
            var node = this.createNode();
            var token = this.nextToken();
            var key;
            switch (token.type) {
              case 8:
              case 6:
                if (this.context.strict && token.octal) {
                  this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);
                }
                var raw = this.getTokenRaw(token);
                key = this.finalize(node, new Node.Literal(token.value, raw));
                break;
              case 3:
              case 1:
              case 5:
              case 4:
                key = this.finalize(node, new Node.Identifier(token.value));
                break;
              case 7:
                if (token.value === "[") {
                  key = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  this.expect("]");
                } else {
                  key = this.throwUnexpectedToken(token);
                }
                break;
              default:
                key = this.throwUnexpectedToken(token);
            }
            return key;
          };
          Parser2.prototype.isPropertyKey = function(key, value) {
            return key.type === syntax_1.Syntax.Identifier && key.name === value || key.type === syntax_1.Syntax.Literal && key.value === value;
          };
          Parser2.prototype.parseObjectProperty = function(hasProto) {
            var node = this.createNode();
            var token = this.lookahead;
            var kind2;
            var key = null;
            var value = null;
            var computed = false;
            var method = false;
            var shorthand = false;
            var isAsync = false;
            if (token.type === 3) {
              var id = token.value;
              this.nextToken();
              computed = this.match("[");
              isAsync = !this.hasLineTerminator && id === "async" && !this.match(":") && !this.match("(") && !this.match("*") && !this.match(",");
              key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node, new Node.Identifier(id));
            } else if (this.match("*")) {
              this.nextToken();
            } else {
              computed = this.match("[");
              key = this.parseObjectPropertyKey();
            }
            var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
            if (token.type === 3 && !isAsync && token.value === "get" && lookaheadPropertyKey) {
              kind2 = "get";
              computed = this.match("[");
              key = this.parseObjectPropertyKey();
              this.context.allowYield = false;
              value = this.parseGetterMethod();
            } else if (token.type === 3 && !isAsync && token.value === "set" && lookaheadPropertyKey) {
              kind2 = "set";
              computed = this.match("[");
              key = this.parseObjectPropertyKey();
              value = this.parseSetterMethod();
            } else if (token.type === 7 && token.value === "*" && lookaheadPropertyKey) {
              kind2 = "init";
              computed = this.match("[");
              key = this.parseObjectPropertyKey();
              value = this.parseGeneratorMethod();
              method = true;
            } else {
              if (!key) {
                this.throwUnexpectedToken(this.lookahead);
              }
              kind2 = "init";
              if (this.match(":") && !isAsync) {
                if (!computed && this.isPropertyKey(key, "__proto__")) {
                  if (hasProto.value) {
                    this.tolerateError(messages_1.Messages.DuplicateProtoProperty);
                  }
                  hasProto.value = true;
                }
                this.nextToken();
                value = this.inheritCoverGrammar(this.parseAssignmentExpression);
              } else if (this.match("(")) {
                value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
                method = true;
              } else if (token.type === 3) {
                var id = this.finalize(node, new Node.Identifier(token.value));
                if (this.match("=")) {
                  this.context.firstCoverInitializedNameError = this.lookahead;
                  this.nextToken();
                  shorthand = true;
                  var init = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  value = this.finalize(node, new Node.AssignmentPattern(id, init));
                } else {
                  shorthand = true;
                  value = id;
                }
              } else {
                this.throwUnexpectedToken(this.nextToken());
              }
            }
            return this.finalize(node, new Node.Property(kind2, key, computed, value, method, shorthand));
          };
          Parser2.prototype.parseObjectInitializer = function() {
            var node = this.createNode();
            this.expect("{");
            var properties = [];
            var hasProto = { value: false };
            while (!this.match("}")) {
              properties.push(this.parseObjectProperty(hasProto));
              if (!this.match("}")) {
                this.expectCommaSeparator();
              }
            }
            this.expect("}");
            return this.finalize(node, new Node.ObjectExpression(properties));
          };
          Parser2.prototype.parseTemplateHead = function() {
            assert_1.assert(this.lookahead.head, "Template literal must start with a template head");
            var node = this.createNode();
            var token = this.nextToken();
            var raw = token.value;
            var cooked = token.cooked;
            return this.finalize(node, new Node.TemplateElement({ raw, cooked }, token.tail));
          };
          Parser2.prototype.parseTemplateElement = function() {
            if (this.lookahead.type !== 10) {
              this.throwUnexpectedToken();
            }
            var node = this.createNode();
            var token = this.nextToken();
            var raw = token.value;
            var cooked = token.cooked;
            return this.finalize(node, new Node.TemplateElement({ raw, cooked }, token.tail));
          };
          Parser2.prototype.parseTemplateLiteral = function() {
            var node = this.createNode();
            var expressions = [];
            var quasis = [];
            var quasi = this.parseTemplateHead();
            quasis.push(quasi);
            while (!quasi.tail) {
              expressions.push(this.parseExpression());
              quasi = this.parseTemplateElement();
              quasis.push(quasi);
            }
            return this.finalize(node, new Node.TemplateLiteral(quasis, expressions));
          };
          Parser2.prototype.reinterpretExpressionAsPattern = function(expr) {
            switch (expr.type) {
              case syntax_1.Syntax.Identifier:
              case syntax_1.Syntax.MemberExpression:
              case syntax_1.Syntax.RestElement:
              case syntax_1.Syntax.AssignmentPattern:
                break;
              case syntax_1.Syntax.SpreadElement:
                expr.type = syntax_1.Syntax.RestElement;
                this.reinterpretExpressionAsPattern(expr.argument);
                break;
              case syntax_1.Syntax.ArrayExpression:
                expr.type = syntax_1.Syntax.ArrayPattern;
                for (var i2 = 0;i2 < expr.elements.length; i2++) {
                  if (expr.elements[i2] !== null) {
                    this.reinterpretExpressionAsPattern(expr.elements[i2]);
                  }
                }
                break;
              case syntax_1.Syntax.ObjectExpression:
                expr.type = syntax_1.Syntax.ObjectPattern;
                for (var i2 = 0;i2 < expr.properties.length; i2++) {
                  this.reinterpretExpressionAsPattern(expr.properties[i2].value);
                }
                break;
              case syntax_1.Syntax.AssignmentExpression:
                expr.type = syntax_1.Syntax.AssignmentPattern;
                delete expr.operator;
                this.reinterpretExpressionAsPattern(expr.left);
                break;
              default:
                break;
            }
          };
          Parser2.prototype.parseGroupExpression = function() {
            var expr;
            this.expect("(");
            if (this.match(")")) {
              this.nextToken();
              if (!this.match("=>")) {
                this.expect("=>");
              }
              expr = {
                type: ArrowParameterPlaceHolder,
                params: [],
                async: false
              };
            } else {
              var startToken = this.lookahead;
              var params = [];
              if (this.match("...")) {
                expr = this.parseRestElement(params);
                this.expect(")");
                if (!this.match("=>")) {
                  this.expect("=>");
                }
                expr = {
                  type: ArrowParameterPlaceHolder,
                  params: [expr],
                  async: false
                };
              } else {
                var arrow = false;
                this.context.isBindingElement = true;
                expr = this.inheritCoverGrammar(this.parseAssignmentExpression);
                if (this.match(",")) {
                  var expressions = [];
                  this.context.isAssignmentTarget = false;
                  expressions.push(expr);
                  while (this.lookahead.type !== 2) {
                    if (!this.match(",")) {
                      break;
                    }
                    this.nextToken();
                    if (this.match(")")) {
                      this.nextToken();
                      for (var i2 = 0;i2 < expressions.length; i2++) {
                        this.reinterpretExpressionAsPattern(expressions[i2]);
                      }
                      arrow = true;
                      expr = {
                        type: ArrowParameterPlaceHolder,
                        params: expressions,
                        async: false
                      };
                    } else if (this.match("...")) {
                      if (!this.context.isBindingElement) {
                        this.throwUnexpectedToken(this.lookahead);
                      }
                      expressions.push(this.parseRestElement(params));
                      this.expect(")");
                      if (!this.match("=>")) {
                        this.expect("=>");
                      }
                      this.context.isBindingElement = false;
                      for (var i2 = 0;i2 < expressions.length; i2++) {
                        this.reinterpretExpressionAsPattern(expressions[i2]);
                      }
                      arrow = true;
                      expr = {
                        type: ArrowParameterPlaceHolder,
                        params: expressions,
                        async: false
                      };
                    } else {
                      expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                    }
                    if (arrow) {
                      break;
                    }
                  }
                  if (!arrow) {
                    expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
                  }
                }
                if (!arrow) {
                  this.expect(")");
                  if (this.match("=>")) {
                    if (expr.type === syntax_1.Syntax.Identifier && expr.name === "yield") {
                      arrow = true;
                      expr = {
                        type: ArrowParameterPlaceHolder,
                        params: [expr],
                        async: false
                      };
                    }
                    if (!arrow) {
                      if (!this.context.isBindingElement) {
                        this.throwUnexpectedToken(this.lookahead);
                      }
                      if (expr.type === syntax_1.Syntax.SequenceExpression) {
                        for (var i2 = 0;i2 < expr.expressions.length; i2++) {
                          this.reinterpretExpressionAsPattern(expr.expressions[i2]);
                        }
                      } else {
                        this.reinterpretExpressionAsPattern(expr);
                      }
                      var parameters = expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr];
                      expr = {
                        type: ArrowParameterPlaceHolder,
                        params: parameters,
                        async: false
                      };
                    }
                  }
                  this.context.isBindingElement = false;
                }
              }
            }
            return expr;
          };
          Parser2.prototype.parseArguments = function() {
            this.expect("(");
            var args = [];
            if (!this.match(")")) {
              while (true) {
                var expr = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAssignmentExpression);
                args.push(expr);
                if (this.match(")")) {
                  break;
                }
                this.expectCommaSeparator();
                if (this.match(")")) {
                  break;
                }
              }
            }
            this.expect(")");
            return args;
          };
          Parser2.prototype.isIdentifierName = function(token) {
            return token.type === 3 || token.type === 4 || token.type === 1 || token.type === 5;
          };
          Parser2.prototype.parseIdentifierName = function() {
            var node = this.createNode();
            var token = this.nextToken();
            if (!this.isIdentifierName(token)) {
              this.throwUnexpectedToken(token);
            }
            return this.finalize(node, new Node.Identifier(token.value));
          };
          Parser2.prototype.parseNewExpression = function() {
            var node = this.createNode();
            var id = this.parseIdentifierName();
            assert_1.assert(id.name === "new", "New expression must start with `new`");
            var expr;
            if (this.match(".")) {
              this.nextToken();
              if (this.lookahead.type === 3 && this.context.inFunctionBody && this.lookahead.value === "target") {
                var property = this.parseIdentifierName();
                expr = new Node.MetaProperty(id, property);
              } else {
                this.throwUnexpectedToken(this.lookahead);
              }
            } else {
              var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
              var args = this.match("(") ? this.parseArguments() : [];
              expr = new Node.NewExpression(callee, args);
              this.context.isAssignmentTarget = false;
              this.context.isBindingElement = false;
            }
            return this.finalize(node, expr);
          };
          Parser2.prototype.parseAsyncArgument = function() {
            var arg = this.parseAssignmentExpression();
            this.context.firstCoverInitializedNameError = null;
            return arg;
          };
          Parser2.prototype.parseAsyncArguments = function() {
            this.expect("(");
            var args = [];
            if (!this.match(")")) {
              while (true) {
                var expr = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAsyncArgument);
                args.push(expr);
                if (this.match(")")) {
                  break;
                }
                this.expectCommaSeparator();
                if (this.match(")")) {
                  break;
                }
              }
            }
            this.expect(")");
            return args;
          };
          Parser2.prototype.parseLeftHandSideExpressionAllowCall = function() {
            var startToken = this.lookahead;
            var maybeAsync = this.matchContextualKeyword("async");
            var previousAllowIn = this.context.allowIn;
            this.context.allowIn = true;
            var expr;
            if (this.matchKeyword("super") && this.context.inFunctionBody) {
              expr = this.createNode();
              this.nextToken();
              expr = this.finalize(expr, new Node.Super);
              if (!this.match("(") && !this.match(".") && !this.match("[")) {
                this.throwUnexpectedToken(this.lookahead);
              }
            } else {
              expr = this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);
            }
            while (true) {
              if (this.match(".")) {
                this.context.isBindingElement = false;
                this.context.isAssignmentTarget = true;
                this.expect(".");
                var property = this.parseIdentifierName();
                expr = this.finalize(this.startNode(startToken), new Node.StaticMemberExpression(expr, property));
              } else if (this.match("(")) {
                var asyncArrow = maybeAsync && startToken.lineNumber === this.lookahead.lineNumber;
                this.context.isBindingElement = false;
                this.context.isAssignmentTarget = false;
                var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
                expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args));
                if (asyncArrow && this.match("=>")) {
                  for (var i2 = 0;i2 < args.length; ++i2) {
                    this.reinterpretExpressionAsPattern(args[i2]);
                  }
                  expr = {
                    type: ArrowParameterPlaceHolder,
                    params: args,
                    async: true
                  };
                }
              } else if (this.match("[")) {
                this.context.isBindingElement = false;
                this.context.isAssignmentTarget = true;
                this.expect("[");
                var property = this.isolateCoverGrammar(this.parseExpression);
                this.expect("]");
                expr = this.finalize(this.startNode(startToken), new Node.ComputedMemberExpression(expr, property));
              } else if (this.lookahead.type === 10 && this.lookahead.head) {
                var quasi = this.parseTemplateLiteral();
                expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));
              } else {
                break;
              }
            }
            this.context.allowIn = previousAllowIn;
            return expr;
          };
          Parser2.prototype.parseSuper = function() {
            var node = this.createNode();
            this.expectKeyword("super");
            if (!this.match("[") && !this.match(".")) {
              this.throwUnexpectedToken(this.lookahead);
            }
            return this.finalize(node, new Node.Super);
          };
          Parser2.prototype.parseLeftHandSideExpression = function() {
            assert_1.assert(this.context.allowIn, "callee of new expression always allow in keyword.");
            var node = this.startNode(this.lookahead);
            var expr = this.matchKeyword("super") && this.context.inFunctionBody ? this.parseSuper() : this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);
            while (true) {
              if (this.match("[")) {
                this.context.isBindingElement = false;
                this.context.isAssignmentTarget = true;
                this.expect("[");
                var property = this.isolateCoverGrammar(this.parseExpression);
                this.expect("]");
                expr = this.finalize(node, new Node.ComputedMemberExpression(expr, property));
              } else if (this.match(".")) {
                this.context.isBindingElement = false;
                this.context.isAssignmentTarget = true;
                this.expect(".");
                var property = this.parseIdentifierName();
                expr = this.finalize(node, new Node.StaticMemberExpression(expr, property));
              } else if (this.lookahead.type === 10 && this.lookahead.head) {
                var quasi = this.parseTemplateLiteral();
                expr = this.finalize(node, new Node.TaggedTemplateExpression(expr, quasi));
              } else {
                break;
              }
            }
            return expr;
          };
          Parser2.prototype.parseUpdateExpression = function() {
            var expr;
            var startToken = this.lookahead;
            if (this.match("++") || this.match("--")) {
              var node = this.startNode(startToken);
              var token = this.nextToken();
              expr = this.inheritCoverGrammar(this.parseUnaryExpression);
              if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
                this.tolerateError(messages_1.Messages.StrictLHSPrefix);
              }
              if (!this.context.isAssignmentTarget) {
                this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
              }
              var prefix = true;
              expr = this.finalize(node, new Node.UpdateExpression(token.value, expr, prefix));
              this.context.isAssignmentTarget = false;
              this.context.isBindingElement = false;
            } else {
              expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
              if (!this.hasLineTerminator && this.lookahead.type === 7) {
                if (this.match("++") || this.match("--")) {
                  if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
                    this.tolerateError(messages_1.Messages.StrictLHSPostfix);
                  }
                  if (!this.context.isAssignmentTarget) {
                    this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                  }
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                  var operator = this.nextToken().value;
                  var prefix = false;
                  expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator, expr, prefix));
                }
              }
            }
            return expr;
          };
          Parser2.prototype.parseAwaitExpression = function() {
            var node = this.createNode();
            this.nextToken();
            var argument = this.parseUnaryExpression();
            return this.finalize(node, new Node.AwaitExpression(argument));
          };
          Parser2.prototype.parseUnaryExpression = function() {
            var expr;
            if (this.match("+") || this.match("-") || this.match("~") || this.match("!") || this.matchKeyword("delete") || this.matchKeyword("void") || this.matchKeyword("typeof")) {
              var node = this.startNode(this.lookahead);
              var token = this.nextToken();
              expr = this.inheritCoverGrammar(this.parseUnaryExpression);
              expr = this.finalize(node, new Node.UnaryExpression(token.value, expr));
              if (this.context.strict && expr.operator === "delete" && expr.argument.type === syntax_1.Syntax.Identifier) {
                this.tolerateError(messages_1.Messages.StrictDelete);
              }
              this.context.isAssignmentTarget = false;
              this.context.isBindingElement = false;
            } else if (this.context.await && this.matchContextualKeyword("await")) {
              expr = this.parseAwaitExpression();
            } else {
              expr = this.parseUpdateExpression();
            }
            return expr;
          };
          Parser2.prototype.parseExponentiationExpression = function() {
            var startToken = this.lookahead;
            var expr = this.inheritCoverGrammar(this.parseUnaryExpression);
            if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match("**")) {
              this.nextToken();
              this.context.isAssignmentTarget = false;
              this.context.isBindingElement = false;
              var left = expr;
              var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
              expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression("**", left, right));
            }
            return expr;
          };
          Parser2.prototype.binaryPrecedence = function(token) {
            var op = token.value;
            var precedence;
            if (token.type === 7) {
              precedence = this.operatorPrecedence[op] || 0;
            } else if (token.type === 4) {
              precedence = op === "instanceof" || this.context.allowIn && op === "in" ? 7 : 0;
            } else {
              precedence = 0;
            }
            return precedence;
          };
          Parser2.prototype.parseBinaryExpression = function() {
            var startToken = this.lookahead;
            var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);
            var token = this.lookahead;
            var prec = this.binaryPrecedence(token);
            if (prec > 0) {
              this.nextToken();
              this.context.isAssignmentTarget = false;
              this.context.isBindingElement = false;
              var markers = [startToken, this.lookahead];
              var left = expr;
              var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
              var stack = [left, token.value, right];
              var precedences = [prec];
              while (true) {
                prec = this.binaryPrecedence(this.lookahead);
                if (prec <= 0) {
                  break;
                }
                while (stack.length > 2 && prec <= precedences[precedences.length - 1]) {
                  right = stack.pop();
                  var operator = stack.pop();
                  precedences.pop();
                  left = stack.pop();
                  markers.pop();
                  var node = this.startNode(markers[markers.length - 1]);
                  stack.push(this.finalize(node, new Node.BinaryExpression(operator, left, right)));
                }
                stack.push(this.nextToken().value);
                precedences.push(prec);
                markers.push(this.lookahead);
                stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
              }
              var i2 = stack.length - 1;
              expr = stack[i2];
              var lastMarker = markers.pop();
              while (i2 > 1) {
                var marker = markers.pop();
                var lastLineStart = lastMarker && lastMarker.lineStart;
                var node = this.startNode(marker, lastLineStart);
                var operator = stack[i2 - 1];
                expr = this.finalize(node, new Node.BinaryExpression(operator, stack[i2 - 2], expr));
                i2 -= 2;
                lastMarker = marker;
              }
            }
            return expr;
          };
          Parser2.prototype.parseConditionalExpression = function() {
            var startToken = this.lookahead;
            var expr = this.inheritCoverGrammar(this.parseBinaryExpression);
            if (this.match("?")) {
              this.nextToken();
              var previousAllowIn = this.context.allowIn;
              this.context.allowIn = true;
              var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
              this.context.allowIn = previousAllowIn;
              this.expect(":");
              var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
              expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate));
              this.context.isAssignmentTarget = false;
              this.context.isBindingElement = false;
            }
            return expr;
          };
          Parser2.prototype.checkPatternParam = function(options2, param) {
            switch (param.type) {
              case syntax_1.Syntax.Identifier:
                this.validateParam(options2, param, param.name);
                break;
              case syntax_1.Syntax.RestElement:
                this.checkPatternParam(options2, param.argument);
                break;
              case syntax_1.Syntax.AssignmentPattern:
                this.checkPatternParam(options2, param.left);
                break;
              case syntax_1.Syntax.ArrayPattern:
                for (var i2 = 0;i2 < param.elements.length; i2++) {
                  if (param.elements[i2] !== null) {
                    this.checkPatternParam(options2, param.elements[i2]);
                  }
                }
                break;
              case syntax_1.Syntax.ObjectPattern:
                for (var i2 = 0;i2 < param.properties.length; i2++) {
                  this.checkPatternParam(options2, param.properties[i2].value);
                }
                break;
              default:
                break;
            }
            options2.simple = options2.simple && param instanceof Node.Identifier;
          };
          Parser2.prototype.reinterpretAsCoverFormalsList = function(expr) {
            var params = [expr];
            var options2;
            var asyncArrow = false;
            switch (expr.type) {
              case syntax_1.Syntax.Identifier:
                break;
              case ArrowParameterPlaceHolder:
                params = expr.params;
                asyncArrow = expr.async;
                break;
              default:
                return null;
            }
            options2 = {
              simple: true,
              paramSet: {}
            };
            for (var i2 = 0;i2 < params.length; ++i2) {
              var param = params[i2];
              if (param.type === syntax_1.Syntax.AssignmentPattern) {
                if (param.right.type === syntax_1.Syntax.YieldExpression) {
                  if (param.right.argument) {
                    this.throwUnexpectedToken(this.lookahead);
                  }
                  param.right.type = syntax_1.Syntax.Identifier;
                  param.right.name = "yield";
                  delete param.right.argument;
                  delete param.right.delegate;
                }
              } else if (asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === "await") {
                this.throwUnexpectedToken(this.lookahead);
              }
              this.checkPatternParam(options2, param);
              params[i2] = param;
            }
            if (this.context.strict || !this.context.allowYield) {
              for (var i2 = 0;i2 < params.length; ++i2) {
                var param = params[i2];
                if (param.type === syntax_1.Syntax.YieldExpression) {
                  this.throwUnexpectedToken(this.lookahead);
                }
              }
            }
            if (options2.message === messages_1.Messages.StrictParamDupe) {
              var token = this.context.strict ? options2.stricted : options2.firstRestricted;
              this.throwUnexpectedToken(token, options2.message);
            }
            return {
              simple: options2.simple,
              params,
              stricted: options2.stricted,
              firstRestricted: options2.firstRestricted,
              message: options2.message
            };
          };
          Parser2.prototype.parseAssignmentExpression = function() {
            var expr;
            if (!this.context.allowYield && this.matchKeyword("yield")) {
              expr = this.parseYieldExpression();
            } else {
              var startToken = this.lookahead;
              var token = startToken;
              expr = this.parseConditionalExpression();
              if (token.type === 3 && token.lineNumber === this.lookahead.lineNumber && token.value === "async") {
                if (this.lookahead.type === 3 || this.matchKeyword("yield")) {
                  var arg = this.parsePrimaryExpression();
                  this.reinterpretExpressionAsPattern(arg);
                  expr = {
                    type: ArrowParameterPlaceHolder,
                    params: [arg],
                    async: true
                  };
                }
              }
              if (expr.type === ArrowParameterPlaceHolder || this.match("=>")) {
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
                var isAsync = expr.async;
                var list = this.reinterpretAsCoverFormalsList(expr);
                if (list) {
                  if (this.hasLineTerminator) {
                    this.tolerateUnexpectedToken(this.lookahead);
                  }
                  this.context.firstCoverInitializedNameError = null;
                  var previousStrict = this.context.strict;
                  var previousAllowStrictDirective = this.context.allowStrictDirective;
                  this.context.allowStrictDirective = list.simple;
                  var previousAllowYield = this.context.allowYield;
                  var previousAwait = this.context.await;
                  this.context.allowYield = true;
                  this.context.await = isAsync;
                  var node = this.startNode(startToken);
                  this.expect("=>");
                  var body = undefined;
                  if (this.match("{")) {
                    var previousAllowIn = this.context.allowIn;
                    this.context.allowIn = true;
                    body = this.parseFunctionSourceElements();
                    this.context.allowIn = previousAllowIn;
                  } else {
                    body = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  }
                  var expression = body.type !== syntax_1.Syntax.BlockStatement;
                  if (this.context.strict && list.firstRestricted) {
                    this.throwUnexpectedToken(list.firstRestricted, list.message);
                  }
                  if (this.context.strict && list.stricted) {
                    this.tolerateUnexpectedToken(list.stricted, list.message);
                  }
                  expr = isAsync ? this.finalize(node, new Node.AsyncArrowFunctionExpression(list.params, body, expression)) : this.finalize(node, new Node.ArrowFunctionExpression(list.params, body, expression));
                  this.context.strict = previousStrict;
                  this.context.allowStrictDirective = previousAllowStrictDirective;
                  this.context.allowYield = previousAllowYield;
                  this.context.await = previousAwait;
                }
              } else {
                if (this.matchAssign()) {
                  if (!this.context.isAssignmentTarget) {
                    this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                  }
                  if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
                    var id = expr;
                    if (this.scanner.isRestrictedWord(id.name)) {
                      this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);
                    }
                    if (this.scanner.isStrictModeReservedWord(id.name)) {
                      this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
                    }
                  }
                  if (!this.match("=")) {
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                  } else {
                    this.reinterpretExpressionAsPattern(expr);
                  }
                  token = this.nextToken();
                  var operator = token.value;
                  var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(operator, expr, right));
                  this.context.firstCoverInitializedNameError = null;
                }
              }
            }
            return expr;
          };
          Parser2.prototype.parseExpression = function() {
            var startToken = this.lookahead;
            var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
            if (this.match(",")) {
              var expressions = [];
              expressions.push(expr);
              while (this.lookahead.type !== 2) {
                if (!this.match(",")) {
                  break;
                }
                this.nextToken();
                expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
              }
              expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
            }
            return expr;
          };
          Parser2.prototype.parseStatementListItem = function() {
            var statement;
            this.context.isAssignmentTarget = true;
            this.context.isBindingElement = true;
            if (this.lookahead.type === 4) {
              switch (this.lookahead.value) {
                case "export":
                  if (!this.context.isModule) {
                    this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);
                  }
                  statement = this.parseExportDeclaration();
                  break;
                case "import":
                  if (!this.context.isModule) {
                    this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);
                  }
                  statement = this.parseImportDeclaration();
                  break;
                case "const":
                  statement = this.parseLexicalDeclaration({ inFor: false });
                  break;
                case "function":
                  statement = this.parseFunctionDeclaration();
                  break;
                case "class":
                  statement = this.parseClassDeclaration();
                  break;
                case "let":
                  statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();
                  break;
                default:
                  statement = this.parseStatement();
                  break;
              }
            } else {
              statement = this.parseStatement();
            }
            return statement;
          };
          Parser2.prototype.parseBlock = function() {
            var node = this.createNode();
            this.expect("{");
            var block2 = [];
            while (true) {
              if (this.match("}")) {
                break;
              }
              block2.push(this.parseStatementListItem());
            }
            this.expect("}");
            return this.finalize(node, new Node.BlockStatement(block2));
          };
          Parser2.prototype.parseLexicalBinding = function(kind2, options2) {
            var node = this.createNode();
            var params = [];
            var id = this.parsePattern(params, kind2);
            if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
              if (this.scanner.isRestrictedWord(id.name)) {
                this.tolerateError(messages_1.Messages.StrictVarName);
              }
            }
            var init = null;
            if (kind2 === "const") {
              if (!this.matchKeyword("in") && !this.matchContextualKeyword("of")) {
                if (this.match("=")) {
                  this.nextToken();
                  init = this.isolateCoverGrammar(this.parseAssignmentExpression);
                } else {
                  this.throwError(messages_1.Messages.DeclarationMissingInitializer, "const");
                }
              }
            } else if (!options2.inFor && id.type !== syntax_1.Syntax.Identifier || this.match("=")) {
              this.expect("=");
              init = this.isolateCoverGrammar(this.parseAssignmentExpression);
            }
            return this.finalize(node, new Node.VariableDeclarator(id, init));
          };
          Parser2.prototype.parseBindingList = function(kind2, options2) {
            var list = [this.parseLexicalBinding(kind2, options2)];
            while (this.match(",")) {
              this.nextToken();
              list.push(this.parseLexicalBinding(kind2, options2));
            }
            return list;
          };
          Parser2.prototype.isLexicalDeclaration = function() {
            var state = this.scanner.saveState();
            this.scanner.scanComments();
            var next = this.scanner.lex();
            this.scanner.restoreState(state);
            return next.type === 3 || next.type === 7 && next.value === "[" || next.type === 7 && next.value === "{" || next.type === 4 && next.value === "let" || next.type === 4 && next.value === "yield";
          };
          Parser2.prototype.parseLexicalDeclaration = function(options2) {
            var node = this.createNode();
            var kind2 = this.nextToken().value;
            assert_1.assert(kind2 === "let" || kind2 === "const", "Lexical declaration must be either let or const");
            var declarations = this.parseBindingList(kind2, options2);
            this.consumeSemicolon();
            return this.finalize(node, new Node.VariableDeclaration(declarations, kind2));
          };
          Parser2.prototype.parseBindingRestElement = function(params, kind2) {
            var node = this.createNode();
            this.expect("...");
            var arg = this.parsePattern(params, kind2);
            return this.finalize(node, new Node.RestElement(arg));
          };
          Parser2.prototype.parseArrayPattern = function(params, kind2) {
            var node = this.createNode();
            this.expect("[");
            var elements = [];
            while (!this.match("]")) {
              if (this.match(",")) {
                this.nextToken();
                elements.push(null);
              } else {
                if (this.match("...")) {
                  elements.push(this.parseBindingRestElement(params, kind2));
                  break;
                } else {
                  elements.push(this.parsePatternWithDefault(params, kind2));
                }
                if (!this.match("]")) {
                  this.expect(",");
                }
              }
            }
            this.expect("]");
            return this.finalize(node, new Node.ArrayPattern(elements));
          };
          Parser2.prototype.parsePropertyPattern = function(params, kind2) {
            var node = this.createNode();
            var computed = false;
            var shorthand = false;
            var method = false;
            var key;
            var value;
            if (this.lookahead.type === 3) {
              var keyToken = this.lookahead;
              key = this.parseVariableIdentifier();
              var init = this.finalize(node, new Node.Identifier(keyToken.value));
              if (this.match("=")) {
                params.push(keyToken);
                shorthand = true;
                this.nextToken();
                var expr = this.parseAssignmentExpression();
                value = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init, expr));
              } else if (!this.match(":")) {
                params.push(keyToken);
                shorthand = true;
                value = init;
              } else {
                this.expect(":");
                value = this.parsePatternWithDefault(params, kind2);
              }
            } else {
              computed = this.match("[");
              key = this.parseObjectPropertyKey();
              this.expect(":");
              value = this.parsePatternWithDefault(params, kind2);
            }
            return this.finalize(node, new Node.Property("init", key, computed, value, method, shorthand));
          };
          Parser2.prototype.parseObjectPattern = function(params, kind2) {
            var node = this.createNode();
            var properties = [];
            this.expect("{");
            while (!this.match("}")) {
              properties.push(this.parsePropertyPattern(params, kind2));
              if (!this.match("}")) {
                this.expect(",");
              }
            }
            this.expect("}");
            return this.finalize(node, new Node.ObjectPattern(properties));
          };
          Parser2.prototype.parsePattern = function(params, kind2) {
            var pattern;
            if (this.match("[")) {
              pattern = this.parseArrayPattern(params, kind2);
            } else if (this.match("{")) {
              pattern = this.parseObjectPattern(params, kind2);
            } else {
              if (this.matchKeyword("let") && (kind2 === "const" || kind2 === "let")) {
                this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);
              }
              params.push(this.lookahead);
              pattern = this.parseVariableIdentifier(kind2);
            }
            return pattern;
          };
          Parser2.prototype.parsePatternWithDefault = function(params, kind2) {
            var startToken = this.lookahead;
            var pattern = this.parsePattern(params, kind2);
            if (this.match("=")) {
              this.nextToken();
              var previousAllowYield = this.context.allowYield;
              this.context.allowYield = true;
              var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
              this.context.allowYield = previousAllowYield;
              pattern = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern, right));
            }
            return pattern;
          };
          Parser2.prototype.parseVariableIdentifier = function(kind2) {
            var node = this.createNode();
            var token = this.nextToken();
            if (token.type === 4 && token.value === "yield") {
              if (this.context.strict) {
                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
              } else if (!this.context.allowYield) {
                this.throwUnexpectedToken(token);
              }
            } else if (token.type !== 3) {
              if (this.context.strict && token.type === 4 && this.scanner.isStrictModeReservedWord(token.value)) {
                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
              } else {
                if (this.context.strict || token.value !== "let" || kind2 !== "var") {
                  this.throwUnexpectedToken(token);
                }
              }
            } else if ((this.context.isModule || this.context.await) && token.type === 3 && token.value === "await") {
              this.tolerateUnexpectedToken(token);
            }
            return this.finalize(node, new Node.Identifier(token.value));
          };
          Parser2.prototype.parseVariableDeclaration = function(options2) {
            var node = this.createNode();
            var params = [];
            var id = this.parsePattern(params, "var");
            if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
              if (this.scanner.isRestrictedWord(id.name)) {
                this.tolerateError(messages_1.Messages.StrictVarName);
              }
            }
            var init = null;
            if (this.match("=")) {
              this.nextToken();
              init = this.isolateCoverGrammar(this.parseAssignmentExpression);
            } else if (id.type !== syntax_1.Syntax.Identifier && !options2.inFor) {
              this.expect("=");
            }
            return this.finalize(node, new Node.VariableDeclarator(id, init));
          };
          Parser2.prototype.parseVariableDeclarationList = function(options2) {
            var opt = { inFor: options2.inFor };
            var list = [];
            list.push(this.parseVariableDeclaration(opt));
            while (this.match(",")) {
              this.nextToken();
              list.push(this.parseVariableDeclaration(opt));
            }
            return list;
          };
          Parser2.prototype.parseVariableStatement = function() {
            var node = this.createNode();
            this.expectKeyword("var");
            var declarations = this.parseVariableDeclarationList({ inFor: false });
            this.consumeSemicolon();
            return this.finalize(node, new Node.VariableDeclaration(declarations, "var"));
          };
          Parser2.prototype.parseEmptyStatement = function() {
            var node = this.createNode();
            this.expect(";");
            return this.finalize(node, new Node.EmptyStatement);
          };
          Parser2.prototype.parseExpressionStatement = function() {
            var node = this.createNode();
            var expr = this.parseExpression();
            this.consumeSemicolon();
            return this.finalize(node, new Node.ExpressionStatement(expr));
          };
          Parser2.prototype.parseIfClause = function() {
            if (this.context.strict && this.matchKeyword("function")) {
              this.tolerateError(messages_1.Messages.StrictFunction);
            }
            return this.parseStatement();
          };
          Parser2.prototype.parseIfStatement = function() {
            var node = this.createNode();
            var consequent;
            var alternate = null;
            this.expectKeyword("if");
            this.expect("(");
            var test = this.parseExpression();
            if (!this.match(")") && this.config.tolerant) {
              this.tolerateUnexpectedToken(this.nextToken());
              consequent = this.finalize(this.createNode(), new Node.EmptyStatement);
            } else {
              this.expect(")");
              consequent = this.parseIfClause();
              if (this.matchKeyword("else")) {
                this.nextToken();
                alternate = this.parseIfClause();
              }
            }
            return this.finalize(node, new Node.IfStatement(test, consequent, alternate));
          };
          Parser2.prototype.parseDoWhileStatement = function() {
            var node = this.createNode();
            this.expectKeyword("do");
            var previousInIteration = this.context.inIteration;
            this.context.inIteration = true;
            var body = this.parseStatement();
            this.context.inIteration = previousInIteration;
            this.expectKeyword("while");
            this.expect("(");
            var test = this.parseExpression();
            if (!this.match(")") && this.config.tolerant) {
              this.tolerateUnexpectedToken(this.nextToken());
            } else {
              this.expect(")");
              if (this.match(";")) {
                this.nextToken();
              }
            }
            return this.finalize(node, new Node.DoWhileStatement(body, test));
          };
          Parser2.prototype.parseWhileStatement = function() {
            var node = this.createNode();
            var body;
            this.expectKeyword("while");
            this.expect("(");
            var test = this.parseExpression();
            if (!this.match(")") && this.config.tolerant) {
              this.tolerateUnexpectedToken(this.nextToken());
              body = this.finalize(this.createNode(), new Node.EmptyStatement);
            } else {
              this.expect(")");
              var previousInIteration = this.context.inIteration;
              this.context.inIteration = true;
              body = this.parseStatement();
              this.context.inIteration = previousInIteration;
            }
            return this.finalize(node, new Node.WhileStatement(test, body));
          };
          Parser2.prototype.parseForStatement = function() {
            var init = null;
            var test = null;
            var update = null;
            var forIn = true;
            var left, right;
            var node = this.createNode();
            this.expectKeyword("for");
            this.expect("(");
            if (this.match(";")) {
              this.nextToken();
            } else {
              if (this.matchKeyword("var")) {
                init = this.createNode();
                this.nextToken();
                var previousAllowIn = this.context.allowIn;
                this.context.allowIn = false;
                var declarations = this.parseVariableDeclarationList({ inFor: true });
                this.context.allowIn = previousAllowIn;
                if (declarations.length === 1 && this.matchKeyword("in")) {
                  var decl = declarations[0];
                  if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {
                    this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, "for-in");
                  }
                  init = this.finalize(init, new Node.VariableDeclaration(declarations, "var"));
                  this.nextToken();
                  left = init;
                  right = this.parseExpression();
                  init = null;
                } else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of")) {
                  init = this.finalize(init, new Node.VariableDeclaration(declarations, "var"));
                  this.nextToken();
                  left = init;
                  right = this.parseAssignmentExpression();
                  init = null;
                  forIn = false;
                } else {
                  init = this.finalize(init, new Node.VariableDeclaration(declarations, "var"));
                  this.expect(";");
                }
              } else if (this.matchKeyword("const") || this.matchKeyword("let")) {
                init = this.createNode();
                var kind2 = this.nextToken().value;
                if (!this.context.strict && this.lookahead.value === "in") {
                  init = this.finalize(init, new Node.Identifier(kind2));
                  this.nextToken();
                  left = init;
                  right = this.parseExpression();
                  init = null;
                } else {
                  var previousAllowIn = this.context.allowIn;
                  this.context.allowIn = false;
                  var declarations = this.parseBindingList(kind2, { inFor: true });
                  this.context.allowIn = previousAllowIn;
                  if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword("in")) {
                    init = this.finalize(init, new Node.VariableDeclaration(declarations, kind2));
                    this.nextToken();
                    left = init;
                    right = this.parseExpression();
                    init = null;
                  } else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of")) {
                    init = this.finalize(init, new Node.VariableDeclaration(declarations, kind2));
                    this.nextToken();
                    left = init;
                    right = this.parseAssignmentExpression();
                    init = null;
                    forIn = false;
                  } else {
                    this.consumeSemicolon();
                    init = this.finalize(init, new Node.VariableDeclaration(declarations, kind2));
                  }
                }
              } else {
                var initStartToken = this.lookahead;
                var previousAllowIn = this.context.allowIn;
                this.context.allowIn = false;
                init = this.inheritCoverGrammar(this.parseAssignmentExpression);
                this.context.allowIn = previousAllowIn;
                if (this.matchKeyword("in")) {
                  if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
                    this.tolerateError(messages_1.Messages.InvalidLHSInForIn);
                  }
                  this.nextToken();
                  this.reinterpretExpressionAsPattern(init);
                  left = init;
                  right = this.parseExpression();
                  init = null;
                } else if (this.matchContextualKeyword("of")) {
                  if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
                    this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);
                  }
                  this.nextToken();
                  this.reinterpretExpressionAsPattern(init);
                  left = init;
                  right = this.parseAssignmentExpression();
                  init = null;
                  forIn = false;
                } else {
                  if (this.match(",")) {
                    var initSeq = [init];
                    while (this.match(",")) {
                      this.nextToken();
                      initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                    }
                    init = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));
                  }
                  this.expect(";");
                }
              }
            }
            if (typeof left === "undefined") {
              if (!this.match(";")) {
                test = this.parseExpression();
              }
              this.expect(";");
              if (!this.match(")")) {
                update = this.parseExpression();
              }
            }
            var body;
            if (!this.match(")") && this.config.tolerant) {
              this.tolerateUnexpectedToken(this.nextToken());
              body = this.finalize(this.createNode(), new Node.EmptyStatement);
            } else {
              this.expect(")");
              var previousInIteration = this.context.inIteration;
              this.context.inIteration = true;
              body = this.isolateCoverGrammar(this.parseStatement);
              this.context.inIteration = previousInIteration;
            }
            return typeof left === "undefined" ? this.finalize(node, new Node.ForStatement(init, test, update, body)) : forIn ? this.finalize(node, new Node.ForInStatement(left, right, body)) : this.finalize(node, new Node.ForOfStatement(left, right, body));
          };
          Parser2.prototype.parseContinueStatement = function() {
            var node = this.createNode();
            this.expectKeyword("continue");
            var label = null;
            if (this.lookahead.type === 3 && !this.hasLineTerminator) {
              var id = this.parseVariableIdentifier();
              label = id;
              var key = "$" + id.name;
              if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                this.throwError(messages_1.Messages.UnknownLabel, id.name);
              }
            }
            this.consumeSemicolon();
            if (label === null && !this.context.inIteration) {
              this.throwError(messages_1.Messages.IllegalContinue);
            }
            return this.finalize(node, new Node.ContinueStatement(label));
          };
          Parser2.prototype.parseBreakStatement = function() {
            var node = this.createNode();
            this.expectKeyword("break");
            var label = null;
            if (this.lookahead.type === 3 && !this.hasLineTerminator) {
              var id = this.parseVariableIdentifier();
              var key = "$" + id.name;
              if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                this.throwError(messages_1.Messages.UnknownLabel, id.name);
              }
              label = id;
            }
            this.consumeSemicolon();
            if (label === null && !this.context.inIteration && !this.context.inSwitch) {
              this.throwError(messages_1.Messages.IllegalBreak);
            }
            return this.finalize(node, new Node.BreakStatement(label));
          };
          Parser2.prototype.parseReturnStatement = function() {
            if (!this.context.inFunctionBody) {
              this.tolerateError(messages_1.Messages.IllegalReturn);
            }
            var node = this.createNode();
            this.expectKeyword("return");
            var hasArgument = !this.match(";") && !this.match("}") && !this.hasLineTerminator && this.lookahead.type !== 2 || this.lookahead.type === 8 || this.lookahead.type === 10;
            var argument = hasArgument ? this.parseExpression() : null;
            this.consumeSemicolon();
            return this.finalize(node, new Node.ReturnStatement(argument));
          };
          Parser2.prototype.parseWithStatement = function() {
            if (this.context.strict) {
              this.tolerateError(messages_1.Messages.StrictModeWith);
            }
            var node = this.createNode();
            var body;
            this.expectKeyword("with");
            this.expect("(");
            var object = this.parseExpression();
            if (!this.match(")") && this.config.tolerant) {
              this.tolerateUnexpectedToken(this.nextToken());
              body = this.finalize(this.createNode(), new Node.EmptyStatement);
            } else {
              this.expect(")");
              body = this.parseStatement();
            }
            return this.finalize(node, new Node.WithStatement(object, body));
          };
          Parser2.prototype.parseSwitchCase = function() {
            var node = this.createNode();
            var test;
            if (this.matchKeyword("default")) {
              this.nextToken();
              test = null;
            } else {
              this.expectKeyword("case");
              test = this.parseExpression();
            }
            this.expect(":");
            var consequent = [];
            while (true) {
              if (this.match("}") || this.matchKeyword("default") || this.matchKeyword("case")) {
                break;
              }
              consequent.push(this.parseStatementListItem());
            }
            return this.finalize(node, new Node.SwitchCase(test, consequent));
          };
          Parser2.prototype.parseSwitchStatement = function() {
            var node = this.createNode();
            this.expectKeyword("switch");
            this.expect("(");
            var discriminant = this.parseExpression();
            this.expect(")");
            var previousInSwitch = this.context.inSwitch;
            this.context.inSwitch = true;
            var cases = [];
            var defaultFound = false;
            this.expect("{");
            while (true) {
              if (this.match("}")) {
                break;
              }
              var clause = this.parseSwitchCase();
              if (clause.test === null) {
                if (defaultFound) {
                  this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);
                }
                defaultFound = true;
              }
              cases.push(clause);
            }
            this.expect("}");
            this.context.inSwitch = previousInSwitch;
            return this.finalize(node, new Node.SwitchStatement(discriminant, cases));
          };
          Parser2.prototype.parseLabelledStatement = function() {
            var node = this.createNode();
            var expr = this.parseExpression();
            var statement;
            if (expr.type === syntax_1.Syntax.Identifier && this.match(":")) {
              this.nextToken();
              var id = expr;
              var key = "$" + id.name;
              if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                this.throwError(messages_1.Messages.Redeclaration, "Label", id.name);
              }
              this.context.labelSet[key] = true;
              var body = undefined;
              if (this.matchKeyword("class")) {
                this.tolerateUnexpectedToken(this.lookahead);
                body = this.parseClassDeclaration();
              } else if (this.matchKeyword("function")) {
                var token = this.lookahead;
                var declaration = this.parseFunctionDeclaration();
                if (this.context.strict) {
                  this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction);
                } else if (declaration.generator) {
                  this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext);
                }
                body = declaration;
              } else {
                body = this.parseStatement();
              }
              delete this.context.labelSet[key];
              statement = new Node.LabeledStatement(id, body);
            } else {
              this.consumeSemicolon();
              statement = new Node.ExpressionStatement(expr);
            }
            return this.finalize(node, statement);
          };
          Parser2.prototype.parseThrowStatement = function() {
            var node = this.createNode();
            this.expectKeyword("throw");
            if (this.hasLineTerminator) {
              this.throwError(messages_1.Messages.NewlineAfterThrow);
            }
            var argument = this.parseExpression();
            this.consumeSemicolon();
            return this.finalize(node, new Node.ThrowStatement(argument));
          };
          Parser2.prototype.parseCatchClause = function() {
            var node = this.createNode();
            this.expectKeyword("catch");
            this.expect("(");
            if (this.match(")")) {
              this.throwUnexpectedToken(this.lookahead);
            }
            var params = [];
            var param = this.parsePattern(params);
            var paramMap = {};
            for (var i2 = 0;i2 < params.length; i2++) {
              var key = "$" + params[i2].value;
              if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
                this.tolerateError(messages_1.Messages.DuplicateBinding, params[i2].value);
              }
              paramMap[key] = true;
            }
            if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {
              if (this.scanner.isRestrictedWord(param.name)) {
                this.tolerateError(messages_1.Messages.StrictCatchVariable);
              }
            }
            this.expect(")");
            var body = this.parseBlock();
            return this.finalize(node, new Node.CatchClause(param, body));
          };
          Parser2.prototype.parseFinallyClause = function() {
            this.expectKeyword("finally");
            return this.parseBlock();
          };
          Parser2.prototype.parseTryStatement = function() {
            var node = this.createNode();
            this.expectKeyword("try");
            var block2 = this.parseBlock();
            var handler = this.matchKeyword("catch") ? this.parseCatchClause() : null;
            var finalizer = this.matchKeyword("finally") ? this.parseFinallyClause() : null;
            if (!handler && !finalizer) {
              this.throwError(messages_1.Messages.NoCatchOrFinally);
            }
            return this.finalize(node, new Node.TryStatement(block2, handler, finalizer));
          };
          Parser2.prototype.parseDebuggerStatement = function() {
            var node = this.createNode();
            this.expectKeyword("debugger");
            this.consumeSemicolon();
            return this.finalize(node, new Node.DebuggerStatement);
          };
          Parser2.prototype.parseStatement = function() {
            var statement;
            switch (this.lookahead.type) {
              case 1:
              case 5:
              case 6:
              case 8:
              case 10:
              case 9:
                statement = this.parseExpressionStatement();
                break;
              case 7:
                var value = this.lookahead.value;
                if (value === "{") {
                  statement = this.parseBlock();
                } else if (value === "(") {
                  statement = this.parseExpressionStatement();
                } else if (value === ";") {
                  statement = this.parseEmptyStatement();
                } else {
                  statement = this.parseExpressionStatement();
                }
                break;
              case 3:
                statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
                break;
              case 4:
                switch (this.lookahead.value) {
                  case "break":
                    statement = this.parseBreakStatement();
                    break;
                  case "continue":
                    statement = this.parseContinueStatement();
                    break;
                  case "debugger":
                    statement = this.parseDebuggerStatement();
                    break;
                  case "do":
                    statement = this.parseDoWhileStatement();
                    break;
                  case "for":
                    statement = this.parseForStatement();
                    break;
                  case "function":
                    statement = this.parseFunctionDeclaration();
                    break;
                  case "if":
                    statement = this.parseIfStatement();
                    break;
                  case "return":
                    statement = this.parseReturnStatement();
                    break;
                  case "switch":
                    statement = this.parseSwitchStatement();
                    break;
                  case "throw":
                    statement = this.parseThrowStatement();
                    break;
                  case "try":
                    statement = this.parseTryStatement();
                    break;
                  case "var":
                    statement = this.parseVariableStatement();
                    break;
                  case "while":
                    statement = this.parseWhileStatement();
                    break;
                  case "with":
                    statement = this.parseWithStatement();
                    break;
                  default:
                    statement = this.parseExpressionStatement();
                    break;
                }
                break;
              default:
                statement = this.throwUnexpectedToken(this.lookahead);
            }
            return statement;
          };
          Parser2.prototype.parseFunctionSourceElements = function() {
            var node = this.createNode();
            this.expect("{");
            var body = this.parseDirectivePrologues();
            var previousLabelSet = this.context.labelSet;
            var previousInIteration = this.context.inIteration;
            var previousInSwitch = this.context.inSwitch;
            var previousInFunctionBody = this.context.inFunctionBody;
            this.context.labelSet = {};
            this.context.inIteration = false;
            this.context.inSwitch = false;
            this.context.inFunctionBody = true;
            while (this.lookahead.type !== 2) {
              if (this.match("}")) {
                break;
              }
              body.push(this.parseStatementListItem());
            }
            this.expect("}");
            this.context.labelSet = previousLabelSet;
            this.context.inIteration = previousInIteration;
            this.context.inSwitch = previousInSwitch;
            this.context.inFunctionBody = previousInFunctionBody;
            return this.finalize(node, new Node.BlockStatement(body));
          };
          Parser2.prototype.validateParam = function(options2, param, name) {
            var key = "$" + name;
            if (this.context.strict) {
              if (this.scanner.isRestrictedWord(name)) {
                options2.stricted = param;
                options2.message = messages_1.Messages.StrictParamName;
              }
              if (Object.prototype.hasOwnProperty.call(options2.paramSet, key)) {
                options2.stricted = param;
                options2.message = messages_1.Messages.StrictParamDupe;
              }
            } else if (!options2.firstRestricted) {
              if (this.scanner.isRestrictedWord(name)) {
                options2.firstRestricted = param;
                options2.message = messages_1.Messages.StrictParamName;
              } else if (this.scanner.isStrictModeReservedWord(name)) {
                options2.firstRestricted = param;
                options2.message = messages_1.Messages.StrictReservedWord;
              } else if (Object.prototype.hasOwnProperty.call(options2.paramSet, key)) {
                options2.stricted = param;
                options2.message = messages_1.Messages.StrictParamDupe;
              }
            }
            if (typeof Object.defineProperty === "function") {
              Object.defineProperty(options2.paramSet, key, { value: true, enumerable: true, writable: true, configurable: true });
            } else {
              options2.paramSet[key] = true;
            }
          };
          Parser2.prototype.parseRestElement = function(params) {
            var node = this.createNode();
            this.expect("...");
            var arg = this.parsePattern(params);
            if (this.match("=")) {
              this.throwError(messages_1.Messages.DefaultRestParameter);
            }
            if (!this.match(")")) {
              this.throwError(messages_1.Messages.ParameterAfterRestParameter);
            }
            return this.finalize(node, new Node.RestElement(arg));
          };
          Parser2.prototype.parseFormalParameter = function(options2) {
            var params = [];
            var param = this.match("...") ? this.parseRestElement(params) : this.parsePatternWithDefault(params);
            for (var i2 = 0;i2 < params.length; i2++) {
              this.validateParam(options2, params[i2], params[i2].value);
            }
            options2.simple = options2.simple && param instanceof Node.Identifier;
            options2.params.push(param);
          };
          Parser2.prototype.parseFormalParameters = function(firstRestricted) {
            var options2;
            options2 = {
              simple: true,
              params: [],
              firstRestricted
            };
            this.expect("(");
            if (!this.match(")")) {
              options2.paramSet = {};
              while (this.lookahead.type !== 2) {
                this.parseFormalParameter(options2);
                if (this.match(")")) {
                  break;
                }
                this.expect(",");
                if (this.match(")")) {
                  break;
                }
              }
            }
            this.expect(")");
            return {
              simple: options2.simple,
              params: options2.params,
              stricted: options2.stricted,
              firstRestricted: options2.firstRestricted,
              message: options2.message
            };
          };
          Parser2.prototype.matchAsyncFunction = function() {
            var match = this.matchContextualKeyword("async");
            if (match) {
              var state = this.scanner.saveState();
              this.scanner.scanComments();
              var next = this.scanner.lex();
              this.scanner.restoreState(state);
              match = state.lineNumber === next.lineNumber && next.type === 4 && next.value === "function";
            }
            return match;
          };
          Parser2.prototype.parseFunctionDeclaration = function(identifierIsOptional) {
            var node = this.createNode();
            var isAsync = this.matchContextualKeyword("async");
            if (isAsync) {
              this.nextToken();
            }
            this.expectKeyword("function");
            var isGenerator = isAsync ? false : this.match("*");
            if (isGenerator) {
              this.nextToken();
            }
            var message;
            var id = null;
            var firstRestricted = null;
            if (!identifierIsOptional || !this.match("(")) {
              var token = this.lookahead;
              id = this.parseVariableIdentifier();
              if (this.context.strict) {
                if (this.scanner.isRestrictedWord(token.value)) {
                  this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
                }
              } else {
                if (this.scanner.isRestrictedWord(token.value)) {
                  firstRestricted = token;
                  message = messages_1.Messages.StrictFunctionName;
                } else if (this.scanner.isStrictModeReservedWord(token.value)) {
                  firstRestricted = token;
                  message = messages_1.Messages.StrictReservedWord;
                }
              }
            }
            var previousAllowAwait = this.context.await;
            var previousAllowYield = this.context.allowYield;
            this.context.await = isAsync;
            this.context.allowYield = !isGenerator;
            var formalParameters = this.parseFormalParameters(firstRestricted);
            var params = formalParameters.params;
            var stricted = formalParameters.stricted;
            firstRestricted = formalParameters.firstRestricted;
            if (formalParameters.message) {
              message = formalParameters.message;
            }
            var previousStrict = this.context.strict;
            var previousAllowStrictDirective = this.context.allowStrictDirective;
            this.context.allowStrictDirective = formalParameters.simple;
            var body = this.parseFunctionSourceElements();
            if (this.context.strict && firstRestricted) {
              this.throwUnexpectedToken(firstRestricted, message);
            }
            if (this.context.strict && stricted) {
              this.tolerateUnexpectedToken(stricted, message);
            }
            this.context.strict = previousStrict;
            this.context.allowStrictDirective = previousAllowStrictDirective;
            this.context.await = previousAllowAwait;
            this.context.allowYield = previousAllowYield;
            return isAsync ? this.finalize(node, new Node.AsyncFunctionDeclaration(id, params, body)) : this.finalize(node, new Node.FunctionDeclaration(id, params, body, isGenerator));
          };
          Parser2.prototype.parseFunctionExpression = function() {
            var node = this.createNode();
            var isAsync = this.matchContextualKeyword("async");
            if (isAsync) {
              this.nextToken();
            }
            this.expectKeyword("function");
            var isGenerator = isAsync ? false : this.match("*");
            if (isGenerator) {
              this.nextToken();
            }
            var message;
            var id = null;
            var firstRestricted;
            var previousAllowAwait = this.context.await;
            var previousAllowYield = this.context.allowYield;
            this.context.await = isAsync;
            this.context.allowYield = !isGenerator;
            if (!this.match("(")) {
              var token = this.lookahead;
              id = !this.context.strict && !isGenerator && this.matchKeyword("yield") ? this.parseIdentifierName() : this.parseVariableIdentifier();
              if (this.context.strict) {
                if (this.scanner.isRestrictedWord(token.value)) {
                  this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
                }
              } else {
                if (this.scanner.isRestrictedWord(token.value)) {
                  firstRestricted = token;
                  message = messages_1.Messages.StrictFunctionName;
                } else if (this.scanner.isStrictModeReservedWord(token.value)) {
                  firstRestricted = token;
                  message = messages_1.Messages.StrictReservedWord;
                }
              }
            }
            var formalParameters = this.parseFormalParameters(firstRestricted);
            var params = formalParameters.params;
            var stricted = formalParameters.stricted;
            firstRestricted = formalParameters.firstRestricted;
            if (formalParameters.message) {
              message = formalParameters.message;
            }
            var previousStrict = this.context.strict;
            var previousAllowStrictDirective = this.context.allowStrictDirective;
            this.context.allowStrictDirective = formalParameters.simple;
            var body = this.parseFunctionSourceElements();
            if (this.context.strict && firstRestricted) {
              this.throwUnexpectedToken(firstRestricted, message);
            }
            if (this.context.strict && stricted) {
              this.tolerateUnexpectedToken(stricted, message);
            }
            this.context.strict = previousStrict;
            this.context.allowStrictDirective = previousAllowStrictDirective;
            this.context.await = previousAllowAwait;
            this.context.allowYield = previousAllowYield;
            return isAsync ? this.finalize(node, new Node.AsyncFunctionExpression(id, params, body)) : this.finalize(node, new Node.FunctionExpression(id, params, body, isGenerator));
          };
          Parser2.prototype.parseDirective = function() {
            var token = this.lookahead;
            var node = this.createNode();
            var expr = this.parseExpression();
            var directive = expr.type === syntax_1.Syntax.Literal ? this.getTokenRaw(token).slice(1, -1) : null;
            this.consumeSemicolon();
            return this.finalize(node, directive ? new Node.Directive(expr, directive) : new Node.ExpressionStatement(expr));
          };
          Parser2.prototype.parseDirectivePrologues = function() {
            var firstRestricted = null;
            var body = [];
            while (true) {
              var token = this.lookahead;
              if (token.type !== 8) {
                break;
              }
              var statement = this.parseDirective();
              body.push(statement);
              var directive = statement.directive;
              if (typeof directive !== "string") {
                break;
              }
              if (directive === "use strict") {
                this.context.strict = true;
                if (firstRestricted) {
                  this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);
                }
                if (!this.context.allowStrictDirective) {
                  this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective);
                }
              } else {
                if (!firstRestricted && token.octal) {
                  firstRestricted = token;
                }
              }
            }
            return body;
          };
          Parser2.prototype.qualifiedPropertyName = function(token) {
            switch (token.type) {
              case 3:
              case 8:
              case 1:
              case 5:
              case 6:
              case 4:
                return true;
              case 7:
                return token.value === "[";
              default:
                break;
            }
            return false;
          };
          Parser2.prototype.parseGetterMethod = function() {
            var node = this.createNode();
            var isGenerator = false;
            var previousAllowYield = this.context.allowYield;
            this.context.allowYield = !isGenerator;
            var formalParameters = this.parseFormalParameters();
            if (formalParameters.params.length > 0) {
              this.tolerateError(messages_1.Messages.BadGetterArity);
            }
            var method = this.parsePropertyMethod(formalParameters);
            this.context.allowYield = previousAllowYield;
            return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
          };
          Parser2.prototype.parseSetterMethod = function() {
            var node = this.createNode();
            var isGenerator = false;
            var previousAllowYield = this.context.allowYield;
            this.context.allowYield = !isGenerator;
            var formalParameters = this.parseFormalParameters();
            if (formalParameters.params.length !== 1) {
              this.tolerateError(messages_1.Messages.BadSetterArity);
            } else if (formalParameters.params[0] instanceof Node.RestElement) {
              this.tolerateError(messages_1.Messages.BadSetterRestParameter);
            }
            var method = this.parsePropertyMethod(formalParameters);
            this.context.allowYield = previousAllowYield;
            return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
          };
          Parser2.prototype.parseGeneratorMethod = function() {
            var node = this.createNode();
            var isGenerator = true;
            var previousAllowYield = this.context.allowYield;
            this.context.allowYield = true;
            var params = this.parseFormalParameters();
            this.context.allowYield = false;
            var method = this.parsePropertyMethod(params);
            this.context.allowYield = previousAllowYield;
            return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
          };
          Parser2.prototype.isStartOfExpression = function() {
            var start = true;
            var value = this.lookahead.value;
            switch (this.lookahead.type) {
              case 7:
                start = value === "[" || value === "(" || value === "{" || value === "+" || value === "-" || value === "!" || value === "~" || value === "++" || value === "--" || value === "/" || value === "/=";
                break;
              case 4:
                start = value === "class" || value === "delete" || value === "function" || value === "let" || value === "new" || value === "super" || value === "this" || value === "typeof" || value === "void" || value === "yield";
                break;
              default:
                break;
            }
            return start;
          };
          Parser2.prototype.parseYieldExpression = function() {
            var node = this.createNode();
            this.expectKeyword("yield");
            var argument = null;
            var delegate = false;
            if (!this.hasLineTerminator) {
              var previousAllowYield = this.context.allowYield;
              this.context.allowYield = false;
              delegate = this.match("*");
              if (delegate) {
                this.nextToken();
                argument = this.parseAssignmentExpression();
              } else if (this.isStartOfExpression()) {
                argument = this.parseAssignmentExpression();
              }
              this.context.allowYield = previousAllowYield;
            }
            return this.finalize(node, new Node.YieldExpression(argument, delegate));
          };
          Parser2.prototype.parseClassElement = function(hasConstructor) {
            var token = this.lookahead;
            var node = this.createNode();
            var kind2 = "";
            var key = null;
            var value = null;
            var computed = false;
            var method = false;
            var isStatic = false;
            var isAsync = false;
            if (this.match("*")) {
              this.nextToken();
            } else {
              computed = this.match("[");
              key = this.parseObjectPropertyKey();
              var id = key;
              if (id.name === "static" && (this.qualifiedPropertyName(this.lookahead) || this.match("*"))) {
                token = this.lookahead;
                isStatic = true;
                computed = this.match("[");
                if (this.match("*")) {
                  this.nextToken();
                } else {
                  key = this.parseObjectPropertyKey();
                }
              }
              if (token.type === 3 && !this.hasLineTerminator && token.value === "async") {
                var punctuator = this.lookahead.value;
                if (punctuator !== ":" && punctuator !== "(" && punctuator !== "*") {
                  isAsync = true;
                  token = this.lookahead;
                  key = this.parseObjectPropertyKey();
                  if (token.type === 3 && token.value === "constructor") {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync);
                  }
                }
              }
            }
            var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
            if (token.type === 3) {
              if (token.value === "get" && lookaheadPropertyKey) {
                kind2 = "get";
                computed = this.match("[");
                key = this.parseObjectPropertyKey();
                this.context.allowYield = false;
                value = this.parseGetterMethod();
              } else if (token.value === "set" && lookaheadPropertyKey) {
                kind2 = "set";
                computed = this.match("[");
                key = this.parseObjectPropertyKey();
                value = this.parseSetterMethod();
              }
            } else if (token.type === 7 && token.value === "*" && lookaheadPropertyKey) {
              kind2 = "init";
              computed = this.match("[");
              key = this.parseObjectPropertyKey();
              value = this.parseGeneratorMethod();
              method = true;
            }
            if (!kind2 && key && this.match("(")) {
              kind2 = "init";
              value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
              method = true;
            }
            if (!kind2) {
              this.throwUnexpectedToken(this.lookahead);
            }
            if (kind2 === "init") {
              kind2 = "method";
            }
            if (!computed) {
              if (isStatic && this.isPropertyKey(key, "prototype")) {
                this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);
              }
              if (!isStatic && this.isPropertyKey(key, "constructor")) {
                if (kind2 !== "method" || !method || value && value.generator) {
                  this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);
                }
                if (hasConstructor.value) {
                  this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);
                } else {
                  hasConstructor.value = true;
                }
                kind2 = "constructor";
              }
            }
            return this.finalize(node, new Node.MethodDefinition(key, computed, value, kind2, isStatic));
          };
          Parser2.prototype.parseClassElementList = function() {
            var body = [];
            var hasConstructor = { value: false };
            this.expect("{");
            while (!this.match("}")) {
              if (this.match(";")) {
                this.nextToken();
              } else {
                body.push(this.parseClassElement(hasConstructor));
              }
            }
            this.expect("}");
            return body;
          };
          Parser2.prototype.parseClassBody = function() {
            var node = this.createNode();
            var elementList = this.parseClassElementList();
            return this.finalize(node, new Node.ClassBody(elementList));
          };
          Parser2.prototype.parseClassDeclaration = function(identifierIsOptional) {
            var node = this.createNode();
            var previousStrict = this.context.strict;
            this.context.strict = true;
            this.expectKeyword("class");
            var id = identifierIsOptional && this.lookahead.type !== 3 ? null : this.parseVariableIdentifier();
            var superClass = null;
            if (this.matchKeyword("extends")) {
              this.nextToken();
              superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
            }
            var classBody = this.parseClassBody();
            this.context.strict = previousStrict;
            return this.finalize(node, new Node.ClassDeclaration(id, superClass, classBody));
          };
          Parser2.prototype.parseClassExpression = function() {
            var node = this.createNode();
            var previousStrict = this.context.strict;
            this.context.strict = true;
            this.expectKeyword("class");
            var id = this.lookahead.type === 3 ? this.parseVariableIdentifier() : null;
            var superClass = null;
            if (this.matchKeyword("extends")) {
              this.nextToken();
              superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
            }
            var classBody = this.parseClassBody();
            this.context.strict = previousStrict;
            return this.finalize(node, new Node.ClassExpression(id, superClass, classBody));
          };
          Parser2.prototype.parseModule = function() {
            this.context.strict = true;
            this.context.isModule = true;
            this.scanner.isModule = true;
            var node = this.createNode();
            var body = this.parseDirectivePrologues();
            while (this.lookahead.type !== 2) {
              body.push(this.parseStatementListItem());
            }
            return this.finalize(node, new Node.Module(body));
          };
          Parser2.prototype.parseScript = function() {
            var node = this.createNode();
            var body = this.parseDirectivePrologues();
            while (this.lookahead.type !== 2) {
              body.push(this.parseStatementListItem());
            }
            return this.finalize(node, new Node.Script(body));
          };
          Parser2.prototype.parseModuleSpecifier = function() {
            var node = this.createNode();
            if (this.lookahead.type !== 8) {
              this.throwError(messages_1.Messages.InvalidModuleSpecifier);
            }
            var token = this.nextToken();
            var raw = this.getTokenRaw(token);
            return this.finalize(node, new Node.Literal(token.value, raw));
          };
          Parser2.prototype.parseImportSpecifier = function() {
            var node = this.createNode();
            var imported;
            var local;
            if (this.lookahead.type === 3) {
              imported = this.parseVariableIdentifier();
              local = imported;
              if (this.matchContextualKeyword("as")) {
                this.nextToken();
                local = this.parseVariableIdentifier();
              }
            } else {
              imported = this.parseIdentifierName();
              local = imported;
              if (this.matchContextualKeyword("as")) {
                this.nextToken();
                local = this.parseVariableIdentifier();
              } else {
                this.throwUnexpectedToken(this.nextToken());
              }
            }
            return this.finalize(node, new Node.ImportSpecifier(local, imported));
          };
          Parser2.prototype.parseNamedImports = function() {
            this.expect("{");
            var specifiers = [];
            while (!this.match("}")) {
              specifiers.push(this.parseImportSpecifier());
              if (!this.match("}")) {
                this.expect(",");
              }
            }
            this.expect("}");
            return specifiers;
          };
          Parser2.prototype.parseImportDefaultSpecifier = function() {
            var node = this.createNode();
            var local = this.parseIdentifierName();
            return this.finalize(node, new Node.ImportDefaultSpecifier(local));
          };
          Parser2.prototype.parseImportNamespaceSpecifier = function() {
            var node = this.createNode();
            this.expect("*");
            if (!this.matchContextualKeyword("as")) {
              this.throwError(messages_1.Messages.NoAsAfterImportNamespace);
            }
            this.nextToken();
            var local = this.parseIdentifierName();
            return this.finalize(node, new Node.ImportNamespaceSpecifier(local));
          };
          Parser2.prototype.parseImportDeclaration = function() {
            if (this.context.inFunctionBody) {
              this.throwError(messages_1.Messages.IllegalImportDeclaration);
            }
            var node = this.createNode();
            this.expectKeyword("import");
            var src;
            var specifiers = [];
            if (this.lookahead.type === 8) {
              src = this.parseModuleSpecifier();
            } else {
              if (this.match("{")) {
                specifiers = specifiers.concat(this.parseNamedImports());
              } else if (this.match("*")) {
                specifiers.push(this.parseImportNamespaceSpecifier());
              } else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword("default")) {
                specifiers.push(this.parseImportDefaultSpecifier());
                if (this.match(",")) {
                  this.nextToken();
                  if (this.match("*")) {
                    specifiers.push(this.parseImportNamespaceSpecifier());
                  } else if (this.match("{")) {
                    specifiers = specifiers.concat(this.parseNamedImports());
                  } else {
                    this.throwUnexpectedToken(this.lookahead);
                  }
                }
              } else {
                this.throwUnexpectedToken(this.nextToken());
              }
              if (!this.matchContextualKeyword("from")) {
                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                this.throwError(message, this.lookahead.value);
              }
              this.nextToken();
              src = this.parseModuleSpecifier();
            }
            this.consumeSemicolon();
            return this.finalize(node, new Node.ImportDeclaration(specifiers, src));
          };
          Parser2.prototype.parseExportSpecifier = function() {
            var node = this.createNode();
            var local = this.parseIdentifierName();
            var exported = local;
            if (this.matchContextualKeyword("as")) {
              this.nextToken();
              exported = this.parseIdentifierName();
            }
            return this.finalize(node, new Node.ExportSpecifier(local, exported));
          };
          Parser2.prototype.parseExportDeclaration = function() {
            if (this.context.inFunctionBody) {
              this.throwError(messages_1.Messages.IllegalExportDeclaration);
            }
            var node = this.createNode();
            this.expectKeyword("export");
            var exportDeclaration;
            if (this.matchKeyword("default")) {
              this.nextToken();
              if (this.matchKeyword("function")) {
                var declaration = this.parseFunctionDeclaration(true);
                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
              } else if (this.matchKeyword("class")) {
                var declaration = this.parseClassDeclaration(true);
                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
              } else if (this.matchContextualKeyword("async")) {
                var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();
                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
              } else {
                if (this.matchContextualKeyword("from")) {
                  this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
                }
                var declaration = this.match("{") ? this.parseObjectInitializer() : this.match("[") ? this.parseArrayInitializer() : this.parseAssignmentExpression();
                this.consumeSemicolon();
                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
              }
            } else if (this.match("*")) {
              this.nextToken();
              if (!this.matchContextualKeyword("from")) {
                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                this.throwError(message, this.lookahead.value);
              }
              this.nextToken();
              var src = this.parseModuleSpecifier();
              this.consumeSemicolon();
              exportDeclaration = this.finalize(node, new Node.ExportAllDeclaration(src));
            } else if (this.lookahead.type === 4) {
              var declaration = undefined;
              switch (this.lookahead.value) {
                case "let":
                case "const":
                  declaration = this.parseLexicalDeclaration({ inFor: false });
                  break;
                case "var":
                case "class":
                case "function":
                  declaration = this.parseStatementListItem();
                  break;
                default:
                  this.throwUnexpectedToken(this.lookahead);
              }
              exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
            } else if (this.matchAsyncFunction()) {
              var declaration = this.parseFunctionDeclaration();
              exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
            } else {
              var specifiers = [];
              var source = null;
              var isExportFromIdentifier = false;
              this.expect("{");
              while (!this.match("}")) {
                isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword("default");
                specifiers.push(this.parseExportSpecifier());
                if (!this.match("}")) {
                  this.expect(",");
                }
              }
              this.expect("}");
              if (this.matchContextualKeyword("from")) {
                this.nextToken();
                source = this.parseModuleSpecifier();
                this.consumeSemicolon();
              } else if (isExportFromIdentifier) {
                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                this.throwError(message, this.lookahead.value);
              } else {
                this.consumeSemicolon();
              }
              exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(null, specifiers, source));
            }
            return exportDeclaration;
          };
          return Parser2;
        }();
        exports2.Parser = Parser;
      },
      function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        function assert(condition, message) {
          if (!condition) {
            throw new Error("ASSERT: " + message);
          }
        }
        exports2.assert = assert;
      },
      function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var ErrorHandler = function() {
          function ErrorHandler2() {
            this.errors = [];
            this.tolerant = false;
          }
          ErrorHandler2.prototype.recordError = function(error5) {
            this.errors.push(error5);
          };
          ErrorHandler2.prototype.tolerate = function(error5) {
            if (this.tolerant) {
              this.recordError(error5);
            } else {
              throw error5;
            }
          };
          ErrorHandler2.prototype.constructError = function(msg, column) {
            var error5 = new Error(msg);
            try {
              throw error5;
            } catch (base) {
              if (Object.create && Object.defineProperty) {
                error5 = Object.create(base);
                Object.defineProperty(error5, "column", { value: column });
              }
            }
            return error5;
          };
          ErrorHandler2.prototype.createError = function(index, line, col, description) {
            var msg = "Line " + line + ": " + description;
            var error5 = this.constructError(msg, col);
            error5.index = index;
            error5.lineNumber = line;
            error5.description = description;
            return error5;
          };
          ErrorHandler2.prototype.throwError = function(index, line, col, description) {
            throw this.createError(index, line, col, description);
          };
          ErrorHandler2.prototype.tolerateError = function(index, line, col, description) {
            var error5 = this.createError(index, line, col, description);
            if (this.tolerant) {
              this.recordError(error5);
            } else {
              throw error5;
            }
          };
          return ErrorHandler2;
        }();
        exports2.ErrorHandler = ErrorHandler;
      },
      function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.Messages = {
          BadGetterArity: "Getter must not have any formal parameters",
          BadSetterArity: "Setter must have exactly one formal parameter",
          BadSetterRestParameter: "Setter function argument must not be a rest parameter",
          ConstructorIsAsync: "Class constructor may not be an async method",
          ConstructorSpecialMethod: "Class constructor may not be an accessor",
          DeclarationMissingInitializer: "Missing initializer in %0 declaration",
          DefaultRestParameter: "Unexpected token =",
          DuplicateBinding: "Duplicate binding %0",
          DuplicateConstructor: "A class may only have one constructor",
          DuplicateProtoProperty: "Duplicate __proto__ fields are not allowed in object literals",
          ForInOfLoopInitializer: "%0 loop variable declaration may not have an initializer",
          GeneratorInLegacyContext: "Generator declarations are not allowed in legacy contexts",
          IllegalBreak: "Illegal break statement",
          IllegalContinue: "Illegal continue statement",
          IllegalExportDeclaration: "Unexpected token",
          IllegalImportDeclaration: "Unexpected token",
          IllegalLanguageModeDirective: "Illegal \'use strict\' directive in function with non-simple parameter list",
          IllegalReturn: "Illegal return statement",
          InvalidEscapedReservedWord: "Keyword must not contain escaped characters",
          InvalidHexEscapeSequence: "Invalid hexadecimal escape sequence",
          InvalidLHSInAssignment: "Invalid left-hand side in assignment",
          InvalidLHSInForIn: "Invalid left-hand side in for-in",
          InvalidLHSInForLoop: "Invalid left-hand side in for-loop",
          InvalidModuleSpecifier: "Unexpected token",
          InvalidRegExp: "Invalid regular expression",
          LetInLexicalBinding: "let is disallowed as a lexically bound name",
          MissingFromClause: "Unexpected token",
          MultipleDefaultsInSwitch: "More than one default clause in switch statement",
          NewlineAfterThrow: "Illegal newline after throw",
          NoAsAfterImportNamespace: "Unexpected token",
          NoCatchOrFinally: "Missing catch or finally after try",
          ParameterAfterRestParameter: "Rest parameter must be last formal parameter",
          Redeclaration: "%0 \'%1\' has already been declared",
          StaticPrototype: "Classes may not have static property named prototype",
          StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode",
          StrictDelete: "Delete of an unqualified identifier in strict mode.",
          StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block",
          StrictFunctionName: "Function name may not be eval or arguments in strict mode",
          StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode",
          StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode",
          StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode",
          StrictModeWith: "Strict mode code may not include a with statement",
          StrictOctalLiteral: "Octal literals are not allowed in strict mode.",
          StrictParamDupe: "Strict mode function may not have duplicate parameter names",
          StrictParamName: "Parameter name eval or arguments is not allowed in strict mode",
          StrictReservedWord: "Use of future reserved word in strict mode",
          StrictVarName: "Variable name may not be eval or arguments in strict mode",
          TemplateOctalLiteral: "Octal literals are not allowed in template strings.",
          UnexpectedEOS: "Unexpected end of input",
          UnexpectedIdentifier: "Unexpected identifier",
          UnexpectedNumber: "Unexpected number",
          UnexpectedReserved: "Unexpected reserved word",
          UnexpectedString: "Unexpected string",
          UnexpectedTemplate: "Unexpected quasi %0",
          UnexpectedToken: "Unexpected token %0",
          UnexpectedTokenIllegal: "Unexpected token ILLEGAL",
          UnknownLabel: "Undefined label \'%0\'",
          UnterminatedRegExp: "Invalid regular expression: missing /"
        };
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var assert_1 = __webpack_require__(9);
        var character_1 = __webpack_require__(4);
        var messages_1 = __webpack_require__(11);
        function hexValue(ch) {
          return "0123456789abcdef".indexOf(ch.toLowerCase());
        }
        function octalValue(ch) {
          return "01234567".indexOf(ch);
        }
        var Scanner = function() {
          function Scanner2(code, handler) {
            this.source = code;
            this.errorHandler = handler;
            this.trackComment = false;
            this.isModule = false;
            this.length = code.length;
            this.index = 0;
            this.lineNumber = code.length > 0 ? 1 : 0;
            this.lineStart = 0;
            this.curlyStack = [];
          }
          Scanner2.prototype.saveState = function() {
            return {
              index: this.index,
              lineNumber: this.lineNumber,
              lineStart: this.lineStart
            };
          };
          Scanner2.prototype.restoreState = function(state) {
            this.index = state.index;
            this.lineNumber = state.lineNumber;
            this.lineStart = state.lineStart;
          };
          Scanner2.prototype.eof = function() {
            return this.index >= this.length;
          };
          Scanner2.prototype.throwUnexpectedToken = function(message) {
            if (message === undefined) {
              message = messages_1.Messages.UnexpectedTokenIllegal;
            }
            return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
          };
          Scanner2.prototype.tolerateUnexpectedToken = function(message) {
            if (message === undefined) {
              message = messages_1.Messages.UnexpectedTokenIllegal;
            }
            this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
          };
          Scanner2.prototype.skipSingleLineComment = function(offset) {
            var comments = [];
            var start, loc;
            if (this.trackComment) {
              comments = [];
              start = this.index - offset;
              loc = {
                start: {
                  line: this.lineNumber,
                  column: this.index - this.lineStart - offset
                },
                end: {}
              };
            }
            while (!this.eof()) {
              var ch = this.source.charCodeAt(this.index);
              ++this.index;
              if (character_1.Character.isLineTerminator(ch)) {
                if (this.trackComment) {
                  loc.end = {
                    line: this.lineNumber,
                    column: this.index - this.lineStart - 1
                  };
                  var entry = {
                    multiLine: false,
                    slice: [start + offset, this.index - 1],
                    range: [start, this.index - 1],
                    loc
                  };
                  comments.push(entry);
                }
                if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
                  ++this.index;
                }
                ++this.lineNumber;
                this.lineStart = this.index;
                return comments;
              }
            }
            if (this.trackComment) {
              loc.end = {
                line: this.lineNumber,
                column: this.index - this.lineStart
              };
              var entry = {
                multiLine: false,
                slice: [start + offset, this.index],
                range: [start, this.index],
                loc
              };
              comments.push(entry);
            }
            return comments;
          };
          Scanner2.prototype.skipMultiLineComment = function() {
            var comments = [];
            var start, loc;
            if (this.trackComment) {
              comments = [];
              start = this.index - 2;
              loc = {
                start: {
                  line: this.lineNumber,
                  column: this.index - this.lineStart - 2
                },
                end: {}
              };
            }
            while (!this.eof()) {
              var ch = this.source.charCodeAt(this.index);
              if (character_1.Character.isLineTerminator(ch)) {
                if (ch === 13 && this.source.charCodeAt(this.index + 1) === 10) {
                  ++this.index;
                }
                ++this.lineNumber;
                ++this.index;
                this.lineStart = this.index;
              } else if (ch === 42) {
                if (this.source.charCodeAt(this.index + 1) === 47) {
                  this.index += 2;
                  if (this.trackComment) {
                    loc.end = {
                      line: this.lineNumber,
                      column: this.index - this.lineStart
                    };
                    var entry = {
                      multiLine: true,
                      slice: [start + 2, this.index - 2],
                      range: [start, this.index],
                      loc
                    };
                    comments.push(entry);
                  }
                  return comments;
                }
                ++this.index;
              } else {
                ++this.index;
              }
            }
            if (this.trackComment) {
              loc.end = {
                line: this.lineNumber,
                column: this.index - this.lineStart
              };
              var entry = {
                multiLine: true,
                slice: [start + 2, this.index],
                range: [start, this.index],
                loc
              };
              comments.push(entry);
            }
            this.tolerateUnexpectedToken();
            return comments;
          };
          Scanner2.prototype.scanComments = function() {
            var comments;
            if (this.trackComment) {
              comments = [];
            }
            var start = this.index === 0;
            while (!this.eof()) {
              var ch = this.source.charCodeAt(this.index);
              if (character_1.Character.isWhiteSpace(ch)) {
                ++this.index;
              } else if (character_1.Character.isLineTerminator(ch)) {
                ++this.index;
                if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
                  ++this.index;
                }
                ++this.lineNumber;
                this.lineStart = this.index;
                start = true;
              } else if (ch === 47) {
                ch = this.source.charCodeAt(this.index + 1);
                if (ch === 47) {
                  this.index += 2;
                  var comment = this.skipSingleLineComment(2);
                  if (this.trackComment) {
                    comments = comments.concat(comment);
                  }
                  start = true;
                } else if (ch === 42) {
                  this.index += 2;
                  var comment = this.skipMultiLineComment();
                  if (this.trackComment) {
                    comments = comments.concat(comment);
                  }
                } else {
                  break;
                }
              } else if (start && ch === 45) {
                if (this.source.charCodeAt(this.index + 1) === 45 && this.source.charCodeAt(this.index + 2) === 62) {
                  this.index += 3;
                  var comment = this.skipSingleLineComment(3);
                  if (this.trackComment) {
                    comments = comments.concat(comment);
                  }
                } else {
                  break;
                }
              } else if (ch === 60 && !this.isModule) {
                if (this.source.slice(this.index + 1, this.index + 4) === "!--") {
                  this.index += 4;
                  var comment = this.skipSingleLineComment(4);
                  if (this.trackComment) {
                    comments = comments.concat(comment);
                  }
                } else {
                  break;
                }
              } else {
                break;
              }
            }
            return comments;
          };
          Scanner2.prototype.isFutureReservedWord = function(id) {
            switch (id) {
              case "enum":
              case "export":
              case "import":
              case "super":
                return true;
              default:
                return false;
            }
          };
          Scanner2.prototype.isStrictModeReservedWord = function(id) {
            switch (id) {
              case "implements":
              case "interface":
              case "package":
              case "private":
              case "protected":
              case "public":
              case "static":
              case "yield":
              case "let":
                return true;
              default:
                return false;
            }
          };
          Scanner2.prototype.isRestrictedWord = function(id) {
            return id === "eval" || id === "arguments";
          };
          Scanner2.prototype.isKeyword = function(id) {
            switch (id.length) {
              case 2:
                return id === "if" || id === "in" || id === "do";
              case 3:
                return id === "var" || id === "for" || id === "new" || id === "try" || id === "let";
              case 4:
                return id === "this" || id === "else" || id === "case" || id === "void" || id === "with" || id === "enum";
              case 5:
                return id === "while" || id === "break" || id === "catch" || id === "throw" || id === "const" || id === "yield" || id === "class" || id === "super";
              case 6:
                return id === "return" || id === "typeof" || id === "delete" || id === "switch" || id === "export" || id === "import";
              case 7:
                return id === "default" || id === "finally" || id === "extends";
              case 8:
                return id === "function" || id === "continue" || id === "debugger";
              case 10:
                return id === "instanceof";
              default:
                return false;
            }
          };
          Scanner2.prototype.codePointAt = function(i2) {
            var cp = this.source.charCodeAt(i2);
            if (cp >= 55296 && cp <= 56319) {
              var second = this.source.charCodeAt(i2 + 1);
              if (second >= 56320 && second <= 57343) {
                var first = cp;
                cp = (first - 55296) * 1024 + second - 56320 + 65536;
              }
            }
            return cp;
          };
          Scanner2.prototype.scanHexEscape = function(prefix) {
            var len = prefix === "u" ? 4 : 2;
            var code = 0;
            for (var i2 = 0;i2 < len; ++i2) {
              if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
                code = code * 16 + hexValue(this.source[this.index++]);
              } else {
                return null;
              }
            }
            return String.fromCharCode(code);
          };
          Scanner2.prototype.scanUnicodeCodePointEscape = function() {
            var ch = this.source[this.index];
            var code = 0;
            if (ch === "}") {
              this.throwUnexpectedToken();
            }
            while (!this.eof()) {
              ch = this.source[this.index++];
              if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {
                break;
              }
              code = code * 16 + hexValue(ch);
            }
            if (code > 1114111 || ch !== "}") {
              this.throwUnexpectedToken();
            }
            return character_1.Character.fromCodePoint(code);
          };
          Scanner2.prototype.getIdentifier = function() {
            var start = this.index++;
            while (!this.eof()) {
              var ch = this.source.charCodeAt(this.index);
              if (ch === 92) {
                this.index = start;
                return this.getComplexIdentifier();
              } else if (ch >= 55296 && ch < 57343) {
                this.index = start;
                return this.getComplexIdentifier();
              }
              if (character_1.Character.isIdentifierPart(ch)) {
                ++this.index;
              } else {
                break;
              }
            }
            return this.source.slice(start, this.index);
          };
          Scanner2.prototype.getComplexIdentifier = function() {
            var cp = this.codePointAt(this.index);
            var id = character_1.Character.fromCodePoint(cp);
            this.index += id.length;
            var ch;
            if (cp === 92) {
              if (this.source.charCodeAt(this.index) !== 117) {
                this.throwUnexpectedToken();
              }
              ++this.index;
              if (this.source[this.index] === "{") {
                ++this.index;
                ch = this.scanUnicodeCodePointEscape();
              } else {
                ch = this.scanHexEscape("u");
                if (ch === null || ch === "\\" || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) {
                  this.throwUnexpectedToken();
                }
              }
              id = ch;
            }
            while (!this.eof()) {
              cp = this.codePointAt(this.index);
              if (!character_1.Character.isIdentifierPart(cp)) {
                break;
              }
              ch = character_1.Character.fromCodePoint(cp);
              id += ch;
              this.index += ch.length;
              if (cp === 92) {
                id = id.substr(0, id.length - 1);
                if (this.source.charCodeAt(this.index) !== 117) {
                  this.throwUnexpectedToken();
                }
                ++this.index;
                if (this.source[this.index] === "{") {
                  ++this.index;
                  ch = this.scanUnicodeCodePointEscape();
                } else {
                  ch = this.scanHexEscape("u");
                  if (ch === null || ch === "\\" || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
                    this.throwUnexpectedToken();
                  }
                }
                id += ch;
              }
            }
            return id;
          };
          Scanner2.prototype.octalToDecimal = function(ch) {
            var octal = ch !== "0";
            var code = octalValue(ch);
            if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
              octal = true;
              code = code * 8 + octalValue(this.source[this.index++]);
              if ("0123".indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                code = code * 8 + octalValue(this.source[this.index++]);
              }
            }
            return {
              code,
              octal
            };
          };
          Scanner2.prototype.scanIdentifier = function() {
            var type;
            var start = this.index;
            var id = this.source.charCodeAt(start) === 92 ? this.getComplexIdentifier() : this.getIdentifier();
            if (id.length === 1) {
              type = 3;
            } else if (this.isKeyword(id)) {
              type = 4;
            } else if (id === "null") {
              type = 5;
            } else if (id === "true" || id === "false") {
              type = 1;
            } else {
              type = 3;
            }
            if (type !== 3 && start + id.length !== this.index) {
              var restore = this.index;
              this.index = start;
              this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);
              this.index = restore;
            }
            return {
              type,
              value: id,
              lineNumber: this.lineNumber,
              lineStart: this.lineStart,
              start,
              end: this.index
            };
          };
          Scanner2.prototype.scanPunctuator = function() {
            var start = this.index;
            var str = this.source[this.index];
            switch (str) {
              case "(":
              case "{":
                if (str === "{") {
                  this.curlyStack.push("{");
                }
                ++this.index;
                break;
              case ".":
                ++this.index;
                if (this.source[this.index] === "." && this.source[this.index + 1] === ".") {
                  this.index += 2;
                  str = "...";
                }
                break;
              case "}":
                ++this.index;
                this.curlyStack.pop();
                break;
              case ")":
              case ";":
              case ",":
              case "[":
              case "]":
              case ":":
              case "?":
              case "~":
                ++this.index;
                break;
              default:
                str = this.source.substr(this.index, 4);
                if (str === ">>>=") {
                  this.index += 4;
                } else {
                  str = str.substr(0, 3);
                  if (str === "===" || str === "!==" || str === ">>>" || str === "<<=" || str === ">>=" || str === "**=") {
                    this.index += 3;
                  } else {
                    str = str.substr(0, 2);
                    if (str === "&&" || str === "||" || str === "==" || str === "!=" || str === "+=" || str === "-=" || str === "*=" || str === "/=" || str === "++" || str === "--" || str === "<<" || str === ">>" || str === "&=" || str === "|=" || str === "^=" || str === "%=" || str === "<=" || str === ">=" || str === "=>" || str === "**") {
                      this.index += 2;
                    } else {
                      str = this.source[this.index];
                      if ("<>=!+-*%&|^/".indexOf(str) >= 0) {
                        ++this.index;
                      }
                    }
                  }
                }
            }
            if (this.index === start) {
              this.throwUnexpectedToken();
            }
            return {
              type: 7,
              value: str,
              lineNumber: this.lineNumber,
              lineStart: this.lineStart,
              start,
              end: this.index
            };
          };
          Scanner2.prototype.scanHexLiteral = function(start) {
            var num = "";
            while (!this.eof()) {
              if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
                break;
              }
              num += this.source[this.index++];
            }
            if (num.length === 0) {
              this.throwUnexpectedToken();
            }
            if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
              this.throwUnexpectedToken();
            }
            return {
              type: 6,
              value: parseInt("0x" + num, 16),
              lineNumber: this.lineNumber,
              lineStart: this.lineStart,
              start,
              end: this.index
            };
          };
          Scanner2.prototype.scanBinaryLiteral = function(start) {
            var num = "";
            var ch;
            while (!this.eof()) {
              ch = this.source[this.index];
              if (ch !== "0" && ch !== "1") {
                break;
              }
              num += this.source[this.index++];
            }
            if (num.length === 0) {
              this.throwUnexpectedToken();
            }
            if (!this.eof()) {
              ch = this.source.charCodeAt(this.index);
              if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {
                this.throwUnexpectedToken();
              }
            }
            return {
              type: 6,
              value: parseInt(num, 2),
              lineNumber: this.lineNumber,
              lineStart: this.lineStart,
              start,
              end: this.index
            };
          };
          Scanner2.prototype.scanOctalLiteral = function(prefix, start) {
            var num = "";
            var octal = false;
            if (character_1.Character.isOctalDigit(prefix.charCodeAt(0))) {
              octal = true;
              num = "0" + this.source[this.index++];
            } else {
              ++this.index;
            }
            while (!this.eof()) {
              if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                break;
              }
              num += this.source[this.index++];
            }
            if (!octal && num.length === 0) {
              this.throwUnexpectedToken();
            }
            if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
              this.throwUnexpectedToken();
            }
            return {
              type: 6,
              value: parseInt(num, 8),
              octal,
              lineNumber: this.lineNumber,
              lineStart: this.lineStart,
              start,
              end: this.index
            };
          };
          Scanner2.prototype.isImplicitOctalLiteral = function() {
            for (var i2 = this.index + 1;i2 < this.length; ++i2) {
              var ch = this.source[i2];
              if (ch === "8" || ch === "9") {
                return false;
              }
              if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                return true;
              }
            }
            return true;
          };
          Scanner2.prototype.scanNumericLiteral = function() {
            var start = this.index;
            var ch = this.source[start];
            assert_1.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || ch === ".", "Numeric literal must start with a decimal digit or a decimal point");
            var num = "";
            if (ch !== ".") {
              num = this.source[this.index++];
              ch = this.source[this.index];
              if (num === "0") {
                if (ch === "x" || ch === "X") {
                  ++this.index;
                  return this.scanHexLiteral(start);
                }
                if (ch === "b" || ch === "B") {
                  ++this.index;
                  return this.scanBinaryLiteral(start);
                }
                if (ch === "o" || ch === "O") {
                  return this.scanOctalLiteral(ch, start);
                }
                if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                  if (this.isImplicitOctalLiteral()) {
                    return this.scanOctalLiteral(ch, start);
                  }
                }
              }
              while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                num += this.source[this.index++];
              }
              ch = this.source[this.index];
            }
            if (ch === ".") {
              num += this.source[this.index++];
              while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                num += this.source[this.index++];
              }
              ch = this.source[this.index];
            }
            if (ch === "e" || ch === "E") {
              num += this.source[this.index++];
              ch = this.source[this.index];
              if (ch === "+" || ch === "-") {
                num += this.source[this.index++];
              }
              if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                  num += this.source[this.index++];
                }
              } else {
                this.throwUnexpectedToken();
              }
            }
            if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
              this.throwUnexpectedToken();
            }
            return {
              type: 6,
              value: parseFloat(num),
              lineNumber: this.lineNumber,
              lineStart: this.lineStart,
              start,
              end: this.index
            };
          };
          Scanner2.prototype.scanStringLiteral = function() {
            var start = this.index;
            var quote = this.source[start];
            assert_1.assert(quote === "\'" || quote === '"', "String literal must starts with a quote");
            ++this.index;
            var octal = false;
            var str = "";
            while (!this.eof()) {
              var ch = this.source[this.index++];
              if (ch === quote) {
                quote = "";
                break;
              } else if (ch === "\\") {
                ch = this.source[this.index++];
                if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                  switch (ch) {
                    case "u":
                      if (this.source[this.index] === "{") {
                        ++this.index;
                        str += this.scanUnicodeCodePointEscape();
                      } else {
                        var unescaped_1 = this.scanHexEscape(ch);
                        if (unescaped_1 === null) {
                          this.throwUnexpectedToken();
                        }
                        str += unescaped_1;
                      }
                      break;
                    case "x":
                      var unescaped = this.scanHexEscape(ch);
                      if (unescaped === null) {
                        this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
                      }
                      str += unescaped;
                      break;
                    case "n":
                      str += "\n";
                      break;
                    case "r":
                      str += "\r";
                      break;
                    case "t":
                      str += "\t";
                      break;
                    case "b":
                      str += "\b";
                      break;
                    case "f":
                      str += "\f";
                      break;
                    case "v":
                      str += "\v";
                      break;
                    case "8":
                    case "9":
                      str += ch;
                      this.tolerateUnexpectedToken();
                      break;
                    default:
                      if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                        var octToDec = this.octalToDecimal(ch);
                        octal = octToDec.octal || octal;
                        str += String.fromCharCode(octToDec.code);
                      } else {
                        str += ch;
                      }
                      break;
                  }
                } else {
                  ++this.lineNumber;
                  if (ch === "\r" && this.source[this.index] === "\n") {
                    ++this.index;
                  }
                  this.lineStart = this.index;
                }
              } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                break;
              } else {
                str += ch;
              }
            }
            if (quote !== "") {
              this.index = start;
              this.throwUnexpectedToken();
            }
            return {
              type: 8,
              value: str,
              octal,
              lineNumber: this.lineNumber,
              lineStart: this.lineStart,
              start,
              end: this.index
            };
          };
          Scanner2.prototype.scanTemplate = function() {
            var cooked = "";
            var terminated = false;
            var start = this.index;
            var head = this.source[start] === "`";
            var tail = false;
            var rawOffset = 2;
            ++this.index;
            while (!this.eof()) {
              var ch = this.source[this.index++];
              if (ch === "`") {
                rawOffset = 1;
                tail = true;
                terminated = true;
                break;
              } else if (ch === "$") {
                if (this.source[this.index] === "{") {
                  this.curlyStack.push("${");
                  ++this.index;
                  terminated = true;
                  break;
                }
                cooked += ch;
              } else if (ch === "\\") {
                ch = this.source[this.index++];
                if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                  switch (ch) {
                    case "n":
                      cooked += "\n";
                      break;
                    case "r":
                      cooked += "\r";
                      break;
                    case "t":
                      cooked += "\t";
                      break;
                    case "u":
                      if (this.source[this.index] === "{") {
                        ++this.index;
                        cooked += this.scanUnicodeCodePointEscape();
                      } else {
                        var restore = this.index;
                        var unescaped_2 = this.scanHexEscape(ch);
                        if (unescaped_2 !== null) {
                          cooked += unescaped_2;
                        } else {
                          this.index = restore;
                          cooked += ch;
                        }
                      }
                      break;
                    case "x":
                      var unescaped = this.scanHexEscape(ch);
                      if (unescaped === null) {
                        this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
                      }
                      cooked += unescaped;
                      break;
                    case "b":
                      cooked += "\b";
                      break;
                    case "f":
                      cooked += "\f";
                      break;
                    case "v":
                      cooked += "\v";
                      break;
                    default:
                      if (ch === "0") {
                        if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                          this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
                        }
                        cooked += "\0";
                      } else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                        this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
                      } else {
                        cooked += ch;
                      }
                      break;
                  }
                } else {
                  ++this.lineNumber;
                  if (ch === "\r" && this.source[this.index] === "\n") {
                    ++this.index;
                  }
                  this.lineStart = this.index;
                }
              } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                ++this.lineNumber;
                if (ch === "\r" && this.source[this.index] === "\n") {
                  ++this.index;
                }
                this.lineStart = this.index;
                cooked += "\n";
              } else {
                cooked += ch;
              }
            }
            if (!terminated) {
              this.throwUnexpectedToken();
            }
            if (!head) {
              this.curlyStack.pop();
            }
            return {
              type: 10,
              value: this.source.slice(start + 1, this.index - rawOffset),
              cooked,
              head,
              tail,
              lineNumber: this.lineNumber,
              lineStart: this.lineStart,
              start,
              end: this.index
            };
          };
          Scanner2.prototype.testRegExp = function(pattern, flags) {
            var astralSubstitute = "\uFFFF";
            var tmp = pattern;
            var self2 = this;
            if (flags.indexOf("u") >= 0) {
              tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function($0, $1, $2) {
                var codePoint = parseInt($1 || $2, 16);
                if (codePoint > 1114111) {
                  self2.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
                }
                if (codePoint <= 65535) {
                  return String.fromCharCode(codePoint);
                }
                return astralSubstitute;
              }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute);
            }
            try {
              RegExp(tmp);
            } catch (e2) {
              this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
            }
            try {
              return new RegExp(pattern, flags);
            } catch (exception) {
              return null;
            }
          };
          Scanner2.prototype.scanRegExpBody = function() {
            var ch = this.source[this.index];
            assert_1.assert(ch === "/", "Regular expression literal must start with a slash");
            var str = this.source[this.index++];
            var classMarker = false;
            var terminated = false;
            while (!this.eof()) {
              ch = this.source[this.index++];
              str += ch;
              if (ch === "\\") {
                ch = this.source[this.index++];
                if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                  this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
                }
                str += ch;
              } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
              } else if (classMarker) {
                if (ch === "]") {
                  classMarker = false;
                }
              } else {
                if (ch === "/") {
                  terminated = true;
                  break;
                } else if (ch === "[") {
                  classMarker = true;
                }
              }
            }
            if (!terminated) {
              this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
            }
            return str.substr(1, str.length - 2);
          };
          Scanner2.prototype.scanRegExpFlags = function() {
            var str = "";
            var flags = "";
            while (!this.eof()) {
              var ch = this.source[this.index];
              if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
                break;
              }
              ++this.index;
              if (ch === "\\" && !this.eof()) {
                ch = this.source[this.index];
                if (ch === "u") {
                  ++this.index;
                  var restore = this.index;
                  var char = this.scanHexEscape("u");
                  if (char !== null) {
                    flags += char;
                    for (str += "\\u";restore < this.index; ++restore) {
                      str += this.source[restore];
                    }
                  } else {
                    this.index = restore;
                    flags += "u";
                    str += "\\u";
                  }
                  this.tolerateUnexpectedToken();
                } else {
                  str += "\\";
                  this.tolerateUnexpectedToken();
                }
              } else {
                flags += ch;
                str += ch;
              }
            }
            return flags;
          };
          Scanner2.prototype.scanRegExp = function() {
            var start = this.index;
            var pattern = this.scanRegExpBody();
            var flags = this.scanRegExpFlags();
            var value = this.testRegExp(pattern, flags);
            return {
              type: 9,
              value: "",
              pattern,
              flags,
              regex: value,
              lineNumber: this.lineNumber,
              lineStart: this.lineStart,
              start,
              end: this.index
            };
          };
          Scanner2.prototype.lex = function() {
            if (this.eof()) {
              return {
                type: 2,
                value: "",
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start: this.index,
                end: this.index
              };
            }
            var cp = this.source.charCodeAt(this.index);
            if (character_1.Character.isIdentifierStart(cp)) {
              return this.scanIdentifier();
            }
            if (cp === 40 || cp === 41 || cp === 59) {
              return this.scanPunctuator();
            }
            if (cp === 39 || cp === 34) {
              return this.scanStringLiteral();
            }
            if (cp === 46) {
              if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
                return this.scanNumericLiteral();
              }
              return this.scanPunctuator();
            }
            if (character_1.Character.isDecimalDigit(cp)) {
              return this.scanNumericLiteral();
            }
            if (cp === 96 || cp === 125 && this.curlyStack[this.curlyStack.length - 1] === "${") {
              return this.scanTemplate();
            }
            if (cp >= 55296 && cp < 57343) {
              if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {
                return this.scanIdentifier();
              }
            }
            return this.scanPunctuator();
          };
          return Scanner2;
        }();
        exports2.Scanner = Scanner;
      },
      function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.TokenName = {};
        exports2.TokenName[1] = "Boolean";
        exports2.TokenName[2] = "<end>";
        exports2.TokenName[3] = "Identifier";
        exports2.TokenName[4] = "Keyword";
        exports2.TokenName[5] = "Null";
        exports2.TokenName[6] = "Numeric";
        exports2.TokenName[7] = "Punctuator";
        exports2.TokenName[8] = "String";
        exports2.TokenName[9] = "RegularExpression";
        exports2.TokenName[10] = "Template";
      },
      function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.XHTMLEntities = {
          quot: '"',
          amp: "&",
          apos: "'",
          gt: ">",
          nbsp: "\xA0",
          iexcl: "\xA1",
          cent: "\xA2",
          pound: "\xA3",
          curren: "\xA4",
          yen: "\xA5",
          brvbar: "\xA6",
          sect: "\xA7",
          uml: "\xA8",
          copy: "\xA9",
          ordf: "\xAA",
          laquo: "\xAB",
          not: "\xAC",
          shy: "\xAD",
          reg: "\xAE",
          macr: "\xAF",
          deg: "\xB0",
          plusmn: "\xB1",
          sup2: "\xB2",
          sup3: "\xB3",
          acute: "\xB4",
          micro: "\xB5",
          para: "\xB6",
          middot: "\xB7",
          cedil: "\xB8",
          sup1: "\xB9",
          ordm: "\xBA",
          raquo: "\xBB",
          frac14: "\xBC",
          frac12: "\xBD",
          frac34: "\xBE",
          iquest: "\xBF",
          Agrave: "\xC0",
          Aacute: "\xC1",
          Acirc: "\xC2",
          Atilde: "\xC3",
          Auml: "\xC4",
          Aring: "\xC5",
          AElig: "\xC6",
          Ccedil: "\xC7",
          Egrave: "\xC8",
          Eacute: "\xC9",
          Ecirc: "\xCA",
          Euml: "\xCB",
          Igrave: "\xCC",
          Iacute: "\xCD",
          Icirc: "\xCE",
          Iuml: "\xCF",
          ETH: "\xD0",
          Ntilde: "\xD1",
          Ograve: "\xD2",
          Oacute: "\xD3",
          Ocirc: "\xD4",
          Otilde: "\xD5",
          Ouml: "\xD6",
          times: "\xD7",
          Oslash: "\xD8",
          Ugrave: "\xD9",
          Uacute: "\xDA",
          Ucirc: "\xDB",
          Uuml: "\xDC",
          Yacute: "\xDD",
          THORN: "\xDE",
          szlig: "\xDF",
          agrave: "\xE0",
          aacute: "\xE1",
          acirc: "\xE2",
          atilde: "\xE3",
          auml: "\xE4",
          aring: "\xE5",
          aelig: "\xE6",
          ccedil: "\xE7",
          egrave: "\xE8",
          eacute: "\xE9",
          ecirc: "\xEA",
          euml: "\xEB",
          igrave: "\xEC",
          iacute: "\xED",
          icirc: "\xEE",
          iuml: "\xEF",
          eth: "\xF0",
          ntilde: "\xF1",
          ograve: "\xF2",
          oacute: "\xF3",
          ocirc: "\xF4",
          otilde: "\xF5",
          ouml: "\xF6",
          divide: "\xF7",
          oslash: "\xF8",
          ugrave: "\xF9",
          uacute: "\xFA",
          ucirc: "\xFB",
          uuml: "\xFC",
          yacute: "\xFD",
          thorn: "\xFE",
          yuml: "\xFF",
          OElig: "\u0152",
          oelig: "\u0153",
          Scaron: "\u0160",
          scaron: "\u0161",
          Yuml: "\u0178",
          fnof: "\u0192",
          circ: "\u02C6",
          tilde: "\u02DC",
          Alpha: "\u0391",
          Beta: "\u0392",
          Gamma: "\u0393",
          Delta: "\u0394",
          Epsilon: "\u0395",
          Zeta: "\u0396",
          Eta: "\u0397",
          Theta: "\u0398",
          Iota: "\u0399",
          Kappa: "\u039A",
          Lambda: "\u039B",
          Mu: "\u039C",
          Nu: "\u039D",
          Xi: "\u039E",
          Omicron: "\u039F",
          Pi: "\u03A0",
          Rho: "\u03A1",
          Sigma: "\u03A3",
          Tau: "\u03A4",
          Upsilon: "\u03A5",
          Phi: "\u03A6",
          Chi: "\u03A7",
          Psi: "\u03A8",
          Omega: "\u03A9",
          alpha: "\u03B1",
          beta: "\u03B2",
          gamma: "\u03B3",
          delta: "\u03B4",
          epsilon: "\u03B5",
          zeta: "\u03B6",
          eta: "\u03B7",
          theta: "\u03B8",
          iota: "\u03B9",
          kappa: "\u03BA",
          lambda: "\u03BB",
          mu: "\u03BC",
          nu: "\u03BD",
          xi: "\u03BE",
          omicron: "\u03BF",
          pi: "\u03C0",
          rho: "\u03C1",
          sigmaf: "\u03C2",
          sigma: "\u03C3",
          tau: "\u03C4",
          upsilon: "\u03C5",
          phi: "\u03C6",
          chi: "\u03C7",
          psi: "\u03C8",
          omega: "\u03C9",
          thetasym: "\u03D1",
          upsih: "\u03D2",
          piv: "\u03D6",
          ensp: "\u2002",
          emsp: "\u2003",
          thinsp: "\u2009",
          zwnj: "\u200C",
          zwj: "\u200D",
          lrm: "\u200E",
          rlm: "\u200F",
          ndash: "\u2013",
          mdash: "\u2014",
          lsquo: "\u2018",
          rsquo: "\u2019",
          sbquo: "\u201A",
          ldquo: "\u201C",
          rdquo: "\u201D",
          bdquo: "\u201E",
          dagger: "\u2020",
          Dagger: "\u2021",
          bull: "\u2022",
          hellip: "\u2026",
          permil: "\u2030",
          prime: "\u2032",
          Prime: "\u2033",
          lsaquo: "\u2039",
          rsaquo: "\u203A",
          oline: "\u203E",
          frasl: "\u2044",
          euro: "\u20AC",
          image: "\u2111",
          weierp: "\u2118",
          real: "\u211C",
          trade: "\u2122",
          alefsym: "\u2135",
          larr: "\u2190",
          uarr: "\u2191",
          rarr: "\u2192",
          darr: "\u2193",
          harr: "\u2194",
          crarr: "\u21B5",
          lArr: "\u21D0",
          uArr: "\u21D1",
          rArr: "\u21D2",
          dArr: "\u21D3",
          hArr: "\u21D4",
          forall: "\u2200",
          part: "\u2202",
          exist: "\u2203",
          empty: "\u2205",
          nabla: "\u2207",
          isin: "\u2208",
          notin: "\u2209",
          ni: "\u220B",
          prod: "\u220F",
          sum: "\u2211",
          minus: "\u2212",
          lowast: "\u2217",
          radic: "\u221A",
          prop: "\u221D",
          infin: "\u221E",
          ang: "\u2220",
          and: "\u2227",
          or: "\u2228",
          cap: "\u2229",
          cup: "\u222A",
          int: "\u222B",
          there4: "\u2234",
          sim: "\u223C",
          cong: "\u2245",
          asymp: "\u2248",
          ne: "\u2260",
          equiv: "\u2261",
          le: "\u2264",
          ge: "\u2265",
          sub: "\u2282",
          sup: "\u2283",
          nsub: "\u2284",
          sube: "\u2286",
          supe: "\u2287",
          oplus: "\u2295",
          otimes: "\u2297",
          perp: "\u22A5",
          sdot: "\u22C5",
          lceil: "\u2308",
          rceil: "\u2309",
          lfloor: "\u230A",
          rfloor: "\u230B",
          loz: "\u25CA",
          spades: "\u2660",
          clubs: "\u2663",
          hearts: "\u2665",
          diams: "\u2666",
          lang: "\u27E8",
          rang: "\u27E9"
        };
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var error_handler_1 = __webpack_require__(10);
        var scanner_1 = __webpack_require__(12);
        var token_1 = __webpack_require__(13);
        var Reader = function() {
          function Reader2() {
            this.values = [];
            this.curly = this.paren = -1;
          }
          Reader2.prototype.beforeFunctionExpression = function(t2) {
            return [
              "(",
              "{",
              "[",
              "in",
              "typeof",
              "instanceof",
              "new",
              "return",
              "case",
              "delete",
              "throw",
              "void",
              "=",
              "+=",
              "-=",
              "*=",
              "**=",
              "/=",
              "%=",
              "<<=",
              ">>=",
              ">>>=",
              "&=",
              "|=",
              "^=",
              ",",
              "+",
              "-",
              "*",
              "**",
              "/",
              "%",
              "++",
              "--",
              "<<",
              ">>",
              ">>>",
              "&",
              "|",
              "^",
              "!",
              "~",
              "&&",
              "||",
              "?",
              ":",
              "===",
              "==",
              ">=",
              "<=",
              "<",
              ">",
              "!=",
              "!=="
            ].indexOf(t2) >= 0;
          };
          Reader2.prototype.isRegexStart = function() {
            var previous = this.values[this.values.length - 1];
            var regex = previous !== null;
            switch (previous) {
              case "this":
              case "]":
                regex = false;
                break;
              case ")":
                var keyword = this.values[this.paren - 1];
                regex = keyword === "if" || keyword === "while" || keyword === "for" || keyword === "with";
                break;
              case "}":
                regex = false;
                if (this.values[this.curly - 3] === "function") {
                  var check = this.values[this.curly - 4];
                  regex = check ? !this.beforeFunctionExpression(check) : false;
                } else if (this.values[this.curly - 4] === "function") {
                  var check = this.values[this.curly - 5];
                  regex = check ? !this.beforeFunctionExpression(check) : true;
                }
                break;
              default:
                break;
            }
            return regex;
          };
          Reader2.prototype.push = function(token) {
            if (token.type === 7 || token.type === 4) {
              if (token.value === "{") {
                this.curly = this.values.length;
              } else if (token.value === "(") {
                this.paren = this.values.length;
              }
              this.values.push(token.value);
            } else {
              this.values.push(null);
            }
          };
          return Reader2;
        }();
        var Tokenizer = function() {
          function Tokenizer2(code, config) {
            this.errorHandler = new error_handler_1.ErrorHandler;
            this.errorHandler.tolerant = config ? typeof config.tolerant === "boolean" && config.tolerant : false;
            this.scanner = new scanner_1.Scanner(code, this.errorHandler);
            this.scanner.trackComment = config ? typeof config.comment === "boolean" && config.comment : false;
            this.trackRange = config ? typeof config.range === "boolean" && config.range : false;
            this.trackLoc = config ? typeof config.loc === "boolean" && config.loc : false;
            this.buffer = [];
            this.reader = new Reader;
          }
          Tokenizer2.prototype.errors = function() {
            return this.errorHandler.errors;
          };
          Tokenizer2.prototype.getNextToken = function() {
            if (this.buffer.length === 0) {
              var comments = this.scanner.scanComments();
              if (this.scanner.trackComment) {
                for (var i2 = 0;i2 < comments.length; ++i2) {
                  var e2 = comments[i2];
                  var value = this.scanner.source.slice(e2.slice[0], e2.slice[1]);
                  var comment = {
                    type: e2.multiLine ? "BlockComment" : "LineComment",
                    value
                  };
                  if (this.trackRange) {
                    comment.range = e2.range;
                  }
                  if (this.trackLoc) {
                    comment.loc = e2.loc;
                  }
                  this.buffer.push(comment);
                }
              }
              if (!this.scanner.eof()) {
                var loc = undefined;
                if (this.trackLoc) {
                  loc = {
                    start: {
                      line: this.scanner.lineNumber,
                      column: this.scanner.index - this.scanner.lineStart
                    },
                    end: {}
                  };
                }
                var startRegex = this.scanner.source[this.scanner.index] === "/" && this.reader.isRegexStart();
                var token = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();
                this.reader.push(token);
                var entry = {
                  type: token_1.TokenName[token.type],
                  value: this.scanner.source.slice(token.start, token.end)
                };
                if (this.trackRange) {
                  entry.range = [token.start, token.end];
                }
                if (this.trackLoc) {
                  loc.end = {
                    line: this.scanner.lineNumber,
                    column: this.scanner.index - this.scanner.lineStart
                  };
                  entry.loc = loc;
                }
                if (token.type === 9) {
                  var pattern = token.pattern;
                  var flags = token.flags;
                  entry.regex = { pattern, flags };
                }
                this.buffer.push(entry);
              }
            }
            return this.buffer.shift();
          };
          return Tokenizer2;
        }();
        exports2.Tokenizer = Tokenizer;
      }
    ]);
  });
});

// node_modules/redeyed/redeyed.js
var require_redeyed = __commonJS((exports, module) => {
  (function() {
    var esprima;
    var exportFn;
    var toString2 = Object.prototype.toString;
    if (typeof module === "object" && typeof exports === "object" && typeof require === "function") {
      esprima = require_esprima();
      exportFn = function(redeyed) {
        module.exports = redeyed;
      };
      bootstrap(esprima, exportFn);
    } else if (typeof define === "function" && define.amd) {
      define(["esprima"], function(esprima2) {
        return bootstrap(esprima2);
      });
    } else if (typeof window === "object") {
      window.redeyed = bootstrap(window.esprima);
    }
    function bootstrap(esprima2, exportFn2) {
      function isFunction8(obj) {
        return toString2.call(obj) === "[object Function]";
      }
      function isString(obj) {
        return toString2.call(obj) === "[object String]";
      }
      function isObject(obj) {
        return toString2.call(obj) === "[object Object]";
      }
      function surroundWith(before, after) {
        return function(s2) {
          return before + s2 + after;
        };
      }
      function isNonCircular(key) {
        return key !== "_parent";
      }
      function objectizeString(value) {
        var vals = value.split(":");
        if (vals.length === 0 || vals.length > 2) {
          throw new Error("illegal string config: " + value + '\nShould be of format "before:after"');
        }
        if (vals.length === 1 || vals[1].length === 0) {
          return vals.indexOf(":") < 0 ? { _before: vals[0] } : { _after: vals[0] };
        } else {
          return { _before: vals[0], _after: vals[1] };
        }
      }
      function objectize(node) {
        function resolve(value, key) {
          if (!value._parent)
            return;
          if (value._parent._default && value._parent._default[key])
            return value._parent._default[key];
          var root = value._parent._parent;
          if (!root)
            return;
          return root._default ? root._default[key] : undefined;
        }
        function process3(key) {
          var value = node[key];
          if (!value)
            return;
          if (isFunction8(value))
            return;
          if (isString(value)) {
            node[key] = value = objectizeString(value);
          }
          value._parent = node;
          if (isObject(value)) {
            if (!value._before && !value._after)
              return objectize(value);
            value._before = value._before || resolve(value, "_before");
            value._after = value._after || resolve(value, "_after");
            return;
          }
          throw new Error("nodes need to be either {String}, {Object} or {Function}." + value + " is neither.");
        }
        if (node._default)
          process3("_default");
        Object.keys(node).filter(function(key) {
          return isNonCircular(key) && node.hasOwnProperty(key) && key !== "_before" && key !== "_after" && key !== "_default";
        }).forEach(process3);
      }
      function functionize(node) {
        Object.keys(node).filter(function(key) {
          return isNonCircular(key) && node.hasOwnProperty(key);
        }).forEach(function(key) {
          var value = node[key];
          if (isFunction8(value))
            return;
          if (isObject(value)) {
            if (!value._before && !value._after)
              return functionize(value);
            var before = value._before || "";
            var after = value._after || "";
            node[key] = surroundWith(before, after);
            return node[key];
          }
        });
      }
      function normalize(root) {
        objectize(root);
        functionize(root);
      }
      function mergeTokensAndComments(tokens, comments) {
        var all = {};
        function addToAllByRangeStart(t2) {
          all[t2.range[0]] = t2;
        }
        tokens.forEach(addToAllByRangeStart);
        comments.forEach(addToAllByRangeStart);
        return Object.keys(all).map(function(k2) {
          return all[k2];
        });
      }
      function redeyed(code, config, opts) {
        opts = opts || {};
        var parser2 = opts.parser || esprima2;
        var jsx = !!opts.jsx;
        var buildAst = jsx || !!opts.buildAst;
        var hashbang = "";
        var ast;
        var tokens;
        var comments;
        var lastSplitEnd = 0;
        var splits = [];
        var transformedCode;
        var all;
        var info;
        if (code[0] === "#" && code[1] === "!") {
          hashbang = code.substr(0, code.indexOf("\n") + 1);
          code = Array.apply(0, Array(hashbang.length)).join(" ") + "\n" + code.substr(hashbang.length);
        }
        if (buildAst) {
          ast = parser2.parse(code, { tokens: true, comment: true, range: true, loc: true, tolerant: true, jsx: true });
          tokens = ast.tokens;
          comments = ast.comments;
        } else {
          tokens = [];
          comments = [];
          parser2.tokenize(code, { range: true, loc: true, comment: true }, function(token2) {
            if (token2.type === "LineComment") {
              token2.type = "Line";
              comments.push(token2);
            } else if (token2.type === "BlockComment") {
              token2.type = "Block";
              comments.push(token2);
            } else {
              if (token2.type === "Identifier" && token2.value === "static")
                token2.type = "Keyword";
              tokens.push(token2);
            }
          });
        }
        normalize(config);
        function tokenIndex(tokens2, tkn, start2) {
          var current;
          var rangeStart = tkn.range[0];
          for (current = start2;current < tokens2.length; current++) {
            if (tokens2[current].range[0] === rangeStart)
              return current;
          }
          throw new Error("Token %s not found at or after index: %d", tkn, start2);
        }
        function process3(surround2) {
          var result;
          var currentIndex;
          var nextIndex;
          var skip = 0;
          var splitEnd;
          result = surround2(code.slice(start, end), info);
          if (isObject(result)) {
            splits.push(result.replacement);
            currentIndex = info.tokenIndex;
            nextIndex = tokenIndex(info.tokens, result.skipPastToken, currentIndex);
            skip = nextIndex - currentIndex;
            splitEnd = skip > 0 ? tokens[nextIndex - 1].range[1] : end;
          } else {
            splits.push(result);
            splitEnd = end;
          }
          return { skip, splitEnd };
        }
        function addSplit(start2, end2, surround2, info2) {
          var result;
          var skip = 0;
          if (start2 >= end2)
            return;
          if (surround2) {
            result = process3(surround2);
            skip = result.skip;
            lastSplitEnd = result.splitEnd;
          } else {
            splits.push(code.slice(start2, end2));
            lastSplitEnd = end2;
          }
          return skip;
        }
        all = mergeTokensAndComments(tokens, comments);
        for (var tokenIdx = 0;tokenIdx < all.length; tokenIdx++) {
          var token = all[tokenIdx];
          var surroundForType = config[token.type];
          var surround;
          var start;
          var end;
          if (surroundForType) {
            surround = surroundForType && surroundForType.hasOwnProperty(token.value) && surroundForType[token.value] && isFunction8(surroundForType[token.value]) ? surroundForType[token.value] : surroundForType._default;
            start = token.range[0];
            end = token.range[1];
            addSplit(lastSplitEnd, start);
            info = { tokenIndex: tokenIdx, tokens: all, ast, code };
            tokenIdx += addSplit(start, end, surround, info);
          }
        }
        if (lastSplitEnd < code.length) {
          addSplit(lastSplitEnd, code.length);
        }
        if (!opts.nojoin) {
          transformedCode = splits.join("");
          if (hashbang.length > 0) {
            transformedCode = hashbang + transformedCode.substr(hashbang.length);
          }
        }
        return {
          ast,
          tokens,
          comments,
          splits,
          code: transformedCode
        };
      }
      return exportFn2 ? exportFn2(redeyed) : redeyed;
    }
  })();
});

// node_modules/ansicolors/ansicolors.js
var require_ansicolors = __commonJS((exports, module) => {
  var colorNums = {
    white: 37,
    black: 30,
    blue: 34,
    cyan: 36,
    green: 32,
    magenta: 35,
    red: 31,
    yellow: 33,
    brightBlack: 90,
    brightRed: 91,
    brightGreen: 92,
    brightYellow: 93,
    brightBlue: 94,
    brightMagenta: 95,
    brightCyan: 96,
    brightWhite: 97
  };
  var backgroundColorNums = {
    bgBlack: 40,
    bgRed: 41,
    bgGreen: 42,
    bgYellow: 43,
    bgBlue: 44,
    bgMagenta: 45,
    bgCyan: 46,
    bgWhite: 47,
    bgBrightBlack: 100,
    bgBrightRed: 101,
    bgBrightGreen: 102,
    bgBrightYellow: 103,
    bgBrightBlue: 104,
    bgBrightMagenta: 105,
    bgBrightCyan: 106,
    bgBrightWhite: 107
  };
  var open = {};
  var close = {};
  var colors = {};
  Object.keys(colorNums).forEach(function(k2) {
    var o2 = open[k2] = "\x1B[" + colorNums[k2] + "m";
    var c2 = close[k2] = "\x1B[39m";
    colors[k2] = function(s2) {
      return o2 + s2 + c2;
    };
  });
  Object.keys(backgroundColorNums).forEach(function(k2) {
    var o2 = open[k2] = "\x1B[" + backgroundColorNums[k2] + "m";
    var c2 = close[k2] = "\x1B[49m";
    colors[k2] = function(s2) {
      return o2 + s2 + c2;
    };
  });
  module.exports = colors;
  colors.open = open;
  colors.close = close;
});

// node_modules/cardinal/themes/default.js
var require_default = __commonJS((exports, module) => {
  var colors = require_ansicolors();
  module.exports = {
    Boolean: {
      true: undefined,
      false: undefined,
      _default: colors.brightRed
    },
    Identifier: {
      undefined: colors.brightBlack,
      self: colors.brightRed,
      console: colors.blue,
      log: colors.blue,
      warn: colors.red,
      error: colors.brightRed,
      _default: colors.white
    },
    Null: {
      _default: colors.brightBlack
    },
    Numeric: {
      _default: colors.blue
    },
    String: {
      _default: function(s2, info) {
        var nextToken = info.tokens[info.tokenIndex + 1];
        return nextToken && nextToken.type === "Punctuator" && nextToken.value === ":" ? colors.green(s2) : colors.brightGreen(s2);
      }
    },
    Keyword: {
      break: undefined,
      case: undefined,
      catch: colors.cyan,
      class: undefined,
      const: undefined,
      continue: undefined,
      debugger: undefined,
      default: undefined,
      delete: colors.red,
      do: undefined,
      else: undefined,
      enum: undefined,
      export: undefined,
      extends: undefined,
      finally: colors.cyan,
      for: undefined,
      function: undefined,
      if: undefined,
      implements: undefined,
      import: undefined,
      in: undefined,
      instanceof: undefined,
      let: undefined,
      new: colors.red,
      package: undefined,
      private: undefined,
      protected: undefined,
      public: undefined,
      return: colors.red,
      static: undefined,
      super: undefined,
      switch: undefined,
      this: colors.brightRed,
      throw: undefined,
      try: colors.cyan,
      typeof: undefined,
      var: colors.green,
      void: undefined,
      while: undefined,
      with: undefined,
      yield: undefined,
      _default: colors.brightBlue
    },
    Punctuator: {
      ";": colors.brightBlack,
      ".": colors.green,
      ",": colors.green,
      "{": colors.yellow,
      "}": colors.yellow,
      "(": colors.brightBlack,
      ")": colors.brightBlack,
      "[": colors.yellow,
      "]": colors.yellow,
      "<": undefined,
      ">": undefined,
      "+": undefined,
      "-": undefined,
      "*": undefined,
      "%": undefined,
      "&": undefined,
      "|": undefined,
      "^": undefined,
      "!": undefined,
      "~": undefined,
      "?": undefined,
      ":": undefined,
      "=": undefined,
      "<=": undefined,
      ">=": undefined,
      "==": undefined,
      "!=": undefined,
      "++": undefined,
      "--": undefined,
      "<<": undefined,
      ">>": undefined,
      "&&": undefined,
      "||": undefined,
      "+=": undefined,
      "-=": undefined,
      "*=": undefined,
      "%=": undefined,
      "&=": undefined,
      "|=": undefined,
      "^=": undefined,
      "/=": undefined,
      "=>": undefined,
      "**": undefined,
      "===": undefined,
      "!==": undefined,
      ">>>": undefined,
      "<<=": undefined,
      ">>=": undefined,
      "...": undefined,
      "**=": undefined,
      ">>>=": undefined,
      _default: colors.brightYellow
    },
    Line: {
      _default: colors.brightBlack
    },
    Block: {
      _default: colors.brightBlack
    },
    JSXAttribute: {
      _default: colors.magenta
    },
    JSXClosingElement: {
      _default: colors.magenta
    },
    JSXElement: {
      _default: colors.magenta
    },
    JSXEmptyExpression: {
      _default: colors.magenta
    },
    JSXExpressionContainer: {
      _default: colors.magenta
    },
    JSXIdentifier: {
      className: colors.blue,
      _default: colors.magenta
    },
    JSXMemberExpression: {
      _default: colors.magenta
    },
    JSXNamespacedName: {
      _default: colors.magenta
    },
    JSXOpeningElement: {
      _default: colors.magenta
    },
    JSXSpreadAttribute: {
      _default: colors.magenta
    },
    JSXText: {
      _default: colors.brightGreen
    },
    _default: undefined
  };
});

// node_modules/cardinal/lib/highlight.js
var require_highlight = __commonJS((exports, module) => {
  var trimEmptyLines = function(lines) {
    var line = lines.pop();
    while (!line || !line.length) {
      line = lines.pop();
    }
    if (line)
      lines.push(line);
  };
  var addLinenos = function(highlightedCode, firstline) {
    var highlightedLines = highlightedCode.split("\n");
    trimEmptyLines(highlightedLines);
    var linesLen = highlightedLines.length;
    var lines = [];
    var totalDigits;
    var lineno;
    function getDigits(n2) {
      if (n2 < 10)
        return 1;
      if (n2 < 100)
        return 2;
      if (n2 < 1000)
        return 3;
      if (n2 < 1e4)
        return 4;
      return 5;
    }
    function pad(n2, totalDigits2) {
      var padDigits = totalDigits2 - getDigits(n2);
      switch (padDigits) {
        case 0:
          return "" + n2;
        case 1:
          return " " + n2;
        case 2:
          return "  " + n2;
        case 3:
          return "   " + n2;
        case 4:
          return "    " + n2;
        case 5:
          return "     " + n2;
      }
    }
    totalDigits = getDigits(linesLen + firstline - 1);
    for (var i2 = 0;i2 < linesLen; i2++) {
      lineno = colorSurround(pad(i2 + firstline, totalDigits) + ": ").replace(surroundClose, "");
      lines.push(lineno + highlightedLines[i2]);
    }
    return lines.join("\n");
  };
  var redeyed = require_redeyed();
  var theme = require_default();
  var colors = require_ansicolors();
  var colorSurround = colors.brightBlack;
  var surroundClose = "\x1B[39m";
  module.exports = function highlight(code, opts) {
    opts = opts || {};
    try {
      var result = redeyed(code, opts.theme || theme, { jsx: !!opts.jsx });
      var firstline = opts.firstline && !isNaN(opts.firstline) ? opts.firstline : 1;
      return opts.linenos ? addLinenos(result.code, firstline) : result.code;
    } catch (e2) {
      e2.message = "Unable to perform highlight. The code contained syntax errors: " + e2.message;
      throw e2;
    }
  };
});

// node_modules/cardinal/lib/highlightFile.js
var require_highlightFile = __commonJS((exports, module) => {
  var isFunction8 = function(obj) {
    return toString.call(obj) === "[object Function]";
  };
  var fs2 = __require("fs");
  var highlight = require_highlight();
  module.exports = function highlightFile(fullPath, opts, cb) {
    if (isFunction8(opts)) {
      cb = opts;
      opts = {};
    }
    opts = opts || {};
    fs2.readFile(fullPath, "utf-8", function(err, code) {
      if (err)
        return cb(err);
      try {
        cb(null, highlight(code, opts));
      } catch (e2) {
        cb(e2);
      }
    });
  };
});

// node_modules/cardinal/lib/highlightFileSync.js
var require_highlightFileSync = __commonJS((exports, module) => {
  var fs2 = __require("fs");
  var highlight = require_highlight();
  module.exports = function highlightFileSync(fullPath, opts) {
    var code = fs2.readFileSync(fullPath, "utf-8");
    opts = opts || {};
    return highlight(code, opts);
  };
});

// node_modules/cardinal/cardinal.js
var require_cardinal = __commonJS((exports, module) => {
  module.exports = {
    highlight: require_highlight(),
    highlightFile: require_highlightFile(),
    highlightFileSync: require_highlightFileSync()
  };
});

// node_modules/@sindresorhus/is/dist/index.js
var require_dist = __commonJS((exports, module) => {
  var isTypedArrayName = function(name) {
    return typedArrayTypeNames.includes(name);
  };
  var isObjectTypeName = function(name) {
    return objectTypeNames.includes(name);
  };
  var isPrimitiveTypeName = function(name) {
    return primitiveTypeNames.includes(name);
  };
  var isOfType = function(type) {
    return (value) => typeof value === type;
  };
  var is = function(value) {
    if (value === null) {
      return "null";
    }
    switch (typeof value) {
      case "undefined":
        return "undefined";
      case "string":
        return "string";
      case "number":
        return "number";
      case "boolean":
        return "boolean";
      case "function":
        return "Function";
      case "bigint":
        return "bigint";
      case "symbol":
        return "symbol";
      default:
    }
    if (is.observable(value)) {
      return "Observable";
    }
    if (is.array(value)) {
      return "Array";
    }
    if (is.buffer(value)) {
      return "Buffer";
    }
    const tagType = getObjectType(value);
    if (tagType) {
      return tagType;
    }
    if (value instanceof String || value instanceof Boolean || value instanceof Number) {
      throw new TypeError("Please don\'t use object wrappers for primitive types");
    }
    return "Object";
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var typedArrayTypeNames = [
    "Int8Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Int16Array",
    "Uint16Array",
    "Int32Array",
    "Uint32Array",
    "Float32Array",
    "Float64Array",
    "BigInt64Array",
    "BigUint64Array"
  ];
  var objectTypeNames = [
    "Function",
    "Generator",
    "AsyncGenerator",
    "GeneratorFunction",
    "AsyncGeneratorFunction",
    "AsyncFunction",
    "Observable",
    "Array",
    "Buffer",
    "Object",
    "RegExp",
    "Date",
    "Error",
    "Map",
    "Set",
    "WeakMap",
    "WeakSet",
    "ArrayBuffer",
    "SharedArrayBuffer",
    "DataView",
    "Promise",
    "URL",
    "HTMLElement",
    ...typedArrayTypeNames
  ];
  var primitiveTypeNames = [
    "null",
    "undefined",
    "string",
    "number",
    "bigint",
    "boolean",
    "symbol"
  ];
  var { toString: toString2 } = Object.prototype;
  var getObjectType = (value) => {
    const objectTypeName = toString2.call(value).slice(8, -1);
    if (/HTML\w+Element/.test(objectTypeName) && is.domElement(value)) {
      return "HTMLElement";
    }
    if (isObjectTypeName(objectTypeName)) {
      return objectTypeName;
    }
    return;
  };
  var isObjectOfType = (type) => (value) => getObjectType(value) === type;
  is.undefined = isOfType("undefined");
  is.string = isOfType("string");
  var isNumberType = isOfType("number");
  is.number = (value) => isNumberType(value) && !is.nan(value);
  is.bigint = isOfType("bigint");
  is.function_ = isOfType("function");
  is.null_ = (value) => value === null;
  is.class_ = (value) => is.function_(value) && value.toString().startsWith("class ");
  is.boolean = (value) => value === true || value === false;
  is.symbol = isOfType("symbol");
  is.numericString = (value) => is.string(value) && !is.emptyStringOrWhitespace(value) && !Number.isNaN(Number(value));
  is.array = (value, assertion) => {
    if (!Array.isArray(value)) {
      return false;
    }
    if (!is.function_(assertion)) {
      return true;
    }
    return value.every(assertion);
  };
  is.buffer = (value) => {
    var _a2, _b, _c, _d;
    return (_d = (_c = (_b = (_a2 = value) === null || _a2 === undefined ? undefined : _a2.constructor) === null || _b === undefined ? undefined : _b.isBuffer) === null || _c === undefined ? undefined : _c.call(_b, value)) !== null && _d !== undefined ? _d : false;
  };
  is.nullOrUndefined = (value) => is.null_(value) || is.undefined(value);
  is.object = (value) => !is.null_(value) && (typeof value === "object" || is.function_(value));
  is.iterable = (value) => {
    var _a2;
    return is.function_((_a2 = value) === null || _a2 === undefined ? undefined : _a2[Symbol.iterator]);
  };
  is.asyncIterable = (value) => {
    var _a2;
    return is.function_((_a2 = value) === null || _a2 === undefined ? undefined : _a2[Symbol.asyncIterator]);
  };
  is.generator = (value) => is.iterable(value) && is.function_(value.next) && is.function_(value.throw);
  is.asyncGenerator = (value) => is.asyncIterable(value) && is.function_(value.next) && is.function_(value.throw);
  is.nativePromise = (value) => isObjectOfType("Promise")(value);
  var hasPromiseAPI = (value) => {
    var _a2, _b;
    return is.function_((_a2 = value) === null || _a2 === undefined ? undefined : _a2.then) && is.function_((_b = value) === null || _b === undefined ? undefined : _b.catch);
  };
  is.promise = (value) => is.nativePromise(value) || hasPromiseAPI(value);
  is.generatorFunction = isObjectOfType("GeneratorFunction");
  is.asyncGeneratorFunction = (value) => getObjectType(value) === "AsyncGeneratorFunction";
  is.asyncFunction = (value) => getObjectType(value) === "AsyncFunction";
  is.boundFunction = (value) => is.function_(value) && !value.hasOwnProperty("prototype");
  is.regExp = isObjectOfType("RegExp");
  is.date = isObjectOfType("Date");
  is.error = isObjectOfType("Error");
  is.map = (value) => isObjectOfType("Map")(value);
  is.set = (value) => isObjectOfType("Set")(value);
  is.weakMap = (value) => isObjectOfType("WeakMap")(value);
  is.weakSet = (value) => isObjectOfType("WeakSet")(value);
  is.int8Array = isObjectOfType("Int8Array");
  is.uint8Array = isObjectOfType("Uint8Array");
  is.uint8ClampedArray = isObjectOfType("Uint8ClampedArray");
  is.int16Array = isObjectOfType("Int16Array");
  is.uint16Array = isObjectOfType("Uint16Array");
  is.int32Array = isObjectOfType("Int32Array");
  is.uint32Array = isObjectOfType("Uint32Array");
  is.float32Array = isObjectOfType("Float32Array");
  is.float64Array = isObjectOfType("Float64Array");
  is.bigInt64Array = isObjectOfType("BigInt64Array");
  is.bigUint64Array = isObjectOfType("BigUint64Array");
  is.arrayBuffer = isObjectOfType("ArrayBuffer");
  is.sharedArrayBuffer = isObjectOfType("SharedArrayBuffer");
  is.dataView = isObjectOfType("DataView");
  is.directInstanceOf = (instance, class_) => Object.getPrototypeOf(instance) === class_.prototype;
  is.urlInstance = (value) => isObjectOfType("URL")(value);
  is.urlString = (value) => {
    if (!is.string(value)) {
      return false;
    }
    try {
      new URL(value);
      return true;
    } catch (_a2) {
      return false;
    }
  };
  is.truthy = (value) => Boolean(value);
  is.falsy = (value) => !value;
  is.nan = (value) => Number.isNaN(value);
  is.primitive = (value) => is.null_(value) || isPrimitiveTypeName(typeof value);
  is.integer = (value) => Number.isInteger(value);
  is.safeInteger = (value) => Number.isSafeInteger(value);
  is.plainObject = (value) => {
    if (toString2.call(value) !== "[object Object]") {
      return false;
    }
    const prototype = Object.getPrototypeOf(value);
    return prototype === null || prototype === Object.getPrototypeOf({});
  };
  is.typedArray = (value) => isTypedArrayName(getObjectType(value));
  var isValidLength = (value) => is.safeInteger(value) && value >= 0;
  is.arrayLike = (value) => !is.nullOrUndefined(value) && !is.function_(value) && isValidLength(value.length);
  is.inRange = (value, range) => {
    if (is.number(range)) {
      return value >= Math.min(0, range) && value <= Math.max(range, 0);
    }
    if (is.array(range) && range.length === 2) {
      return value >= Math.min(...range) && value <= Math.max(...range);
    }
    throw new TypeError(`Invalid range: ${JSON.stringify(range)}`);
  };
  var NODE_TYPE_ELEMENT = 1;
  var DOM_PROPERTIES_TO_CHECK = [
    "innerHTML",
    "ownerDocument",
    "style",
    "attributes",
    "nodeValue"
  ];
  is.domElement = (value) => {
    return is.object(value) && value.nodeType === NODE_TYPE_ELEMENT && is.string(value.nodeName) && !is.plainObject(value) && DOM_PROPERTIES_TO_CHECK.every((property) => (property in value));
  };
  is.observable = (value) => {
    var _a2, _b, _c, _d;
    if (!value) {
      return false;
    }
    if (value === ((_b = (_a2 = value)[Symbol.observable]) === null || _b === undefined ? undefined : _b.call(_a2))) {
      return true;
    }
    if (value === ((_d = (_c = value)["@@observable"]) === null || _d === undefined ? undefined : _d.call(_c))) {
      return true;
    }
    return false;
  };
  is.nodeStream = (value) => is.object(value) && is.function_(value.pipe) && !is.observable(value);
  is.infinite = (value) => value === Infinity || value === (-Infinity);
  var isAbsoluteMod2 = (remainder) => (value) => is.integer(value) && Math.abs(value % 2) === remainder;
  is.evenInteger = isAbsoluteMod2(0);
  is.oddInteger = isAbsoluteMod2(1);
  is.emptyArray = (value) => is.array(value) && value.length === 0;
  is.nonEmptyArray = (value) => is.array(value) && value.length > 0;
  is.emptyString = (value) => is.string(value) && value.length === 0;
  is.nonEmptyString = (value) => is.string(value) && value.length > 0;
  var isWhiteSpaceString = (value) => is.string(value) && !/\S/.test(value);
  is.emptyStringOrWhitespace = (value) => is.emptyString(value) || isWhiteSpaceString(value);
  is.emptyObject = (value) => is.object(value) && !is.map(value) && !is.set(value) && Object.keys(value).length === 0;
  is.nonEmptyObject = (value) => is.object(value) && !is.map(value) && !is.set(value) && Object.keys(value).length > 0;
  is.emptySet = (value) => is.set(value) && value.size === 0;
  is.nonEmptySet = (value) => is.set(value) && value.size > 0;
  is.emptyMap = (value) => is.map(value) && value.size === 0;
  is.nonEmptyMap = (value) => is.map(value) && value.size > 0;
  var predicateOnArray = (method, predicate, values) => {
    if (!is.function_(predicate)) {
      throw new TypeError(`Invalid predicate: ${JSON.stringify(predicate)}`);
    }
    if (values.length === 0) {
      throw new TypeError("Invalid number of values");
    }
    return method.call(values, predicate);
  };
  is.any = (predicate, ...values) => {
    const predicates = is.array(predicate) ? predicate : [predicate];
    return predicates.some((singlePredicate) => predicateOnArray(Array.prototype.some, singlePredicate, values));
  };
  is.all = (predicate, ...values) => predicateOnArray(Array.prototype.every, predicate, values);
  var assertType = (condition, description, value) => {
    if (!condition) {
      throw new TypeError(`Expected value which is \`${description}\`, received value of type \`${is(value)}\`.`);
    }
  };
  exports.assert = {
    undefined: (value) => assertType(is.undefined(value), "undefined", value),
    string: (value) => assertType(is.string(value), "string", value),
    number: (value) => assertType(is.number(value), "number", value),
    bigint: (value) => assertType(is.bigint(value), "bigint", value),
    function_: (value) => assertType(is.function_(value), "Function", value),
    null_: (value) => assertType(is.null_(value), "null", value),
    class_: (value) => assertType(is.class_(value), "Class", value),
    boolean: (value) => assertType(is.boolean(value), "boolean", value),
    symbol: (value) => assertType(is.symbol(value), "symbol", value),
    numericString: (value) => assertType(is.numericString(value), "string with a number", value),
    array: (value, assertion) => {
      const assert = assertType;
      assert(is.array(value), "Array", value);
      if (assertion) {
        value.forEach(assertion);
      }
    },
    buffer: (value) => assertType(is.buffer(value), "Buffer", value),
    nullOrUndefined: (value) => assertType(is.nullOrUndefined(value), "null or undefined", value),
    object: (value) => assertType(is.object(value), "Object", value),
    iterable: (value) => assertType(is.iterable(value), "Iterable", value),
    asyncIterable: (value) => assertType(is.asyncIterable(value), "AsyncIterable", value),
    generator: (value) => assertType(is.generator(value), "Generator", value),
    asyncGenerator: (value) => assertType(is.asyncGenerator(value), "AsyncGenerator", value),
    nativePromise: (value) => assertType(is.nativePromise(value), "native Promise", value),
    promise: (value) => assertType(is.promise(value), "Promise", value),
    generatorFunction: (value) => assertType(is.generatorFunction(value), "GeneratorFunction", value),
    asyncGeneratorFunction: (value) => assertType(is.asyncGeneratorFunction(value), "AsyncGeneratorFunction", value),
    asyncFunction: (value) => assertType(is.asyncFunction(value), "AsyncFunction", value),
    boundFunction: (value) => assertType(is.boundFunction(value), "Function", value),
    regExp: (value) => assertType(is.regExp(value), "RegExp", value),
    date: (value) => assertType(is.date(value), "Date", value),
    error: (value) => assertType(is.error(value), "Error", value),
    map: (value) => assertType(is.map(value), "Map", value),
    set: (value) => assertType(is.set(value), "Set", value),
    weakMap: (value) => assertType(is.weakMap(value), "WeakMap", value),
    weakSet: (value) => assertType(is.weakSet(value), "WeakSet", value),
    int8Array: (value) => assertType(is.int8Array(value), "Int8Array", value),
    uint8Array: (value) => assertType(is.uint8Array(value), "Uint8Array", value),
    uint8ClampedArray: (value) => assertType(is.uint8ClampedArray(value), "Uint8ClampedArray", value),
    int16Array: (value) => assertType(is.int16Array(value), "Int16Array", value),
    uint16Array: (value) => assertType(is.uint16Array(value), "Uint16Array", value),
    int32Array: (value) => assertType(is.int32Array(value), "Int32Array", value),
    uint32Array: (value) => assertType(is.uint32Array(value), "Uint32Array", value),
    float32Array: (value) => assertType(is.float32Array(value), "Float32Array", value),
    float64Array: (value) => assertType(is.float64Array(value), "Float64Array", value),
    bigInt64Array: (value) => assertType(is.bigInt64Array(value), "BigInt64Array", value),
    bigUint64Array: (value) => assertType(is.bigUint64Array(value), "BigUint64Array", value),
    arrayBuffer: (value) => assertType(is.arrayBuffer(value), "ArrayBuffer", value),
    sharedArrayBuffer: (value) => assertType(is.sharedArrayBuffer(value), "SharedArrayBuffer", value),
    dataView: (value) => assertType(is.dataView(value), "DataView", value),
    urlInstance: (value) => assertType(is.urlInstance(value), "URL", value),
    urlString: (value) => assertType(is.urlString(value), "string with a URL", value),
    truthy: (value) => assertType(is.truthy(value), "truthy", value),
    falsy: (value) => assertType(is.falsy(value), "falsy", value),
    nan: (value) => assertType(is.nan(value), "NaN", value),
    primitive: (value) => assertType(is.primitive(value), "primitive", value),
    integer: (value) => assertType(is.integer(value), "integer", value),
    safeInteger: (value) => assertType(is.safeInteger(value), "integer", value),
    plainObject: (value) => assertType(is.plainObject(value), "plain object", value),
    typedArray: (value) => assertType(is.typedArray(value), "TypedArray", value),
    arrayLike: (value) => assertType(is.arrayLike(value), "array-like", value),
    domElement: (value) => assertType(is.domElement(value), "HTMLElement", value),
    observable: (value) => assertType(is.observable(value), "Observable", value),
    nodeStream: (value) => assertType(is.nodeStream(value), "Node.js Stream", value),
    infinite: (value) => assertType(is.infinite(value), "infinite number", value),
    emptyArray: (value) => assertType(is.emptyArray(value), "empty array", value),
    nonEmptyArray: (value) => assertType(is.nonEmptyArray(value), "non-empty array", value),
    emptyString: (value) => assertType(is.emptyString(value), "empty string", value),
    nonEmptyString: (value) => assertType(is.nonEmptyString(value), "non-empty string", value),
    emptyStringOrWhitespace: (value) => assertType(is.emptyStringOrWhitespace(value), "empty string or whitespace", value),
    emptyObject: (value) => assertType(is.emptyObject(value), "empty object", value),
    nonEmptyObject: (value) => assertType(is.nonEmptyObject(value), "non-empty object", value),
    emptySet: (value) => assertType(is.emptySet(value), "empty set", value),
    nonEmptySet: (value) => assertType(is.nonEmptySet(value), "non-empty set", value),
    emptyMap: (value) => assertType(is.emptyMap(value), "empty map", value),
    nonEmptyMap: (value) => assertType(is.nonEmptyMap(value), "non-empty map", value),
    evenInteger: (value) => assertType(is.evenInteger(value), "even integer", value),
    oddInteger: (value) => assertType(is.oddInteger(value), "odd integer", value),
    directInstanceOf: (instance, class_) => assertType(is.directInstanceOf(instance, class_), "T", instance),
    inRange: (value, range) => assertType(is.inRange(value, range), "in range", value),
    any: (predicate, ...values) => assertType(is.any(predicate, ...values), "predicate returns truthy for any value", values),
    all: (predicate, ...values) => assertType(is.all(predicate, ...values), "predicate returns truthy for all values", values)
  };
  Object.defineProperties(is, {
    class: {
      value: is.class_
    },
    function: {
      value: is.function_
    },
    null: {
      value: is.null_
    }
  });
  Object.defineProperties(exports.assert, {
    class: {
      value: exports.assert.class_
    },
    function: {
      value: exports.assert.function_
    },
    null: {
      value: exports.assert.null_
    }
  });
  exports.default = is;
  module.exports = is;
  module.exports.default = is;
  module.exports.assert = exports.assert;
});

// node_modules/emojilib/emojis.json
var require_emojis = __commonJS((exports, module) => {
  module.exports = {
    grinning: {
      keywords: ["face", "smile", "happy", "joy", ":D", "grin"],
      char: "\uD83D\uDE00",
      fitzpatrick_scale: false,
      category: "people"
    },
    grimacing: {
      keywords: ["face", "grimace", "teeth"],
      char: "\uD83D\uDE2C",
      fitzpatrick_scale: false,
      category: "people"
    },
    grin: {
      keywords: ["face", "happy", "smile", "joy", "kawaii"],
      char: "\uD83D\uDE01",
      fitzpatrick_scale: false,
      category: "people"
    },
    joy: {
      keywords: ["face", "cry", "tears", "weep", "happy", "happytears", "haha"],
      char: "\uD83D\uDE02",
      fitzpatrick_scale: false,
      category: "people"
    },
    rofl: {
      keywords: ["face", "rolling", "floor", "laughing", "lol", "haha"],
      char: "\uD83E\uDD23",
      fitzpatrick_scale: false,
      category: "people"
    },
    partying: {
      keywords: ["face", "celebration", "woohoo"],
      char: "\uD83E\uDD73",
      fitzpatrick_scale: false,
      category: "people"
    },
    smiley: {
      keywords: ["face", "happy", "joy", "haha", ":D", ":)", "smile", "funny"],
      char: "\uD83D\uDE03",
      fitzpatrick_scale: false,
      category: "people"
    },
    smile: {
      keywords: ["face", "happy", "joy", "funny", "haha", "laugh", "like", ":D", ":)"],
      char: "\uD83D\uDE04",
      fitzpatrick_scale: false,
      category: "people"
    },
    sweat_smile: {
      keywords: ["face", "hot", "happy", "laugh", "sweat", "smile", "relief"],
      char: "\uD83D\uDE05",
      fitzpatrick_scale: false,
      category: "people"
    },
    laughing: {
      keywords: ["happy", "joy", "lol", "satisfied", "haha", "face", "glad", "XD", "laugh"],
      char: "\uD83D\uDE06",
      fitzpatrick_scale: false,
      category: "people"
    },
    innocent: {
      keywords: ["face", "angel", "heaven", "halo"],
      char: "\uD83D\uDE07",
      fitzpatrick_scale: false,
      category: "people"
    },
    wink: {
      keywords: ["face", "happy", "mischievous", "secret", ";)", "smile", "eye"],
      char: "\uD83D\uDE09",
      fitzpatrick_scale: false,
      category: "people"
    },
    blush: {
      keywords: ["face", "smile", "happy", "flushed", "crush", "embarrassed", "shy", "joy"],
      char: "\uD83D\uDE0A",
      fitzpatrick_scale: false,
      category: "people"
    },
    slightly_smiling_face: {
      keywords: ["face", "smile"],
      char: "\uD83D\uDE42",
      fitzpatrick_scale: false,
      category: "people"
    },
    upside_down_face: {
      keywords: ["face", "flipped", "silly", "smile"],
      char: "\uD83D\uDE43",
      fitzpatrick_scale: false,
      category: "people"
    },
    relaxed: {
      keywords: ["face", "blush", "massage", "happiness"],
      char: "\u263A\uFE0F",
      fitzpatrick_scale: false,
      category: "people"
    },
    yum: {
      keywords: ["happy", "joy", "tongue", "smile", "face", "silly", "yummy", "nom", "delicious", "savouring"],
      char: "\uD83D\uDE0B",
      fitzpatrick_scale: false,
      category: "people"
    },
    relieved: {
      keywords: ["face", "relaxed", "phew", "massage", "happiness"],
      char: "\uD83D\uDE0C",
      fitzpatrick_scale: false,
      category: "people"
    },
    heart_eyes: {
      keywords: ["face", "love", "like", "affection", "valentines", "infatuation", "crush", "heart"],
      char: "\uD83D\uDE0D",
      fitzpatrick_scale: false,
      category: "people"
    },
    smiling_face_with_three_hearts: {
      keywords: ["face", "love", "like", "affection", "valentines", "infatuation", "crush", "hearts", "adore"],
      char: "\uD83E\uDD70",
      fitzpatrick_scale: false,
      category: "people"
    },
    kissing_heart: {
      keywords: ["face", "love", "like", "affection", "valentines", "infatuation", "kiss"],
      char: "\uD83D\uDE18",
      fitzpatrick_scale: false,
      category: "people"
    },
    kissing: {
      keywords: ["love", "like", "face", "3", "valentines", "infatuation", "kiss"],
      char: "\uD83D\uDE17",
      fitzpatrick_scale: false,
      category: "people"
    },
    kissing_smiling_eyes: {
      keywords: ["face", "affection", "valentines", "infatuation", "kiss"],
      char: "\uD83D\uDE19",
      fitzpatrick_scale: false,
      category: "people"
    },
    kissing_closed_eyes: {
      keywords: ["face", "love", "like", "affection", "valentines", "infatuation", "kiss"],
      char: "\uD83D\uDE1A",
      fitzpatrick_scale: false,
      category: "people"
    },
    stuck_out_tongue_winking_eye: {
      keywords: ["face", "prank", "childish", "playful", "mischievous", "smile", "wink", "tongue"],
      char: "\uD83D\uDE1C",
      fitzpatrick_scale: false,
      category: "people"
    },
    zany: {
      keywords: ["face", "goofy", "crazy"],
      char: "\uD83E\uDD2A",
      fitzpatrick_scale: false,
      category: "people"
    },
    raised_eyebrow: {
      keywords: ["face", "distrust", "scepticism", "disapproval", "disbelief", "surprise"],
      char: "\uD83E\uDD28",
      fitzpatrick_scale: false,
      category: "people"
    },
    monocle: {
      keywords: ["face", "stuffy", "wealthy"],
      char: "\uD83E\uDDD0",
      fitzpatrick_scale: false,
      category: "people"
    },
    stuck_out_tongue_closed_eyes: {
      keywords: ["face", "prank", "playful", "mischievous", "smile", "tongue"],
      char: "\uD83D\uDE1D",
      fitzpatrick_scale: false,
      category: "people"
    },
    stuck_out_tongue: {
      keywords: ["face", "prank", "childish", "playful", "mischievous", "smile", "tongue"],
      char: "\uD83D\uDE1B",
      fitzpatrick_scale: false,
      category: "people"
    },
    money_mouth_face: {
      keywords: ["face", "rich", "dollar", "money"],
      char: "\uD83E\uDD11",
      fitzpatrick_scale: false,
      category: "people"
    },
    nerd_face: {
      keywords: ["face", "nerdy", "geek", "dork"],
      char: "\uD83E\uDD13",
      fitzpatrick_scale: false,
      category: "people"
    },
    sunglasses: {
      keywords: ["face", "cool", "smile", "summer", "beach", "sunglass"],
      char: "\uD83D\uDE0E",
      fitzpatrick_scale: false,
      category: "people"
    },
    star_struck: {
      keywords: ["face", "smile", "starry", "eyes", "grinning"],
      char: "\uD83E\uDD29",
      fitzpatrick_scale: false,
      category: "people"
    },
    clown_face: {
      keywords: ["face"],
      char: "\uD83E\uDD21",
      fitzpatrick_scale: false,
      category: "people"
    },
    cowboy_hat_face: {
      keywords: ["face", "cowgirl", "hat"],
      char: "\uD83E\uDD20",
      fitzpatrick_scale: false,
      category: "people"
    },
    hugs: {
      keywords: ["face", "smile", "hug"],
      char: "\uD83E\uDD17",
      fitzpatrick_scale: false,
      category: "people"
    },
    smirk: {
      keywords: ["face", "smile", "mean", "prank", "smug", "sarcasm"],
      char: "\uD83D\uDE0F",
      fitzpatrick_scale: false,
      category: "people"
    },
    no_mouth: {
      keywords: ["face", "hellokitty"],
      char: "\uD83D\uDE36",
      fitzpatrick_scale: false,
      category: "people"
    },
    neutral_face: {
      keywords: ["indifference", "meh", ":|", "neutral"],
      char: "\uD83D\uDE10",
      fitzpatrick_scale: false,
      category: "people"
    },
    expressionless: {
      keywords: ["face", "indifferent", "-_-", "meh", "deadpan"],
      char: "\uD83D\uDE11",
      fitzpatrick_scale: false,
      category: "people"
    },
    unamused: {
      keywords: ["indifference", "bored", "straight face", "serious", "sarcasm", "unimpressed", "skeptical", "dubious", "side_eye"],
      char: "\uD83D\uDE12",
      fitzpatrick_scale: false,
      category: "people"
    },
    roll_eyes: {
      keywords: ["face", "eyeroll", "frustrated"],
      char: "\uD83D\uDE44",
      fitzpatrick_scale: false,
      category: "people"
    },
    thinking: {
      keywords: ["face", "hmmm", "think", "consider"],
      char: "\uD83E\uDD14",
      fitzpatrick_scale: false,
      category: "people"
    },
    lying_face: {
      keywords: ["face", "lie", "pinocchio"],
      char: "\uD83E\uDD25",
      fitzpatrick_scale: false,
      category: "people"
    },
    hand_over_mouth: {
      keywords: ["face", "whoops", "shock", "surprise"],
      char: "\uD83E\uDD2D",
      fitzpatrick_scale: false,
      category: "people"
    },
    shushing: {
      keywords: ["face", "quiet", "shhh"],
      char: "\uD83E\uDD2B",
      fitzpatrick_scale: false,
      category: "people"
    },
    symbols_over_mouth: {
      keywords: ["face", "swearing", "cursing", "cussing", "profanity", "expletive"],
      char: "\uD83E\uDD2C",
      fitzpatrick_scale: false,
      category: "people"
    },
    exploding_head: {
      keywords: ["face", "shocked", "mind", "blown"],
      char: "\uD83E\uDD2F",
      fitzpatrick_scale: false,
      category: "people"
    },
    flushed: {
      keywords: ["face", "blush", "shy", "flattered"],
      char: "\uD83D\uDE33",
      fitzpatrick_scale: false,
      category: "people"
    },
    disappointed: {
      keywords: ["face", "sad", "upset", "depressed", ":("],
      char: "\uD83D\uDE1E",
      fitzpatrick_scale: false,
      category: "people"
    },
    worried: {
      keywords: ["face", "concern", "nervous", ":("],
      char: "\uD83D\uDE1F",
      fitzpatrick_scale: false,
      category: "people"
    },
    angry: {
      keywords: ["mad", "face", "annoyed", "frustrated"],
      char: "\uD83D\uDE20",
      fitzpatrick_scale: false,
      category: "people"
    },
    rage: {
      keywords: ["angry", "mad", "hate", "despise"],
      char: "\uD83D\uDE21",
      fitzpatrick_scale: false,
      category: "people"
    },
    pensive: {
      keywords: ["face", "sad", "depressed", "upset"],
      char: "\uD83D\uDE14",
      fitzpatrick_scale: false,
      category: "people"
    },
    confused: {
      keywords: ["face", "indifference", "huh", "weird", "hmmm", ":/"],
      char: "\uD83D\uDE15",
      fitzpatrick_scale: false,
      category: "people"
    },
    slightly_frowning_face: {
      keywords: ["face", "frowning", "disappointed", "sad", "upset"],
      char: "\uD83D\uDE41",
      fitzpatrick_scale: false,
      category: "people"
    },
    frowning_face: {
      keywords: ["face", "sad", "upset", "frown"],
      char: "\u2639",
      fitzpatrick_scale: false,
      category: "people"
    },
    persevere: {
      keywords: ["face", "sick", "no", "upset", "oops"],
      char: "\uD83D\uDE23",
      fitzpatrick_scale: false,
      category: "people"
    },
    confounded: {
      keywords: ["face", "confused", "sick", "unwell", "oops", ":S"],
      char: "\uD83D\uDE16",
      fitzpatrick_scale: false,
      category: "people"
    },
    tired_face: {
      keywords: ["sick", "whine", "upset", "frustrated"],
      char: "\uD83D\uDE2B",
      fitzpatrick_scale: false,
      category: "people"
    },
    weary: {
      keywords: ["face", "tired", "sleepy", "sad", "frustrated", "upset"],
      char: "\uD83D\uDE29",
      fitzpatrick_scale: false,
      category: "people"
    },
    pleading: {
      keywords: ["face", "begging", "mercy"],
      char: "\uD83E\uDD7A",
      fitzpatrick_scale: false,
      category: "people"
    },
    triumph: {
      keywords: ["face", "gas", "phew", "proud", "pride"],
      char: "\uD83D\uDE24",
      fitzpatrick_scale: false,
      category: "people"
    },
    open_mouth: {
      keywords: ["face", "surprise", "impressed", "wow", "whoa", ":O"],
      char: "\uD83D\uDE2E",
      fitzpatrick_scale: false,
      category: "people"
    },
    scream: {
      keywords: ["face", "munch", "scared", "omg"],
      char: "\uD83D\uDE31",
      fitzpatrick_scale: false,
      category: "people"
    },
    fearful: {
      keywords: ["face", "scared", "terrified", "nervous", "oops", "huh"],
      char: "\uD83D\uDE28",
      fitzpatrick_scale: false,
      category: "people"
    },
    cold_sweat: {
      keywords: ["face", "nervous", "sweat"],
      char: "\uD83D\uDE30",
      fitzpatrick_scale: false,
      category: "people"
    },
    hushed: {
      keywords: ["face", "woo", "shh"],
      char: "\uD83D\uDE2F",
      fitzpatrick_scale: false,
      category: "people"
    },
    frowning: {
      keywords: ["face", "aw", "what"],
      char: "\uD83D\uDE26",
      fitzpatrick_scale: false,
      category: "people"
    },
    anguished: {
      keywords: ["face", "stunned", "nervous"],
      char: "\uD83D\uDE27",
      fitzpatrick_scale: false,
      category: "people"
    },
    cry: {
      keywords: ["face", "tears", "sad", "depressed", "upset", ":'("],
      char: "\uD83D\uDE22",
      fitzpatrick_scale: false,
      category: "people"
    },
    disappointed_relieved: {
      keywords: ["face", "phew", "sweat", "nervous"],
      char: "\uD83D\uDE25",
      fitzpatrick_scale: false,
      category: "people"
    },
    drooling_face: {
      keywords: ["face"],
      char: "\uD83E\uDD24",
      fitzpatrick_scale: false,
      category: "people"
    },
    sleepy: {
      keywords: ["face", "tired", "rest", "nap"],
      char: "\uD83D\uDE2A",
      fitzpatrick_scale: false,
      category: "people"
    },
    sweat: {
      keywords: ["face", "hot", "sad", "tired", "exercise"],
      char: "\uD83D\uDE13",
      fitzpatrick_scale: false,
      category: "people"
    },
    hot: {
      keywords: ["face", "feverish", "heat", "red", "sweating"],
      char: "\uD83E\uDD75",
      fitzpatrick_scale: false,
      category: "people"
    },
    cold: {
      keywords: ["face", "blue", "freezing", "frozen", "frostbite", "icicles"],
      char: "\uD83E\uDD76",
      fitzpatrick_scale: false,
      category: "people"
    },
    sob: {
      keywords: ["face", "cry", "tears", "sad", "upset", "depressed"],
      char: "\uD83D\uDE2D",
      fitzpatrick_scale: false,
      category: "people"
    },
    dizzy_face: {
      keywords: ["spent", "unconscious", "xox", "dizzy"],
      char: "\uD83D\uDE35",
      fitzpatrick_scale: false,
      category: "people"
    },
    astonished: {
      keywords: ["face", "xox", "surprised", "poisoned"],
      char: "\uD83D\uDE32",
      fitzpatrick_scale: false,
      category: "people"
    },
    zipper_mouth_face: {
      keywords: ["face", "sealed", "zipper", "secret"],
      char: "\uD83E\uDD10",
      fitzpatrick_scale: false,
      category: "people"
    },
    nauseated_face: {
      keywords: ["face", "vomit", "gross", "green", "sick", "throw up", "ill"],
      char: "\uD83E\uDD22",
      fitzpatrick_scale: false,
      category: "people"
    },
    sneezing_face: {
      keywords: ["face", "gesundheit", "sneeze", "sick", "allergy"],
      char: "\uD83E\uDD27",
      fitzpatrick_scale: false,
      category: "people"
    },
    vomiting: {
      keywords: ["face", "sick"],
      char: "\uD83E\uDD2E",
      fitzpatrick_scale: false,
      category: "people"
    },
    mask: {
      keywords: ["face", "sick", "ill", "disease"],
      char: "\uD83D\uDE37",
      fitzpatrick_scale: false,
      category: "people"
    },
    face_with_thermometer: {
      keywords: ["sick", "temperature", "thermometer", "cold", "fever"],
      char: "\uD83E\uDD12",
      fitzpatrick_scale: false,
      category: "people"
    },
    face_with_head_bandage: {
      keywords: ["injured", "clumsy", "bandage", "hurt"],
      char: "\uD83E\uDD15",
      fitzpatrick_scale: false,
      category: "people"
    },
    woozy: {
      keywords: ["face", "dizzy", "intoxicated", "tipsy", "wavy"],
      char: "\uD83E\uDD74",
      fitzpatrick_scale: false,
      category: "people"
    },
    sleeping: {
      keywords: ["face", "tired", "sleepy", "night", "zzz"],
      char: "\uD83D\uDE34",
      fitzpatrick_scale: false,
      category: "people"
    },
    zzz: {
      keywords: ["sleepy", "tired", "dream"],
      char: "\uD83D\uDCA4",
      fitzpatrick_scale: false,
      category: "people"
    },
    poop: {
      keywords: ["hankey", "shitface", "fail", "turd", "shit"],
      char: "\uD83D\uDCA9",
      fitzpatrick_scale: false,
      category: "people"
    },
    smiling_imp: {
      keywords: ["devil", "horns"],
      char: "\uD83D\uDE08",
      fitzpatrick_scale: false,
      category: "people"
    },
    imp: {
      keywords: ["devil", "angry", "horns"],
      char: "\uD83D\uDC7F",
      fitzpatrick_scale: false,
      category: "people"
    },
    japanese_ogre: {
      keywords: ["monster", "red", "mask", "halloween", "scary", "creepy", "devil", "demon", "japanese", "ogre"],
      char: "\uD83D\uDC79",
      fitzpatrick_scale: false,
      category: "people"
    },
    japanese_goblin: {
      keywords: ["red", "evil", "mask", "monster", "scary", "creepy", "japanese", "goblin"],
      char: "\uD83D\uDC7A",
      fitzpatrick_scale: false,
      category: "people"
    },
    skull: {
      keywords: ["dead", "skeleton", "creepy", "death"],
      char: "\uD83D\uDC80",
      fitzpatrick_scale: false,
      category: "people"
    },
    ghost: {
      keywords: ["halloween", "spooky", "scary"],
      char: "\uD83D\uDC7B",
      fitzpatrick_scale: false,
      category: "people"
    },
    alien: {
      keywords: ["UFO", "paul", "weird", "outer_space"],
      char: "\uD83D\uDC7D",
      fitzpatrick_scale: false,
      category: "people"
    },
    robot: {
      keywords: ["computer", "machine", "bot"],
      char: "\uD83E\uDD16",
      fitzpatrick_scale: false,
      category: "people"
    },
    smiley_cat: {
      keywords: ["animal", "cats", "happy", "smile"],
      char: "\uD83D\uDE3A",
      fitzpatrick_scale: false,
      category: "people"
    },
    smile_cat: {
      keywords: ["animal", "cats", "smile"],
      char: "\uD83D\uDE38",
      fitzpatrick_scale: false,
      category: "people"
    },
    joy_cat: {
      keywords: ["animal", "cats", "haha", "happy", "tears"],
      char: "\uD83D\uDE39",
      fitzpatrick_scale: false,
      category: "people"
    },
    heart_eyes_cat: {
      keywords: ["animal", "love", "like", "affection", "cats", "valentines", "heart"],
      char: "\uD83D\uDE3B",
      fitzpatrick_scale: false,
      category: "people"
    },
    smirk_cat: {
      keywords: ["animal", "cats", "smirk"],
      char: "\uD83D\uDE3C",
      fitzpatrick_scale: false,
      category: "people"
    },
    kissing_cat: {
      keywords: ["animal", "cats", "kiss"],
      char: "\uD83D\uDE3D",
      fitzpatrick_scale: false,
      category: "people"
    },
    scream_cat: {
      keywords: ["animal", "cats", "munch", "scared", "scream"],
      char: "\uD83D\uDE40",
      fitzpatrick_scale: false,
      category: "people"
    },
    crying_cat_face: {
      keywords: ["animal", "tears", "weep", "sad", "cats", "upset", "cry"],
      char: "\uD83D\uDE3F",
      fitzpatrick_scale: false,
      category: "people"
    },
    pouting_cat: {
      keywords: ["animal", "cats"],
      char: "\uD83D\uDE3E",
      fitzpatrick_scale: false,
      category: "people"
    },
    palms_up: {
      keywords: ["hands", "gesture", "cupped", "prayer"],
      char: "\uD83E\uDD32",
      fitzpatrick_scale: true,
      category: "people"
    },
    raised_hands: {
      keywords: ["gesture", "hooray", "yea", "celebration", "hands"],
      char: "\uD83D\uDE4C",
      fitzpatrick_scale: true,
      category: "people"
    },
    clap: {
      keywords: ["hands", "praise", "applause", "congrats", "yay"],
      char: "\uD83D\uDC4F",
      fitzpatrick_scale: true,
      category: "people"
    },
    wave: {
      keywords: ["hands", "gesture", "goodbye", "solong", "farewell", "hello", "hi", "palm"],
      char: "\uD83D\uDC4B",
      fitzpatrick_scale: true,
      category: "people"
    },
    call_me_hand: {
      keywords: ["hands", "gesture"],
      char: "\uD83E\uDD19",
      fitzpatrick_scale: true,
      category: "people"
    },
    "+1": {
      keywords: ["thumbsup", "yes", "awesome", "good", "agree", "accept", "cool", "hand", "like"],
      char: "\uD83D\uDC4D",
      fitzpatrick_scale: true,
      category: "people"
    },
    "-1": {
      keywords: ["thumbsdown", "no", "dislike", "hand"],
      char: "\uD83D\uDC4E",
      fitzpatrick_scale: true,
      category: "people"
    },
    facepunch: {
      keywords: ["angry", "violence", "fist", "hit", "attack", "hand"],
      char: "\uD83D\uDC4A",
      fitzpatrick_scale: true,
      category: "people"
    },
    fist: {
      keywords: ["fingers", "hand", "grasp"],
      char: "\u270A",
      fitzpatrick_scale: true,
      category: "people"
    },
    fist_left: {
      keywords: ["hand", "fistbump"],
      char: "\uD83E\uDD1B",
      fitzpatrick_scale: true,
      category: "people"
    },
    fist_right: {
      keywords: ["hand", "fistbump"],
      char: "\uD83E\uDD1C",
      fitzpatrick_scale: true,
      category: "people"
    },
    v: {
      keywords: ["fingers", "ohyeah", "hand", "peace", "victory", "two"],
      char: "\u270C",
      fitzpatrick_scale: true,
      category: "people"
    },
    ok_hand: {
      keywords: ["fingers", "limbs", "perfect", "ok", "okay"],
      char: "\uD83D\uDC4C",
      fitzpatrick_scale: true,
      category: "people"
    },
    raised_hand: {
      keywords: ["fingers", "stop", "highfive", "palm", "ban"],
      char: "\u270B",
      fitzpatrick_scale: true,
      category: "people"
    },
    raised_back_of_hand: {
      keywords: ["fingers", "raised", "backhand"],
      char: "\uD83E\uDD1A",
      fitzpatrick_scale: true,
      category: "people"
    },
    open_hands: {
      keywords: ["fingers", "butterfly", "hands", "open"],
      char: "\uD83D\uDC50",
      fitzpatrick_scale: true,
      category: "people"
    },
    muscle: {
      keywords: ["arm", "flex", "hand", "summer", "strong", "biceps"],
      char: "\uD83D\uDCAA",
      fitzpatrick_scale: true,
      category: "people"
    },
    pray: {
      keywords: ["please", "hope", "wish", "namaste", "highfive"],
      char: "\uD83D\uDE4F",
      fitzpatrick_scale: true,
      category: "people"
    },
    foot: {
      keywords: ["kick", "stomp"],
      char: "\uD83E\uDDB6",
      fitzpatrick_scale: true,
      category: "people"
    },
    leg: {
      keywords: ["kick", "limb"],
      char: "\uD83E\uDDB5",
      fitzpatrick_scale: true,
      category: "people"
    },
    handshake: {
      keywords: ["agreement", "shake"],
      char: "\uD83E\uDD1D",
      fitzpatrick_scale: false,
      category: "people"
    },
    point_up: {
      keywords: ["hand", "fingers", "direction", "up"],
      char: "\u261D",
      fitzpatrick_scale: true,
      category: "people"
    },
    point_up_2: {
      keywords: ["fingers", "hand", "direction", "up"],
      char: "\uD83D\uDC46",
      fitzpatrick_scale: true,
      category: "people"
    },
    point_down: {
      keywords: ["fingers", "hand", "direction", "down"],
      char: "\uD83D\uDC47",
      fitzpatrick_scale: true,
      category: "people"
    },
    point_left: {
      keywords: ["direction", "fingers", "hand", "left"],
      char: "\uD83D\uDC48",
      fitzpatrick_scale: true,
      category: "people"
    },
    point_right: {
      keywords: ["fingers", "hand", "direction", "right"],
      char: "\uD83D\uDC49",
      fitzpatrick_scale: true,
      category: "people"
    },
    fu: {
      keywords: ["hand", "fingers", "rude", "middle", "flipping"],
      char: "\uD83D\uDD95",
      fitzpatrick_scale: true,
      category: "people"
    },
    raised_hand_with_fingers_splayed: {
      keywords: ["hand", "fingers", "palm"],
      char: "\uD83D\uDD90",
      fitzpatrick_scale: true,
      category: "people"
    },
    love_you: {
      keywords: ["hand", "fingers", "gesture"],
      char: "\uD83E\uDD1F",
      fitzpatrick_scale: true,
      category: "people"
    },
    metal: {
      keywords: ["hand", "fingers", "evil_eye", "sign_of_horns", "rock_on"],
      char: "\uD83E\uDD18",
      fitzpatrick_scale: true,
      category: "people"
    },
    crossed_fingers: {
      keywords: ["good", "lucky"],
      char: "\uD83E\uDD1E",
      fitzpatrick_scale: true,
      category: "people"
    },
    vulcan_salute: {
      keywords: ["hand", "fingers", "spock", "star trek"],
      char: "\uD83D\uDD96",
      fitzpatrick_scale: true,
      category: "people"
    },
    writing_hand: {
      keywords: ["lower_left_ballpoint_pen", "stationery", "write", "compose"],
      char: "\u270D",
      fitzpatrick_scale: true,
      category: "people"
    },
    selfie: {
      keywords: ["camera", "phone"],
      char: "\uD83E\uDD33",
      fitzpatrick_scale: true,
      category: "people"
    },
    nail_care: {
      keywords: ["beauty", "manicure", "finger", "fashion", "nail"],
      char: "\uD83D\uDC85",
      fitzpatrick_scale: true,
      category: "people"
    },
    lips: {
      keywords: ["mouth", "kiss"],
      char: "\uD83D\uDC44",
      fitzpatrick_scale: false,
      category: "people"
    },
    tooth: {
      keywords: ["teeth", "dentist"],
      char: "\uD83E\uDDB7",
      fitzpatrick_scale: false,
      category: "people"
    },
    tongue: {
      keywords: ["mouth", "playful"],
      char: "\uD83D\uDC45",
      fitzpatrick_scale: false,
      category: "people"
    },
    ear: {
      keywords: ["face", "hear", "sound", "listen"],
      char: "\uD83D\uDC42",
      fitzpatrick_scale: true,
      category: "people"
    },
    nose: {
      keywords: ["smell", "sniff"],
      char: "\uD83D\uDC43",
      fitzpatrick_scale: true,
      category: "people"
    },
    eye: {
      keywords: ["face", "look", "see", "watch", "stare"],
      char: "\uD83D\uDC41",
      fitzpatrick_scale: false,
      category: "people"
    },
    eyes: {
      keywords: ["look", "watch", "stalk", "peek", "see"],
      char: "\uD83D\uDC40",
      fitzpatrick_scale: false,
      category: "people"
    },
    brain: {
      keywords: ["smart", "intelligent"],
      char: "\uD83E\uDDE0",
      fitzpatrick_scale: false,
      category: "people"
    },
    bust_in_silhouette: {
      keywords: ["user", "person", "human"],
      char: "\uD83D\uDC64",
      fitzpatrick_scale: false,
      category: "people"
    },
    busts_in_silhouette: {
      keywords: ["user", "person", "human", "group", "team"],
      char: "\uD83D\uDC65",
      fitzpatrick_scale: false,
      category: "people"
    },
    speaking_head: {
      keywords: ["user", "person", "human", "sing", "say", "talk"],
      char: "\uD83D\uDDE3",
      fitzpatrick_scale: false,
      category: "people"
    },
    baby: {
      keywords: ["child", "boy", "girl", "toddler"],
      char: "\uD83D\uDC76",
      fitzpatrick_scale: true,
      category: "people"
    },
    child: {
      keywords: ["gender-neutral", "young"],
      char: "\uD83E\uDDD2",
      fitzpatrick_scale: true,
      category: "people"
    },
    boy: {
      keywords: ["man", "male", "guy", "teenager"],
      char: "\uD83D\uDC66",
      fitzpatrick_scale: true,
      category: "people"
    },
    girl: {
      keywords: ["female", "woman", "teenager"],
      char: "\uD83D\uDC67",
      fitzpatrick_scale: true,
      category: "people"
    },
    adult: {
      keywords: ["gender-neutral", "person"],
      char: "\uD83E\uDDD1",
      fitzpatrick_scale: true,
      category: "people"
    },
    man: {
      keywords: ["mustache", "father", "dad", "guy", "classy", "sir", "moustache"],
      char: "\uD83D\uDC68",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman: {
      keywords: ["female", "girls", "lady"],
      char: "\uD83D\uDC69",
      fitzpatrick_scale: true,
      category: "people"
    },
    blonde_woman: {
      keywords: ["woman", "female", "girl", "blonde", "person"],
      char: "\uD83D\uDC71\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    blonde_man: {
      keywords: ["man", "male", "boy", "blonde", "guy", "person"],
      char: "\uD83D\uDC71",
      fitzpatrick_scale: true,
      category: "people"
    },
    bearded_person: {
      keywords: ["person", "bewhiskered"],
      char: "\uD83E\uDDD4",
      fitzpatrick_scale: true,
      category: "people"
    },
    older_adult: {
      keywords: ["human", "elder", "senior", "gender-neutral"],
      char: "\uD83E\uDDD3",
      fitzpatrick_scale: true,
      category: "people"
    },
    older_man: {
      keywords: ["human", "male", "men", "old", "elder", "senior"],
      char: "\uD83D\uDC74",
      fitzpatrick_scale: true,
      category: "people"
    },
    older_woman: {
      keywords: ["human", "female", "women", "lady", "old", "elder", "senior"],
      char: "\uD83D\uDC75",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_with_gua_pi_mao: {
      keywords: ["male", "boy", "chinese"],
      char: "\uD83D\uDC72",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_with_headscarf: {
      keywords: ["female", "hijab", "mantilla", "tichel"],
      char: "\uD83E\uDDD5",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_with_turban: {
      keywords: ["female", "indian", "hinduism", "arabs", "woman"],
      char: "\uD83D\uDC73\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_with_turban: {
      keywords: ["male", "indian", "hinduism", "arabs"],
      char: "\uD83D\uDC73",
      fitzpatrick_scale: true,
      category: "people"
    },
    policewoman: {
      keywords: ["woman", "police", "law", "legal", "enforcement", "arrest", "911", "female"],
      char: "\uD83D\uDC6E\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    policeman: {
      keywords: ["man", "police", "law", "legal", "enforcement", "arrest", "911"],
      char: "\uD83D\uDC6E",
      fitzpatrick_scale: true,
      category: "people"
    },
    construction_worker_woman: {
      keywords: ["female", "human", "wip", "build", "construction", "worker", "labor", "woman"],
      char: "\uD83D\uDC77\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    construction_worker_man: {
      keywords: ["male", "human", "wip", "guy", "build", "construction", "worker", "labor"],
      char: "\uD83D\uDC77",
      fitzpatrick_scale: true,
      category: "people"
    },
    guardswoman: {
      keywords: ["uk", "gb", "british", "female", "royal", "woman"],
      char: "\uD83D\uDC82\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    guardsman: {
      keywords: ["uk", "gb", "british", "male", "guy", "royal"],
      char: "\uD83D\uDC82",
      fitzpatrick_scale: true,
      category: "people"
    },
    female_detective: {
      keywords: ["human", "spy", "detective", "female", "woman"],
      char: "\uD83D\uDD75\uFE0F\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    male_detective: {
      keywords: ["human", "spy", "detective"],
      char: "\uD83D\uDD75",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_health_worker: {
      keywords: ["doctor", "nurse", "therapist", "healthcare", "woman", "human"],
      char: "\uD83D\uDC69\u200D\u2695\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_health_worker: {
      keywords: ["doctor", "nurse", "therapist", "healthcare", "man", "human"],
      char: "\uD83D\uDC68\u200D\u2695\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_farmer: {
      keywords: ["rancher", "gardener", "woman", "human"],
      char: "\uD83D\uDC69\u200D\uD83C\uDF3E",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_farmer: {
      keywords: ["rancher", "gardener", "man", "human"],
      char: "\uD83D\uDC68\u200D\uD83C\uDF3E",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_cook: {
      keywords: ["chef", "woman", "human"],
      char: "\uD83D\uDC69\u200D\uD83C\uDF73",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_cook: {
      keywords: ["chef", "man", "human"],
      char: "\uD83D\uDC68\u200D\uD83C\uDF73",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_student: {
      keywords: ["graduate", "woman", "human"],
      char: "\uD83D\uDC69\u200D\uD83C\uDF93",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_student: {
      keywords: ["graduate", "man", "human"],
      char: "\uD83D\uDC68\u200D\uD83C\uDF93",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_singer: {
      keywords: ["rockstar", "entertainer", "woman", "human"],
      char: "\uD83D\uDC69\u200D\uD83C\uDFA4",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_singer: {
      keywords: ["rockstar", "entertainer", "man", "human"],
      char: "\uD83D\uDC68\u200D\uD83C\uDFA4",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_teacher: {
      keywords: ["instructor", "professor", "woman", "human"],
      char: "\uD83D\uDC69\u200D\uD83C\uDFEB",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_teacher: {
      keywords: ["instructor", "professor", "man", "human"],
      char: "\uD83D\uDC68\u200D\uD83C\uDFEB",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_factory_worker: {
      keywords: ["assembly", "industrial", "woman", "human"],
      char: "\uD83D\uDC69\u200D\uD83C\uDFED",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_factory_worker: {
      keywords: ["assembly", "industrial", "man", "human"],
      char: "\uD83D\uDC68\u200D\uD83C\uDFED",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_technologist: {
      keywords: ["coder", "developer", "engineer", "programmer", "software", "woman", "human", "laptop", "computer"],
      char: "\uD83D\uDC69\u200D\uD83D\uDCBB",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_technologist: {
      keywords: ["coder", "developer", "engineer", "programmer", "software", "man", "human", "laptop", "computer"],
      char: "\uD83D\uDC68\u200D\uD83D\uDCBB",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_office_worker: {
      keywords: ["business", "manager", "woman", "human"],
      char: "\uD83D\uDC69\u200D\uD83D\uDCBC",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_office_worker: {
      keywords: ["business", "manager", "man", "human"],
      char: "\uD83D\uDC68\u200D\uD83D\uDCBC",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_mechanic: {
      keywords: ["plumber", "woman", "human", "wrench"],
      char: "\uD83D\uDC69\u200D\uD83D\uDD27",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_mechanic: {
      keywords: ["plumber", "man", "human", "wrench"],
      char: "\uD83D\uDC68\u200D\uD83D\uDD27",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_scientist: {
      keywords: ["biologist", "chemist", "engineer", "physicist", "woman", "human"],
      char: "\uD83D\uDC69\u200D\uD83D\uDD2C",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_scientist: {
      keywords: ["biologist", "chemist", "engineer", "physicist", "man", "human"],
      char: "\uD83D\uDC68\u200D\uD83D\uDD2C",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_artist: {
      keywords: ["painter", "woman", "human"],
      char: "\uD83D\uDC69\u200D\uD83C\uDFA8",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_artist: {
      keywords: ["painter", "man", "human"],
      char: "\uD83D\uDC68\u200D\uD83C\uDFA8",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_firefighter: {
      keywords: ["fireman", "woman", "human"],
      char: "\uD83D\uDC69\u200D\uD83D\uDE92",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_firefighter: {
      keywords: ["fireman", "man", "human"],
      char: "\uD83D\uDC68\u200D\uD83D\uDE92",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_pilot: {
      keywords: ["aviator", "plane", "woman", "human"],
      char: "\uD83D\uDC69\u200D\u2708\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_pilot: {
      keywords: ["aviator", "plane", "man", "human"],
      char: "\uD83D\uDC68\u200D\u2708\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_astronaut: {
      keywords: ["space", "rocket", "woman", "human"],
      char: "\uD83D\uDC69\u200D\uD83D\uDE80",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_astronaut: {
      keywords: ["space", "rocket", "man", "human"],
      char: "\uD83D\uDC68\u200D\uD83D\uDE80",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_judge: {
      keywords: ["justice", "court", "woman", "human"],
      char: "\uD83D\uDC69\u200D\u2696\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_judge: {
      keywords: ["justice", "court", "man", "human"],
      char: "\uD83D\uDC68\u200D\u2696\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_superhero: {
      keywords: ["woman", "female", "good", "heroine", "superpowers"],
      char: "\uD83E\uDDB8\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_superhero: {
      keywords: ["man", "male", "good", "hero", "superpowers"],
      char: "\uD83E\uDDB8\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_supervillain: {
      keywords: ["woman", "female", "evil", "bad", "criminal", "heroine", "superpowers"],
      char: "\uD83E\uDDB9\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_supervillain: {
      keywords: ["man", "male", "evil", "bad", "criminal", "hero", "superpowers"],
      char: "\uD83E\uDDB9\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    mrs_claus: {
      keywords: ["woman", "female", "xmas", "mother christmas"],
      char: "\uD83E\uDD36",
      fitzpatrick_scale: true,
      category: "people"
    },
    santa: {
      keywords: ["festival", "man", "male", "xmas", "father christmas"],
      char: "\uD83C\uDF85",
      fitzpatrick_scale: true,
      category: "people"
    },
    sorceress: {
      keywords: ["woman", "female", "mage", "witch"],
      char: "\uD83E\uDDD9\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    wizard: {
      keywords: ["man", "male", "mage", "sorcerer"],
      char: "\uD83E\uDDD9\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_elf: {
      keywords: ["woman", "female"],
      char: "\uD83E\uDDDD\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_elf: {
      keywords: ["man", "male"],
      char: "\uD83E\uDDDD\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_vampire: {
      keywords: ["woman", "female"],
      char: "\uD83E\uDDDB\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_vampire: {
      keywords: ["man", "male", "dracula"],
      char: "\uD83E\uDDDB\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_zombie: {
      keywords: ["woman", "female", "undead", "walking dead"],
      char: "\uD83E\uDDDF\u200D\u2640\uFE0F",
      fitzpatrick_scale: false,
      category: "people"
    },
    man_zombie: {
      keywords: ["man", "male", "dracula", "undead", "walking dead"],
      char: "\uD83E\uDDDF\u200D\u2642\uFE0F",
      fitzpatrick_scale: false,
      category: "people"
    },
    woman_genie: {
      keywords: ["woman", "female"],
      char: "\uD83E\uDDDE\u200D\u2640\uFE0F",
      fitzpatrick_scale: false,
      category: "people"
    },
    man_genie: {
      keywords: ["man", "male"],
      char: "\uD83E\uDDDE\u200D\u2642\uFE0F",
      fitzpatrick_scale: false,
      category: "people"
    },
    mermaid: {
      keywords: ["woman", "female", "merwoman", "ariel"],
      char: "\uD83E\uDDDC\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    merman: {
      keywords: ["man", "male", "triton"],
      char: "\uD83E\uDDDC\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_fairy: {
      keywords: ["woman", "female"],
      char: "\uD83E\uDDDA\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_fairy: {
      keywords: ["man", "male"],
      char: "\uD83E\uDDDA\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    angel: {
      keywords: ["heaven", "wings", "halo"],
      char: "\uD83D\uDC7C",
      fitzpatrick_scale: true,
      category: "people"
    },
    pregnant_woman: {
      keywords: ["baby"],
      char: "\uD83E\uDD30",
      fitzpatrick_scale: true,
      category: "people"
    },
    breastfeeding: {
      keywords: ["nursing", "baby"],
      char: "\uD83E\uDD31",
      fitzpatrick_scale: true,
      category: "people"
    },
    princess: {
      keywords: ["girl", "woman", "female", "blond", "crown", "royal", "queen"],
      char: "\uD83D\uDC78",
      fitzpatrick_scale: true,
      category: "people"
    },
    prince: {
      keywords: ["boy", "man", "male", "crown", "royal", "king"],
      char: "\uD83E\uDD34",
      fitzpatrick_scale: true,
      category: "people"
    },
    bride_with_veil: {
      keywords: ["couple", "marriage", "wedding", "woman", "bride"],
      char: "\uD83D\uDC70",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_in_tuxedo: {
      keywords: ["couple", "marriage", "wedding", "groom"],
      char: "\uD83E\uDD35",
      fitzpatrick_scale: true,
      category: "people"
    },
    running_woman: {
      keywords: ["woman", "walking", "exercise", "race", "running", "female"],
      char: "\uD83C\uDFC3\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    running_man: {
      keywords: ["man", "walking", "exercise", "race", "running"],
      char: "\uD83C\uDFC3",
      fitzpatrick_scale: true,
      category: "people"
    },
    walking_woman: {
      keywords: ["human", "feet", "steps", "woman", "female"],
      char: "\uD83D\uDEB6\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    walking_man: {
      keywords: ["human", "feet", "steps"],
      char: "\uD83D\uDEB6",
      fitzpatrick_scale: true,
      category: "people"
    },
    dancer: {
      keywords: ["female", "girl", "woman", "fun"],
      char: "\uD83D\uDC83",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_dancing: {
      keywords: ["male", "boy", "fun", "dancer"],
      char: "\uD83D\uDD7A",
      fitzpatrick_scale: true,
      category: "people"
    },
    dancing_women: {
      keywords: ["female", "bunny", "women", "girls"],
      char: "\uD83D\uDC6F",
      fitzpatrick_scale: false,
      category: "people"
    },
    dancing_men: {
      keywords: ["male", "bunny", "men", "boys"],
      char: "\uD83D\uDC6F\u200D\u2642\uFE0F",
      fitzpatrick_scale: false,
      category: "people"
    },
    couple: {
      keywords: ["pair", "people", "human", "love", "date", "dating", "like", "affection", "valentines", "marriage"],
      char: "\uD83D\uDC6B",
      fitzpatrick_scale: false,
      category: "people"
    },
    two_men_holding_hands: {
      keywords: ["pair", "couple", "love", "like", "bromance", "friendship", "people", "human"],
      char: "\uD83D\uDC6C",
      fitzpatrick_scale: false,
      category: "people"
    },
    two_women_holding_hands: {
      keywords: ["pair", "friendship", "couple", "love", "like", "female", "people", "human"],
      char: "\uD83D\uDC6D",
      fitzpatrick_scale: false,
      category: "people"
    },
    bowing_woman: {
      keywords: ["woman", "female", "girl"],
      char: "\uD83D\uDE47\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    bowing_man: {
      keywords: ["man", "male", "boy"],
      char: "\uD83D\uDE47",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_facepalming: {
      keywords: ["man", "male", "boy", "disbelief"],
      char: "\uD83E\uDD26\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_facepalming: {
      keywords: ["woman", "female", "girl", "disbelief"],
      char: "\uD83E\uDD26\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_shrugging: {
      keywords: ["woman", "female", "girl", "confused", "indifferent", "doubt"],
      char: "\uD83E\uDD37",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_shrugging: {
      keywords: ["man", "male", "boy", "confused", "indifferent", "doubt"],
      char: "\uD83E\uDD37\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    tipping_hand_woman: {
      keywords: ["female", "girl", "woman", "human", "information"],
      char: "\uD83D\uDC81",
      fitzpatrick_scale: true,
      category: "people"
    },
    tipping_hand_man: {
      keywords: ["male", "boy", "man", "human", "information"],
      char: "\uD83D\uDC81\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    no_good_woman: {
      keywords: ["female", "girl", "woman", "nope"],
      char: "\uD83D\uDE45",
      fitzpatrick_scale: true,
      category: "people"
    },
    no_good_man: {
      keywords: ["male", "boy", "man", "nope"],
      char: "\uD83D\uDE45\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    ok_woman: {
      keywords: ["women", "girl", "female", "pink", "human", "woman"],
      char: "\uD83D\uDE46",
      fitzpatrick_scale: true,
      category: "people"
    },
    ok_man: {
      keywords: ["men", "boy", "male", "blue", "human", "man"],
      char: "\uD83D\uDE46\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    raising_hand_woman: {
      keywords: ["female", "girl", "woman"],
      char: "\uD83D\uDE4B",
      fitzpatrick_scale: true,
      category: "people"
    },
    raising_hand_man: {
      keywords: ["male", "boy", "man"],
      char: "\uD83D\uDE4B\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    pouting_woman: {
      keywords: ["female", "girl", "woman"],
      char: "\uD83D\uDE4E",
      fitzpatrick_scale: true,
      category: "people"
    },
    pouting_man: {
      keywords: ["male", "boy", "man"],
      char: "\uD83D\uDE4E\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    frowning_woman: {
      keywords: ["female", "girl", "woman", "sad", "depressed", "discouraged", "unhappy"],
      char: "\uD83D\uDE4D",
      fitzpatrick_scale: true,
      category: "people"
    },
    frowning_man: {
      keywords: ["male", "boy", "man", "sad", "depressed", "discouraged", "unhappy"],
      char: "\uD83D\uDE4D\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    haircut_woman: {
      keywords: ["female", "girl", "woman"],
      char: "\uD83D\uDC87",
      fitzpatrick_scale: true,
      category: "people"
    },
    haircut_man: {
      keywords: ["male", "boy", "man"],
      char: "\uD83D\uDC87\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    massage_woman: {
      keywords: ["female", "girl", "woman", "head"],
      char: "\uD83D\uDC86",
      fitzpatrick_scale: true,
      category: "people"
    },
    massage_man: {
      keywords: ["male", "boy", "man", "head"],
      char: "\uD83D\uDC86\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_in_steamy_room: {
      keywords: ["female", "woman", "spa", "steamroom", "sauna"],
      char: "\uD83E\uDDD6\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_in_steamy_room: {
      keywords: ["male", "man", "spa", "steamroom", "sauna"],
      char: "\uD83E\uDDD6\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    couple_with_heart_woman_man: {
      keywords: ["pair", "love", "like", "affection", "human", "dating", "valentines", "marriage"],
      char: "\uD83D\uDC91",
      fitzpatrick_scale: false,
      category: "people"
    },
    couple_with_heart_woman_woman: {
      keywords: ["pair", "love", "like", "affection", "human", "dating", "valentines", "marriage"],
      char: "\uD83D\uDC69\u200D\u2764\uFE0F\u200D\uD83D\uDC69",
      fitzpatrick_scale: false,
      category: "people"
    },
    couple_with_heart_man_man: {
      keywords: ["pair", "love", "like", "affection", "human", "dating", "valentines", "marriage"],
      char: "\uD83D\uDC68\u200D\u2764\uFE0F\u200D\uD83D\uDC68",
      fitzpatrick_scale: false,
      category: "people"
    },
    couplekiss_man_woman: {
      keywords: ["pair", "valentines", "love", "like", "dating", "marriage"],
      char: "\uD83D\uDC8F",
      fitzpatrick_scale: false,
      category: "people"
    },
    couplekiss_woman_woman: {
      keywords: ["pair", "valentines", "love", "like", "dating", "marriage"],
      char: "\uD83D\uDC69\u200D\u2764\uFE0F\u200D\uD83D\uDC8B\u200D\uD83D\uDC69",
      fitzpatrick_scale: false,
      category: "people"
    },
    couplekiss_man_man: {
      keywords: ["pair", "valentines", "love", "like", "dating", "marriage"],
      char: "\uD83D\uDC68\u200D\u2764\uFE0F\u200D\uD83D\uDC8B\u200D\uD83D\uDC68",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_man_woman_boy: {
      keywords: ["home", "parents", "child", "mom", "dad", "father", "mother", "people", "human"],
      char: "\uD83D\uDC6A",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_man_woman_girl: {
      keywords: ["home", "parents", "people", "human", "child"],
      char: "\uD83D\uDC68\u200D\uD83D\uDC69\u200D\uD83D\uDC67",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_man_woman_girl_boy: {
      keywords: ["home", "parents", "people", "human", "children"],
      char: "\uD83D\uDC68\u200D\uD83D\uDC69\u200D\uD83D\uDC67\u200D\uD83D\uDC66",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_man_woman_boy_boy: {
      keywords: ["home", "parents", "people", "human", "children"],
      char: "\uD83D\uDC68\u200D\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_man_woman_girl_girl: {
      keywords: ["home", "parents", "people", "human", "children"],
      char: "\uD83D\uDC68\u200D\uD83D\uDC69\u200D\uD83D\uDC67\u200D\uD83D\uDC67",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_woman_woman_boy: {
      keywords: ["home", "parents", "people", "human", "children"],
      char: "\uD83D\uDC69\u200D\uD83D\uDC69\u200D\uD83D\uDC66",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_woman_woman_girl: {
      keywords: ["home", "parents", "people", "human", "children"],
      char: "\uD83D\uDC69\u200D\uD83D\uDC69\u200D\uD83D\uDC67",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_woman_woman_girl_boy: {
      keywords: ["home", "parents", "people", "human", "children"],
      char: "\uD83D\uDC69\u200D\uD83D\uDC69\u200D\uD83D\uDC67\u200D\uD83D\uDC66",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_woman_woman_boy_boy: {
      keywords: ["home", "parents", "people", "human", "children"],
      char: "\uD83D\uDC69\u200D\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_woman_woman_girl_girl: {
      keywords: ["home", "parents", "people", "human", "children"],
      char: "\uD83D\uDC69\u200D\uD83D\uDC69\u200D\uD83D\uDC67\u200D\uD83D\uDC67",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_man_man_boy: {
      keywords: ["home", "parents", "people", "human", "children"],
      char: "\uD83D\uDC68\u200D\uD83D\uDC68\u200D\uD83D\uDC66",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_man_man_girl: {
      keywords: ["home", "parents", "people", "human", "children"],
      char: "\uD83D\uDC68\u200D\uD83D\uDC68\u200D\uD83D\uDC67",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_man_man_girl_boy: {
      keywords: ["home", "parents", "people", "human", "children"],
      char: "\uD83D\uDC68\u200D\uD83D\uDC68\u200D\uD83D\uDC67\u200D\uD83D\uDC66",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_man_man_boy_boy: {
      keywords: ["home", "parents", "people", "human", "children"],
      char: "\uD83D\uDC68\u200D\uD83D\uDC68\u200D\uD83D\uDC66\u200D\uD83D\uDC66",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_man_man_girl_girl: {
      keywords: ["home", "parents", "people", "human", "children"],
      char: "\uD83D\uDC68\u200D\uD83D\uDC68\u200D\uD83D\uDC67\u200D\uD83D\uDC67",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_woman_boy: {
      keywords: ["home", "parent", "people", "human", "child"],
      char: "\uD83D\uDC69\u200D\uD83D\uDC66",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_woman_girl: {
      keywords: ["home", "parent", "people", "human", "child"],
      char: "\uD83D\uDC69\u200D\uD83D\uDC67",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_woman_girl_boy: {
      keywords: ["home", "parent", "people", "human", "children"],
      char: "\uD83D\uDC69\u200D\uD83D\uDC67\u200D\uD83D\uDC66",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_woman_boy_boy: {
      keywords: ["home", "parent", "people", "human", "children"],
      char: "\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_woman_girl_girl: {
      keywords: ["home", "parent", "people", "human", "children"],
      char: "\uD83D\uDC69\u200D\uD83D\uDC67\u200D\uD83D\uDC67",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_man_boy: {
      keywords: ["home", "parent", "people", "human", "child"],
      char: "\uD83D\uDC68\u200D\uD83D\uDC66",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_man_girl: {
      keywords: ["home", "parent", "people", "human", "child"],
      char: "\uD83D\uDC68\u200D\uD83D\uDC67",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_man_girl_boy: {
      keywords: ["home", "parent", "people", "human", "children"],
      char: "\uD83D\uDC68\u200D\uD83D\uDC67\u200D\uD83D\uDC66",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_man_boy_boy: {
      keywords: ["home", "parent", "people", "human", "children"],
      char: "\uD83D\uDC68\u200D\uD83D\uDC66\u200D\uD83D\uDC66",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_man_girl_girl: {
      keywords: ["home", "parent", "people", "human", "children"],
      char: "\uD83D\uDC68\u200D\uD83D\uDC67\u200D\uD83D\uDC67",
      fitzpatrick_scale: false,
      category: "people"
    },
    yarn: {
      keywords: ["ball", "crochet", "knit"],
      char: "\uD83E\uDDF6",
      fitzpatrick_scale: false,
      category: "people"
    },
    thread: {
      keywords: ["needle", "sewing", "spool", "string"],
      char: "\uD83E\uDDF5",
      fitzpatrick_scale: false,
      category: "people"
    },
    coat: {
      keywords: ["jacket"],
      char: "\uD83E\uDDE5",
      fitzpatrick_scale: false,
      category: "people"
    },
    labcoat: {
      keywords: ["doctor", "experiment", "scientist", "chemist"],
      char: "\uD83E\uDD7C",
      fitzpatrick_scale: false,
      category: "people"
    },
    womans_clothes: {
      keywords: ["fashion", "shopping_bags", "female"],
      char: "\uD83D\uDC5A",
      fitzpatrick_scale: false,
      category: "people"
    },
    tshirt: {
      keywords: ["fashion", "cloth", "casual", "shirt", "tee"],
      char: "\uD83D\uDC55",
      fitzpatrick_scale: false,
      category: "people"
    },
    jeans: {
      keywords: ["fashion", "shopping"],
      char: "\uD83D\uDC56",
      fitzpatrick_scale: false,
      category: "people"
    },
    necktie: {
      keywords: ["shirt", "suitup", "formal", "fashion", "cloth", "business"],
      char: "\uD83D\uDC54",
      fitzpatrick_scale: false,
      category: "people"
    },
    dress: {
      keywords: ["clothes", "fashion", "shopping"],
      char: "\uD83D\uDC57",
      fitzpatrick_scale: false,
      category: "people"
    },
    bikini: {
      keywords: ["swimming", "female", "woman", "girl", "fashion", "beach", "summer"],
      char: "\uD83D\uDC59",
      fitzpatrick_scale: false,
      category: "people"
    },
    kimono: {
      keywords: ["dress", "fashion", "women", "female", "japanese"],
      char: "\uD83D\uDC58",
      fitzpatrick_scale: false,
      category: "people"
    },
    lipstick: {
      keywords: ["female", "girl", "fashion", "woman"],
      char: "\uD83D\uDC84",
      fitzpatrick_scale: false,
      category: "people"
    },
    kiss: {
      keywords: ["face", "lips", "love", "like", "affection", "valentines"],
      char: "\uD83D\uDC8B",
      fitzpatrick_scale: false,
      category: "people"
    },
    footprints: {
      keywords: ["feet", "tracking", "walking", "beach"],
      char: "\uD83D\uDC63",
      fitzpatrick_scale: false,
      category: "people"
    },
    flat_shoe: {
      keywords: ["ballet", "slip-on", "slipper"],
      char: "\uD83E\uDD7F",
      fitzpatrick_scale: false,
      category: "people"
    },
    high_heel: {
      keywords: ["fashion", "shoes", "female", "pumps", "stiletto"],
      char: "\uD83D\uDC60",
      fitzpatrick_scale: false,
      category: "people"
    },
    sandal: {
      keywords: ["shoes", "fashion", "flip flops"],
      char: "\uD83D\uDC61",
      fitzpatrick_scale: false,
      category: "people"
    },
    boot: {
      keywords: ["shoes", "fashion"],
      char: "\uD83D\uDC62",
      fitzpatrick_scale: false,
      category: "people"
    },
    mans_shoe: {
      keywords: ["fashion", "male"],
      char: "\uD83D\uDC5E",
      fitzpatrick_scale: false,
      category: "people"
    },
    athletic_shoe: {
      keywords: ["shoes", "sports", "sneakers"],
      char: "\uD83D\uDC5F",
      fitzpatrick_scale: false,
      category: "people"
    },
    hiking_boot: {
      keywords: ["backpacking", "camping", "hiking"],
      char: "\uD83E\uDD7E",
      fitzpatrick_scale: false,
      category: "people"
    },
    socks: {
      keywords: ["stockings", "clothes"],
      char: "\uD83E\uDDE6",
      fitzpatrick_scale: false,
      category: "people"
    },
    gloves: {
      keywords: ["hands", "winter", "clothes"],
      char: "\uD83E\uDDE4",
      fitzpatrick_scale: false,
      category: "people"
    },
    scarf: {
      keywords: ["neck", "winter", "clothes"],
      char: "\uD83E\uDDE3",
      fitzpatrick_scale: false,
      category: "people"
    },
    womans_hat: {
      keywords: ["fashion", "accessories", "female", "lady", "spring"],
      char: "\uD83D\uDC52",
      fitzpatrick_scale: false,
      category: "people"
    },
    tophat: {
      keywords: ["magic", "gentleman", "classy", "circus"],
      char: "\uD83C\uDFA9",
      fitzpatrick_scale: false,
      category: "people"
    },
    billed_hat: {
      keywords: ["cap", "baseball"],
      char: "\uD83E\uDDE2",
      fitzpatrick_scale: false,
      category: "people"
    },
    rescue_worker_helmet: {
      keywords: ["construction", "build"],
      char: "\u26D1",
      fitzpatrick_scale: false,
      category: "people"
    },
    mortar_board: {
      keywords: ["school", "college", "degree", "university", "graduation", "cap", "hat", "legal", "learn", "education"],
      char: "\uD83C\uDF93",
      fitzpatrick_scale: false,
      category: "people"
    },
    crown: {
      keywords: ["king", "kod", "leader", "royalty", "lord"],
      char: "\uD83D\uDC51",
      fitzpatrick_scale: false,
      category: "people"
    },
    school_satchel: {
      keywords: ["student", "education", "bag", "backpack"],
      char: "\uD83C\uDF92",
      fitzpatrick_scale: false,
      category: "people"
    },
    luggage: {
      keywords: ["packing", "travel"],
      char: "\uD83E\uDDF3",
      fitzpatrick_scale: false,
      category: "people"
    },
    pouch: {
      keywords: ["bag", "accessories", "shopping"],
      char: "\uD83D\uDC5D",
      fitzpatrick_scale: false,
      category: "people"
    },
    purse: {
      keywords: ["fashion", "accessories", "money", "sales", "shopping"],
      char: "\uD83D\uDC5B",
      fitzpatrick_scale: false,
      category: "people"
    },
    handbag: {
      keywords: ["fashion", "accessory", "accessories", "shopping"],
      char: "\uD83D\uDC5C",
      fitzpatrick_scale: false,
      category: "people"
    },
    briefcase: {
      keywords: ["business", "documents", "work", "law", "legal", "job", "career"],
      char: "\uD83D\uDCBC",
      fitzpatrick_scale: false,
      category: "people"
    },
    eyeglasses: {
      keywords: ["fashion", "accessories", "eyesight", "nerdy", "dork", "geek"],
      char: "\uD83D\uDC53",
      fitzpatrick_scale: false,
      category: "people"
    },
    dark_sunglasses: {
      keywords: ["face", "cool", "accessories"],
      char: "\uD83D\uDD76",
      fitzpatrick_scale: false,
      category: "people"
    },
    goggles: {
      keywords: ["eyes", "protection", "safety"],
      char: "\uD83E\uDD7D",
      fitzpatrick_scale: false,
      category: "people"
    },
    ring: {
      keywords: ["wedding", "propose", "marriage", "valentines", "diamond", "fashion", "jewelry", "gem", "engagement"],
      char: "\uD83D\uDC8D",
      fitzpatrick_scale: false,
      category: "people"
    },
    closed_umbrella: {
      keywords: ["weather", "rain", "drizzle"],
      char: "\uD83C\uDF02",
      fitzpatrick_scale: false,
      category: "people"
    },
    dog: {
      keywords: ["animal", "friend", "nature", "woof", "puppy", "pet", "faithful"],
      char: "\uD83D\uDC36",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    cat: {
      keywords: ["animal", "meow", "nature", "pet", "kitten"],
      char: "\uD83D\uDC31",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    mouse: {
      keywords: ["animal", "nature", "cheese_wedge", "rodent"],
      char: "\uD83D\uDC2D",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    hamster: {
      keywords: ["animal", "nature"],
      char: "\uD83D\uDC39",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    rabbit: {
      keywords: ["animal", "nature", "pet", "spring", "magic", "bunny"],
      char: "\uD83D\uDC30",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    fox_face: {
      keywords: ["animal", "nature", "face"],
      char: "\uD83E\uDD8A",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    bear: {
      keywords: ["animal", "nature", "wild"],
      char: "\uD83D\uDC3B",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    panda_face: {
      keywords: ["animal", "nature", "panda"],
      char: "\uD83D\uDC3C",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    koala: {
      keywords: ["animal", "nature"],
      char: "\uD83D\uDC28",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    tiger: {
      keywords: ["animal", "cat", "danger", "wild", "nature", "roar"],
      char: "\uD83D\uDC2F",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    lion: {
      keywords: ["animal", "nature"],
      char: "\uD83E\uDD81",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    cow: {
      keywords: ["beef", "ox", "animal", "nature", "moo", "milk"],
      char: "\uD83D\uDC2E",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    pig: {
      keywords: ["animal", "oink", "nature"],
      char: "\uD83D\uDC37",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    pig_nose: {
      keywords: ["animal", "oink"],
      char: "\uD83D\uDC3D",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    frog: {
      keywords: ["animal", "nature", "croak", "toad"],
      char: "\uD83D\uDC38",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    squid: {
      keywords: ["animal", "nature", "ocean", "sea"],
      char: "\uD83E\uDD91",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    octopus: {
      keywords: ["animal", "creature", "ocean", "sea", "nature", "beach"],
      char: "\uD83D\uDC19",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    shrimp: {
      keywords: ["animal", "ocean", "nature", "seafood"],
      char: "\uD83E\uDD90",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    monkey_face: {
      keywords: ["animal", "nature", "circus"],
      char: "\uD83D\uDC35",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    gorilla: {
      keywords: ["animal", "nature", "circus"],
      char: "\uD83E\uDD8D",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    see_no_evil: {
      keywords: ["monkey", "animal", "nature", "haha"],
      char: "\uD83D\uDE48",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    hear_no_evil: {
      keywords: ["animal", "monkey", "nature"],
      char: "\uD83D\uDE49",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    speak_no_evil: {
      keywords: ["monkey", "animal", "nature", "omg"],
      char: "\uD83D\uDE4A",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    monkey: {
      keywords: ["animal", "nature", "banana", "circus"],
      char: "\uD83D\uDC12",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    chicken: {
      keywords: ["animal", "cluck", "nature", "bird"],
      char: "\uD83D\uDC14",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    penguin: {
      keywords: ["animal", "nature"],
      char: "\uD83D\uDC27",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    bird: {
      keywords: ["animal", "nature", "fly", "tweet", "spring"],
      char: "\uD83D\uDC26",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    baby_chick: {
      keywords: ["animal", "chicken", "bird"],
      char: "\uD83D\uDC24",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    hatching_chick: {
      keywords: ["animal", "chicken", "egg", "born", "baby", "bird"],
      char: "\uD83D\uDC23",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    hatched_chick: {
      keywords: ["animal", "chicken", "baby", "bird"],
      char: "\uD83D\uDC25",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    duck: {
      keywords: ["animal", "nature", "bird", "mallard"],
      char: "\uD83E\uDD86",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    eagle: {
      keywords: ["animal", "nature", "bird"],
      char: "\uD83E\uDD85",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    owl: {
      keywords: ["animal", "nature", "bird", "hoot"],
      char: "\uD83E\uDD89",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    bat: {
      keywords: ["animal", "nature", "blind", "vampire"],
      char: "\uD83E\uDD87",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    wolf: {
      keywords: ["animal", "nature", "wild"],
      char: "\uD83D\uDC3A",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    boar: {
      keywords: ["animal", "nature"],
      char: "\uD83D\uDC17",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    horse: {
      keywords: ["animal", "brown", "nature"],
      char: "\uD83D\uDC34",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    unicorn: {
      keywords: ["animal", "nature", "mystical"],
      char: "\uD83E\uDD84",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    honeybee: {
      keywords: ["animal", "insect", "nature", "bug", "spring", "honey"],
      char: "\uD83D\uDC1D",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    bug: {
      keywords: ["animal", "insect", "nature", "worm"],
      char: "\uD83D\uDC1B",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    butterfly: {
      keywords: ["animal", "insect", "nature", "caterpillar"],
      char: "\uD83E\uDD8B",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    snail: {
      keywords: ["slow", "animal", "shell"],
      char: "\uD83D\uDC0C",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    beetle: {
      keywords: ["animal", "insect", "nature", "ladybug"],
      char: "\uD83D\uDC1E",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    ant: {
      keywords: ["animal", "insect", "nature", "bug"],
      char: "\uD83D\uDC1C",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    grasshopper: {
      keywords: ["animal", "cricket", "chirp"],
      char: "\uD83E\uDD97",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    spider: {
      keywords: ["animal", "arachnid"],
      char: "\uD83D\uDD77",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    scorpion: {
      keywords: ["animal", "arachnid"],
      char: "\uD83E\uDD82",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    crab: {
      keywords: ["animal", "crustacean"],
      char: "\uD83E\uDD80",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    snake: {
      keywords: ["animal", "evil", "nature", "hiss", "python"],
      char: "\uD83D\uDC0D",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    lizard: {
      keywords: ["animal", "nature", "reptile"],
      char: "\uD83E\uDD8E",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    "t-rex": {
      keywords: ["animal", "nature", "dinosaur", "tyrannosaurus", "extinct"],
      char: "\uD83E\uDD96",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    sauropod: {
      keywords: ["animal", "nature", "dinosaur", "brachiosaurus", "brontosaurus", "diplodocus", "extinct"],
      char: "\uD83E\uDD95",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    turtle: {
      keywords: ["animal", "slow", "nature", "tortoise"],
      char: "\uD83D\uDC22",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    tropical_fish: {
      keywords: ["animal", "swim", "ocean", "beach", "nemo"],
      char: "\uD83D\uDC20",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    fish: {
      keywords: ["animal", "food", "nature"],
      char: "\uD83D\uDC1F",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    blowfish: {
      keywords: ["animal", "nature", "food", "sea", "ocean"],
      char: "\uD83D\uDC21",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    dolphin: {
      keywords: ["animal", "nature", "fish", "sea", "ocean", "flipper", "fins", "beach"],
      char: "\uD83D\uDC2C",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    shark: {
      keywords: ["animal", "nature", "fish", "sea", "ocean", "jaws", "fins", "beach"],
      char: "\uD83E\uDD88",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    whale: {
      keywords: ["animal", "nature", "sea", "ocean"],
      char: "\uD83D\uDC33",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    whale2: {
      keywords: ["animal", "nature", "sea", "ocean"],
      char: "\uD83D\uDC0B",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    crocodile: {
      keywords: ["animal", "nature", "reptile", "lizard", "alligator"],
      char: "\uD83D\uDC0A",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    leopard: {
      keywords: ["animal", "nature"],
      char: "\uD83D\uDC06",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    zebra: {
      keywords: ["animal", "nature", "stripes", "safari"],
      char: "\uD83E\uDD93",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    tiger2: {
      keywords: ["animal", "nature", "roar"],
      char: "\uD83D\uDC05",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    water_buffalo: {
      keywords: ["animal", "nature", "ox", "cow"],
      char: "\uD83D\uDC03",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    ox: {
      keywords: ["animal", "cow", "beef"],
      char: "\uD83D\uDC02",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    cow2: {
      keywords: ["beef", "ox", "animal", "nature", "moo", "milk"],
      char: "\uD83D\uDC04",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    deer: {
      keywords: ["animal", "nature", "horns", "venison"],
      char: "\uD83E\uDD8C",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    dromedary_camel: {
      keywords: ["animal", "hot", "desert", "hump"],
      char: "\uD83D\uDC2A",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    camel: {
      keywords: ["animal", "nature", "hot", "desert", "hump"],
      char: "\uD83D\uDC2B",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    giraffe: {
      keywords: ["animal", "nature", "spots", "safari"],
      char: "\uD83E\uDD92",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    elephant: {
      keywords: ["animal", "nature", "nose", "th", "circus"],
      char: "\uD83D\uDC18",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    rhinoceros: {
      keywords: ["animal", "nature", "horn"],
      char: "\uD83E\uDD8F",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    goat: {
      keywords: ["animal", "nature"],
      char: "\uD83D\uDC10",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    ram: {
      keywords: ["animal", "sheep", "nature"],
      char: "\uD83D\uDC0F",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    sheep: {
      keywords: ["animal", "nature", "wool", "shipit"],
      char: "\uD83D\uDC11",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    racehorse: {
      keywords: ["animal", "gamble", "luck"],
      char: "\uD83D\uDC0E",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    pig2: {
      keywords: ["animal", "nature"],
      char: "\uD83D\uDC16",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    rat: {
      keywords: ["animal", "mouse", "rodent"],
      char: "\uD83D\uDC00",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    mouse2: {
      keywords: ["animal", "nature", "rodent"],
      char: "\uD83D\uDC01",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    rooster: {
      keywords: ["animal", "nature", "chicken"],
      char: "\uD83D\uDC13",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    turkey: {
      keywords: ["animal", "bird"],
      char: "\uD83E\uDD83",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    dove: {
      keywords: ["animal", "bird"],
      char: "\uD83D\uDD4A",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    dog2: {
      keywords: ["animal", "nature", "friend", "doge", "pet", "faithful"],
      char: "\uD83D\uDC15",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    poodle: {
      keywords: ["dog", "animal", "101", "nature", "pet"],
      char: "\uD83D\uDC29",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    cat2: {
      keywords: ["animal", "meow", "pet", "cats"],
      char: "\uD83D\uDC08",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    rabbit2: {
      keywords: ["animal", "nature", "pet", "magic", "spring"],
      char: "\uD83D\uDC07",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    chipmunk: {
      keywords: ["animal", "nature", "rodent", "squirrel"],
      char: "\uD83D\uDC3F",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    hedgehog: {
      keywords: ["animal", "nature", "spiny"],
      char: "\uD83E\uDD94",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    raccoon: {
      keywords: ["animal", "nature"],
      char: "\uD83E\uDD9D",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    llama: {
      keywords: ["animal", "nature", "alpaca"],
      char: "\uD83E\uDD99",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    hippopotamus: {
      keywords: ["animal", "nature"],
      char: "\uD83E\uDD9B",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    kangaroo: {
      keywords: ["animal", "nature", "australia", "joey", "hop", "marsupial"],
      char: "\uD83E\uDD98",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    badger: {
      keywords: ["animal", "nature", "honey"],
      char: "\uD83E\uDDA1",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    swan: {
      keywords: ["animal", "nature", "bird"],
      char: "\uD83E\uDDA2",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    peacock: {
      keywords: ["animal", "nature", "peahen", "bird"],
      char: "\uD83E\uDD9A",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    parrot: {
      keywords: ["animal", "nature", "bird", "pirate", "talk"],
      char: "\uD83E\uDD9C",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    lobster: {
      keywords: ["animal", "nature", "bisque", "claws", "seafood"],
      char: "\uD83E\uDD9E",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    mosquito: {
      keywords: ["animal", "nature", "insect", "malaria"],
      char: "\uD83E\uDD9F",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    paw_prints: {
      keywords: ["animal", "tracking", "footprints", "dog", "cat", "pet", "feet"],
      char: "\uD83D\uDC3E",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    dragon: {
      keywords: ["animal", "myth", "nature", "chinese", "green"],
      char: "\uD83D\uDC09",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    dragon_face: {
      keywords: ["animal", "myth", "nature", "chinese", "green"],
      char: "\uD83D\uDC32",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    cactus: {
      keywords: ["vegetable", "plant", "nature"],
      char: "\uD83C\uDF35",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    christmas_tree: {
      keywords: ["festival", "vacation", "december", "xmas", "celebration"],
      char: "\uD83C\uDF84",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    evergreen_tree: {
      keywords: ["plant", "nature"],
      char: "\uD83C\uDF32",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    deciduous_tree: {
      keywords: ["plant", "nature"],
      char: "\uD83C\uDF33",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    palm_tree: {
      keywords: ["plant", "vegetable", "nature", "summer", "beach", "mojito", "tropical"],
      char: "\uD83C\uDF34",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    seedling: {
      keywords: ["plant", "nature", "grass", "lawn", "spring"],
      char: "\uD83C\uDF31",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    herb: {
      keywords: ["vegetable", "plant", "medicine", "weed", "grass", "lawn"],
      char: "\uD83C\uDF3F",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    shamrock: {
      keywords: ["vegetable", "plant", "nature", "irish", "clover"],
      char: "\u2618",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    four_leaf_clover: {
      keywords: ["vegetable", "plant", "nature", "lucky", "irish"],
      char: "\uD83C\uDF40",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    bamboo: {
      keywords: ["plant", "nature", "vegetable", "panda", "pine_decoration"],
      char: "\uD83C\uDF8D",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    tanabata_tree: {
      keywords: ["plant", "nature", "branch", "summer"],
      char: "\uD83C\uDF8B",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    leaves: {
      keywords: ["nature", "plant", "tree", "vegetable", "grass", "lawn", "spring"],
      char: "\uD83C\uDF43",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    fallen_leaf: {
      keywords: ["nature", "plant", "vegetable", "leaves"],
      char: "\uD83C\uDF42",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    maple_leaf: {
      keywords: ["nature", "plant", "vegetable", "ca", "fall"],
      char: "\uD83C\uDF41",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    ear_of_rice: {
      keywords: ["nature", "plant"],
      char: "\uD83C\uDF3E",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    hibiscus: {
      keywords: ["plant", "vegetable", "flowers", "beach"],
      char: "\uD83C\uDF3A",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    sunflower: {
      keywords: ["nature", "plant", "fall"],
      char: "\uD83C\uDF3B",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    rose: {
      keywords: ["flowers", "valentines", "love", "spring"],
      char: "\uD83C\uDF39",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    wilted_flower: {
      keywords: ["plant", "nature", "flower"],
      char: "\uD83E\uDD40",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    tulip: {
      keywords: ["flowers", "plant", "nature", "summer", "spring"],
      char: "\uD83C\uDF37",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    blossom: {
      keywords: ["nature", "flowers", "yellow"],
      char: "\uD83C\uDF3C",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    cherry_blossom: {
      keywords: ["nature", "plant", "spring", "flower"],
      char: "\uD83C\uDF38",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    bouquet: {
      keywords: ["flowers", "nature", "spring"],
      char: "\uD83D\uDC90",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    mushroom: {
      keywords: ["plant", "vegetable"],
      char: "\uD83C\uDF44",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    chestnut: {
      keywords: ["food", "squirrel"],
      char: "\uD83C\uDF30",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    jack_o_lantern: {
      keywords: ["halloween", "light", "pumpkin", "creepy", "fall"],
      char: "\uD83C\uDF83",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    shell: {
      keywords: ["nature", "sea", "beach"],
      char: "\uD83D\uDC1A",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    spider_web: {
      keywords: ["animal", "insect", "arachnid", "silk"],
      char: "\uD83D\uDD78",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    earth_americas: {
      keywords: ["globe", "world", "USA", "international"],
      char: "\uD83C\uDF0E",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    earth_africa: {
      keywords: ["globe", "world", "international"],
      char: "\uD83C\uDF0D",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    earth_asia: {
      keywords: ["globe", "world", "east", "international"],
      char: "\uD83C\uDF0F",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    full_moon: {
      keywords: ["nature", "yellow", "twilight", "planet", "space", "night", "evening", "sleep"],
      char: "\uD83C\uDF15",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    waning_gibbous_moon: {
      keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep", "waxing_gibbous_moon"],
      char: "\uD83C\uDF16",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    last_quarter_moon: {
      keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"],
      char: "\uD83C\uDF17",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    waning_crescent_moon: {
      keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"],
      char: "\uD83C\uDF18",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    new_moon: {
      keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"],
      char: "\uD83C\uDF11",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    waxing_crescent_moon: {
      keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"],
      char: "\uD83C\uDF12",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    first_quarter_moon: {
      keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"],
      char: "\uD83C\uDF13",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    waxing_gibbous_moon: {
      keywords: ["nature", "night", "sky", "gray", "twilight", "planet", "space", "evening", "sleep"],
      char: "\uD83C\uDF14",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    new_moon_with_face: {
      keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"],
      char: "\uD83C\uDF1A",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    full_moon_with_face: {
      keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"],
      char: "\uD83C\uDF1D",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    first_quarter_moon_with_face: {
      keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"],
      char: "\uD83C\uDF1B",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    last_quarter_moon_with_face: {
      keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"],
      char: "\uD83C\uDF1C",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    sun_with_face: {
      keywords: ["nature", "morning", "sky"],
      char: "\uD83C\uDF1E",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    crescent_moon: {
      keywords: ["night", "sleep", "sky", "evening", "magic"],
      char: "\uD83C\uDF19",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    star: {
      keywords: ["night", "yellow"],
      char: "\u2B50",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    star2: {
      keywords: ["night", "sparkle", "awesome", "good", "magic"],
      char: "\uD83C\uDF1F",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    dizzy: {
      keywords: ["star", "sparkle", "shoot", "magic"],
      char: "\uD83D\uDCAB",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    sparkles: {
      keywords: ["stars", "shine", "shiny", "cool", "awesome", "good", "magic"],
      char: "\u2728",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    comet: {
      keywords: ["space"],
      char: "\u2604",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    sunny: {
      keywords: ["weather", "nature", "brightness", "summer", "beach", "spring"],
      char: "\u2600\uFE0F",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    sun_behind_small_cloud: {
      keywords: ["weather"],
      char: "\uD83C\uDF24",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    partly_sunny: {
      keywords: ["weather", "nature", "cloudy", "morning", "fall", "spring"],
      char: "\u26C5",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    sun_behind_large_cloud: {
      keywords: ["weather"],
      char: "\uD83C\uDF25",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    sun_behind_rain_cloud: {
      keywords: ["weather"],
      char: "\uD83C\uDF26",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    cloud: {
      keywords: ["weather", "sky"],
      char: "\u2601\uFE0F",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    cloud_with_rain: {
      keywords: ["weather"],
      char: "\uD83C\uDF27",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    cloud_with_lightning_and_rain: {
      keywords: ["weather", "lightning"],
      char: "\u26C8",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    cloud_with_lightning: {
      keywords: ["weather", "thunder"],
      char: "\uD83C\uDF29",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    zap: {
      keywords: ["thunder", "weather", "lightning bolt", "fast"],
      char: "\u26A1",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    fire: {
      keywords: ["hot", "cook", "flame"],
      char: "\uD83D\uDD25",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    boom: {
      keywords: ["bomb", "explode", "explosion", "collision", "blown"],
      char: "\uD83D\uDCA5",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    snowflake: {
      keywords: ["winter", "season", "cold", "weather", "christmas", "xmas"],
      char: "\u2744\uFE0F",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    cloud_with_snow: {
      keywords: ["weather"],
      char: "\uD83C\uDF28",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    snowman: {
      keywords: ["winter", "season", "cold", "weather", "christmas", "xmas", "frozen", "without_snow"],
      char: "\u26C4",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    snowman_with_snow: {
      keywords: ["winter", "season", "cold", "weather", "christmas", "xmas", "frozen"],
      char: "\u2603",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    wind_face: {
      keywords: ["gust", "air"],
      char: "\uD83C\uDF2C",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    dash: {
      keywords: ["wind", "air", "fast", "shoo", "fart", "smoke", "puff"],
      char: "\uD83D\uDCA8",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    tornado: {
      keywords: ["weather", "cyclone", "twister"],
      char: "\uD83C\uDF2A",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    fog: {
      keywords: ["weather"],
      char: "\uD83C\uDF2B",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    open_umbrella: {
      keywords: ["weather", "spring"],
      char: "\u2602",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    umbrella: {
      keywords: ["rainy", "weather", "spring"],
      char: "\u2614",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    droplet: {
      keywords: ["water", "drip", "faucet", "spring"],
      char: "\uD83D\uDCA7",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    sweat_drops: {
      keywords: ["water", "drip", "oops"],
      char: "\uD83D\uDCA6",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    ocean: {
      keywords: ["sea", "water", "wave", "nature", "tsunami", "disaster"],
      char: "\uD83C\uDF0A",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    green_apple: {
      keywords: ["fruit", "nature"],
      char: "\uD83C\uDF4F",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    apple: {
      keywords: ["fruit", "mac", "school"],
      char: "\uD83C\uDF4E",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    pear: {
      keywords: ["fruit", "nature", "food"],
      char: "\uD83C\uDF50",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    tangerine: {
      keywords: ["food", "fruit", "nature", "orange"],
      char: "\uD83C\uDF4A",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    lemon: {
      keywords: ["fruit", "nature"],
      char: "\uD83C\uDF4B",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    banana: {
      keywords: ["fruit", "food", "monkey"],
      char: "\uD83C\uDF4C",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    watermelon: {
      keywords: ["fruit", "food", "picnic", "summer"],
      char: "\uD83C\uDF49",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    grapes: {
      keywords: ["fruit", "food", "wine"],
      char: "\uD83C\uDF47",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    strawberry: {
      keywords: ["fruit", "food", "nature"],
      char: "\uD83C\uDF53",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    melon: {
      keywords: ["fruit", "nature", "food"],
      char: "\uD83C\uDF48",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    cherries: {
      keywords: ["food", "fruit"],
      char: "\uD83C\uDF52",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    peach: {
      keywords: ["fruit", "nature", "food"],
      char: "\uD83C\uDF51",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    pineapple: {
      keywords: ["fruit", "nature", "food"],
      char: "\uD83C\uDF4D",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    coconut: {
      keywords: ["fruit", "nature", "food", "palm"],
      char: "\uD83E\uDD65",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    kiwi_fruit: {
      keywords: ["fruit", "food"],
      char: "\uD83E\uDD5D",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    mango: {
      keywords: ["fruit", "food", "tropical"],
      char: "\uD83E\uDD6D",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    avocado: {
      keywords: ["fruit", "food"],
      char: "\uD83E\uDD51",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    broccoli: {
      keywords: ["fruit", "food", "vegetable"],
      char: "\uD83E\uDD66",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    tomato: {
      keywords: ["fruit", "vegetable", "nature", "food"],
      char: "\uD83C\uDF45",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    eggplant: {
      keywords: ["vegetable", "nature", "food", "aubergine"],
      char: "\uD83C\uDF46",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    cucumber: {
      keywords: ["fruit", "food", "pickle"],
      char: "\uD83E\uDD52",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    carrot: {
      keywords: ["vegetable", "food", "orange"],
      char: "\uD83E\uDD55",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    hot_pepper: {
      keywords: ["food", "spicy", "chilli", "chili"],
      char: "\uD83C\uDF36",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    potato: {
      keywords: ["food", "tuber", "vegatable", "starch"],
      char: "\uD83E\uDD54",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    corn: {
      keywords: ["food", "vegetable", "plant"],
      char: "\uD83C\uDF3D",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    leafy_greens: {
      keywords: ["food", "vegetable", "plant", "bok choy", "cabbage", "kale", "lettuce"],
      char: "\uD83E\uDD6C",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    sweet_potato: {
      keywords: ["food", "nature"],
      char: "\uD83C\uDF60",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    peanuts: {
      keywords: ["food", "nut"],
      char: "\uD83E\uDD5C",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    honey_pot: {
      keywords: ["bees", "sweet", "kitchen"],
      char: "\uD83C\uDF6F",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    croissant: {
      keywords: ["food", "bread", "french"],
      char: "\uD83E\uDD50",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    bread: {
      keywords: ["food", "wheat", "breakfast", "toast"],
      char: "\uD83C\uDF5E",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    baguette_bread: {
      keywords: ["food", "bread", "french"],
      char: "\uD83E\uDD56",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    bagel: {
      keywords: ["food", "bread", "bakery", "schmear"],
      char: "\uD83E\uDD6F",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    pretzel: {
      keywords: ["food", "bread", "twisted"],
      char: "\uD83E\uDD68",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    cheese: {
      keywords: ["food", "chadder"],
      char: "\uD83E\uDDC0",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    egg: {
      keywords: ["food", "chicken", "breakfast"],
      char: "\uD83E\uDD5A",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    bacon: {
      keywords: ["food", "breakfast", "pork", "pig", "meat"],
      char: "\uD83E\uDD53",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    steak: {
      keywords: ["food", "cow", "meat", "cut", "chop", "lambchop", "porkchop"],
      char: "\uD83E\uDD69",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    pancakes: {
      keywords: ["food", "breakfast", "flapjacks", "hotcakes"],
      char: "\uD83E\uDD5E",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    poultry_leg: {
      keywords: ["food", "meat", "drumstick", "bird", "chicken", "turkey"],
      char: "\uD83C\uDF57",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    meat_on_bone: {
      keywords: ["good", "food", "drumstick"],
      char: "\uD83C\uDF56",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    bone: {
      keywords: ["skeleton"],
      char: "\uD83E\uDDB4",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    fried_shrimp: {
      keywords: ["food", "animal", "appetizer", "summer"],
      char: "\uD83C\uDF64",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    fried_egg: {
      keywords: ["food", "breakfast", "kitchen", "egg"],
      char: "\uD83C\uDF73",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    hamburger: {
      keywords: ["meat", "fast food", "beef", "cheeseburger", "mcdonalds", "burger king"],
      char: "\uD83C\uDF54",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    fries: {
      keywords: ["chips", "snack", "fast food"],
      char: "\uD83C\uDF5F",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    stuffed_flatbread: {
      keywords: ["food", "flatbread", "stuffed", "gyro"],
      char: "\uD83E\uDD59",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    hotdog: {
      keywords: ["food", "frankfurter"],
      char: "\uD83C\uDF2D",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    pizza: {
      keywords: ["food", "party"],
      char: "\uD83C\uDF55",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    sandwich: {
      keywords: ["food", "lunch", "bread"],
      char: "\uD83E\uDD6A",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    canned_food: {
      keywords: ["food", "soup"],
      char: "\uD83E\uDD6B",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    spaghetti: {
      keywords: ["food", "italian", "noodle"],
      char: "\uD83C\uDF5D",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    taco: {
      keywords: ["food", "mexican"],
      char: "\uD83C\uDF2E",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    burrito: {
      keywords: ["food", "mexican"],
      char: "\uD83C\uDF2F",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    green_salad: {
      keywords: ["food", "healthy", "lettuce"],
      char: "\uD83E\uDD57",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    shallow_pan_of_food: {
      keywords: ["food", "cooking", "casserole", "paella"],
      char: "\uD83E\uDD58",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    ramen: {
      keywords: ["food", "japanese", "noodle", "chopsticks"],
      char: "\uD83C\uDF5C",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    stew: {
      keywords: ["food", "meat", "soup"],
      char: "\uD83C\uDF72",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    fish_cake: {
      keywords: ["food", "japan", "sea", "beach", "narutomaki", "pink", "swirl", "kamaboko", "surimi", "ramen"],
      char: "\uD83C\uDF65",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    fortune_cookie: {
      keywords: ["food", "prophecy"],
      char: "\uD83E\uDD60",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    sushi: {
      keywords: ["food", "fish", "japanese", "rice"],
      char: "\uD83C\uDF63",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    bento: {
      keywords: ["food", "japanese", "box"],
      char: "\uD83C\uDF71",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    curry: {
      keywords: ["food", "spicy", "hot", "indian"],
      char: "\uD83C\uDF5B",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    rice_ball: {
      keywords: ["food", "japanese"],
      char: "\uD83C\uDF59",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    rice: {
      keywords: ["food", "china", "asian"],
      char: "\uD83C\uDF5A",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    rice_cracker: {
      keywords: ["food", "japanese"],
      char: "\uD83C\uDF58",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    oden: {
      keywords: ["food", "japanese"],
      char: "\uD83C\uDF62",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    dango: {
      keywords: ["food", "dessert", "sweet", "japanese", "barbecue", "meat"],
      char: "\uD83C\uDF61",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    shaved_ice: {
      keywords: ["hot", "dessert", "summer"],
      char: "\uD83C\uDF67",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    ice_cream: {
      keywords: ["food", "hot", "dessert"],
      char: "\uD83C\uDF68",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    icecream: {
      keywords: ["food", "hot", "dessert", "summer"],
      char: "\uD83C\uDF66",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    pie: {
      keywords: ["food", "dessert", "pastry"],
      char: "\uD83E\uDD67",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    cake: {
      keywords: ["food", "dessert"],
      char: "\uD83C\uDF70",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    cupcake: {
      keywords: ["food", "dessert", "bakery", "sweet"],
      char: "\uD83E\uDDC1",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    moon_cake: {
      keywords: ["food", "autumn"],
      char: "\uD83E\uDD6E",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    birthday: {
      keywords: ["food", "dessert", "cake"],
      char: "\uD83C\uDF82",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    custard: {
      keywords: ["dessert", "food"],
      char: "\uD83C\uDF6E",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    candy: {
      keywords: ["snack", "dessert", "sweet", "lolly"],
      char: "\uD83C\uDF6C",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    lollipop: {
      keywords: ["food", "snack", "candy", "sweet"],
      char: "\uD83C\uDF6D",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    chocolate_bar: {
      keywords: ["food", "snack", "dessert", "sweet"],
      char: "\uD83C\uDF6B",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    popcorn: {
      keywords: ["food", "movie theater", "films", "snack"],
      char: "\uD83C\uDF7F",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    dumpling: {
      keywords: ["food", "empanada", "pierogi", "potsticker"],
      char: "\uD83E\uDD5F",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    doughnut: {
      keywords: ["food", "dessert", "snack", "sweet", "donut"],
      char: "\uD83C\uDF69",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    cookie: {
      keywords: ["food", "snack", "oreo", "chocolate", "sweet", "dessert"],
      char: "\uD83C\uDF6A",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    milk_glass: {
      keywords: ["beverage", "drink", "cow"],
      char: "\uD83E\uDD5B",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    beer: {
      keywords: ["relax", "beverage", "drink", "drunk", "party", "pub", "summer", "alcohol", "booze"],
      char: "\uD83C\uDF7A",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    beers: {
      keywords: ["relax", "beverage", "drink", "drunk", "party", "pub", "summer", "alcohol", "booze"],
      char: "\uD83C\uDF7B",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    clinking_glasses: {
      keywords: ["beverage", "drink", "party", "alcohol", "celebrate", "cheers", "wine", "champagne", "toast"],
      char: "\uD83E\uDD42",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    wine_glass: {
      keywords: ["drink", "beverage", "drunk", "alcohol", "booze"],
      char: "\uD83C\uDF77",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    tumbler_glass: {
      keywords: ["drink", "beverage", "drunk", "alcohol", "liquor", "booze", "bourbon", "scotch", "whisky", "glass", "shot"],
      char: "\uD83E\uDD43",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    cocktail: {
      keywords: ["drink", "drunk", "alcohol", "beverage", "booze", "mojito"],
      char: "\uD83C\uDF78",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    tropical_drink: {
      keywords: ["beverage", "cocktail", "summer", "beach", "alcohol", "booze", "mojito"],
      char: "\uD83C\uDF79",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    champagne: {
      keywords: ["drink", "wine", "bottle", "celebration"],
      char: "\uD83C\uDF7E",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    sake: {
      keywords: ["wine", "drink", "drunk", "beverage", "japanese", "alcohol", "booze"],
      char: "\uD83C\uDF76",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    tea: {
      keywords: ["drink", "bowl", "breakfast", "green", "british"],
      char: "\uD83C\uDF75",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    cup_with_straw: {
      keywords: ["drink", "soda"],
      char: "\uD83E\uDD64",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    coffee: {
      keywords: ["beverage", "caffeine", "latte", "espresso"],
      char: "\u2615",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    baby_bottle: {
      keywords: ["food", "container", "milk"],
      char: "\uD83C\uDF7C",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    salt: {
      keywords: ["condiment", "shaker"],
      char: "\uD83E\uDDC2",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    spoon: {
      keywords: ["cutlery", "kitchen", "tableware"],
      char: "\uD83E\uDD44",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    fork_and_knife: {
      keywords: ["cutlery", "kitchen"],
      char: "\uD83C\uDF74",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    plate_with_cutlery: {
      keywords: ["food", "eat", "meal", "lunch", "dinner", "restaurant"],
      char: "\uD83C\uDF7D",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    bowl_with_spoon: {
      keywords: ["food", "breakfast", "cereal", "oatmeal", "porridge"],
      char: "\uD83E\uDD63",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    takeout_box: {
      keywords: ["food", "leftovers"],
      char: "\uD83E\uDD61",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    chopsticks: {
      keywords: ["food"],
      char: "\uD83E\uDD62",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    soccer: {
      keywords: ["sports", "football"],
      char: "\u26BD",
      fitzpatrick_scale: false,
      category: "activity"
    },
    basketball: {
      keywords: ["sports", "balls", "NBA"],
      char: "\uD83C\uDFC0",
      fitzpatrick_scale: false,
      category: "activity"
    },
    football: {
      keywords: ["sports", "balls", "NFL"],
      char: "\uD83C\uDFC8",
      fitzpatrick_scale: false,
      category: "activity"
    },
    baseball: {
      keywords: ["sports", "balls"],
      char: "\u26BE",
      fitzpatrick_scale: false,
      category: "activity"
    },
    softball: {
      keywords: ["sports", "balls"],
      char: "\uD83E\uDD4E",
      fitzpatrick_scale: false,
      category: "activity"
    },
    tennis: {
      keywords: ["sports", "balls", "green"],
      char: "\uD83C\uDFBE",
      fitzpatrick_scale: false,
      category: "activity"
    },
    volleyball: {
      keywords: ["sports", "balls"],
      char: "\uD83C\uDFD0",
      fitzpatrick_scale: false,
      category: "activity"
    },
    rugby_football: {
      keywords: ["sports", "team"],
      char: "\uD83C\uDFC9",
      fitzpatrick_scale: false,
      category: "activity"
    },
    flying_disc: {
      keywords: ["sports", "frisbee", "ultimate"],
      char: "\uD83E\uDD4F",
      fitzpatrick_scale: false,
      category: "activity"
    },
    "8ball": {
      keywords: ["pool", "hobby", "game", "luck", "magic"],
      char: "\uD83C\uDFB1",
      fitzpatrick_scale: false,
      category: "activity"
    },
    golf: {
      keywords: ["sports", "business", "flag", "hole", "summer"],
      char: "\u26F3",
      fitzpatrick_scale: false,
      category: "activity"
    },
    golfing_woman: {
      keywords: ["sports", "business", "woman", "female"],
      char: "\uD83C\uDFCC\uFE0F\u200D\u2640\uFE0F",
      fitzpatrick_scale: false,
      category: "activity"
    },
    golfing_man: {
      keywords: ["sports", "business"],
      char: "\uD83C\uDFCC",
      fitzpatrick_scale: true,
      category: "activity"
    },
    ping_pong: {
      keywords: ["sports", "pingpong"],
      char: "\uD83C\uDFD3",
      fitzpatrick_scale: false,
      category: "activity"
    },
    badminton: {
      keywords: ["sports"],
      char: "\uD83C\uDFF8",
      fitzpatrick_scale: false,
      category: "activity"
    },
    goal_net: {
      keywords: ["sports"],
      char: "\uD83E\uDD45",
      fitzpatrick_scale: false,
      category: "activity"
    },
    ice_hockey: {
      keywords: ["sports"],
      char: "\uD83C\uDFD2",
      fitzpatrick_scale: false,
      category: "activity"
    },
    field_hockey: {
      keywords: ["sports"],
      char: "\uD83C\uDFD1",
      fitzpatrick_scale: false,
      category: "activity"
    },
    lacrosse: {
      keywords: ["sports", "ball", "stick"],
      char: "\uD83E\uDD4D",
      fitzpatrick_scale: false,
      category: "activity"
    },
    cricket: {
      keywords: ["sports"],
      char: "\uD83C\uDFCF",
      fitzpatrick_scale: false,
      category: "activity"
    },
    ski: {
      keywords: ["sports", "winter", "cold", "snow"],
      char: "\uD83C\uDFBF",
      fitzpatrick_scale: false,
      category: "activity"
    },
    skier: {
      keywords: ["sports", "winter", "snow"],
      char: "\u26F7",
      fitzpatrick_scale: false,
      category: "activity"
    },
    snowboarder: {
      keywords: ["sports", "winter"],
      char: "\uD83C\uDFC2",
      fitzpatrick_scale: true,
      category: "activity"
    },
    person_fencing: {
      keywords: ["sports", "fencing", "sword"],
      char: "\uD83E\uDD3A",
      fitzpatrick_scale: false,
      category: "activity"
    },
    women_wrestling: {
      keywords: ["sports", "wrestlers"],
      char: "\uD83E\uDD3C\u200D\u2640\uFE0F",
      fitzpatrick_scale: false,
      category: "activity"
    },
    men_wrestling: {
      keywords: ["sports", "wrestlers"],
      char: "\uD83E\uDD3C\u200D\u2642\uFE0F",
      fitzpatrick_scale: false,
      category: "activity"
    },
    woman_cartwheeling: {
      keywords: ["gymnastics"],
      char: "\uD83E\uDD38\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "activity"
    },
    man_cartwheeling: {
      keywords: ["gymnastics"],
      char: "\uD83E\uDD38\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "activity"
    },
    woman_playing_handball: {
      keywords: ["sports"],
      char: "\uD83E\uDD3E\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "activity"
    },
    man_playing_handball: {
      keywords: ["sports"],
      char: "\uD83E\uDD3E\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "activity"
    },
    ice_skate: {
      keywords: ["sports"],
      char: "\u26F8",
      fitzpatrick_scale: false,
      category: "activity"
    },
    curling_stone: {
      keywords: ["sports"],
      char: "\uD83E\uDD4C",
      fitzpatrick_scale: false,
      category: "activity"
    },
    skateboard: {
      keywords: ["board"],
      char: "\uD83D\uDEF9",
      fitzpatrick_scale: false,
      category: "activity"
    },
    sled: {
      keywords: ["sleigh", "luge", "toboggan"],
      char: "\uD83D\uDEF7",
      fitzpatrick_scale: false,
      category: "activity"
    },
    bow_and_arrow: {
      keywords: ["sports"],
      char: "\uD83C\uDFF9",
      fitzpatrick_scale: false,
      category: "activity"
    },
    fishing_pole_and_fish: {
      keywords: ["food", "hobby", "summer"],
      char: "\uD83C\uDFA3",
      fitzpatrick_scale: false,
      category: "activity"
    },
    boxing_glove: {
      keywords: ["sports", "fighting"],
      char: "\uD83E\uDD4A",
      fitzpatrick_scale: false,
      category: "activity"
    },
    martial_arts_uniform: {
      keywords: ["judo", "karate", "taekwondo"],
      char: "\uD83E\uDD4B",
      fitzpatrick_scale: false,
      category: "activity"
    },
    rowing_woman: {
      keywords: ["sports", "hobby", "water", "ship", "woman", "female"],
      char: "\uD83D\uDEA3\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "activity"
    },
    rowing_man: {
      keywords: ["sports", "hobby", "water", "ship"],
      char: "\uD83D\uDEA3",
      fitzpatrick_scale: true,
      category: "activity"
    },
    climbing_woman: {
      keywords: ["sports", "hobby", "woman", "female", "rock"],
      char: "\uD83E\uDDD7\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "activity"
    },
    climbing_man: {
      keywords: ["sports", "hobby", "man", "male", "rock"],
      char: "\uD83E\uDDD7\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "activity"
    },
    swimming_woman: {
      keywords: ["sports", "exercise", "human", "athlete", "water", "summer", "woman", "female"],
      char: "\uD83C\uDFCA\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "activity"
    },
    swimming_man: {
      keywords: ["sports", "exercise", "human", "athlete", "water", "summer"],
      char: "\uD83C\uDFCA",
      fitzpatrick_scale: true,
      category: "activity"
    },
    woman_playing_water_polo: {
      keywords: ["sports", "pool"],
      char: "\uD83E\uDD3D\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "activity"
    },
    man_playing_water_polo: {
      keywords: ["sports", "pool"],
      char: "\uD83E\uDD3D\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "activity"
    },
    woman_in_lotus_position: {
      keywords: ["woman", "female", "meditation", "yoga", "serenity", "zen", "mindfulness"],
      char: "\uD83E\uDDD8\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "activity"
    },
    man_in_lotus_position: {
      keywords: ["man", "male", "meditation", "yoga", "serenity", "zen", "mindfulness"],
      char: "\uD83E\uDDD8\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "activity"
    },
    surfing_woman: {
      keywords: ["sports", "ocean", "sea", "summer", "beach", "woman", "female"],
      char: "\uD83C\uDFC4\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "activity"
    },
    surfing_man: {
      keywords: ["sports", "ocean", "sea", "summer", "beach"],
      char: "\uD83C\uDFC4",
      fitzpatrick_scale: true,
      category: "activity"
    },
    bath: {
      keywords: ["clean", "shower", "bathroom"],
      char: "\uD83D\uDEC0",
      fitzpatrick_scale: true,
      category: "activity"
    },
    basketball_woman: {
      keywords: ["sports", "human", "woman", "female"],
      char: "\u26F9\uFE0F\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "activity"
    },
    basketball_man: {
      keywords: ["sports", "human"],
      char: "\u26F9",
      fitzpatrick_scale: true,
      category: "activity"
    },
    weight_lifting_woman: {
      keywords: ["sports", "training", "exercise", "woman", "female"],
      char: "\uD83C\uDFCB\uFE0F\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "activity"
    },
    weight_lifting_man: {
      keywords: ["sports", "training", "exercise"],
      char: "\uD83C\uDFCB",
      fitzpatrick_scale: true,
      category: "activity"
    },
    biking_woman: {
      keywords: ["sports", "bike", "exercise", "hipster", "woman", "female"],
      char: "\uD83D\uDEB4\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "activity"
    },
    biking_man: {
      keywords: ["sports", "bike", "exercise", "hipster"],
      char: "\uD83D\uDEB4",
      fitzpatrick_scale: true,
      category: "activity"
    },
    mountain_biking_woman: {
      keywords: ["transportation", "sports", "human", "race", "bike", "woman", "female"],
      char: "\uD83D\uDEB5\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "activity"
    },
    mountain_biking_man: {
      keywords: ["transportation", "sports", "human", "race", "bike"],
      char: "\uD83D\uDEB5",
      fitzpatrick_scale: true,
      category: "activity"
    },
    horse_racing: {
      keywords: ["animal", "betting", "competition", "gambling", "luck"],
      char: "\uD83C\uDFC7",
      fitzpatrick_scale: true,
      category: "activity"
    },
    business_suit_levitating: {
      keywords: ["suit", "business", "levitate", "hover", "jump"],
      char: "\uD83D\uDD74",
      fitzpatrick_scale: true,
      category: "activity"
    },
    trophy: {
      keywords: ["win", "award", "contest", "place", "ftw", "ceremony"],
      char: "\uD83C\uDFC6",
      fitzpatrick_scale: false,
      category: "activity"
    },
    running_shirt_with_sash: {
      keywords: ["play", "pageant"],
      char: "\uD83C\uDFBD",
      fitzpatrick_scale: false,
      category: "activity"
    },
    medal_sports: {
      keywords: ["award", "winning"],
      char: "\uD83C\uDFC5",
      fitzpatrick_scale: false,
      category: "activity"
    },
    medal_military: {
      keywords: ["award", "winning", "army"],
      char: "\uD83C\uDF96",
      fitzpatrick_scale: false,
      category: "activity"
    },
    "1st_place_medal": {
      keywords: ["award", "winning", "first"],
      char: "\uD83E\uDD47",
      fitzpatrick_scale: false,
      category: "activity"
    },
    "2nd_place_medal": {
      keywords: ["award", "second"],
      char: "\uD83E\uDD48",
      fitzpatrick_scale: false,
      category: "activity"
    },
    "3rd_place_medal": {
      keywords: ["award", "third"],
      char: "\uD83E\uDD49",
      fitzpatrick_scale: false,
      category: "activity"
    },
    reminder_ribbon: {
      keywords: ["sports", "cause", "support", "awareness"],
      char: "\uD83C\uDF97",
      fitzpatrick_scale: false,
      category: "activity"
    },
    rosette: {
      keywords: ["flower", "decoration", "military"],
      char: "\uD83C\uDFF5",
      fitzpatrick_scale: false,
      category: "activity"
    },
    ticket: {
      keywords: ["event", "concert", "pass"],
      char: "\uD83C\uDFAB",
      fitzpatrick_scale: false,
      category: "activity"
    },
    tickets: {
      keywords: ["sports", "concert", "entrance"],
      char: "\uD83C\uDF9F",
      fitzpatrick_scale: false,
      category: "activity"
    },
    performing_arts: {
      keywords: ["acting", "theater", "drama"],
      char: "\uD83C\uDFAD",
      fitzpatrick_scale: false,
      category: "activity"
    },
    art: {
      keywords: ["design", "paint", "draw", "colors"],
      char: "\uD83C\uDFA8",
      fitzpatrick_scale: false,
      category: "activity"
    },
    circus_tent: {
      keywords: ["festival", "carnival", "party"],
      char: "\uD83C\uDFAA",
      fitzpatrick_scale: false,
      category: "activity"
    },
    woman_juggling: {
      keywords: ["juggle", "balance", "skill", "multitask"],
      char: "\uD83E\uDD39\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "activity"
    },
    man_juggling: {
      keywords: ["juggle", "balance", "skill", "multitask"],
      char: "\uD83E\uDD39\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "activity"
    },
    microphone: {
      keywords: ["sound", "music", "PA", "sing", "talkshow"],
      char: "\uD83C\uDFA4",
      fitzpatrick_scale: false,
      category: "activity"
    },
    headphones: {
      keywords: ["music", "score", "gadgets"],
      char: "\uD83C\uDFA7",
      fitzpatrick_scale: false,
      category: "activity"
    },
    musical_score: {
      keywords: ["treble", "clef", "compose"],
      char: "\uD83C\uDFBC",
      fitzpatrick_scale: false,
      category: "activity"
    },
    musical_keyboard: {
      keywords: ["piano", "instrument", "compose"],
      char: "\uD83C\uDFB9",
      fitzpatrick_scale: false,
      category: "activity"
    },
    drum: {
      keywords: ["music", "instrument", "drumsticks", "snare"],
      char: "\uD83E\uDD41",
      fitzpatrick_scale: false,
      category: "activity"
    },
    saxophone: {
      keywords: ["music", "instrument", "jazz", "blues"],
      char: "\uD83C\uDFB7",
      fitzpatrick_scale: false,
      category: "activity"
    },
    trumpet: {
      keywords: ["music", "brass"],
      char: "\uD83C\uDFBA",
      fitzpatrick_scale: false,
      category: "activity"
    },
    guitar: {
      keywords: ["music", "instrument"],
      char: "\uD83C\uDFB8",
      fitzpatrick_scale: false,
      category: "activity"
    },
    violin: {
      keywords: ["music", "instrument", "orchestra", "symphony"],
      char: "\uD83C\uDFBB",
      fitzpatrick_scale: false,
      category: "activity"
    },
    clapper: {
      keywords: ["movie", "film", "record"],
      char: "\uD83C\uDFAC",
      fitzpatrick_scale: false,
      category: "activity"
    },
    video_game: {
      keywords: ["play", "console", "PS4", "controller"],
      char: "\uD83C\uDFAE",
      fitzpatrick_scale: false,
      category: "activity"
    },
    space_invader: {
      keywords: ["game", "arcade", "play"],
      char: "\uD83D\uDC7E",
      fitzpatrick_scale: false,
      category: "activity"
    },
    dart: {
      keywords: ["game", "play", "bar", "target", "bullseye"],
      char: "\uD83C\uDFAF",
      fitzpatrick_scale: false,
      category: "activity"
    },
    game_die: {
      keywords: ["dice", "random", "tabletop", "play", "luck"],
      char: "\uD83C\uDFB2",
      fitzpatrick_scale: false,
      category: "activity"
    },
    chess_pawn: {
      keywords: ["expendable"],
      char: "\u265F",
      fitzpatrick_scale: false,
      category: "activity"
    },
    slot_machine: {
      keywords: ["bet", "gamble", "vegas", "fruit machine", "luck", "casino"],
      char: "\uD83C\uDFB0",
      fitzpatrick_scale: false,
      category: "activity"
    },
    jigsaw: {
      keywords: ["interlocking", "puzzle", "piece"],
      char: "\uD83E\uDDE9",
      fitzpatrick_scale: false,
      category: "activity"
    },
    bowling: {
      keywords: ["sports", "fun", "play"],
      char: "\uD83C\uDFB3",
      fitzpatrick_scale: false,
      category: "activity"
    },
    red_car: {
      keywords: ["red", "transportation", "vehicle"],
      char: "\uD83D\uDE97",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    taxi: {
      keywords: ["uber", "vehicle", "cars", "transportation"],
      char: "\uD83D\uDE95",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    blue_car: {
      keywords: ["transportation", "vehicle"],
      char: "\uD83D\uDE99",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    bus: {
      keywords: ["car", "vehicle", "transportation"],
      char: "\uD83D\uDE8C",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    trolleybus: {
      keywords: ["bart", "transportation", "vehicle"],
      char: "\uD83D\uDE8E",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    racing_car: {
      keywords: ["sports", "race", "fast", "formula", "f1"],
      char: "\uD83C\uDFCE",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    police_car: {
      keywords: ["vehicle", "cars", "transportation", "law", "legal", "enforcement"],
      char: "\uD83D\uDE93",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    ambulance: {
      keywords: ["health", "911", "hospital"],
      char: "\uD83D\uDE91",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    fire_engine: {
      keywords: ["transportation", "cars", "vehicle"],
      char: "\uD83D\uDE92",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    minibus: {
      keywords: ["vehicle", "car", "transportation"],
      char: "\uD83D\uDE90",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    truck: {
      keywords: ["cars", "transportation"],
      char: "\uD83D\uDE9A",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    articulated_lorry: {
      keywords: ["vehicle", "cars", "transportation", "express"],
      char: "\uD83D\uDE9B",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    tractor: {
      keywords: ["vehicle", "car", "farming", "agriculture"],
      char: "\uD83D\uDE9C",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    kick_scooter: {
      keywords: ["vehicle", "kick", "razor"],
      char: "\uD83D\uDEF4",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    motorcycle: {
      keywords: ["race", "sports", "fast"],
      char: "\uD83C\uDFCD",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    bike: {
      keywords: ["sports", "bicycle", "exercise", "hipster"],
      char: "\uD83D\uDEB2",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    motor_scooter: {
      keywords: ["vehicle", "vespa", "sasha"],
      char: "\uD83D\uDEF5",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    rotating_light: {
      keywords: ["police", "ambulance", "911", "emergency", "alert", "error", "pinged", "law", "legal"],
      char: "\uD83D\uDEA8",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    oncoming_police_car: {
      keywords: ["vehicle", "law", "legal", "enforcement", "911"],
      char: "\uD83D\uDE94",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    oncoming_bus: {
      keywords: ["vehicle", "transportation"],
      char: "\uD83D\uDE8D",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    oncoming_automobile: {
      keywords: ["car", "vehicle", "transportation"],
      char: "\uD83D\uDE98",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    oncoming_taxi: {
      keywords: ["vehicle", "cars", "uber"],
      char: "\uD83D\uDE96",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    aerial_tramway: {
      keywords: ["transportation", "vehicle", "ski"],
      char: "\uD83D\uDEA1",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    mountain_cableway: {
      keywords: ["transportation", "vehicle", "ski"],
      char: "\uD83D\uDEA0",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    suspension_railway: {
      keywords: ["vehicle", "transportation"],
      char: "\uD83D\uDE9F",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    railway_car: {
      keywords: ["transportation", "vehicle"],
      char: "\uD83D\uDE83",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    train: {
      keywords: ["transportation", "vehicle", "carriage", "public", "travel"],
      char: "\uD83D\uDE8B",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    monorail: {
      keywords: ["transportation", "vehicle"],
      char: "\uD83D\uDE9D",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    bullettrain_side: {
      keywords: ["transportation", "vehicle"],
      char: "\uD83D\uDE84",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    bullettrain_front: {
      keywords: ["transportation", "vehicle", "speed", "fast", "public", "travel"],
      char: "\uD83D\uDE85",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    light_rail: {
      keywords: ["transportation", "vehicle"],
      char: "\uD83D\uDE88",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    mountain_railway: {
      keywords: ["transportation", "vehicle"],
      char: "\uD83D\uDE9E",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    steam_locomotive: {
      keywords: ["transportation", "vehicle", "train"],
      char: "\uD83D\uDE82",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    train2: {
      keywords: ["transportation", "vehicle"],
      char: "\uD83D\uDE86",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    metro: {
      keywords: ["transportation", "blue-square", "mrt", "underground", "tube"],
      char: "\uD83D\uDE87",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    tram: {
      keywords: ["transportation", "vehicle"],
      char: "\uD83D\uDE8A",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    station: {
      keywords: ["transportation", "vehicle", "public"],
      char: "\uD83D\uDE89",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    flying_saucer: {
      keywords: ["transportation", "vehicle", "ufo"],
      char: "\uD83D\uDEF8",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    helicopter: {
      keywords: ["transportation", "vehicle", "fly"],
      char: "\uD83D\uDE81",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    small_airplane: {
      keywords: ["flight", "transportation", "fly", "vehicle"],
      char: "\uD83D\uDEE9",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    airplane: {
      keywords: ["vehicle", "transportation", "flight", "fly"],
      char: "\u2708\uFE0F",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    flight_departure: {
      keywords: ["airport", "flight", "landing"],
      char: "\uD83D\uDEEB",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    flight_arrival: {
      keywords: ["airport", "flight", "boarding"],
      char: "\uD83D\uDEEC",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    sailboat: {
      keywords: ["ship", "summer", "transportation", "water", "sailing"],
      char: "\u26F5",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    motor_boat: {
      keywords: ["ship"],
      char: "\uD83D\uDEE5",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    speedboat: {
      keywords: ["ship", "transportation", "vehicle", "summer"],
      char: "\uD83D\uDEA4",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    ferry: {
      keywords: ["boat", "ship", "yacht"],
      char: "\u26F4",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    passenger_ship: {
      keywords: ["yacht", "cruise", "ferry"],
      char: "\uD83D\uDEF3",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    rocket: {
      keywords: ["launch", "ship", "staffmode", "NASA", "outer space", "outer_space", "fly"],
      char: "\uD83D\uDE80",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    artificial_satellite: {
      keywords: ["communication", "gps", "orbit", "spaceflight", "NASA", "ISS"],
      char: "\uD83D\uDEF0",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    seat: {
      keywords: ["sit", "airplane", "transport", "bus", "flight", "fly"],
      char: "\uD83D\uDCBA",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    canoe: {
      keywords: ["boat", "paddle", "water", "ship"],
      char: "\uD83D\uDEF6",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    anchor: {
      keywords: ["ship", "ferry", "sea", "boat"],
      char: "\u2693",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    construction: {
      keywords: ["wip", "progress", "caution", "warning"],
      char: "\uD83D\uDEA7",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    fuelpump: {
      keywords: ["gas station", "petroleum"],
      char: "\u26FD",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    busstop: {
      keywords: ["transportation", "wait"],
      char: "\uD83D\uDE8F",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    vertical_traffic_light: {
      keywords: ["transportation", "driving"],
      char: "\uD83D\uDEA6",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    traffic_light: {
      keywords: ["transportation", "signal"],
      char: "\uD83D\uDEA5",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    checkered_flag: {
      keywords: ["contest", "finishline", "race", "gokart"],
      char: "\uD83C\uDFC1",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    ship: {
      keywords: ["transportation", "titanic", "deploy"],
      char: "\uD83D\uDEA2",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    ferris_wheel: {
      keywords: ["photo", "carnival", "londoneye"],
      char: "\uD83C\uDFA1",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    roller_coaster: {
      keywords: ["carnival", "playground", "photo", "fun"],
      char: "\uD83C\uDFA2",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    carousel_horse: {
      keywords: ["photo", "carnival"],
      char: "\uD83C\uDFA0",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    building_construction: {
      keywords: ["wip", "working", "progress"],
      char: "\uD83C\uDFD7",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    foggy: {
      keywords: ["photo", "mountain"],
      char: "\uD83C\uDF01",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    tokyo_tower: {
      keywords: ["photo", "japanese"],
      char: "\uD83D\uDDFC",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    factory: {
      keywords: ["building", "industry", "pollution", "smoke"],
      char: "\uD83C\uDFED",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    fountain: {
      keywords: ["photo", "summer", "water", "fresh"],
      char: "\u26F2",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    rice_scene: {
      keywords: ["photo", "japan", "asia", "tsukimi"],
      char: "\uD83C\uDF91",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    mountain: {
      keywords: ["photo", "nature", "environment"],
      char: "\u26F0",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    mountain_snow: {
      keywords: ["photo", "nature", "environment", "winter", "cold"],
      char: "\uD83C\uDFD4",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    mount_fuji: {
      keywords: ["photo", "mountain", "nature", "japanese"],
      char: "\uD83D\uDDFB",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    volcano: {
      keywords: ["photo", "nature", "disaster"],
      char: "\uD83C\uDF0B",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    japan: {
      keywords: ["nation", "country", "japanese", "asia"],
      char: "\uD83D\uDDFE",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    camping: {
      keywords: ["photo", "outdoors", "tent"],
      char: "\uD83C\uDFD5",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    tent: {
      keywords: ["photo", "camping", "outdoors"],
      char: "\u26FA",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    national_park: {
      keywords: ["photo", "environment", "nature"],
      char: "\uD83C\uDFDE",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    motorway: {
      keywords: ["road", "cupertino", "interstate", "highway"],
      char: "\uD83D\uDEE3",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    railway_track: {
      keywords: ["train", "transportation"],
      char: "\uD83D\uDEE4",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    sunrise: {
      keywords: ["morning", "view", "vacation", "photo"],
      char: "\uD83C\uDF05",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    sunrise_over_mountains: {
      keywords: ["view", "vacation", "photo"],
      char: "\uD83C\uDF04",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    desert: {
      keywords: ["photo", "warm", "saharah"],
      char: "\uD83C\uDFDC",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    beach_umbrella: {
      keywords: ["weather", "summer", "sunny", "sand", "mojito"],
      char: "\uD83C\uDFD6",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    desert_island: {
      keywords: ["photo", "tropical", "mojito"],
      char: "\uD83C\uDFDD",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    city_sunrise: {
      keywords: ["photo", "good morning", "dawn"],
      char: "\uD83C\uDF07",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    city_sunset: {
      keywords: ["photo", "evening", "sky", "buildings"],
      char: "\uD83C\uDF06",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    cityscape: {
      keywords: ["photo", "night life", "urban"],
      char: "\uD83C\uDFD9",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    night_with_stars: {
      keywords: ["evening", "city", "downtown"],
      char: "\uD83C\uDF03",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    bridge_at_night: {
      keywords: ["photo", "sanfrancisco"],
      char: "\uD83C\uDF09",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    milky_way: {
      keywords: ["photo", "space", "stars"],
      char: "\uD83C\uDF0C",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    stars: {
      keywords: ["night", "photo"],
      char: "\uD83C\uDF20",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    sparkler: {
      keywords: ["stars", "night", "shine"],
      char: "\uD83C\uDF87",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    fireworks: {
      keywords: ["photo", "festival", "carnival", "congratulations"],
      char: "\uD83C\uDF86",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    rainbow: {
      keywords: ["nature", "happy", "unicorn_face", "photo", "sky", "spring"],
      char: "\uD83C\uDF08",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    houses: {
      keywords: ["buildings", "photo"],
      char: "\uD83C\uDFD8",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    european_castle: {
      keywords: ["building", "royalty", "history"],
      char: "\uD83C\uDFF0",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    japanese_castle: {
      keywords: ["photo", "building"],
      char: "\uD83C\uDFEF",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    stadium: {
      keywords: ["photo", "place", "sports", "concert", "venue"],
      char: "\uD83C\uDFDF",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    statue_of_liberty: {
      keywords: ["american", "newyork"],
      char: "\uD83D\uDDFD",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    house: {
      keywords: ["building", "home"],
      char: "\uD83C\uDFE0",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    house_with_garden: {
      keywords: ["home", "plant", "nature"],
      char: "\uD83C\uDFE1",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    derelict_house: {
      keywords: ["abandon", "evict", "broken", "building"],
      char: "\uD83C\uDFDA",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    office: {
      keywords: ["building", "bureau", "work"],
      char: "\uD83C\uDFE2",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    department_store: {
      keywords: ["building", "shopping", "mall"],
      char: "\uD83C\uDFEC",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    post_office: {
      keywords: ["building", "envelope", "communication"],
      char: "\uD83C\uDFE3",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    european_post_office: {
      keywords: ["building", "email"],
      char: "\uD83C\uDFE4",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    hospital: {
      keywords: ["building", "health", "surgery", "doctor"],
      char: "\uD83C\uDFE5",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    bank: {
      keywords: ["building", "money", "sales", "cash", "business", "enterprise"],
      char: "\uD83C\uDFE6",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    hotel: {
      keywords: ["building", "accomodation", "checkin"],
      char: "\uD83C\uDFE8",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    convenience_store: {
      keywords: ["building", "shopping", "groceries"],
      char: "\uD83C\uDFEA",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    school: {
      keywords: ["building", "student", "education", "learn", "teach"],
      char: "\uD83C\uDFEB",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    love_hotel: {
      keywords: ["like", "affection", "dating"],
      char: "\uD83C\uDFE9",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    wedding: {
      keywords: ["love", "like", "affection", "couple", "marriage", "bride", "groom"],
      char: "\uD83D\uDC92",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    classical_building: {
      keywords: ["art", "culture", "history"],
      char: "\uD83C\uDFDB",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    church: {
      keywords: ["building", "religion", "christ"],
      char: "\u26EA",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    mosque: {
      keywords: ["islam", "worship", "minaret"],
      char: "\uD83D\uDD4C",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    synagogue: {
      keywords: ["judaism", "worship", "temple", "jewish"],
      char: "\uD83D\uDD4D",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    kaaba: {
      keywords: ["mecca", "mosque", "islam"],
      char: "\uD83D\uDD4B",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    shinto_shrine: {
      keywords: ["temple", "japan", "kyoto"],
      char: "\u26E9",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    watch: {
      keywords: ["time", "accessories"],
      char: "\u231A",
      fitzpatrick_scale: false,
      category: "objects"
    },
    iphone: {
      keywords: ["technology", "apple", "gadgets", "dial"],
      char: "\uD83D\uDCF1",
      fitzpatrick_scale: false,
      category: "objects"
    },
    calling: {
      keywords: ["iphone", "incoming"],
      char: "\uD83D\uDCF2",
      fitzpatrick_scale: false,
      category: "objects"
    },
    computer: {
      keywords: ["technology", "laptop", "screen", "display", "monitor"],
      char: "\uD83D\uDCBB",
      fitzpatrick_scale: false,
      category: "objects"
    },
    keyboard: {
      keywords: ["technology", "computer", "type", "input", "text"],
      char: "\u2328",
      fitzpatrick_scale: false,
      category: "objects"
    },
    desktop_computer: {
      keywords: ["technology", "computing", "screen"],
      char: "\uD83D\uDDA5",
      fitzpatrick_scale: false,
      category: "objects"
    },
    printer: {
      keywords: ["paper", "ink"],
      char: "\uD83D\uDDA8",
      fitzpatrick_scale: false,
      category: "objects"
    },
    computer_mouse: {
      keywords: ["click"],
      char: "\uD83D\uDDB1",
      fitzpatrick_scale: false,
      category: "objects"
    },
    trackball: {
      keywords: ["technology", "trackpad"],
      char: "\uD83D\uDDB2",
      fitzpatrick_scale: false,
      category: "objects"
    },
    joystick: {
      keywords: ["game", "play"],
      char: "\uD83D\uDD79",
      fitzpatrick_scale: false,
      category: "objects"
    },
    clamp: {
      keywords: ["tool"],
      char: "\uD83D\uDDDC",
      fitzpatrick_scale: false,
      category: "objects"
    },
    minidisc: {
      keywords: ["technology", "record", "data", "disk", "90s"],
      char: "\uD83D\uDCBD",
      fitzpatrick_scale: false,
      category: "objects"
    },
    floppy_disk: {
      keywords: ["oldschool", "technology", "save", "90s", "80s"],
      char: "\uD83D\uDCBE",
      fitzpatrick_scale: false,
      category: "objects"
    },
    cd: {
      keywords: ["technology", "dvd", "disk", "disc", "90s"],
      char: "\uD83D\uDCBF",
      fitzpatrick_scale: false,
      category: "objects"
    },
    dvd: {
      keywords: ["cd", "disk", "disc"],
      char: "\uD83D\uDCC0",
      fitzpatrick_scale: false,
      category: "objects"
    },
    vhs: {
      keywords: ["record", "video", "oldschool", "90s", "80s"],
      char: "\uD83D\uDCFC",
      fitzpatrick_scale: false,
      category: "objects"
    },
    camera: {
      keywords: ["gadgets", "photography"],
      char: "\uD83D\uDCF7",
      fitzpatrick_scale: false,
      category: "objects"
    },
    camera_flash: {
      keywords: ["photography", "gadgets"],
      char: "\uD83D\uDCF8",
      fitzpatrick_scale: false,
      category: "objects"
    },
    video_camera: {
      keywords: ["film", "record"],
      char: "\uD83D\uDCF9",
      fitzpatrick_scale: false,
      category: "objects"
    },
    movie_camera: {
      keywords: ["film", "record"],
      char: "\uD83C\uDFA5",
      fitzpatrick_scale: false,
      category: "objects"
    },
    film_projector: {
      keywords: ["video", "tape", "record", "movie"],
      char: "\uD83D\uDCFD",
      fitzpatrick_scale: false,
      category: "objects"
    },
    film_strip: {
      keywords: ["movie"],
      char: "\uD83C\uDF9E",
      fitzpatrick_scale: false,
      category: "objects"
    },
    telephone_receiver: {
      keywords: ["technology", "communication", "dial"],
      char: "\uD83D\uDCDE",
      fitzpatrick_scale: false,
      category: "objects"
    },
    phone: {
      keywords: ["technology", "communication", "dial", "telephone"],
      char: "\u260E\uFE0F",
      fitzpatrick_scale: false,
      category: "objects"
    },
    pager: {
      keywords: ["bbcall", "oldschool", "90s"],
      char: "\uD83D\uDCDF",
      fitzpatrick_scale: false,
      category: "objects"
    },
    fax: {
      keywords: ["communication", "technology"],
      char: "\uD83D\uDCE0",
      fitzpatrick_scale: false,
      category: "objects"
    },
    tv: {
      keywords: ["technology", "program", "oldschool", "show", "television"],
      char: "\uD83D\uDCFA",
      fitzpatrick_scale: false,
      category: "objects"
    },
    radio: {
      keywords: ["communication", "music", "podcast", "program"],
      char: "\uD83D\uDCFB",
      fitzpatrick_scale: false,
      category: "objects"
    },
    studio_microphone: {
      keywords: ["sing", "recording", "artist", "talkshow"],
      char: "\uD83C\uDF99",
      fitzpatrick_scale: false,
      category: "objects"
    },
    level_slider: {
      keywords: ["scale"],
      char: "\uD83C\uDF9A",
      fitzpatrick_scale: false,
      category: "objects"
    },
    control_knobs: {
      keywords: ["dial"],
      char: "\uD83C\uDF9B",
      fitzpatrick_scale: false,
      category: "objects"
    },
    compass: {
      keywords: ["magnetic", "navigation", "orienteering"],
      char: "\uD83E\uDDED",
      fitzpatrick_scale: false,
      category: "objects"
    },
    stopwatch: {
      keywords: ["time", "deadline"],
      char: "\u23F1",
      fitzpatrick_scale: false,
      category: "objects"
    },
    timer_clock: {
      keywords: ["alarm"],
      char: "\u23F2",
      fitzpatrick_scale: false,
      category: "objects"
    },
    alarm_clock: {
      keywords: ["time", "wake"],
      char: "\u23F0",
      fitzpatrick_scale: false,
      category: "objects"
    },
    mantelpiece_clock: {
      keywords: ["time"],
      char: "\uD83D\uDD70",
      fitzpatrick_scale: false,
      category: "objects"
    },
    hourglass_flowing_sand: {
      keywords: ["oldschool", "time", "countdown"],
      char: "\u23F3",
      fitzpatrick_scale: false,
      category: "objects"
    },
    hourglass: {
      keywords: ["time", "clock", "oldschool", "limit", "exam", "quiz", "test"],
      char: "\u231B",
      fitzpatrick_scale: false,
      category: "objects"
    },
    satellite: {
      keywords: ["communication", "future", "radio", "space"],
      char: "\uD83D\uDCE1",
      fitzpatrick_scale: false,
      category: "objects"
    },
    battery: {
      keywords: ["power", "energy", "sustain"],
      char: "\uD83D\uDD0B",
      fitzpatrick_scale: false,
      category: "objects"
    },
    electric_plug: {
      keywords: ["charger", "power"],
      char: "\uD83D\uDD0C",
      fitzpatrick_scale: false,
      category: "objects"
    },
    bulb: {
      keywords: ["light", "electricity", "idea"],
      char: "\uD83D\uDCA1",
      fitzpatrick_scale: false,
      category: "objects"
    },
    flashlight: {
      keywords: ["dark", "camping", "sight", "night"],
      char: "\uD83D\uDD26",
      fitzpatrick_scale: false,
      category: "objects"
    },
    candle: {
      keywords: ["fire", "wax"],
      char: "\uD83D\uDD6F",
      fitzpatrick_scale: false,
      category: "objects"
    },
    fire_extinguisher: {
      keywords: ["quench"],
      char: "\uD83E\uDDEF",
      fitzpatrick_scale: false,
      category: "objects"
    },
    wastebasket: {
      keywords: ["bin", "trash", "rubbish", "garbage", "toss"],
      char: "\uD83D\uDDD1",
      fitzpatrick_scale: false,
      category: "objects"
    },
    oil_drum: {
      keywords: ["barrell"],
      char: "\uD83D\uDEE2",
      fitzpatrick_scale: false,
      category: "objects"
    },
    money_with_wings: {
      keywords: ["dollar", "bills", "payment", "sale"],
      char: "\uD83D\uDCB8",
      fitzpatrick_scale: false,
      category: "objects"
    },
    dollar: {
      keywords: ["money", "sales", "bill", "currency"],
      char: "\uD83D\uDCB5",
      fitzpatrick_scale: false,
      category: "objects"
    },
    yen: {
      keywords: ["money", "sales", "japanese", "dollar", "currency"],
      char: "\uD83D\uDCB4",
      fitzpatrick_scale: false,
      category: "objects"
    },
    euro: {
      keywords: ["money", "sales", "dollar", "currency"],
      char: "\uD83D\uDCB6",
      fitzpatrick_scale: false,
      category: "objects"
    },
    pound: {
      keywords: ["british", "sterling", "money", "sales", "bills", "uk", "england", "currency"],
      char: "\uD83D\uDCB7",
      fitzpatrick_scale: false,
      category: "objects"
    },
    moneybag: {
      keywords: ["dollar", "payment", "coins", "sale"],
      char: "\uD83D\uDCB0",
      fitzpatrick_scale: false,
      category: "objects"
    },
    credit_card: {
      keywords: ["money", "sales", "dollar", "bill", "payment", "shopping"],
      char: "\uD83D\uDCB3",
      fitzpatrick_scale: false,
      category: "objects"
    },
    gem: {
      keywords: ["blue", "ruby", "diamond", "jewelry"],
      char: "\uD83D\uDC8E",
      fitzpatrick_scale: false,
      category: "objects"
    },
    balance_scale: {
      keywords: ["law", "fairness", "weight"],
      char: "\u2696",
      fitzpatrick_scale: false,
      category: "objects"
    },
    toolbox: {
      keywords: ["tools", "diy", "fix", "maintainer", "mechanic"],
      char: "\uD83E\uDDF0",
      fitzpatrick_scale: false,
      category: "objects"
    },
    wrench: {
      keywords: ["tools", "diy", "ikea", "fix", "maintainer"],
      char: "\uD83D\uDD27",
      fitzpatrick_scale: false,
      category: "objects"
    },
    hammer: {
      keywords: ["tools", "build", "create"],
      char: "\uD83D\uDD28",
      fitzpatrick_scale: false,
      category: "objects"
    },
    hammer_and_pick: {
      keywords: ["tools", "build", "create"],
      char: "\u2692",
      fitzpatrick_scale: false,
      category: "objects"
    },
    hammer_and_wrench: {
      keywords: ["tools", "build", "create"],
      char: "\uD83D\uDEE0",
      fitzpatrick_scale: false,
      category: "objects"
    },
    pick: {
      keywords: ["tools", "dig"],
      char: "\u26CF",
      fitzpatrick_scale: false,
      category: "objects"
    },
    nut_and_bolt: {
      keywords: ["handy", "tools", "fix"],
      char: "\uD83D\uDD29",
      fitzpatrick_scale: false,
      category: "objects"
    },
    gear: {
      keywords: ["cog"],
      char: "\u2699",
      fitzpatrick_scale: false,
      category: "objects"
    },
    brick: {
      keywords: ["bricks"],
      char: "\uD83E\uDDF1",
      fitzpatrick_scale: false,
      category: "objects"
    },
    chains: {
      keywords: ["lock", "arrest"],
      char: "\u26D3",
      fitzpatrick_scale: false,
      category: "objects"
    },
    magnet: {
      keywords: ["attraction", "magnetic"],
      char: "\uD83E\uDDF2",
      fitzpatrick_scale: false,
      category: "objects"
    },
    gun: {
      keywords: ["violence", "weapon", "pistol", "revolver"],
      char: "\uD83D\uDD2B",
      fitzpatrick_scale: false,
      category: "objects"
    },
    bomb: {
      keywords: ["boom", "explode", "explosion", "terrorism"],
      char: "\uD83D\uDCA3",
      fitzpatrick_scale: false,
      category: "objects"
    },
    firecracker: {
      keywords: ["dynamite", "boom", "explode", "explosion", "explosive"],
      char: "\uD83E\uDDE8",
      fitzpatrick_scale: false,
      category: "objects"
    },
    hocho: {
      keywords: ["knife", "blade", "cutlery", "kitchen", "weapon"],
      char: "\uD83D\uDD2A",
      fitzpatrick_scale: false,
      category: "objects"
    },
    dagger: {
      keywords: ["weapon"],
      char: "\uD83D\uDDE1",
      fitzpatrick_scale: false,
      category: "objects"
    },
    crossed_swords: {
      keywords: ["weapon"],
      char: "\u2694",
      fitzpatrick_scale: false,
      category: "objects"
    },
    shield: {
      keywords: ["protection", "security"],
      char: "\uD83D\uDEE1",
      fitzpatrick_scale: false,
      category: "objects"
    },
    smoking: {
      keywords: ["kills", "tobacco", "cigarette", "joint", "smoke"],
      char: "\uD83D\uDEAC",
      fitzpatrick_scale: false,
      category: "objects"
    },
    skull_and_crossbones: {
      keywords: ["poison", "danger", "deadly", "scary", "death", "pirate", "evil"],
      char: "\u2620",
      fitzpatrick_scale: false,
      category: "objects"
    },
    coffin: {
      keywords: ["vampire", "dead", "die", "death", "rip", "graveyard", "cemetery", "casket", "funeral", "box"],
      char: "\u26B0",
      fitzpatrick_scale: false,
      category: "objects"
    },
    funeral_urn: {
      keywords: ["dead", "die", "death", "rip", "ashes"],
      char: "\u26B1",
      fitzpatrick_scale: false,
      category: "objects"
    },
    amphora: {
      keywords: ["vase", "jar"],
      char: "\uD83C\uDFFA",
      fitzpatrick_scale: false,
      category: "objects"
    },
    crystal_ball: {
      keywords: ["disco", "party", "magic", "circus", "fortune_teller"],
      char: "\uD83D\uDD2E",
      fitzpatrick_scale: false,
      category: "objects"
    },
    prayer_beads: {
      keywords: ["dhikr", "religious"],
      char: "\uD83D\uDCFF",
      fitzpatrick_scale: false,
      category: "objects"
    },
    nazar_amulet: {
      keywords: ["bead", "charm"],
      char: "\uD83E\uDDFF",
      fitzpatrick_scale: false,
      category: "objects"
    },
    barber: {
      keywords: ["hair", "salon", "style"],
      char: "\uD83D\uDC88",
      fitzpatrick_scale: false,
      category: "objects"
    },
    alembic: {
      keywords: ["distilling", "science", "experiment", "chemistry"],
      char: "\u2697",
      fitzpatrick_scale: false,
      category: "objects"
    },
    telescope: {
      keywords: ["stars", "space", "zoom", "science", "astronomy"],
      char: "\uD83D\uDD2D",
      fitzpatrick_scale: false,
      category: "objects"
    },
    microscope: {
      keywords: ["laboratory", "experiment", "zoomin", "science", "study"],
      char: "\uD83D\uDD2C",
      fitzpatrick_scale: false,
      category: "objects"
    },
    hole: {
      keywords: ["embarrassing"],
      char: "\uD83D\uDD73",
      fitzpatrick_scale: false,
      category: "objects"
    },
    pill: {
      keywords: ["health", "medicine", "doctor", "pharmacy", "drug"],
      char: "\uD83D\uDC8A",
      fitzpatrick_scale: false,
      category: "objects"
    },
    syringe: {
      keywords: ["health", "hospital", "drugs", "blood", "medicine", "needle", "doctor", "nurse"],
      char: "\uD83D\uDC89",
      fitzpatrick_scale: false,
      category: "objects"
    },
    dna: {
      keywords: ["biologist", "genetics", "life"],
      char: "\uD83E\uDDEC",
      fitzpatrick_scale: false,
      category: "objects"
    },
    microbe: {
      keywords: ["amoeba", "bacteria", "germs"],
      char: "\uD83E\uDDA0",
      fitzpatrick_scale: false,
      category: "objects"
    },
    petri_dish: {
      keywords: ["bacteria", "biology", "culture", "lab"],
      char: "\uD83E\uDDEB",
      fitzpatrick_scale: false,
      category: "objects"
    },
    test_tube: {
      keywords: ["chemistry", "experiment", "lab", "science"],
      char: "\uD83E\uDDEA",
      fitzpatrick_scale: false,
      category: "objects"
    },
    thermometer: {
      keywords: ["weather", "temperature", "hot", "cold"],
      char: "\uD83C\uDF21",
      fitzpatrick_scale: false,
      category: "objects"
    },
    broom: {
      keywords: ["cleaning", "sweeping", "witch"],
      char: "\uD83E\uDDF9",
      fitzpatrick_scale: false,
      category: "objects"
    },
    basket: {
      keywords: ["laundry"],
      char: "\uD83E\uDDFA",
      fitzpatrick_scale: false,
      category: "objects"
    },
    toilet_paper: {
      keywords: ["roll"],
      char: "\uD83E\uDDFB",
      fitzpatrick_scale: false,
      category: "objects"
    },
    label: {
      keywords: ["sale", "tag"],
      char: "\uD83C\uDFF7",
      fitzpatrick_scale: false,
      category: "objects"
    },
    bookmark: {
      keywords: ["favorite", "label", "save"],
      char: "\uD83D\uDD16",
      fitzpatrick_scale: false,
      category: "objects"
    },
    toilet: {
      keywords: ["restroom", "wc", "washroom", "bathroom", "potty"],
      char: "\uD83D\uDEBD",
      fitzpatrick_scale: false,
      category: "objects"
    },
    shower: {
      keywords: ["clean", "water", "bathroom"],
      char: "\uD83D\uDEBF",
      fitzpatrick_scale: false,
      category: "objects"
    },
    bathtub: {
      keywords: ["clean", "shower", "bathroom"],
      char: "\uD83D\uDEC1",
      fitzpatrick_scale: false,
      category: "objects"
    },
    soap: {
      keywords: ["bar", "bathing", "cleaning", "lather"],
      char: "\uD83E\uDDFC",
      fitzpatrick_scale: false,
      category: "objects"
    },
    sponge: {
      keywords: ["absorbing", "cleaning", "porous"],
      char: "\uD83E\uDDFD",
      fitzpatrick_scale: false,
      category: "objects"
    },
    lotion_bottle: {
      keywords: ["moisturizer", "sunscreen"],
      char: "\uD83E\uDDF4",
      fitzpatrick_scale: false,
      category: "objects"
    },
    key: {
      keywords: ["lock", "door", "password"],
      char: "\uD83D\uDD11",
      fitzpatrick_scale: false,
      category: "objects"
    },
    old_key: {
      keywords: ["lock", "door", "password"],
      char: "\uD83D\uDDDD",
      fitzpatrick_scale: false,
      category: "objects"
    },
    couch_and_lamp: {
      keywords: ["read", "chill"],
      char: "\uD83D\uDECB",
      fitzpatrick_scale: false,
      category: "objects"
    },
    sleeping_bed: {
      keywords: ["bed", "rest"],
      char: "\uD83D\uDECC",
      fitzpatrick_scale: true,
      category: "objects"
    },
    bed: {
      keywords: ["sleep", "rest"],
      char: "\uD83D\uDECF",
      fitzpatrick_scale: false,
      category: "objects"
    },
    door: {
      keywords: ["house", "entry", "exit"],
      char: "\uD83D\uDEAA",
      fitzpatrick_scale: false,
      category: "objects"
    },
    bellhop_bell: {
      keywords: ["service"],
      char: "\uD83D\uDECE",
      fitzpatrick_scale: false,
      category: "objects"
    },
    teddy_bear: {
      keywords: ["plush", "stuffed"],
      char: "\uD83E\uDDF8",
      fitzpatrick_scale: false,
      category: "objects"
    },
    framed_picture: {
      keywords: ["photography"],
      char: "\uD83D\uDDBC",
      fitzpatrick_scale: false,
      category: "objects"
    },
    world_map: {
      keywords: ["location", "direction"],
      char: "\uD83D\uDDFA",
      fitzpatrick_scale: false,
      category: "objects"
    },
    parasol_on_ground: {
      keywords: ["weather", "summer"],
      char: "\u26F1",
      fitzpatrick_scale: false,
      category: "objects"
    },
    moyai: {
      keywords: ["rock", "easter island", "moai"],
      char: "\uD83D\uDDFF",
      fitzpatrick_scale: false,
      category: "objects"
    },
    shopping: {
      keywords: ["mall", "buy", "purchase"],
      char: "\uD83D\uDECD",
      fitzpatrick_scale: false,
      category: "objects"
    },
    shopping_cart: {
      keywords: ["trolley"],
      char: "\uD83D\uDED2",
      fitzpatrick_scale: false,
      category: "objects"
    },
    balloon: {
      keywords: ["party", "celebration", "birthday", "circus"],
      char: "\uD83C\uDF88",
      fitzpatrick_scale: false,
      category: "objects"
    },
    flags: {
      keywords: ["fish", "japanese", "koinobori", "carp", "banner"],
      char: "\uD83C\uDF8F",
      fitzpatrick_scale: false,
      category: "objects"
    },
    ribbon: {
      keywords: ["decoration", "pink", "girl", "bowtie"],
      char: "\uD83C\uDF80",
      fitzpatrick_scale: false,
      category: "objects"
    },
    gift: {
      keywords: ["present", "birthday", "christmas", "xmas"],
      char: "\uD83C\uDF81",
      fitzpatrick_scale: false,
      category: "objects"
    },
    confetti_ball: {
      keywords: ["festival", "party", "birthday", "circus"],
      char: "\uD83C\uDF8A",
      fitzpatrick_scale: false,
      category: "objects"
    },
    tada: {
      keywords: ["party", "congratulations", "birthday", "magic", "circus", "celebration"],
      char: "\uD83C\uDF89",
      fitzpatrick_scale: false,
      category: "objects"
    },
    dolls: {
      keywords: ["japanese", "toy", "kimono"],
      char: "\uD83C\uDF8E",
      fitzpatrick_scale: false,
      category: "objects"
    },
    wind_chime: {
      keywords: ["nature", "ding", "spring", "bell"],
      char: "\uD83C\uDF90",
      fitzpatrick_scale: false,
      category: "objects"
    },
    crossed_flags: {
      keywords: ["japanese", "nation", "country", "border"],
      char: "\uD83C\uDF8C",
      fitzpatrick_scale: false,
      category: "objects"
    },
    izakaya_lantern: {
      keywords: ["light", "paper", "halloween", "spooky"],
      char: "\uD83C\uDFEE",
      fitzpatrick_scale: false,
      category: "objects"
    },
    red_envelope: {
      keywords: ["gift"],
      char: "\uD83E\uDDE7",
      fitzpatrick_scale: false,
      category: "objects"
    },
    email: {
      keywords: ["letter", "postal", "inbox", "communication"],
      char: "\u2709\uFE0F",
      fitzpatrick_scale: false,
      category: "objects"
    },
    envelope_with_arrow: {
      keywords: ["email", "communication"],
      char: "\uD83D\uDCE9",
      fitzpatrick_scale: false,
      category: "objects"
    },
    incoming_envelope: {
      keywords: ["email", "inbox"],
      char: "\uD83D\uDCE8",
      fitzpatrick_scale: false,
      category: "objects"
    },
    "e-mail": {
      keywords: ["communication", "inbox"],
      char: "\uD83D\uDCE7",
      fitzpatrick_scale: false,
      category: "objects"
    },
    love_letter: {
      keywords: ["email", "like", "affection", "envelope", "valentines"],
      char: "\uD83D\uDC8C",
      fitzpatrick_scale: false,
      category: "objects"
    },
    postbox: {
      keywords: ["email", "letter", "envelope"],
      char: "\uD83D\uDCEE",
      fitzpatrick_scale: false,
      category: "objects"
    },
    mailbox_closed: {
      keywords: ["email", "communication", "inbox"],
      char: "\uD83D\uDCEA",
      fitzpatrick_scale: false,
      category: "objects"
    },
    mailbox: {
      keywords: ["email", "inbox", "communication"],
      char: "\uD83D\uDCEB",
      fitzpatrick_scale: false,
      category: "objects"
    },
    mailbox_with_mail: {
      keywords: ["email", "inbox", "communication"],
      char: "\uD83D\uDCEC",
      fitzpatrick_scale: false,
      category: "objects"
    },
    mailbox_with_no_mail: {
      keywords: ["email", "inbox"],
      char: "\uD83D\uDCED",
      fitzpatrick_scale: false,
      category: "objects"
    },
    package: {
      keywords: ["mail", "gift", "cardboard", "box", "moving"],
      char: "\uD83D\uDCE6",
      fitzpatrick_scale: false,
      category: "objects"
    },
    postal_horn: {
      keywords: ["instrument", "music"],
      char: "\uD83D\uDCEF",
      fitzpatrick_scale: false,
      category: "objects"
    },
    inbox_tray: {
      keywords: ["email", "documents"],
      char: "\uD83D\uDCE5",
      fitzpatrick_scale: false,
      category: "objects"
    },
    outbox_tray: {
      keywords: ["inbox", "email"],
      char: "\uD83D\uDCE4",
      fitzpatrick_scale: false,
      category: "objects"
    },
    scroll: {
      keywords: ["documents", "ancient", "history", "paper"],
      char: "\uD83D\uDCDC",
      fitzpatrick_scale: false,
      category: "objects"
    },
    page_with_curl: {
      keywords: ["documents", "office", "paper"],
      char: "\uD83D\uDCC3",
      fitzpatrick_scale: false,
      category: "objects"
    },
    bookmark_tabs: {
      keywords: ["favorite", "save", "order", "tidy"],
      char: "\uD83D\uDCD1",
      fitzpatrick_scale: false,
      category: "objects"
    },
    receipt: {
      keywords: ["accounting", "expenses"],
      char: "\uD83E\uDDFE",
      fitzpatrick_scale: false,
      category: "objects"
    },
    bar_chart: {
      keywords: ["graph", "presentation", "stats"],
      char: "\uD83D\uDCCA",
      fitzpatrick_scale: false,
      category: "objects"
    },
    chart_with_upwards_trend: {
      keywords: ["graph", "presentation", "stats", "recovery", "business", "economics", "money", "sales", "good", "success"],
      char: "\uD83D\uDCC8",
      fitzpatrick_scale: false,
      category: "objects"
    },
    chart_with_downwards_trend: {
      keywords: ["graph", "presentation", "stats", "recession", "business", "economics", "money", "sales", "bad", "failure"],
      char: "\uD83D\uDCC9",
      fitzpatrick_scale: false,
      category: "objects"
    },
    page_facing_up: {
      keywords: ["documents", "office", "paper", "information"],
      char: "\uD83D\uDCC4",
      fitzpatrick_scale: false,
      category: "objects"
    },
    date: {
      keywords: ["calendar", "schedule"],
      char: "\uD83D\uDCC5",
      fitzpatrick_scale: false,
      category: "objects"
    },
    calendar: {
      keywords: ["schedule", "date", "planning"],
      char: "\uD83D\uDCC6",
      fitzpatrick_scale: false,
      category: "objects"
    },
    spiral_calendar: {
      keywords: ["date", "schedule", "planning"],
      char: "\uD83D\uDDD3",
      fitzpatrick_scale: false,
      category: "objects"
    },
    card_index: {
      keywords: ["business", "stationery"],
      char: "\uD83D\uDCC7",
      fitzpatrick_scale: false,
      category: "objects"
    },
    card_file_box: {
      keywords: ["business", "stationery"],
      char: "\uD83D\uDDC3",
      fitzpatrick_scale: false,
      category: "objects"
    },
    ballot_box: {
      keywords: ["election", "vote"],
      char: "\uD83D\uDDF3",
      fitzpatrick_scale: false,
      category: "objects"
    },
    file_cabinet: {
      keywords: ["filing", "organizing"],
      char: "\uD83D\uDDC4",
      fitzpatrick_scale: false,
      category: "objects"
    },
    clipboard: {
      keywords: ["stationery", "documents"],
      char: "\uD83D\uDCCB",
      fitzpatrick_scale: false,
      category: "objects"
    },
    spiral_notepad: {
      keywords: ["memo", "stationery"],
      char: "\uD83D\uDDD2",
      fitzpatrick_scale: false,
      category: "objects"
    },
    file_folder: {
      keywords: ["documents", "business", "office"],
      char: "\uD83D\uDCC1",
      fitzpatrick_scale: false,
      category: "objects"
    },
    open_file_folder: {
      keywords: ["documents", "load"],
      char: "\uD83D\uDCC2",
      fitzpatrick_scale: false,
      category: "objects"
    },
    card_index_dividers: {
      keywords: ["organizing", "business", "stationery"],
      char: "\uD83D\uDDC2",
      fitzpatrick_scale: false,
      category: "objects"
    },
    newspaper_roll: {
      keywords: ["press", "headline"],
      char: "\uD83D\uDDDE",
      fitzpatrick_scale: false,
      category: "objects"
    },
    newspaper: {
      keywords: ["press", "headline"],
      char: "\uD83D\uDCF0",
      fitzpatrick_scale: false,
      category: "objects"
    },
    notebook: {
      keywords: ["stationery", "record", "notes", "paper", "study"],
      char: "\uD83D\uDCD3",
      fitzpatrick_scale: false,
      category: "objects"
    },
    closed_book: {
      keywords: ["read", "library", "knowledge", "textbook", "learn"],
      char: "\uD83D\uDCD5",
      fitzpatrick_scale: false,
      category: "objects"
    },
    green_book: {
      keywords: ["read", "library", "knowledge", "study"],
      char: "\uD83D\uDCD7",
      fitzpatrick_scale: false,
      category: "objects"
    },
    blue_book: {
      keywords: ["read", "library", "knowledge", "learn", "study"],
      char: "\uD83D\uDCD8",
      fitzpatrick_scale: false,
      category: "objects"
    },
    orange_book: {
      keywords: ["read", "library", "knowledge", "textbook", "study"],
      char: "\uD83D\uDCD9",
      fitzpatrick_scale: false,
      category: "objects"
    },
    notebook_with_decorative_cover: {
      keywords: ["classroom", "notes", "record", "paper", "study"],
      char: "\uD83D\uDCD4",
      fitzpatrick_scale: false,
      category: "objects"
    },
    ledger: {
      keywords: ["notes", "paper"],
      char: "\uD83D\uDCD2",
      fitzpatrick_scale: false,
      category: "objects"
    },
    books: {
      keywords: ["literature", "library", "study"],
      char: "\uD83D\uDCDA",
      fitzpatrick_scale: false,
      category: "objects"
    },
    open_book: {
      keywords: ["book", "read", "library", "knowledge", "literature", "learn", "study"],
      char: "\uD83D\uDCD6",
      fitzpatrick_scale: false,
      category: "objects"
    },
    safety_pin: {
      keywords: ["diaper"],
      char: "\uD83E\uDDF7",
      fitzpatrick_scale: false,
      category: "objects"
    },
    link: {
      keywords: ["rings", "url"],
      char: "\uD83D\uDD17",
      fitzpatrick_scale: false,
      category: "objects"
    },
    paperclip: {
      keywords: ["documents", "stationery"],
      char: "\uD83D\uDCCE",
      fitzpatrick_scale: false,
      category: "objects"
    },
    paperclips: {
      keywords: ["documents", "stationery"],
      char: "\uD83D\uDD87",
      fitzpatrick_scale: false,
      category: "objects"
    },
    scissors: {
      keywords: ["stationery", "cut"],
      char: "\u2702\uFE0F",
      fitzpatrick_scale: false,
      category: "objects"
    },
    triangular_ruler: {
      keywords: ["stationery", "math", "architect", "sketch"],
      char: "\uD83D\uDCD0",
      fitzpatrick_scale: false,
      category: "objects"
    },
    straight_ruler: {
      keywords: ["stationery", "calculate", "length", "math", "school", "drawing", "architect", "sketch"],
      char: "\uD83D\uDCCF",
      fitzpatrick_scale: false,
      category: "objects"
    },
    abacus: {
      keywords: ["calculation"],
      char: "\uD83E\uDDEE",
      fitzpatrick_scale: false,
      category: "objects"
    },
    pushpin: {
      keywords: ["stationery", "mark", "here"],
      char: "\uD83D\uDCCC",
      fitzpatrick_scale: false,
      category: "objects"
    },
    round_pushpin: {
      keywords: ["stationery", "location", "map", "here"],
      char: "\uD83D\uDCCD",
      fitzpatrick_scale: false,
      category: "objects"
    },
    triangular_flag_on_post: {
      keywords: ["mark", "milestone", "place"],
      char: "\uD83D\uDEA9",
      fitzpatrick_scale: false,
      category: "objects"
    },
    white_flag: {
      keywords: ["losing", "loser", "lost", "surrender", "give up", "fail"],
      char: "\uD83C\uDFF3",
      fitzpatrick_scale: false,
      category: "objects"
    },
    black_flag: {
      keywords: ["pirate"],
      char: "\uD83C\uDFF4",
      fitzpatrick_scale: false,
      category: "objects"
    },
    rainbow_flag: {
      keywords: ["flag", "rainbow", "pride", "gay", "lgbt", "glbt", "queer", "homosexual", "lesbian", "bisexual", "transgender"],
      char: "\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08",
      fitzpatrick_scale: false,
      category: "objects"
    },
    closed_lock_with_key: {
      keywords: ["security", "privacy"],
      char: "\uD83D\uDD10",
      fitzpatrick_scale: false,
      category: "objects"
    },
    lock: {
      keywords: ["security", "password", "padlock"],
      char: "\uD83D\uDD12",
      fitzpatrick_scale: false,
      category: "objects"
    },
    unlock: {
      keywords: ["privacy", "security"],
      char: "\uD83D\uDD13",
      fitzpatrick_scale: false,
      category: "objects"
    },
    lock_with_ink_pen: {
      keywords: ["security", "secret"],
      char: "\uD83D\uDD0F",
      fitzpatrick_scale: false,
      category: "objects"
    },
    pen: {
      keywords: ["stationery", "writing", "write"],
      char: "\uD83D\uDD8A",
      fitzpatrick_scale: false,
      category: "objects"
    },
    fountain_pen: {
      keywords: ["stationery", "writing", "write"],
      char: "\uD83D\uDD8B",
      fitzpatrick_scale: false,
      category: "objects"
    },
    black_nib: {
      keywords: ["pen", "stationery", "writing", "write"],
      char: "\u2712\uFE0F",
      fitzpatrick_scale: false,
      category: "objects"
    },
    memo: {
      keywords: ["write", "documents", "stationery", "pencil", "paper", "writing", "legal", "exam", "quiz", "test", "study", "compose"],
      char: "\uD83D\uDCDD",
      fitzpatrick_scale: false,
      category: "objects"
    },
    pencil2: {
      keywords: ["stationery", "write", "paper", "writing", "school", "study"],
      char: "\u270F\uFE0F",
      fitzpatrick_scale: false,
      category: "objects"
    },
    crayon: {
      keywords: ["drawing", "creativity"],
      char: "\uD83D\uDD8D",
      fitzpatrick_scale: false,
      category: "objects"
    },
    paintbrush: {
      keywords: ["drawing", "creativity", "art"],
      char: "\uD83D\uDD8C",
      fitzpatrick_scale: false,
      category: "objects"
    },
    mag: {
      keywords: ["search", "zoom", "find", "detective"],
      char: "\uD83D\uDD0D",
      fitzpatrick_scale: false,
      category: "objects"
    },
    mag_right: {
      keywords: ["search", "zoom", "find", "detective"],
      char: "\uD83D\uDD0E",
      fitzpatrick_scale: false,
      category: "objects"
    },
    heart: {
      keywords: ["love", "like", "valentines"],
      char: "\u2764\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    orange_heart: {
      keywords: ["love", "like", "affection", "valentines"],
      char: "\uD83E\uDDE1",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    yellow_heart: {
      keywords: ["love", "like", "affection", "valentines"],
      char: "\uD83D\uDC9B",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    green_heart: {
      keywords: ["love", "like", "affection", "valentines"],
      char: "\uD83D\uDC9A",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    blue_heart: {
      keywords: ["love", "like", "affection", "valentines"],
      char: "\uD83D\uDC99",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    purple_heart: {
      keywords: ["love", "like", "affection", "valentines"],
      char: "\uD83D\uDC9C",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    black_heart: {
      keywords: ["evil"],
      char: "\uD83D\uDDA4",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    broken_heart: {
      keywords: ["sad", "sorry", "break", "heart", "heartbreak"],
      char: "\uD83D\uDC94",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    heavy_heart_exclamation: {
      keywords: ["decoration", "love"],
      char: "\u2763",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    two_hearts: {
      keywords: ["love", "like", "affection", "valentines", "heart"],
      char: "\uD83D\uDC95",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    revolving_hearts: {
      keywords: ["love", "like", "affection", "valentines"],
      char: "\uD83D\uDC9E",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    heartbeat: {
      keywords: ["love", "like", "affection", "valentines", "pink", "heart"],
      char: "\uD83D\uDC93",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    heartpulse: {
      keywords: ["like", "love", "affection", "valentines", "pink"],
      char: "\uD83D\uDC97",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    sparkling_heart: {
      keywords: ["love", "like", "affection", "valentines"],
      char: "\uD83D\uDC96",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    cupid: {
      keywords: ["love", "like", "heart", "affection", "valentines"],
      char: "\uD83D\uDC98",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    gift_heart: {
      keywords: ["love", "valentines"],
      char: "\uD83D\uDC9D",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    heart_decoration: {
      keywords: ["purple-square", "love", "like"],
      char: "\uD83D\uDC9F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    peace_symbol: {
      keywords: ["hippie"],
      char: "\u262E",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    latin_cross: {
      keywords: ["christianity"],
      char: "\u271D",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    star_and_crescent: {
      keywords: ["islam"],
      char: "\u262A",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    om: {
      keywords: ["hinduism", "buddhism", "sikhism", "jainism"],
      char: "\uD83D\uDD49",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    wheel_of_dharma: {
      keywords: ["hinduism", "buddhism", "sikhism", "jainism"],
      char: "\u2638",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    star_of_david: {
      keywords: ["judaism"],
      char: "\u2721",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    six_pointed_star: {
      keywords: ["purple-square", "religion", "jewish", "hexagram"],
      char: "\uD83D\uDD2F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    menorah: {
      keywords: ["hanukkah", "candles", "jewish"],
      char: "\uD83D\uDD4E",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    yin_yang: {
      keywords: ["balance"],
      char: "\u262F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    orthodox_cross: {
      keywords: ["suppedaneum", "religion"],
      char: "\u2626",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    place_of_worship: {
      keywords: ["religion", "church", "temple", "prayer"],
      char: "\uD83D\uDED0",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    ophiuchus: {
      keywords: ["sign", "purple-square", "constellation", "astrology"],
      char: "\u26CE",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    aries: {
      keywords: ["sign", "purple-square", "zodiac", "astrology"],
      char: "\u2648",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    taurus: {
      keywords: ["purple-square", "sign", "zodiac", "astrology"],
      char: "\u2649",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    gemini: {
      keywords: ["sign", "zodiac", "purple-square", "astrology"],
      char: "\u264A",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    cancer: {
      keywords: ["sign", "zodiac", "purple-square", "astrology"],
      char: "\u264B",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    leo: {
      keywords: ["sign", "purple-square", "zodiac", "astrology"],
      char: "\u264C",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    virgo: {
      keywords: ["sign", "zodiac", "purple-square", "astrology"],
      char: "\u264D",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    libra: {
      keywords: ["sign", "purple-square", "zodiac", "astrology"],
      char: "\u264E",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    scorpius: {
      keywords: ["sign", "zodiac", "purple-square", "astrology", "scorpio"],
      char: "\u264F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    sagittarius: {
      keywords: ["sign", "zodiac", "purple-square", "astrology"],
      char: "\u2650",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    capricorn: {
      keywords: ["sign", "zodiac", "purple-square", "astrology"],
      char: "\u2651",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    aquarius: {
      keywords: ["sign", "purple-square", "zodiac", "astrology"],
      char: "\u2652",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    pisces: {
      keywords: ["purple-square", "sign", "zodiac", "astrology"],
      char: "\u2653",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    id: {
      keywords: ["purple-square", "words"],
      char: "\uD83C\uDD94",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    atom_symbol: {
      keywords: ["science", "physics", "chemistry"],
      char: "\u269B",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    u7a7a: {
      keywords: ["kanji", "japanese", "chinese", "empty", "sky", "blue-square"],
      char: "\uD83C\uDE33",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    u5272: {
      keywords: ["cut", "divide", "chinese", "kanji", "pink-square"],
      char: "\uD83C\uDE39",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    radioactive: {
      keywords: ["nuclear", "danger"],
      char: "\u2622",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    biohazard: {
      keywords: ["danger"],
      char: "\u2623",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    mobile_phone_off: {
      keywords: ["mute", "orange-square", "silence", "quiet"],
      char: "\uD83D\uDCF4",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    vibration_mode: {
      keywords: ["orange-square", "phone"],
      char: "\uD83D\uDCF3",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    u6709: {
      keywords: ["orange-square", "chinese", "have", "kanji"],
      char: "\uD83C\uDE36",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    u7121: {
      keywords: ["nothing", "chinese", "kanji", "japanese", "orange-square"],
      char: "\uD83C\uDE1A",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    u7533: {
      keywords: ["chinese", "japanese", "kanji", "orange-square"],
      char: "\uD83C\uDE38",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    u55b6: {
      keywords: ["japanese", "opening hours", "orange-square"],
      char: "\uD83C\uDE3A",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    u6708: {
      keywords: ["chinese", "month", "moon", "japanese", "orange-square", "kanji"],
      char: "\uD83C\uDE37\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    eight_pointed_black_star: {
      keywords: ["orange-square", "shape", "polygon"],
      char: "\u2734\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    vs: {
      keywords: ["words", "orange-square"],
      char: "\uD83C\uDD9A",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    accept: {
      keywords: ["ok", "good", "chinese", "kanji", "agree", "yes", "orange-circle"],
      char: "\uD83C\uDE51",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    white_flower: {
      keywords: ["japanese", "spring"],
      char: "\uD83D\uDCAE",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    ideograph_advantage: {
      keywords: ["chinese", "kanji", "obtain", "get", "circle"],
      char: "\uD83C\uDE50",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    secret: {
      keywords: ["privacy", "chinese", "sshh", "kanji", "red-circle"],
      char: "\u3299\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    congratulations: {
      keywords: ["chinese", "kanji", "japanese", "red-circle"],
      char: "\u3297\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    u5408: {
      keywords: ["japanese", "chinese", "join", "kanji", "red-square"],
      char: "\uD83C\uDE34",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    u6e80: {
      keywords: ["full", "chinese", "japanese", "red-square", "kanji"],
      char: "\uD83C\uDE35",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    u7981: {
      keywords: ["kanji", "japanese", "chinese", "forbidden", "limit", "restricted", "red-square"],
      char: "\uD83C\uDE32",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    a: {
      keywords: ["red-square", "alphabet", "letter"],
      char: "\uD83C\uDD70\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    b: {
      keywords: ["red-square", "alphabet", "letter"],
      char: "\uD83C\uDD71\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    ab: {
      keywords: ["red-square", "alphabet"],
      char: "\uD83C\uDD8E",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    cl: {
      keywords: ["alphabet", "words", "red-square"],
      char: "\uD83C\uDD91",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    o2: {
      keywords: ["alphabet", "red-square", "letter"],
      char: "\uD83C\uDD7E\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    sos: {
      keywords: ["help", "red-square", "words", "emergency", "911"],
      char: "\uD83C\uDD98",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    no_entry: {
      keywords: ["limit", "security", "privacy", "bad", "denied", "stop", "circle"],
      char: "\u26D4",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    name_badge: {
      keywords: ["fire", "forbid"],
      char: "\uD83D\uDCDB",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    no_entry_sign: {
      keywords: ["forbid", "stop", "limit", "denied", "disallow", "circle"],
      char: "\uD83D\uDEAB",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    x: {
      keywords: ["no", "delete", "remove", "cancel", "red"],
      char: "\u274C",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    o: {
      keywords: ["circle", "round"],
      char: "\u2B55",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    stop_sign: {
      keywords: ["stop"],
      char: "\uD83D\uDED1",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    anger: {
      keywords: ["angry", "mad"],
      char: "\uD83D\uDCA2",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    hotsprings: {
      keywords: ["bath", "warm", "relax"],
      char: "\u2668\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    no_pedestrians: {
      keywords: ["rules", "crossing", "walking", "circle"],
      char: "\uD83D\uDEB7",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    do_not_litter: {
      keywords: ["trash", "bin", "garbage", "circle"],
      char: "\uD83D\uDEAF",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    no_bicycles: {
      keywords: ["cyclist", "prohibited", "circle"],
      char: "\uD83D\uDEB3",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    "non-potable_water": {
      keywords: ["drink", "faucet", "tap", "circle"],
      char: "\uD83D\uDEB1",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    underage: {
      keywords: ["18", "drink", "pub", "night", "minor", "circle"],
      char: "\uD83D\uDD1E",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    no_mobile_phones: {
      keywords: ["iphone", "mute", "circle"],
      char: "\uD83D\uDCF5",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    exclamation: {
      keywords: ["heavy_exclamation_mark", "danger", "surprise", "punctuation", "wow", "warning"],
      char: "\u2757",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    grey_exclamation: {
      keywords: ["surprise", "punctuation", "gray", "wow", "warning"],
      char: "\u2755",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    question: {
      keywords: ["doubt", "confused"],
      char: "\u2753",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    grey_question: {
      keywords: ["doubts", "gray", "huh", "confused"],
      char: "\u2754",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    bangbang: {
      keywords: ["exclamation", "surprise"],
      char: "\u203C\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    interrobang: {
      keywords: ["wat", "punctuation", "surprise"],
      char: "\u2049\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    "100": {
      keywords: ["score", "perfect", "numbers", "century", "exam", "quiz", "test", "pass", "hundred"],
      char: "\uD83D\uDCAF",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    low_brightness: {
      keywords: ["sun", "afternoon", "warm", "summer"],
      char: "\uD83D\uDD05",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    high_brightness: {
      keywords: ["sun", "light"],
      char: "\uD83D\uDD06",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    trident: {
      keywords: ["weapon", "spear"],
      char: "\uD83D\uDD31",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    fleur_de_lis: {
      keywords: ["decorative", "scout"],
      char: "\u269C",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    part_alternation_mark: {
      keywords: ["graph", "presentation", "stats", "business", "economics", "bad"],
      char: "\u303D\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    warning: {
      keywords: ["exclamation", "wip", "alert", "error", "problem", "issue"],
      char: "\u26A0\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    children_crossing: {
      keywords: ["school", "warning", "danger", "sign", "driving", "yellow-diamond"],
      char: "\uD83D\uDEB8",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    beginner: {
      keywords: ["badge", "shield"],
      char: "\uD83D\uDD30",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    recycle: {
      keywords: ["arrow", "environment", "garbage", "trash"],
      char: "\u267B\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    u6307: {
      keywords: ["chinese", "point", "green-square", "kanji"],
      char: "\uD83C\uDE2F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    chart: {
      keywords: ["green-square", "graph", "presentation", "stats"],
      char: "\uD83D\uDCB9",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    sparkle: {
      keywords: ["stars", "green-square", "awesome", "good", "fireworks"],
      char: "\u2747\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    eight_spoked_asterisk: {
      keywords: ["star", "sparkle", "green-square"],
      char: "\u2733\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    negative_squared_cross_mark: {
      keywords: ["x", "green-square", "no", "deny"],
      char: "\u274E",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    white_check_mark: {
      keywords: ["green-square", "ok", "agree", "vote", "election", "answer", "tick"],
      char: "\u2705",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    diamond_shape_with_a_dot_inside: {
      keywords: ["jewel", "blue", "gem", "crystal", "fancy"],
      char: "\uD83D\uDCA0",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    cyclone: {
      keywords: ["weather", "swirl", "blue", "cloud", "vortex", "spiral", "whirlpool", "spin", "tornado", "hurricane", "typhoon"],
      char: "\uD83C\uDF00",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    loop: {
      keywords: ["tape", "cassette"],
      char: "\u27BF",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    globe_with_meridians: {
      keywords: ["earth", "international", "world", "internet", "interweb", "i18n"],
      char: "\uD83C\uDF10",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    m: {
      keywords: ["alphabet", "blue-circle", "letter"],
      char: "\u24C2\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    atm: {
      keywords: ["money", "sales", "cash", "blue-square", "payment", "bank"],
      char: "\uD83C\uDFE7",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    sa: {
      keywords: ["japanese", "blue-square", "katakana"],
      char: "\uD83C\uDE02\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    passport_control: {
      keywords: ["custom", "blue-square"],
      char: "\uD83D\uDEC2",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    customs: {
      keywords: ["passport", "border", "blue-square"],
      char: "\uD83D\uDEC3",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    baggage_claim: {
      keywords: ["blue-square", "airport", "transport"],
      char: "\uD83D\uDEC4",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    left_luggage: {
      keywords: ["blue-square", "travel"],
      char: "\uD83D\uDEC5",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    wheelchair: {
      keywords: ["blue-square", "disabled", "a11y", "accessibility"],
      char: "\u267F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    no_smoking: {
      keywords: ["cigarette", "blue-square", "smell", "smoke"],
      char: "\uD83D\uDEAD",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    wc: {
      keywords: ["toilet", "restroom", "blue-square"],
      char: "\uD83D\uDEBE",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    parking: {
      keywords: ["cars", "blue-square", "alphabet", "letter"],
      char: "\uD83C\uDD7F\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    potable_water: {
      keywords: ["blue-square", "liquid", "restroom", "cleaning", "faucet"],
      char: "\uD83D\uDEB0",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    mens: {
      keywords: ["toilet", "restroom", "wc", "blue-square", "gender", "male"],
      char: "\uD83D\uDEB9",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    womens: {
      keywords: ["purple-square", "woman", "female", "toilet", "loo", "restroom", "gender"],
      char: "\uD83D\uDEBA",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    baby_symbol: {
      keywords: ["orange-square", "child"],
      char: "\uD83D\uDEBC",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    restroom: {
      keywords: ["blue-square", "toilet", "refresh", "wc", "gender"],
      char: "\uD83D\uDEBB",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    put_litter_in_its_place: {
      keywords: ["blue-square", "sign", "human", "info"],
      char: "\uD83D\uDEAE",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    cinema: {
      keywords: ["blue-square", "record", "film", "movie", "curtain", "stage", "theater"],
      char: "\uD83C\uDFA6",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    signal_strength: {
      keywords: ["blue-square", "reception", "phone", "internet", "connection", "wifi", "bluetooth", "bars"],
      char: "\uD83D\uDCF6",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    koko: {
      keywords: ["blue-square", "here", "katakana", "japanese", "destination"],
      char: "\uD83C\uDE01",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    ng: {
      keywords: ["blue-square", "words", "shape", "icon"],
      char: "\uD83C\uDD96",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    ok: {
      keywords: ["good", "agree", "yes", "blue-square"],
      char: "\uD83C\uDD97",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    up: {
      keywords: ["blue-square", "above", "high"],
      char: "\uD83C\uDD99",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    cool: {
      keywords: ["words", "blue-square"],
      char: "\uD83C\uDD92",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    new: {
      keywords: ["blue-square", "words", "start"],
      char: "\uD83C\uDD95",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    free: {
      keywords: ["blue-square", "words"],
      char: "\uD83C\uDD93",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    zero: {
      keywords: ["0", "numbers", "blue-square", "null"],
      char: "0\uFE0F\u20E3",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    one: {
      keywords: ["blue-square", "numbers", "1"],
      char: "1\uFE0F\u20E3",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    two: {
      keywords: ["numbers", "2", "prime", "blue-square"],
      char: "2\uFE0F\u20E3",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    three: {
      keywords: ["3", "numbers", "prime", "blue-square"],
      char: "3\uFE0F\u20E3",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    four: {
      keywords: ["4", "numbers", "blue-square"],
      char: "4\uFE0F\u20E3",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    five: {
      keywords: ["5", "numbers", "blue-square", "prime"],
      char: "5\uFE0F\u20E3",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    six: {
      keywords: ["6", "numbers", "blue-square"],
      char: "6\uFE0F\u20E3",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    seven: {
      keywords: ["7", "numbers", "blue-square", "prime"],
      char: "7\uFE0F\u20E3",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    eight: {
      keywords: ["8", "blue-square", "numbers"],
      char: "8\uFE0F\u20E3",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    nine: {
      keywords: ["blue-square", "numbers", "9"],
      char: "9\uFE0F\u20E3",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    keycap_ten: {
      keywords: ["numbers", "10", "blue-square"],
      char: "\uD83D\uDD1F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    asterisk: {
      keywords: ["star", "keycap"],
      char: "*\u20E3",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    "1234": {
      keywords: ["numbers", "blue-square"],
      char: "\uD83D\uDD22",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    eject_button: {
      keywords: ["blue-square"],
      char: "\u23CF\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    arrow_forward: {
      keywords: ["blue-square", "right", "direction", "play"],
      char: "\u25B6\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    pause_button: {
      keywords: ["pause", "blue-square"],
      char: "\u23F8",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    next_track_button: {
      keywords: ["forward", "next", "blue-square"],
      char: "\u23ED",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    stop_button: {
      keywords: ["blue-square"],
      char: "\u23F9",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    record_button: {
      keywords: ["blue-square"],
      char: "\u23FA",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    play_or_pause_button: {
      keywords: ["blue-square", "play", "pause"],
      char: "\u23EF",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    previous_track_button: {
      keywords: ["backward"],
      char: "\u23EE",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    fast_forward: {
      keywords: ["blue-square", "play", "speed", "continue"],
      char: "\u23E9",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    rewind: {
      keywords: ["play", "blue-square"],
      char: "\u23EA",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    twisted_rightwards_arrows: {
      keywords: ["blue-square", "shuffle", "music", "random"],
      char: "\uD83D\uDD00",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    repeat: {
      keywords: ["loop", "record"],
      char: "\uD83D\uDD01",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    repeat_one: {
      keywords: ["blue-square", "loop"],
      char: "\uD83D\uDD02",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    arrow_backward: {
      keywords: ["blue-square", "left", "direction"],
      char: "\u25C0\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    arrow_up_small: {
      keywords: ["blue-square", "triangle", "direction", "point", "forward", "top"],
      char: "\uD83D\uDD3C",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    arrow_down_small: {
      keywords: ["blue-square", "direction", "bottom"],
      char: "\uD83D\uDD3D",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    arrow_double_up: {
      keywords: ["blue-square", "direction", "top"],
      char: "\u23EB",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    arrow_double_down: {
      keywords: ["blue-square", "direction", "bottom"],
      char: "\u23EC",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    arrow_right: {
      keywords: ["blue-square", "next"],
      char: "\u27A1\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    arrow_left: {
      keywords: ["blue-square", "previous", "back"],
      char: "\u2B05\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    arrow_up: {
      keywords: ["blue-square", "continue", "top", "direction"],
      char: "\u2B06\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    arrow_down: {
      keywords: ["blue-square", "direction", "bottom"],
      char: "\u2B07\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    arrow_upper_right: {
      keywords: ["blue-square", "point", "direction", "diagonal", "northeast"],
      char: "\u2197\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    arrow_lower_right: {
      keywords: ["blue-square", "direction", "diagonal", "southeast"],
      char: "\u2198\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    arrow_lower_left: {
      keywords: ["blue-square", "direction", "diagonal", "southwest"],
      char: "\u2199\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    arrow_upper_left: {
      keywords: ["blue-square", "point", "direction", "diagonal", "northwest"],
      char: "\u2196\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    arrow_up_down: {
      keywords: ["blue-square", "direction", "way", "vertical"],
      char: "\u2195\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    left_right_arrow: {
      keywords: ["shape", "direction", "horizontal", "sideways"],
      char: "\u2194\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    arrows_counterclockwise: {
      keywords: ["blue-square", "sync", "cycle"],
      char: "\uD83D\uDD04",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    arrow_right_hook: {
      keywords: ["blue-square", "return", "rotate", "direction"],
      char: "\u21AA\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    leftwards_arrow_with_hook: {
      keywords: ["back", "return", "blue-square", "undo", "enter"],
      char: "\u21A9\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    arrow_heading_up: {
      keywords: ["blue-square", "direction", "top"],
      char: "\u2934\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    arrow_heading_down: {
      keywords: ["blue-square", "direction", "bottom"],
      char: "\u2935\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    hash: {
      keywords: ["symbol", "blue-square", "twitter"],
      char: "#\uFE0F\u20E3",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    information_source: {
      keywords: ["blue-square", "alphabet", "letter"],
      char: "\u2139\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    abc: {
      keywords: ["blue-square", "alphabet"],
      char: "\uD83D\uDD24",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    abcd: {
      keywords: ["blue-square", "alphabet"],
      char: "\uD83D\uDD21",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    capital_abcd: {
      keywords: ["alphabet", "words", "blue-square"],
      char: "\uD83D\uDD20",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    symbols: {
      keywords: ["blue-square", "music", "note", "ampersand", "percent", "glyphs", "characters"],
      char: "\uD83D\uDD23",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    musical_note: {
      keywords: ["score", "tone", "sound"],
      char: "\uD83C\uDFB5",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    notes: {
      keywords: ["music", "score"],
      char: "\uD83C\uDFB6",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    wavy_dash: {
      keywords: ["draw", "line", "moustache", "mustache", "squiggle", "scribble"],
      char: "\u3030\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    curly_loop: {
      keywords: ["scribble", "draw", "shape", "squiggle"],
      char: "\u27B0",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    heavy_check_mark: {
      keywords: ["ok", "nike", "answer", "yes", "tick"],
      char: "\u2714\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    arrows_clockwise: {
      keywords: ["sync", "cycle", "round", "repeat"],
      char: "\uD83D\uDD03",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    heavy_plus_sign: {
      keywords: ["math", "calculation", "addition", "more", "increase"],
      char: "\u2795",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    heavy_minus_sign: {
      keywords: ["math", "calculation", "subtract", "less"],
      char: "\u2796",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    heavy_division_sign: {
      keywords: ["divide", "math", "calculation"],
      char: "\u2797",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    heavy_multiplication_x: {
      keywords: ["math", "calculation"],
      char: "\u2716\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    infinity: {
      keywords: ["forever"],
      char: "\u267E",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    heavy_dollar_sign: {
      keywords: ["money", "sales", "payment", "currency", "buck"],
      char: "\uD83D\uDCB2",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    currency_exchange: {
      keywords: ["money", "sales", "dollar", "travel"],
      char: "\uD83D\uDCB1",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    copyright: {
      keywords: ["ip", "license", "circle", "law", "legal"],
      char: "\xA9\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    registered: {
      keywords: ["alphabet", "circle"],
      char: "\xAE\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    tm: {
      keywords: ["trademark", "brand", "law", "legal"],
      char: "\u2122\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    end: {
      keywords: ["words", "arrow"],
      char: "\uD83D\uDD1A",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    back: {
      keywords: ["arrow", "words", "return"],
      char: "\uD83D\uDD19",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    on: {
      keywords: ["arrow", "words"],
      char: "\uD83D\uDD1B",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    top: {
      keywords: ["words", "blue-square"],
      char: "\uD83D\uDD1D",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    soon: {
      keywords: ["arrow", "words"],
      char: "\uD83D\uDD1C",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    ballot_box_with_check: {
      keywords: ["ok", "agree", "confirm", "black-square", "vote", "election", "yes", "tick"],
      char: "\u2611\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    radio_button: {
      keywords: ["input", "old", "music", "circle"],
      char: "\uD83D\uDD18",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    white_circle: {
      keywords: ["shape", "round"],
      char: "\u26AA",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    black_circle: {
      keywords: ["shape", "button", "round"],
      char: "\u26AB",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    red_circle: {
      keywords: ["shape", "error", "danger"],
      char: "\uD83D\uDD34",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    large_blue_circle: {
      keywords: ["shape", "icon", "button"],
      char: "\uD83D\uDD35",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    small_orange_diamond: {
      keywords: ["shape", "jewel", "gem"],
      char: "\uD83D\uDD38",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    small_blue_diamond: {
      keywords: ["shape", "jewel", "gem"],
      char: "\uD83D\uDD39",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    large_orange_diamond: {
      keywords: ["shape", "jewel", "gem"],
      char: "\uD83D\uDD36",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    large_blue_diamond: {
      keywords: ["shape", "jewel", "gem"],
      char: "\uD83D\uDD37",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    small_red_triangle: {
      keywords: ["shape", "direction", "up", "top"],
      char: "\uD83D\uDD3A",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    black_small_square: {
      keywords: ["shape", "icon"],
      char: "\u25AA\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    white_small_square: {
      keywords: ["shape", "icon"],
      char: "\u25AB\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    black_large_square: {
      keywords: ["shape", "icon", "button"],
      char: "\u2B1B",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    white_large_square: {
      keywords: ["shape", "icon", "stone", "button"],
      char: "\u2B1C",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    small_red_triangle_down: {
      keywords: ["shape", "direction", "bottom"],
      char: "\uD83D\uDD3B",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    black_medium_square: {
      keywords: ["shape", "button", "icon"],
      char: "\u25FC\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    white_medium_square: {
      keywords: ["shape", "stone", "icon"],
      char: "\u25FB\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    black_medium_small_square: {
      keywords: ["icon", "shape", "button"],
      char: "\u25FE",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    white_medium_small_square: {
      keywords: ["shape", "stone", "icon", "button"],
      char: "\u25FD",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    black_square_button: {
      keywords: ["shape", "input", "frame"],
      char: "\uD83D\uDD32",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    white_square_button: {
      keywords: ["shape", "input"],
      char: "\uD83D\uDD33",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    speaker: {
      keywords: ["sound", "volume", "silence", "broadcast"],
      char: "\uD83D\uDD08",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    sound: {
      keywords: ["volume", "speaker", "broadcast"],
      char: "\uD83D\uDD09",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    loud_sound: {
      keywords: ["volume", "noise", "noisy", "speaker", "broadcast"],
      char: "\uD83D\uDD0A",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    mute: {
      keywords: ["sound", "volume", "silence", "quiet"],
      char: "\uD83D\uDD07",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    mega: {
      keywords: ["sound", "speaker", "volume"],
      char: "\uD83D\uDCE3",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    loudspeaker: {
      keywords: ["volume", "sound"],
      char: "\uD83D\uDCE2",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    bell: {
      keywords: ["sound", "notification", "christmas", "xmas", "chime"],
      char: "\uD83D\uDD14",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    no_bell: {
      keywords: ["sound", "volume", "mute", "quiet", "silent"],
      char: "\uD83D\uDD15",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    black_joker: {
      keywords: ["poker", "cards", "game", "play", "magic"],
      char: "\uD83C\uDCCF",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    mahjong: {
      keywords: ["game", "play", "chinese", "kanji"],
      char: "\uD83C\uDC04",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    spades: {
      keywords: ["poker", "cards", "suits", "magic"],
      char: "\u2660\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clubs: {
      keywords: ["poker", "cards", "magic", "suits"],
      char: "\u2663\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    hearts: {
      keywords: ["poker", "cards", "magic", "suits"],
      char: "\u2665\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    diamonds: {
      keywords: ["poker", "cards", "magic", "suits"],
      char: "\u2666\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    flower_playing_cards: {
      keywords: ["game", "sunset", "red"],
      char: "\uD83C\uDFB4",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    thought_balloon: {
      keywords: ["bubble", "cloud", "speech", "thinking", "dream"],
      char: "\uD83D\uDCAD",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    right_anger_bubble: {
      keywords: ["caption", "speech", "thinking", "mad"],
      char: "\uD83D\uDDEF",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    speech_balloon: {
      keywords: ["bubble", "words", "message", "talk", "chatting"],
      char: "\uD83D\uDCAC",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    left_speech_bubble: {
      keywords: ["words", "message", "talk", "chatting"],
      char: "\uD83D\uDDE8",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock1: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD50",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock2: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD51",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock3: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD52",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock4: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD53",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock5: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD54",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock6: {
      keywords: ["time", "late", "early", "schedule", "dawn", "dusk"],
      char: "\uD83D\uDD55",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock7: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD56",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock8: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD57",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock9: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD58",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock10: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD59",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock11: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD5A",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock12: {
      keywords: ["time", "noon", "midnight", "midday", "late", "early", "schedule"],
      char: "\uD83D\uDD5B",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock130: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD5C",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock230: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD5D",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock330: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD5E",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock430: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD5F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock530: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD60",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock630: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD61",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock730: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD62",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock830: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD63",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock930: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD64",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock1030: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD65",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock1130: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD66",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock1230: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD67",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    afghanistan: {
      keywords: ["af", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE6\uD83C\uDDEB",
      fitzpatrick_scale: false,
      category: "flags"
    },
    aland_islands: {
      keywords: ["\xC5land", "islands", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE6\uD83C\uDDFD",
      fitzpatrick_scale: false,
      category: "flags"
    },
    albania: {
      keywords: ["al", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE6\uD83C\uDDF1",
      fitzpatrick_scale: false,
      category: "flags"
    },
    algeria: {
      keywords: ["dz", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE9\uD83C\uDDFF",
      fitzpatrick_scale: false,
      category: "flags"
    },
    american_samoa: {
      keywords: ["american", "ws", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE6\uD83C\uDDF8",
      fitzpatrick_scale: false,
      category: "flags"
    },
    andorra: {
      keywords: ["ad", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE6\uD83C\uDDE9",
      fitzpatrick_scale: false,
      category: "flags"
    },
    angola: {
      keywords: ["ao", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE6\uD83C\uDDF4",
      fitzpatrick_scale: false,
      category: "flags"
    },
    anguilla: {
      keywords: ["ai", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE6\uD83C\uDDEE",
      fitzpatrick_scale: false,
      category: "flags"
    },
    antarctica: {
      keywords: ["aq", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE6\uD83C\uDDF6",
      fitzpatrick_scale: false,
      category: "flags"
    },
    antigua_barbuda: {
      keywords: ["antigua", "barbuda", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE6\uD83C\uDDEC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    argentina: {
      keywords: ["ar", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE6\uD83C\uDDF7",
      fitzpatrick_scale: false,
      category: "flags"
    },
    armenia: {
      keywords: ["am", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE6\uD83C\uDDF2",
      fitzpatrick_scale: false,
      category: "flags"
    },
    aruba: {
      keywords: ["aw", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE6\uD83C\uDDFC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    australia: {
      keywords: ["au", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE6\uD83C\uDDFA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    austria: {
      keywords: ["at", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE6\uD83C\uDDF9",
      fitzpatrick_scale: false,
      category: "flags"
    },
    azerbaijan: {
      keywords: ["az", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE6\uD83C\uDDFF",
      fitzpatrick_scale: false,
      category: "flags"
    },
    bahamas: {
      keywords: ["bs", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE7\uD83C\uDDF8",
      fitzpatrick_scale: false,
      category: "flags"
    },
    bahrain: {
      keywords: ["bh", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE7\uD83C\uDDED",
      fitzpatrick_scale: false,
      category: "flags"
    },
    bangladesh: {
      keywords: ["bd", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE7\uD83C\uDDE9",
      fitzpatrick_scale: false,
      category: "flags"
    },
    barbados: {
      keywords: ["bb", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE7\uD83C\uDDE7",
      fitzpatrick_scale: false,
      category: "flags"
    },
    belarus: {
      keywords: ["by", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE7\uD83C\uDDFE",
      fitzpatrick_scale: false,
      category: "flags"
    },
    belgium: {
      keywords: ["be", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE7\uD83C\uDDEA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    belize: {
      keywords: ["bz", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE7\uD83C\uDDFF",
      fitzpatrick_scale: false,
      category: "flags"
    },
    benin: {
      keywords: ["bj", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE7\uD83C\uDDEF",
      fitzpatrick_scale: false,
      category: "flags"
    },
    bermuda: {
      keywords: ["bm", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE7\uD83C\uDDF2",
      fitzpatrick_scale: false,
      category: "flags"
    },
    bhutan: {
      keywords: ["bt", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE7\uD83C\uDDF9",
      fitzpatrick_scale: false,
      category: "flags"
    },
    bolivia: {
      keywords: ["bo", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE7\uD83C\uDDF4",
      fitzpatrick_scale: false,
      category: "flags"
    },
    caribbean_netherlands: {
      keywords: ["bonaire", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE7\uD83C\uDDF6",
      fitzpatrick_scale: false,
      category: "flags"
    },
    bosnia_herzegovina: {
      keywords: ["bosnia", "herzegovina", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE7\uD83C\uDDE6",
      fitzpatrick_scale: false,
      category: "flags"
    },
    botswana: {
      keywords: ["bw", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE7\uD83C\uDDFC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    brazil: {
      keywords: ["br", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE7\uD83C\uDDF7",
      fitzpatrick_scale: false,
      category: "flags"
    },
    british_indian_ocean_territory: {
      keywords: ["british", "indian", "ocean", "territory", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEE\uD83C\uDDF4",
      fitzpatrick_scale: false,
      category: "flags"
    },
    british_virgin_islands: {
      keywords: ["british", "virgin", "islands", "bvi", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDFB\uD83C\uDDEC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    brunei: {
      keywords: ["bn", "darussalam", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE7\uD83C\uDDF3",
      fitzpatrick_scale: false,
      category: "flags"
    },
    bulgaria: {
      keywords: ["bg", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE7\uD83C\uDDEC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    burkina_faso: {
      keywords: ["burkina", "faso", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE7\uD83C\uDDEB",
      fitzpatrick_scale: false,
      category: "flags"
    },
    burundi: {
      keywords: ["bi", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE7\uD83C\uDDEE",
      fitzpatrick_scale: false,
      category: "flags"
    },
    cape_verde: {
      keywords: ["cabo", "verde", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE8\uD83C\uDDFB",
      fitzpatrick_scale: false,
      category: "flags"
    },
    cambodia: {
      keywords: ["kh", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF0\uD83C\uDDED",
      fitzpatrick_scale: false,
      category: "flags"
    },
    cameroon: {
      keywords: ["cm", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE8\uD83C\uDDF2",
      fitzpatrick_scale: false,
      category: "flags"
    },
    canada: {
      keywords: ["ca", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE8\uD83C\uDDE6",
      fitzpatrick_scale: false,
      category: "flags"
    },
    canary_islands: {
      keywords: ["canary", "islands", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEE\uD83C\uDDE8",
      fitzpatrick_scale: false,
      category: "flags"
    },
    cayman_islands: {
      keywords: ["cayman", "islands", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF0\uD83C\uDDFE",
      fitzpatrick_scale: false,
      category: "flags"
    },
    central_african_republic: {
      keywords: ["central", "african", "republic", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE8\uD83C\uDDEB",
      fitzpatrick_scale: false,
      category: "flags"
    },
    chad: {
      keywords: ["td", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF9\uD83C\uDDE9",
      fitzpatrick_scale: false,
      category: "flags"
    },
    chile: {
      keywords: ["flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE8\uD83C\uDDF1",
      fitzpatrick_scale: false,
      category: "flags"
    },
    cn: {
      keywords: ["china", "chinese", "prc", "flag", "country", "nation", "banner"],
      char: "\uD83C\uDDE8\uD83C\uDDF3",
      fitzpatrick_scale: false,
      category: "flags"
    },
    christmas_island: {
      keywords: ["christmas", "island", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE8\uD83C\uDDFD",
      fitzpatrick_scale: false,
      category: "flags"
    },
    cocos_islands: {
      keywords: ["cocos", "keeling", "islands", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE8\uD83C\uDDE8",
      fitzpatrick_scale: false,
      category: "flags"
    },
    colombia: {
      keywords: ["co", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE8\uD83C\uDDF4",
      fitzpatrick_scale: false,
      category: "flags"
    },
    comoros: {
      keywords: ["km", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF0\uD83C\uDDF2",
      fitzpatrick_scale: false,
      category: "flags"
    },
    congo_brazzaville: {
      keywords: ["congo", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE8\uD83C\uDDEC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    congo_kinshasa: {
      keywords: ["congo", "democratic", "republic", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE8\uD83C\uDDE9",
      fitzpatrick_scale: false,
      category: "flags"
    },
    cook_islands: {
      keywords: ["cook", "islands", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE8\uD83C\uDDF0",
      fitzpatrick_scale: false,
      category: "flags"
    },
    costa_rica: {
      keywords: ["costa", "rica", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE8\uD83C\uDDF7",
      fitzpatrick_scale: false,
      category: "flags"
    },
    croatia: {
      keywords: ["hr", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDED\uD83C\uDDF7",
      fitzpatrick_scale: false,
      category: "flags"
    },
    cuba: {
      keywords: ["cu", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE8\uD83C\uDDFA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    curacao: {
      keywords: ["cura\xE7ao", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE8\uD83C\uDDFC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    cyprus: {
      keywords: ["cy", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE8\uD83C\uDDFE",
      fitzpatrick_scale: false,
      category: "flags"
    },
    czech_republic: {
      keywords: ["cz", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE8\uD83C\uDDFF",
      fitzpatrick_scale: false,
      category: "flags"
    },
    denmark: {
      keywords: ["dk", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE9\uD83C\uDDF0",
      fitzpatrick_scale: false,
      category: "flags"
    },
    djibouti: {
      keywords: ["dj", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE9\uD83C\uDDEF",
      fitzpatrick_scale: false,
      category: "flags"
    },
    dominica: {
      keywords: ["dm", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE9\uD83C\uDDF2",
      fitzpatrick_scale: false,
      category: "flags"
    },
    dominican_republic: {
      keywords: ["dominican", "republic", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE9\uD83C\uDDF4",
      fitzpatrick_scale: false,
      category: "flags"
    },
    ecuador: {
      keywords: ["ec", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEA\uD83C\uDDE8",
      fitzpatrick_scale: false,
      category: "flags"
    },
    egypt: {
      keywords: ["eg", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEA\uD83C\uDDEC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    el_salvador: {
      keywords: ["el", "salvador", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF8\uD83C\uDDFB",
      fitzpatrick_scale: false,
      category: "flags"
    },
    equatorial_guinea: {
      keywords: ["equatorial", "gn", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEC\uD83C\uDDF6",
      fitzpatrick_scale: false,
      category: "flags"
    },
    eritrea: {
      keywords: ["er", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEA\uD83C\uDDF7",
      fitzpatrick_scale: false,
      category: "flags"
    },
    estonia: {
      keywords: ["ee", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEA\uD83C\uDDEA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    ethiopia: {
      keywords: ["et", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEA\uD83C\uDDF9",
      fitzpatrick_scale: false,
      category: "flags"
    },
    eu: {
      keywords: ["european", "union", "flag", "banner"],
      char: "\uD83C\uDDEA\uD83C\uDDFA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    falkland_islands: {
      keywords: ["falkland", "islands", "malvinas", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEB\uD83C\uDDF0",
      fitzpatrick_scale: false,
      category: "flags"
    },
    faroe_islands: {
      keywords: ["faroe", "islands", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEB\uD83C\uDDF4",
      fitzpatrick_scale: false,
      category: "flags"
    },
    fiji: {
      keywords: ["fj", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEB\uD83C\uDDEF",
      fitzpatrick_scale: false,
      category: "flags"
    },
    finland: {
      keywords: ["fi", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEB\uD83C\uDDEE",
      fitzpatrick_scale: false,
      category: "flags"
    },
    fr: {
      keywords: ["banner", "flag", "nation", "france", "french", "country"],
      char: "\uD83C\uDDEB\uD83C\uDDF7",
      fitzpatrick_scale: false,
      category: "flags"
    },
    french_guiana: {
      keywords: ["french", "guiana", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEC\uD83C\uDDEB",
      fitzpatrick_scale: false,
      category: "flags"
    },
    french_polynesia: {
      keywords: ["french", "polynesia", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF5\uD83C\uDDEB",
      fitzpatrick_scale: false,
      category: "flags"
    },
    french_southern_territories: {
      keywords: ["french", "southern", "territories", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF9\uD83C\uDDEB",
      fitzpatrick_scale: false,
      category: "flags"
    },
    gabon: {
      keywords: ["ga", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEC\uD83C\uDDE6",
      fitzpatrick_scale: false,
      category: "flags"
    },
    gambia: {
      keywords: ["gm", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEC\uD83C\uDDF2",
      fitzpatrick_scale: false,
      category: "flags"
    },
    georgia: {
      keywords: ["ge", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEC\uD83C\uDDEA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    de: {
      keywords: ["german", "nation", "flag", "country", "banner"],
      char: "\uD83C\uDDE9\uD83C\uDDEA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    ghana: {
      keywords: ["gh", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEC\uD83C\uDDED",
      fitzpatrick_scale: false,
      category: "flags"
    },
    gibraltar: {
      keywords: ["gi", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEC\uD83C\uDDEE",
      fitzpatrick_scale: false,
      category: "flags"
    },
    greece: {
      keywords: ["gr", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEC\uD83C\uDDF7",
      fitzpatrick_scale: false,
      category: "flags"
    },
    greenland: {
      keywords: ["gl", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEC\uD83C\uDDF1",
      fitzpatrick_scale: false,
      category: "flags"
    },
    grenada: {
      keywords: ["gd", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEC\uD83C\uDDE9",
      fitzpatrick_scale: false,
      category: "flags"
    },
    guadeloupe: {
      keywords: ["gp", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEC\uD83C\uDDF5",
      fitzpatrick_scale: false,
      category: "flags"
    },
    guam: {
      keywords: ["gu", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEC\uD83C\uDDFA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    guatemala: {
      keywords: ["gt", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEC\uD83C\uDDF9",
      fitzpatrick_scale: false,
      category: "flags"
    },
    guernsey: {
      keywords: ["gg", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEC\uD83C\uDDEC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    guinea: {
      keywords: ["gn", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEC\uD83C\uDDF3",
      fitzpatrick_scale: false,
      category: "flags"
    },
    guinea_bissau: {
      keywords: ["gw", "bissau", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEC\uD83C\uDDFC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    guyana: {
      keywords: ["gy", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEC\uD83C\uDDFE",
      fitzpatrick_scale: false,
      category: "flags"
    },
    haiti: {
      keywords: ["ht", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDED\uD83C\uDDF9",
      fitzpatrick_scale: false,
      category: "flags"
    },
    honduras: {
      keywords: ["hn", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDED\uD83C\uDDF3",
      fitzpatrick_scale: false,
      category: "flags"
    },
    hong_kong: {
      keywords: ["hong", "kong", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDED\uD83C\uDDF0",
      fitzpatrick_scale: false,
      category: "flags"
    },
    hungary: {
      keywords: ["hu", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDED\uD83C\uDDFA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    iceland: {
      keywords: ["is", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEE\uD83C\uDDF8",
      fitzpatrick_scale: false,
      category: "flags"
    },
    india: {
      keywords: ["in", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEE\uD83C\uDDF3",
      fitzpatrick_scale: false,
      category: "flags"
    },
    indonesia: {
      keywords: ["flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEE\uD83C\uDDE9",
      fitzpatrick_scale: false,
      category: "flags"
    },
    iran: {
      keywords: ["iran,", "islamic", "republic", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEE\uD83C\uDDF7",
      fitzpatrick_scale: false,
      category: "flags"
    },
    iraq: {
      keywords: ["iq", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEE\uD83C\uDDF6",
      fitzpatrick_scale: false,
      category: "flags"
    },
    ireland: {
      keywords: ["ie", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEE\uD83C\uDDEA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    isle_of_man: {
      keywords: ["isle", "man", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEE\uD83C\uDDF2",
      fitzpatrick_scale: false,
      category: "flags"
    },
    israel: {
      keywords: ["il", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEE\uD83C\uDDF1",
      fitzpatrick_scale: false,
      category: "flags"
    },
    it: {
      keywords: ["italy", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEE\uD83C\uDDF9",
      fitzpatrick_scale: false,
      category: "flags"
    },
    cote_divoire: {
      keywords: ["ivory", "coast", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE8\uD83C\uDDEE",
      fitzpatrick_scale: false,
      category: "flags"
    },
    jamaica: {
      keywords: ["jm", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEF\uD83C\uDDF2",
      fitzpatrick_scale: false,
      category: "flags"
    },
    jp: {
      keywords: ["japanese", "nation", "flag", "country", "banner"],
      char: "\uD83C\uDDEF\uD83C\uDDF5",
      fitzpatrick_scale: false,
      category: "flags"
    },
    jersey: {
      keywords: ["je", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEF\uD83C\uDDEA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    jordan: {
      keywords: ["jo", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEF\uD83C\uDDF4",
      fitzpatrick_scale: false,
      category: "flags"
    },
    kazakhstan: {
      keywords: ["kz", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF0\uD83C\uDDFF",
      fitzpatrick_scale: false,
      category: "flags"
    },
    kenya: {
      keywords: ["ke", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF0\uD83C\uDDEA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    kiribati: {
      keywords: ["ki", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF0\uD83C\uDDEE",
      fitzpatrick_scale: false,
      category: "flags"
    },
    kosovo: {
      keywords: ["xk", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDFD\uD83C\uDDF0",
      fitzpatrick_scale: false,
      category: "flags"
    },
    kuwait: {
      keywords: ["kw", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF0\uD83C\uDDFC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    kyrgyzstan: {
      keywords: ["kg", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF0\uD83C\uDDEC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    laos: {
      keywords: ["lao", "democratic", "republic", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF1\uD83C\uDDE6",
      fitzpatrick_scale: false,
      category: "flags"
    },
    latvia: {
      keywords: ["lv", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF1\uD83C\uDDFB",
      fitzpatrick_scale: false,
      category: "flags"
    },
    lebanon: {
      keywords: ["lb", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF1\uD83C\uDDE7",
      fitzpatrick_scale: false,
      category: "flags"
    },
    lesotho: {
      keywords: ["ls", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF1\uD83C\uDDF8",
      fitzpatrick_scale: false,
      category: "flags"
    },
    liberia: {
      keywords: ["lr", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF1\uD83C\uDDF7",
      fitzpatrick_scale: false,
      category: "flags"
    },
    libya: {
      keywords: ["ly", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF1\uD83C\uDDFE",
      fitzpatrick_scale: false,
      category: "flags"
    },
    liechtenstein: {
      keywords: ["li", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF1\uD83C\uDDEE",
      fitzpatrick_scale: false,
      category: "flags"
    },
    lithuania: {
      keywords: ["lt", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF1\uD83C\uDDF9",
      fitzpatrick_scale: false,
      category: "flags"
    },
    luxembourg: {
      keywords: ["lu", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF1\uD83C\uDDFA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    macau: {
      keywords: ["macao", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDF4",
      fitzpatrick_scale: false,
      category: "flags"
    },
    macedonia: {
      keywords: ["macedonia,", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDF0",
      fitzpatrick_scale: false,
      category: "flags"
    },
    madagascar: {
      keywords: ["mg", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDEC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    malawi: {
      keywords: ["mw", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDFC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    malaysia: {
      keywords: ["my", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDFE",
      fitzpatrick_scale: false,
      category: "flags"
    },
    maldives: {
      keywords: ["mv", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDFB",
      fitzpatrick_scale: false,
      category: "flags"
    },
    mali: {
      keywords: ["ml", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDF1",
      fitzpatrick_scale: false,
      category: "flags"
    },
    malta: {
      keywords: ["mt", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDF9",
      fitzpatrick_scale: false,
      category: "flags"
    },
    marshall_islands: {
      keywords: ["marshall", "islands", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDED",
      fitzpatrick_scale: false,
      category: "flags"
    },
    martinique: {
      keywords: ["mq", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDF6",
      fitzpatrick_scale: false,
      category: "flags"
    },
    mauritania: {
      keywords: ["mr", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDF7",
      fitzpatrick_scale: false,
      category: "flags"
    },
    mauritius: {
      keywords: ["mu", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDFA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    mayotte: {
      keywords: ["yt", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDFE\uD83C\uDDF9",
      fitzpatrick_scale: false,
      category: "flags"
    },
    mexico: {
      keywords: ["mx", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDFD",
      fitzpatrick_scale: false,
      category: "flags"
    },
    micronesia: {
      keywords: ["micronesia,", "federated", "states", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEB\uD83C\uDDF2",
      fitzpatrick_scale: false,
      category: "flags"
    },
    moldova: {
      keywords: ["moldova,", "republic", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDE9",
      fitzpatrick_scale: false,
      category: "flags"
    },
    monaco: {
      keywords: ["mc", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDE8",
      fitzpatrick_scale: false,
      category: "flags"
    },
    mongolia: {
      keywords: ["mn", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDF3",
      fitzpatrick_scale: false,
      category: "flags"
    },
    montenegro: {
      keywords: ["me", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDEA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    montserrat: {
      keywords: ["ms", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDF8",
      fitzpatrick_scale: false,
      category: "flags"
    },
    morocco: {
      keywords: ["ma", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDE6",
      fitzpatrick_scale: false,
      category: "flags"
    },
    mozambique: {
      keywords: ["mz", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDFF",
      fitzpatrick_scale: false,
      category: "flags"
    },
    myanmar: {
      keywords: ["mm", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDF2",
      fitzpatrick_scale: false,
      category: "flags"
    },
    namibia: {
      keywords: ["na", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF3\uD83C\uDDE6",
      fitzpatrick_scale: false,
      category: "flags"
    },
    nauru: {
      keywords: ["nr", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF3\uD83C\uDDF7",
      fitzpatrick_scale: false,
      category: "flags"
    },
    nepal: {
      keywords: ["np", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF3\uD83C\uDDF5",
      fitzpatrick_scale: false,
      category: "flags"
    },
    netherlands: {
      keywords: ["nl", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF3\uD83C\uDDF1",
      fitzpatrick_scale: false,
      category: "flags"
    },
    new_caledonia: {
      keywords: ["new", "caledonia", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF3\uD83C\uDDE8",
      fitzpatrick_scale: false,
      category: "flags"
    },
    new_zealand: {
      keywords: ["new", "zealand", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF3\uD83C\uDDFF",
      fitzpatrick_scale: false,
      category: "flags"
    },
    nicaragua: {
      keywords: ["ni", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF3\uD83C\uDDEE",
      fitzpatrick_scale: false,
      category: "flags"
    },
    niger: {
      keywords: ["ne", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF3\uD83C\uDDEA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    nigeria: {
      keywords: ["flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF3\uD83C\uDDEC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    niue: {
      keywords: ["nu", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF3\uD83C\uDDFA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    norfolk_island: {
      keywords: ["norfolk", "island", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF3\uD83C\uDDEB",
      fitzpatrick_scale: false,
      category: "flags"
    },
    northern_mariana_islands: {
      keywords: ["northern", "mariana", "islands", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDF5",
      fitzpatrick_scale: false,
      category: "flags"
    },
    north_korea: {
      keywords: ["north", "korea", "nation", "flag", "country", "banner"],
      char: "\uD83C\uDDF0\uD83C\uDDF5",
      fitzpatrick_scale: false,
      category: "flags"
    },
    norway: {
      keywords: ["no", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF3\uD83C\uDDF4",
      fitzpatrick_scale: false,
      category: "flags"
    },
    oman: {
      keywords: ["om_symbol", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF4\uD83C\uDDF2",
      fitzpatrick_scale: false,
      category: "flags"
    },
    pakistan: {
      keywords: ["pk", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF5\uD83C\uDDF0",
      fitzpatrick_scale: false,
      category: "flags"
    },
    palau: {
      keywords: ["pw", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF5\uD83C\uDDFC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    palestinian_territories: {
      keywords: ["palestine", "palestinian", "territories", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF5\uD83C\uDDF8",
      fitzpatrick_scale: false,
      category: "flags"
    },
    panama: {
      keywords: ["pa", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF5\uD83C\uDDE6",
      fitzpatrick_scale: false,
      category: "flags"
    },
    papua_new_guinea: {
      keywords: ["papua", "new", "guinea", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF5\uD83C\uDDEC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    paraguay: {
      keywords: ["py", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF5\uD83C\uDDFE",
      fitzpatrick_scale: false,
      category: "flags"
    },
    peru: {
      keywords: ["pe", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF5\uD83C\uDDEA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    philippines: {
      keywords: ["ph", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF5\uD83C\uDDED",
      fitzpatrick_scale: false,
      category: "flags"
    },
    pitcairn_islands: {
      keywords: ["pitcairn", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF5\uD83C\uDDF3",
      fitzpatrick_scale: false,
      category: "flags"
    },
    poland: {
      keywords: ["pl", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF5\uD83C\uDDF1",
      fitzpatrick_scale: false,
      category: "flags"
    },
    portugal: {
      keywords: ["pt", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF5\uD83C\uDDF9",
      fitzpatrick_scale: false,
      category: "flags"
    },
    puerto_rico: {
      keywords: ["puerto", "rico", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF5\uD83C\uDDF7",
      fitzpatrick_scale: false,
      category: "flags"
    },
    qatar: {
      keywords: ["qa", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF6\uD83C\uDDE6",
      fitzpatrick_scale: false,
      category: "flags"
    },
    reunion: {
      keywords: ["r\xE9union", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF7\uD83C\uDDEA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    romania: {
      keywords: ["ro", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF7\uD83C\uDDF4",
      fitzpatrick_scale: false,
      category: "flags"
    },
    ru: {
      keywords: ["russian", "federation", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF7\uD83C\uDDFA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    rwanda: {
      keywords: ["rw", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF7\uD83C\uDDFC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    st_barthelemy: {
      keywords: ["saint", "barth\xE9lemy", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE7\uD83C\uDDF1",
      fitzpatrick_scale: false,
      category: "flags"
    },
    st_helena: {
      keywords: ["saint", "helena", "ascension", "tristan", "cunha", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF8\uD83C\uDDED",
      fitzpatrick_scale: false,
      category: "flags"
    },
    st_kitts_nevis: {
      keywords: ["saint", "kitts", "nevis", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF0\uD83C\uDDF3",
      fitzpatrick_scale: false,
      category: "flags"
    },
    st_lucia: {
      keywords: ["saint", "lucia", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF1\uD83C\uDDE8",
      fitzpatrick_scale: false,
      category: "flags"
    },
    st_pierre_miquelon: {
      keywords: ["saint", "pierre", "miquelon", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF5\uD83C\uDDF2",
      fitzpatrick_scale: false,
      category: "flags"
    },
    st_vincent_grenadines: {
      keywords: ["saint", "vincent", "grenadines", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDFB\uD83C\uDDE8",
      fitzpatrick_scale: false,
      category: "flags"
    },
    samoa: {
      keywords: ["ws", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDFC\uD83C\uDDF8",
      fitzpatrick_scale: false,
      category: "flags"
    },
    san_marino: {
      keywords: ["san", "marino", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF8\uD83C\uDDF2",
      fitzpatrick_scale: false,
      category: "flags"
    },
    sao_tome_principe: {
      keywords: ["sao", "tome", "principe", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF8\uD83C\uDDF9",
      fitzpatrick_scale: false,
      category: "flags"
    },
    saudi_arabia: {
      keywords: ["flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF8\uD83C\uDDE6",
      fitzpatrick_scale: false,
      category: "flags"
    },
    senegal: {
      keywords: ["sn", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF8\uD83C\uDDF3",
      fitzpatrick_scale: false,
      category: "flags"
    },
    serbia: {
      keywords: ["rs", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF7\uD83C\uDDF8",
      fitzpatrick_scale: false,
      category: "flags"
    },
    seychelles: {
      keywords: ["sc", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF8\uD83C\uDDE8",
      fitzpatrick_scale: false,
      category: "flags"
    },
    sierra_leone: {
      keywords: ["sierra", "leone", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF8\uD83C\uDDF1",
      fitzpatrick_scale: false,
      category: "flags"
    },
    singapore: {
      keywords: ["sg", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF8\uD83C\uDDEC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    sint_maarten: {
      keywords: ["sint", "maarten", "dutch", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF8\uD83C\uDDFD",
      fitzpatrick_scale: false,
      category: "flags"
    },
    slovakia: {
      keywords: ["sk", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF8\uD83C\uDDF0",
      fitzpatrick_scale: false,
      category: "flags"
    },
    slovenia: {
      keywords: ["si", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF8\uD83C\uDDEE",
      fitzpatrick_scale: false,
      category: "flags"
    },
    solomon_islands: {
      keywords: ["solomon", "islands", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF8\uD83C\uDDE7",
      fitzpatrick_scale: false,
      category: "flags"
    },
    somalia: {
      keywords: ["so", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF8\uD83C\uDDF4",
      fitzpatrick_scale: false,
      category: "flags"
    },
    south_africa: {
      keywords: ["south", "africa", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDFF\uD83C\uDDE6",
      fitzpatrick_scale: false,
      category: "flags"
    },
    south_georgia_south_sandwich_islands: {
      keywords: ["south", "georgia", "sandwich", "islands", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEC\uD83C\uDDF8",
      fitzpatrick_scale: false,
      category: "flags"
    },
    kr: {
      keywords: ["south", "korea", "nation", "flag", "country", "banner"],
      char: "\uD83C\uDDF0\uD83C\uDDF7",
      fitzpatrick_scale: false,
      category: "flags"
    },
    south_sudan: {
      keywords: ["south", "sd", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF8\uD83C\uDDF8",
      fitzpatrick_scale: false,
      category: "flags"
    },
    es: {
      keywords: ["spain", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEA\uD83C\uDDF8",
      fitzpatrick_scale: false,
      category: "flags"
    },
    sri_lanka: {
      keywords: ["sri", "lanka", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF1\uD83C\uDDF0",
      fitzpatrick_scale: false,
      category: "flags"
    },
    sudan: {
      keywords: ["sd", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF8\uD83C\uDDE9",
      fitzpatrick_scale: false,
      category: "flags"
    },
    suriname: {
      keywords: ["sr", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF8\uD83C\uDDF7",
      fitzpatrick_scale: false,
      category: "flags"
    },
    swaziland: {
      keywords: ["sz", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF8\uD83C\uDDFF",
      fitzpatrick_scale: false,
      category: "flags"
    },
    sweden: {
      keywords: ["se", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF8\uD83C\uDDEA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    switzerland: {
      keywords: ["ch", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE8\uD83C\uDDED",
      fitzpatrick_scale: false,
      category: "flags"
    },
    syria: {
      keywords: ["syrian", "arab", "republic", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF8\uD83C\uDDFE",
      fitzpatrick_scale: false,
      category: "flags"
    },
    taiwan: {
      keywords: ["tw", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF9\uD83C\uDDFC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    tajikistan: {
      keywords: ["tj", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF9\uD83C\uDDEF",
      fitzpatrick_scale: false,
      category: "flags"
    },
    tanzania: {
      keywords: ["tanzania,", "united", "republic", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF9\uD83C\uDDFF",
      fitzpatrick_scale: false,
      category: "flags"
    },
    thailand: {
      keywords: ["th", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF9\uD83C\uDDED",
      fitzpatrick_scale: false,
      category: "flags"
    },
    timor_leste: {
      keywords: ["timor", "leste", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF9\uD83C\uDDF1",
      fitzpatrick_scale: false,
      category: "flags"
    },
    togo: {
      keywords: ["tg", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF9\uD83C\uDDEC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    tokelau: {
      keywords: ["tk", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF9\uD83C\uDDF0",
      fitzpatrick_scale: false,
      category: "flags"
    },
    tonga: {
      keywords: ["to", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF9\uD83C\uDDF4",
      fitzpatrick_scale: false,
      category: "flags"
    },
    trinidad_tobago: {
      keywords: ["trinidad", "tobago", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF9\uD83C\uDDF9",
      fitzpatrick_scale: false,
      category: "flags"
    },
    tunisia: {
      keywords: ["tn", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF9\uD83C\uDDF3",
      fitzpatrick_scale: false,
      category: "flags"
    },
    tr: {
      keywords: ["turkey", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF9\uD83C\uDDF7",
      fitzpatrick_scale: false,
      category: "flags"
    },
    turkmenistan: {
      keywords: ["flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF9\uD83C\uDDF2",
      fitzpatrick_scale: false,
      category: "flags"
    },
    turks_caicos_islands: {
      keywords: ["turks", "caicos", "islands", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF9\uD83C\uDDE8",
      fitzpatrick_scale: false,
      category: "flags"
    },
    tuvalu: {
      keywords: ["flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF9\uD83C\uDDFB",
      fitzpatrick_scale: false,
      category: "flags"
    },
    uganda: {
      keywords: ["ug", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDFA\uD83C\uDDEC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    ukraine: {
      keywords: ["ua", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDFA\uD83C\uDDE6",
      fitzpatrick_scale: false,
      category: "flags"
    },
    united_arab_emirates: {
      keywords: ["united", "arab", "emirates", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE6\uD83C\uDDEA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    uk: {
      keywords: ["united", "kingdom", "great", "britain", "northern", "ireland", "flag", "nation", "country", "banner", "british", "UK", "english", "england", "union jack"],
      char: "\uD83C\uDDEC\uD83C\uDDE7",
      fitzpatrick_scale: false,
      category: "flags"
    },
    england: {
      keywords: ["flag", "english"],
      char: "\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67\uDB40\uDC7F",
      fitzpatrick_scale: false,
      category: "flags"
    },
    scotland: {
      keywords: ["flag", "scottish"],
      char: "\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74\uDB40\uDC7F",
      fitzpatrick_scale: false,
      category: "flags"
    },
    wales: {
      keywords: ["flag", "welsh"],
      char: "\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73\uDB40\uDC7F",
      fitzpatrick_scale: false,
      category: "flags"
    },
    us: {
      keywords: ["united", "states", "america", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDFA\uD83C\uDDF8",
      fitzpatrick_scale: false,
      category: "flags"
    },
    us_virgin_islands: {
      keywords: ["virgin", "islands", "us", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDFB\uD83C\uDDEE",
      fitzpatrick_scale: false,
      category: "flags"
    },
    uruguay: {
      keywords: ["uy", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDFA\uD83C\uDDFE",
      fitzpatrick_scale: false,
      category: "flags"
    },
    uzbekistan: {
      keywords: ["uz", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDFA\uD83C\uDDFF",
      fitzpatrick_scale: false,
      category: "flags"
    },
    vanuatu: {
      keywords: ["vu", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDFB\uD83C\uDDFA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    vatican_city: {
      keywords: ["vatican", "city", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDFB\uD83C\uDDE6",
      fitzpatrick_scale: false,
      category: "flags"
    },
    venezuela: {
      keywords: ["ve", "bolivarian", "republic", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDFB\uD83C\uDDEA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    vietnam: {
      keywords: ["viet", "nam", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDFB\uD83C\uDDF3",
      fitzpatrick_scale: false,
      category: "flags"
    },
    wallis_futuna: {
      keywords: ["wallis", "futuna", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDFC\uD83C\uDDEB",
      fitzpatrick_scale: false,
      category: "flags"
    },
    western_sahara: {
      keywords: ["western", "sahara", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEA\uD83C\uDDED",
      fitzpatrick_scale: false,
      category: "flags"
    },
    yemen: {
      keywords: ["ye", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDFE\uD83C\uDDEA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    zambia: {
      keywords: ["zm", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDFF\uD83C\uDDF2",
      fitzpatrick_scale: false,
      category: "flags"
    },
    zimbabwe: {
      keywords: ["zw", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDFF\uD83C\uDDFC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    united_nations: {
      keywords: ["un", "flag", "banner"],
      char: "\uD83C\uDDFA\uD83C\uDDF3",
      fitzpatrick_scale: false,
      category: "flags"
    },
    pirate_flag: {
      keywords: ["skull", "crossbones", "flag", "banner"],
      char: "\uD83C\uDFF4\u200D\u2620\uFE0F",
      fitzpatrick_scale: false,
      category: "flags"
    }
  };
});

// node_modules/emojilib/ordered.json
var require_ordered = __commonJS((exports, module) => {
  module.exports = [
    "grinning",
    "smiley",
    "smile",
    "grin",
    "laughing",
    "sweat_smile",
    "joy",
    "rofl",
    "relaxed",
    "blush",
    "innocent",
    "slightly_smiling_face",
    "upside_down_face",
    "wink",
    "relieved",
    "heart_eyes",
    "smiling_face_with_three_hearts",
    "kissing_heart",
    "kissing",
    "kissing_smiling_eyes",
    "kissing_closed_eyes",
    "yum",
    "stuck_out_tongue",
    "stuck_out_tongue_closed_eyes",
    "stuck_out_tongue_winking_eye",
    "zany",
    "raised_eyebrow",
    "monocle",
    "nerd_face",
    "sunglasses",
    "star_struck",
    "partying",
    "smirk",
    "unamused",
    "disappointed",
    "pensive",
    "worried",
    "confused",
    "slightly_frowning_face",
    "frowning_face",
    "persevere",
    "confounded",
    "tired_face",
    "weary",
    "pleading",
    "cry",
    "sob",
    "triumph",
    "angry",
    "rage",
    "symbols_over_mouth",
    "exploding_head",
    "flushed",
    "hot",
    "cold",
    "scream",
    "fearful",
    "cold_sweat",
    "disappointed_relieved",
    "sweat",
    "hugs",
    "thinking",
    "hand_over_mouth",
    "shushing",
    "lying_face",
    "no_mouth",
    "neutral_face",
    "expressionless",
    "grimacing",
    "roll_eyes",
    "hushed",
    "frowning",
    "anguished",
    "open_mouth",
    "astonished",
    "sleeping",
    "drooling_face",
    "sleepy",
    "dizzy_face",
    "zipper_mouth_face",
    "woozy",
    "nauseated_face",
    "vomiting",
    "sneezing_face",
    "mask",
    "face_with_thermometer",
    "face_with_head_bandage",
    "money_mouth_face",
    "cowboy_hat_face",
    "smiling_imp",
    "imp",
    "japanese_ogre",
    "japanese_goblin",
    "clown_face",
    "poop",
    "ghost",
    "skull",
    "skull_and_crossbones",
    "alien",
    "space_invader",
    "robot",
    "jack_o_lantern",
    "smiley_cat",
    "smile_cat",
    "joy_cat",
    "heart_eyes_cat",
    "smirk_cat",
    "kissing_cat",
    "scream_cat",
    "crying_cat_face",
    "pouting_cat",
    "palms_up",
    "open_hands",
    "raised_hands",
    "clap",
    "handshake",
    "+1",
    "-1",
    "facepunch",
    "fist",
    "fist_left",
    "fist_right",
    "crossed_fingers",
    "v",
    "love_you",
    "metal",
    "ok_hand",
    "point_left",
    "point_right",
    "point_up",
    "point_down",
    "point_up_2",
    "raised_hand",
    "raised_back_of_hand",
    "raised_hand_with_fingers_splayed",
    "vulcan_salute",
    "wave",
    "call_me_hand",
    "muscle",
    "fu",
    "writing_hand",
    "pray",
    "foot",
    "leg",
    "ring",
    "lipstick",
    "kiss",
    "lips",
    "tooth",
    "tongue",
    "ear",
    "nose",
    "footprints",
    "eye",
    "eyes",
    "brain",
    "speaking_head",
    "bust_in_silhouette",
    "busts_in_silhouette",
    "baby",
    "girl",
    "child",
    "boy",
    "woman",
    "adult",
    "man",
    "blonde_woman",
    "blonde_man",
    "bearded_person",
    "older_woman",
    "older_adult",
    "older_man",
    "man_with_gua_pi_mao",
    "woman_with_headscarf",
    "woman_with_turban",
    "man_with_turban",
    "policewoman",
    "policeman",
    "construction_worker_woman",
    "construction_worker_man",
    "guardswoman",
    "guardsman",
    "female_detective",
    "male_detective",
    "woman_health_worker",
    "man_health_worker",
    "woman_farmer",
    "man_farmer",
    "woman_cook",
    "man_cook",
    "woman_student",
    "man_student",
    "woman_singer",
    "man_singer",
    "woman_teacher",
    "man_teacher",
    "woman_factory_worker",
    "man_factory_worker",
    "woman_technologist",
    "man_technologist",
    "woman_office_worker",
    "man_office_worker",
    "woman_mechanic",
    "man_mechanic",
    "woman_scientist",
    "man_scientist",
    "woman_artist",
    "man_artist",
    "woman_firefighter",
    "man_firefighter",
    "woman_pilot",
    "man_pilot",
    "woman_astronaut",
    "man_astronaut",
    "woman_judge",
    "man_judge",
    "bride_with_veil",
    "man_in_tuxedo",
    "princess",
    "prince",
    "woman_superhero",
    "man_superhero",
    "woman_supervillain",
    "man_supervillain",
    "mrs_claus",
    "santa",
    "sorceress",
    "wizard",
    "woman_elf",
    "man_elf",
    "woman_vampire",
    "man_vampire",
    "woman_zombie",
    "man_zombie",
    "woman_genie",
    "man_genie",
    "mermaid",
    "merman",
    "woman_fairy",
    "man_fairy",
    "angel",
    "pregnant_woman",
    "breastfeeding",
    "bowing_woman",
    "bowing_man",
    "tipping_hand_woman",
    "tipping_hand_man",
    "no_good_woman",
    "no_good_man",
    "ok_woman",
    "ok_man",
    "raising_hand_woman",
    "raising_hand_man",
    "woman_facepalming",
    "man_facepalming",
    "woman_shrugging",
    "man_shrugging",
    "pouting_woman",
    "pouting_man",
    "frowning_woman",
    "frowning_man",
    "haircut_woman",
    "haircut_man",
    "massage_woman",
    "massage_man",
    "woman_in_steamy_room",
    "man_in_steamy_room",
    "nail_care",
    "selfie",
    "dancer",
    "man_dancing",
    "dancing_women",
    "dancing_men",
    "business_suit_levitating",
    "walking_woman",
    "walking_man",
    "running_woman",
    "running_man",
    "couple",
    "two_women_holding_hands",
    "two_men_holding_hands",
    "couple_with_heart_woman_man",
    "couple_with_heart_woman_woman",
    "couple_with_heart_man_man",
    "couplekiss_man_woman",
    "couplekiss_woman_woman",
    "couplekiss_man_man",
    "family_man_woman_boy",
    "family_man_woman_girl",
    "family_man_woman_girl_boy",
    "family_man_woman_boy_boy",
    "family_man_woman_girl_girl",
    "family_woman_woman_boy",
    "family_woman_woman_girl",
    "family_woman_woman_girl_boy",
    "family_woman_woman_boy_boy",
    "family_woman_woman_girl_girl",
    "family_man_man_boy",
    "family_man_man_girl",
    "family_man_man_girl_boy",
    "family_man_man_boy_boy",
    "family_man_man_girl_girl",
    "family_woman_boy",
    "family_woman_girl",
    "family_woman_girl_boy",
    "family_woman_boy_boy",
    "family_woman_girl_girl",
    "family_man_boy",
    "family_man_girl",
    "family_man_girl_boy",
    "family_man_boy_boy",
    "family_man_girl_girl",
    "yarn",
    "thread",
    "coat",
    "labcoat",
    "womans_clothes",
    "tshirt",
    "jeans",
    "necktie",
    "dress",
    "bikini",
    "kimono",
    "flat_shoe",
    "high_heel",
    "sandal",
    "boot",
    "mans_shoe",
    "athletic_shoe",
    "hiking_boot",
    "socks",
    "gloves",
    "scarf",
    "tophat",
    "billed_hat",
    "womans_hat",
    "mortar_board",
    "rescue_worker_helmet",
    "crown",
    "pouch",
    "purse",
    "handbag",
    "briefcase",
    "school_satchel",
    "luggage",
    "eyeglasses",
    "dark_sunglasses",
    "goggles",
    "closed_umbrella",
    "dog",
    "cat",
    "mouse",
    "hamster",
    "rabbit",
    "fox_face",
    "bear",
    "panda_face",
    "koala",
    "tiger",
    "lion",
    "cow",
    "pig",
    "pig_nose",
    "frog",
    "monkey_face",
    "see_no_evil",
    "hear_no_evil",
    "speak_no_evil",
    "monkey",
    "chicken",
    "penguin",
    "bird",
    "baby_chick",
    "hatching_chick",
    "hatched_chick",
    "duck",
    "eagle",
    "owl",
    "bat",
    "wolf",
    "boar",
    "horse",
    "unicorn",
    "honeybee",
    "bug",
    "butterfly",
    "snail",
    "shell",
    "beetle",
    "ant",
    "mosquito",
    "grasshopper",
    "spider",
    "spider_web",
    "scorpion",
    "turtle",
    "snake",
    "lizard",
    "t-rex",
    "sauropod",
    "octopus",
    "squid",
    "shrimp",
    "lobster",
    "crab",
    "blowfish",
    "tropical_fish",
    "fish",
    "dolphin",
    "whale",
    "whale2",
    "shark",
    "crocodile",
    "tiger2",
    "leopard",
    "zebra",
    "gorilla",
    "elephant",
    "hippopotamus",
    "rhinoceros",
    "dromedary_camel",
    "giraffe",
    "kangaroo",
    "camel",
    "water_buffalo",
    "ox",
    "cow2",
    "racehorse",
    "pig2",
    "ram",
    "sheep",
    "llama",
    "goat",
    "deer",
    "dog2",
    "poodle",
    "cat2",
    "rooster",
    "turkey",
    "peacock",
    "parrot",
    "swan",
    "dove",
    "rabbit2",
    "raccoon",
    "badger",
    "rat",
    "mouse2",
    "chipmunk",
    "hedgehog",
    "paw_prints",
    "dragon",
    "dragon_face",
    "cactus",
    "christmas_tree",
    "evergreen_tree",
    "deciduous_tree",
    "palm_tree",
    "seedling",
    "herb",
    "shamrock",
    "four_leaf_clover",
    "bamboo",
    "tanabata_tree",
    "leaves",
    "fallen_leaf",
    "maple_leaf",
    "ear_of_rice",
    "hibiscus",
    "sunflower",
    "rose",
    "wilted_flower",
    "tulip",
    "blossom",
    "cherry_blossom",
    "bouquet",
    "mushroom",
    "earth_americas",
    "earth_africa",
    "earth_asia",
    "full_moon",
    "waning_gibbous_moon",
    "last_quarter_moon",
    "waning_crescent_moon",
    "new_moon",
    "waxing_crescent_moon",
    "first_quarter_moon",
    "waxing_gibbous_moon",
    "new_moon_with_face",
    "full_moon_with_face",
    "first_quarter_moon_with_face",
    "last_quarter_moon_with_face",
    "sun_with_face",
    "crescent_moon",
    "star",
    "star2",
    "dizzy",
    "sparkles",
    "comet",
    "sunny",
    "sun_behind_small_cloud",
    "partly_sunny",
    "sun_behind_large_cloud",
    "sun_behind_rain_cloud",
    "cloud",
    "cloud_with_rain",
    "cloud_with_lightning_and_rain",
    "cloud_with_lightning",
    "zap",
    "fire",
    "boom",
    "snowflake",
    "cloud_with_snow",
    "snowman",
    "snowman_with_snow",
    "wind_face",
    "dash",
    "tornado",
    "fog",
    "open_umbrella",
    "umbrella",
    "droplet",
    "sweat_drops",
    "ocean",
    "green_apple",
    "apple",
    "pear",
    "tangerine",
    "lemon",
    "banana",
    "watermelon",
    "grapes",
    "strawberry",
    "melon",
    "cherries",
    "peach",
    "mango",
    "pineapple",
    "coconut",
    "kiwi_fruit",
    "tomato",
    "eggplant",
    "avocado",
    "broccoli",
    "leafy_greens",
    "cucumber",
    "hot_pepper",
    "corn",
    "carrot",
    "potato",
    "sweet_potato",
    "croissant",
    "bagel",
    "bread",
    "baguette_bread",
    "pretzel",
    "cheese",
    "egg",
    "fried_egg",
    "pancakes",
    "bacon",
    "steak",
    "poultry_leg",
    "meat_on_bone",
    "bone",
    "hotdog",
    "hamburger",
    "fries",
    "pizza",
    "sandwich",
    "stuffed_flatbread",
    "taco",
    "burrito",
    "green_salad",
    "shallow_pan_of_food",
    "canned_food",
    "spaghetti",
    "ramen",
    "stew",
    "curry",
    "sushi",
    "bento",
    "fried_shrimp",
    "rice_ball",
    "rice",
    "rice_cracker",
    "fish_cake",
    "fortune_cookie",
    "moon_cake",
    "oden",
    "dango",
    "shaved_ice",
    "ice_cream",
    "icecream",
    "pie",
    "cupcake",
    "cake",
    "birthday",
    "custard",
    "lollipop",
    "candy",
    "chocolate_bar",
    "popcorn",
    "doughnut",
    "dumpling",
    "cookie",
    "chestnut",
    "peanuts",
    "honey_pot",
    "milk_glass",
    "baby_bottle",
    "coffee",
    "tea",
    "cup_with_straw",
    "sake",
    "beer",
    "beers",
    "clinking_glasses",
    "wine_glass",
    "tumbler_glass",
    "cocktail",
    "tropical_drink",
    "champagne",
    "spoon",
    "fork_and_knife",
    "plate_with_cutlery",
    "bowl_with_spoon",
    "takeout_box",
    "chopsticks",
    "salt",
    "soccer",
    "basketball",
    "football",
    "baseball",
    "softball",
    "tennis",
    "volleyball",
    "rugby_football",
    "flying_disc",
    "8ball",
    "golf",
    "golfing_woman",
    "golfing_man",
    "ping_pong",
    "badminton",
    "goal_net",
    "ice_hockey",
    "field_hockey",
    "lacrosse",
    "cricket",
    "ski",
    "skier",
    "snowboarder",
    "person_fencing",
    "women_wrestling",
    "men_wrestling",
    "woman_cartwheeling",
    "man_cartwheeling",
    "woman_playing_handball",
    "man_playing_handball",
    "ice_skate",
    "curling_stone",
    "skateboard",
    "sled",
    "bow_and_arrow",
    "fishing_pole_and_fish",
    "boxing_glove",
    "martial_arts_uniform",
    "rowing_woman",
    "rowing_man",
    "climbing_woman",
    "climbing_man",
    "swimming_woman",
    "swimming_man",
    "woman_playing_water_polo",
    "man_playing_water_polo",
    "woman_in_lotus_position",
    "man_in_lotus_position",
    "surfing_woman",
    "surfing_man",
    "basketball_woman",
    "basketball_man",
    "weight_lifting_woman",
    "weight_lifting_man",
    "biking_woman",
    "biking_man",
    "mountain_biking_woman",
    "mountain_biking_man",
    "horse_racing",
    "trophy",
    "running_shirt_with_sash",
    "medal_sports",
    "medal_military",
    "1st_place_medal",
    "2nd_place_medal",
    "3rd_place_medal",
    "reminder_ribbon",
    "rosette",
    "ticket",
    "tickets",
    "performing_arts",
    "art",
    "circus_tent",
    "woman_juggling",
    "man_juggling",
    "microphone",
    "headphones",
    "musical_score",
    "musical_keyboard",
    "drum",
    "saxophone",
    "trumpet",
    "guitar",
    "violin",
    "clapper",
    "video_game",
    "dart",
    "game_die",
    "chess_pawn",
    "slot_machine",
    "jigsaw",
    "bowling",
    "red_car",
    "taxi",
    "blue_car",
    "bus",
    "trolleybus",
    "racing_car",
    "police_car",
    "ambulance",
    "fire_engine",
    "minibus",
    "truck",
    "articulated_lorry",
    "tractor",
    "kick_scooter",
    "motorcycle",
    "bike",
    "motor_scooter",
    "rotating_light",
    "oncoming_police_car",
    "oncoming_bus",
    "oncoming_automobile",
    "oncoming_taxi",
    "aerial_tramway",
    "mountain_cableway",
    "suspension_railway",
    "railway_car",
    "train",
    "monorail",
    "bullettrain_side",
    "bullettrain_front",
    "light_rail",
    "mountain_railway",
    "steam_locomotive",
    "train2",
    "metro",
    "tram",
    "station",
    "flying_saucer",
    "helicopter",
    "small_airplane",
    "airplane",
    "flight_departure",
    "flight_arrival",
    "sailboat",
    "motor_boat",
    "speedboat",
    "ferry",
    "passenger_ship",
    "rocket",
    "artificial_satellite",
    "seat",
    "canoe",
    "anchor",
    "construction",
    "fuelpump",
    "busstop",
    "vertical_traffic_light",
    "traffic_light",
    "ship",
    "ferris_wheel",
    "roller_coaster",
    "carousel_horse",
    "building_construction",
    "foggy",
    "tokyo_tower",
    "factory",
    "fountain",
    "rice_scene",
    "mountain",
    "mountain_snow",
    "mount_fuji",
    "volcano",
    "japan",
    "camping",
    "tent",
    "national_park",
    "motorway",
    "railway_track",
    "sunrise",
    "sunrise_over_mountains",
    "desert",
    "beach_umbrella",
    "desert_island",
    "city_sunrise",
    "city_sunset",
    "cityscape",
    "night_with_stars",
    "bridge_at_night",
    "milky_way",
    "stars",
    "sparkler",
    "fireworks",
    "rainbow",
    "houses",
    "european_castle",
    "japanese_castle",
    "stadium",
    "statue_of_liberty",
    "house",
    "house_with_garden",
    "derelict_house",
    "office",
    "department_store",
    "post_office",
    "european_post_office",
    "hospital",
    "bank",
    "hotel",
    "convenience_store",
    "school",
    "love_hotel",
    "wedding",
    "classical_building",
    "church",
    "mosque",
    "synagogue",
    "kaaba",
    "shinto_shrine",
    "watch",
    "iphone",
    "calling",
    "computer",
    "keyboard",
    "desktop_computer",
    "printer",
    "computer_mouse",
    "trackball",
    "joystick",
    "clamp",
    "minidisc",
    "floppy_disk",
    "cd",
    "dvd",
    "vhs",
    "camera",
    "camera_flash",
    "video_camera",
    "movie_camera",
    "film_projector",
    "film_strip",
    "telephone_receiver",
    "phone",
    "pager",
    "fax",
    "tv",
    "radio",
    "studio_microphone",
    "level_slider",
    "control_knobs",
    "compass",
    "stopwatch",
    "timer_clock",
    "alarm_clock",
    "mantelpiece_clock",
    "hourglass_flowing_sand",
    "hourglass",
    "satellite",
    "battery",
    "electric_plug",
    "bulb",
    "flashlight",
    "candle",
    "fire_extinguisher",
    "wastebasket",
    "oil_drum",
    "money_with_wings",
    "dollar",
    "yen",
    "euro",
    "pound",
    "moneybag",
    "credit_card",
    "gem",
    "balance_scale",
    "toolbox",
    "wrench",
    "hammer",
    "hammer_and_pick",
    "hammer_and_wrench",
    "pick",
    "nut_and_bolt",
    "gear",
    "brick",
    "chains",
    "magnet",
    "gun",
    "bomb",
    "firecracker",
    "hocho",
    "dagger",
    "crossed_swords",
    "shield",
    "smoking",
    "coffin",
    "funeral_urn",
    "amphora",
    "crystal_ball",
    "prayer_beads",
    "nazar_amulet",
    "barber",
    "alembic",
    "telescope",
    "microscope",
    "hole",
    "pill",
    "syringe",
    "dna",
    "microbe",
    "petri_dish",
    "test_tube",
    "thermometer",
    "broom",
    "basket",
    "toilet_paper",
    "label",
    "bookmark",
    "toilet",
    "shower",
    "bathtub",
    "bath",
    "soap",
    "sponge",
    "lotion_bottle",
    "key",
    "old_key",
    "couch_and_lamp",
    "sleeping_bed",
    "bed",
    "door",
    "bellhop_bell",
    "teddy_bear",
    "framed_picture",
    "world_map",
    "parasol_on_ground",
    "moyai",
    "shopping",
    "shopping_cart",
    "balloon",
    "flags",
    "ribbon",
    "gift",
    "confetti_ball",
    "tada",
    "dolls",
    "wind_chime",
    "crossed_flags",
    "izakaya_lantern",
    "red_envelope",
    "email",
    "envelope_with_arrow",
    "incoming_envelope",
    "e-mail",
    "love_letter",
    "postbox",
    "mailbox_closed",
    "mailbox",
    "mailbox_with_mail",
    "mailbox_with_no_mail",
    "package",
    "postal_horn",
    "inbox_tray",
    "outbox_tray",
    "scroll",
    "page_with_curl",
    "bookmark_tabs",
    "receipt",
    "bar_chart",
    "chart_with_upwards_trend",
    "chart_with_downwards_trend",
    "page_facing_up",
    "date",
    "calendar",
    "spiral_calendar",
    "card_index",
    "card_file_box",
    "ballot_box",
    "file_cabinet",
    "clipboard",
    "spiral_notepad",
    "file_folder",
    "open_file_folder",
    "card_index_dividers",
    "newspaper_roll",
    "newspaper",
    "notebook",
    "closed_book",
    "green_book",
    "blue_book",
    "orange_book",
    "notebook_with_decorative_cover",
    "ledger",
    "books",
    "open_book",
    "safety_pin",
    "link",
    "paperclip",
    "paperclips",
    "scissors",
    "triangular_ruler",
    "straight_ruler",
    "abacus",
    "pushpin",
    "round_pushpin",
    "closed_lock_with_key",
    "lock",
    "unlock",
    "lock_with_ink_pen",
    "pen",
    "fountain_pen",
    "black_nib",
    "memo",
    "pencil2",
    "crayon",
    "paintbrush",
    "mag",
    "mag_right",
    "heart",
    "orange_heart",
    "yellow_heart",
    "green_heart",
    "blue_heart",
    "purple_heart",
    "black_heart",
    "broken_heart",
    "heavy_heart_exclamation",
    "two_hearts",
    "revolving_hearts",
    "heartbeat",
    "heartpulse",
    "sparkling_heart",
    "cupid",
    "gift_heart",
    "heart_decoration",
    "peace_symbol",
    "latin_cross",
    "star_and_crescent",
    "om",
    "wheel_of_dharma",
    "star_of_david",
    "six_pointed_star",
    "menorah",
    "yin_yang",
    "orthodox_cross",
    "place_of_worship",
    "ophiuchus",
    "aries",
    "taurus",
    "gemini",
    "cancer",
    "leo",
    "virgo",
    "libra",
    "scorpius",
    "sagittarius",
    "capricorn",
    "aquarius",
    "pisces",
    "id",
    "atom_symbol",
    "u7a7a",
    "u5272",
    "radioactive",
    "biohazard",
    "mobile_phone_off",
    "vibration_mode",
    "u6709",
    "u7121",
    "u7533",
    "u55b6",
    "u6708",
    "eight_pointed_black_star",
    "vs",
    "accept",
    "white_flower",
    "ideograph_advantage",
    "secret",
    "congratulations",
    "u5408",
    "u6e80",
    "u7981",
    "a",
    "b",
    "ab",
    "cl",
    "o2",
    "sos",
    "no_entry",
    "name_badge",
    "no_entry_sign",
    "x",
    "o",
    "stop_sign",
    "anger",
    "hotsprings",
    "no_pedestrians",
    "do_not_litter",
    "no_bicycles",
    "non-potable_water",
    "underage",
    "no_mobile_phones",
    "exclamation",
    "grey_exclamation",
    "question",
    "grey_question",
    "bangbang",
    "interrobang",
    "100",
    "low_brightness",
    "high_brightness",
    "trident",
    "fleur_de_lis",
    "part_alternation_mark",
    "warning",
    "children_crossing",
    "beginner",
    "recycle",
    "u6307",
    "chart",
    "sparkle",
    "eight_spoked_asterisk",
    "negative_squared_cross_mark",
    "white_check_mark",
    "diamond_shape_with_a_dot_inside",
    "cyclone",
    "loop",
    "globe_with_meridians",
    "m",
    "atm",
    "zzz",
    "sa",
    "passport_control",
    "customs",
    "baggage_claim",
    "left_luggage",
    "wheelchair",
    "no_smoking",
    "wc",
    "parking",
    "potable_water",
    "mens",
    "womens",
    "baby_symbol",
    "restroom",
    "put_litter_in_its_place",
    "cinema",
    "signal_strength",
    "koko",
    "ng",
    "ok",
    "up",
    "cool",
    "new",
    "free",
    "zero",
    "one",
    "two",
    "three",
    "four",
    "five",
    "six",
    "seven",
    "eight",
    "nine",
    "keycap_ten",
    "asterisk",
    "1234",
    "eject_button",
    "arrow_forward",
    "pause_button",
    "next_track_button",
    "stop_button",
    "record_button",
    "play_or_pause_button",
    "previous_track_button",
    "fast_forward",
    "rewind",
    "twisted_rightwards_arrows",
    "repeat",
    "repeat_one",
    "arrow_backward",
    "arrow_up_small",
    "arrow_down_small",
    "arrow_double_up",
    "arrow_double_down",
    "arrow_right",
    "arrow_left",
    "arrow_up",
    "arrow_down",
    "arrow_upper_right",
    "arrow_lower_right",
    "arrow_lower_left",
    "arrow_upper_left",
    "arrow_up_down",
    "left_right_arrow",
    "arrows_counterclockwise",
    "arrow_right_hook",
    "leftwards_arrow_with_hook",
    "arrow_heading_up",
    "arrow_heading_down",
    "hash",
    "information_source",
    "abc",
    "abcd",
    "capital_abcd",
    "symbols",
    "musical_note",
    "notes",
    "wavy_dash",
    "curly_loop",
    "heavy_check_mark",
    "arrows_clockwise",
    "heavy_plus_sign",
    "heavy_minus_sign",
    "heavy_division_sign",
    "heavy_multiplication_x",
    "infinity",
    "heavy_dollar_sign",
    "currency_exchange",
    "copyright",
    "registered",
    "tm",
    "end",
    "back",
    "on",
    "top",
    "soon",
    "ballot_box_with_check",
    "radio_button",
    "white_circle",
    "black_circle",
    "red_circle",
    "large_blue_circle",
    "small_orange_diamond",
    "small_blue_diamond",
    "large_orange_diamond",
    "large_blue_diamond",
    "small_red_triangle",
    "black_small_square",
    "white_small_square",
    "black_large_square",
    "white_large_square",
    "small_red_triangle_down",
    "black_medium_square",
    "white_medium_square",
    "black_medium_small_square",
    "white_medium_small_square",
    "black_square_button",
    "white_square_button",
    "speaker",
    "sound",
    "loud_sound",
    "mute",
    "mega",
    "loudspeaker",
    "bell",
    "no_bell",
    "black_joker",
    "mahjong",
    "spades",
    "clubs",
    "hearts",
    "diamonds",
    "flower_playing_cards",
    "thought_balloon",
    "right_anger_bubble",
    "speech_balloon",
    "left_speech_bubble",
    "clock1",
    "clock2",
    "clock3",
    "clock4",
    "clock5",
    "clock6",
    "clock7",
    "clock8",
    "clock9",
    "clock10",
    "clock11",
    "clock12",
    "clock130",
    "clock230",
    "clock330",
    "clock430",
    "clock530",
    "clock630",
    "clock730",
    "clock830",
    "clock930",
    "clock1030",
    "clock1130",
    "clock1230",
    "white_flag",
    "black_flag",
    "pirate_flag",
    "checkered_flag",
    "triangular_flag_on_post",
    "rainbow_flag",
    "united_nations",
    "afghanistan",
    "aland_islands",
    "albania",
    "algeria",
    "american_samoa",
    "andorra",
    "angola",
    "anguilla",
    "antarctica",
    "antigua_barbuda",
    "argentina",
    "armenia",
    "aruba",
    "australia",
    "austria",
    "azerbaijan",
    "bahamas",
    "bahrain",
    "bangladesh",
    "barbados",
    "belarus",
    "belgium",
    "belize",
    "benin",
    "bermuda",
    "bhutan",
    "bolivia",
    "caribbean_netherlands",
    "bosnia_herzegovina",
    "botswana",
    "brazil",
    "british_indian_ocean_territory",
    "british_virgin_islands",
    "brunei",
    "bulgaria",
    "burkina_faso",
    "burundi",
    "cape_verde",
    "cambodia",
    "cameroon",
    "canada",
    "canary_islands",
    "cayman_islands",
    "central_african_republic",
    "chad",
    "chile",
    "cn",
    "christmas_island",
    "cocos_islands",
    "colombia",
    "comoros",
    "congo_brazzaville",
    "congo_kinshasa",
    "cook_islands",
    "costa_rica",
    "croatia",
    "cuba",
    "curacao",
    "cyprus",
    "czech_republic",
    "denmark",
    "djibouti",
    "dominica",
    "dominican_republic",
    "ecuador",
    "egypt",
    "el_salvador",
    "equatorial_guinea",
    "eritrea",
    "estonia",
    "ethiopia",
    "eu",
    "falkland_islands",
    "faroe_islands",
    "fiji",
    "finland",
    "fr",
    "french_guiana",
    "french_polynesia",
    "french_southern_territories",
    "gabon",
    "gambia",
    "georgia",
    "de",
    "ghana",
    "gibraltar",
    "greece",
    "greenland",
    "grenada",
    "guadeloupe",
    "guam",
    "guatemala",
    "guernsey",
    "guinea",
    "guinea_bissau",
    "guyana",
    "haiti",
    "honduras",
    "hong_kong",
    "hungary",
    "iceland",
    "india",
    "indonesia",
    "iran",
    "iraq",
    "ireland",
    "isle_of_man",
    "israel",
    "it",
    "cote_divoire",
    "jamaica",
    "jp",
    "jersey",
    "jordan",
    "kazakhstan",
    "kenya",
    "kiribati",
    "kosovo",
    "kuwait",
    "kyrgyzstan",
    "laos",
    "latvia",
    "lebanon",
    "lesotho",
    "liberia",
    "libya",
    "liechtenstein",
    "lithuania",
    "luxembourg",
    "macau",
    "macedonia",
    "madagascar",
    "malawi",
    "malaysia",
    "maldives",
    "mali",
    "malta",
    "marshall_islands",
    "martinique",
    "mauritania",
    "mauritius",
    "mayotte",
    "mexico",
    "micronesia",
    "moldova",
    "monaco",
    "mongolia",
    "montenegro",
    "montserrat",
    "morocco",
    "mozambique",
    "myanmar",
    "namibia",
    "nauru",
    "nepal",
    "netherlands",
    "new_caledonia",
    "new_zealand",
    "nicaragua",
    "niger",
    "nigeria",
    "niue",
    "norfolk_island",
    "northern_mariana_islands",
    "north_korea",
    "norway",
    "oman",
    "pakistan",
    "palau",
    "palestinian_territories",
    "panama",
    "papua_new_guinea",
    "paraguay",
    "peru",
    "philippines",
    "pitcairn_islands",
    "poland",
    "portugal",
    "puerto_rico",
    "qatar",
    "reunion",
    "romania",
    "ru",
    "rwanda",
    "st_barthelemy",
    "st_helena",
    "st_kitts_nevis",
    "st_lucia",
    "st_pierre_miquelon",
    "st_vincent_grenadines",
    "samoa",
    "san_marino",
    "sao_tome_principe",
    "saudi_arabia",
    "senegal",
    "serbia",
    "seychelles",
    "sierra_leone",
    "singapore",
    "sint_maarten",
    "slovakia",
    "slovenia",
    "solomon_islands",
    "somalia",
    "south_africa",
    "south_georgia_south_sandwich_islands",
    "kr",
    "south_sudan",
    "es",
    "sri_lanka",
    "sudan",
    "suriname",
    "swaziland",
    "sweden",
    "switzerland",
    "syria",
    "taiwan",
    "tajikistan",
    "tanzania",
    "thailand",
    "timor_leste",
    "togo",
    "tokelau",
    "tonga",
    "trinidad_tobago",
    "tunisia",
    "tr",
    "turkmenistan",
    "turks_caicos_islands",
    "tuvalu",
    "uganda",
    "ukraine",
    "united_arab_emirates",
    "uk",
    "england",
    "scotland",
    "wales",
    "us",
    "us_virgin_islands",
    "uruguay",
    "uzbekistan",
    "vanuatu",
    "vatican_city",
    "venezuela",
    "vietnam",
    "wallis_futuna",
    "western_sahara",
    "yemen",
    "zambia",
    "zimbabwe"
  ];
});

// node_modules/emojilib/index.js
var require_emojilib = __commonJS((exports, module) => {
  module.exports = {
    lib: require_emojis(),
    ordered: require_ordered(),
    fitzpatrick_scale_modifiers: ["\uD83C\uDFFB", "\uD83C\uDFFC", "\uD83C\uDFFD", "\uD83C\uDFFE", "\uD83C\uDFFF"]
  };
});

// node_modules/char-regex/index.js
var require_char_regex = __commonJS((exports, module) => {
  module.exports = () => {
    const astralRange = "\\ud800-\\udfff";
    const comboMarksRange = "\\u0300-\\u036f";
    const comboHalfMarksRange = "\\ufe20-\\ufe2f";
    const comboSymbolsRange = "\\u20d0-\\u20ff";
    const comboMarksExtendedRange = "\\u1ab0-\\u1aff";
    const comboMarksSupplementRange = "\\u1dc0-\\u1dff";
    const comboRange = comboMarksRange + comboHalfMarksRange + comboSymbolsRange + comboMarksExtendedRange + comboMarksSupplementRange;
    const varRange = "\\ufe0e\\ufe0f";
    const familyRange = "\\uD83D\\uDC69\\uD83C\\uDFFB\\u200D\\uD83C\\uDF93";
    const astral = `[${astralRange}]`;
    const combo = `[${comboRange}]`;
    const fitz = "\\ud83c[\\udffb-\\udfff]";
    const modifier = `(?:${combo}|${fitz})`;
    const nonAstral = `[^${astralRange}]`;
    const regional = "(?:\\uD83C[\\uDDE6-\\uDDFF]){2}";
    const surrogatePair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    const zwj = "\\u200d";
    const blackFlag = "(?:\\ud83c\\udff4\\udb40\\udc67\\udb40\\udc62\\udb40(?:\\udc65|\\udc73|\\udc77)\\udb40(?:\\udc6e|\\udc63|\\udc6c)\\udb40(?:\\udc67|\\udc74|\\udc73)\\udb40\\udc7f)";
    const family = `[${familyRange}]`;
    const optModifier = `${modifier}?`;
    const optVar = `[${varRange}]?`;
    const optJoin = `(?:${zwj}(?:${[nonAstral, regional, surrogatePair].join("|")})${optVar + optModifier})*`;
    const seq = optVar + optModifier + optJoin;
    const nonAstralCombo = `${nonAstral}${combo}?`;
    const symbol = `(?:${[nonAstralCombo, combo, regional, surrogatePair, astral, family].join("|")})`;
    return new RegExp(`${blackFlag}|${fitz}(?=${fitz})|${symbol + seq}`, "g");
  };
});

// node_modules/unicode-emoji-modifier-base/index.js
var require_unicode_emoji_modifier_base = __commonJS((exports, module) => {
  module.exports = new Set([
    9757,
    9977,
    9994,
    9995,
    9996,
    9997,
    127877,
    127939,
    127940,
    127946,
    127947,
    128066,
    128067,
    128070,
    128071,
    128072,
    128073,
    128074,
    128075,
    128076,
    128077,
    128078,
    128079,
    128080,
    128102,
    128103,
    128104,
    128105,
    128110,
    128112,
    128113,
    128114,
    128115,
    128116,
    128117,
    128118,
    128119,
    128120,
    128124,
    128129,
    128130,
    128131,
    128133,
    128134,
    128135,
    128170,
    128373,
    128378,
    128400,
    128405,
    128406,
    128581,
    128582,
    128583,
    128587,
    128588,
    128589,
    128590,
    128591,
    128675,
    128692,
    128693,
    128694,
    128704,
    129304,
    129305,
    129306,
    129307,
    129308,
    129309,
    129310,
    129318,
    129328,
    129331,
    129332,
    129333,
    129334,
    129335,
    129336,
    129337,
    129340,
    129341,
    129342
  ]);
});

// node_modules/skin-tone/index.js
var require_skin_tone = __commonJS((exports, module) => {
  var emojiModifierBase = require_unicode_emoji_modifier_base();
  var skinTones = new Map([
    ["none", ""],
    ["white", "\uD83C\uDFFB"],
    ["creamWhite", "\uD83C\uDFFC"],
    ["lightBrown", "\uD83C\uDFFD"],
    ["brown", "\uD83C\uDFFE"],
    ["darkBrown", "\uD83C\uDFFF"]
  ]);
  module.exports = (emoji, tone) => {
    if (!skinTones.has(tone)) {
      throw new TypeError(`Unexpected \`skinTone\` name: ${tone}`);
    }
    emoji = emoji.replace(/[\u{1f3fb}-\u{1f3ff}]/u, "");
    if (emojiModifierBase.has(emoji.codePointAt(0)) && tone !== "none") {
      emoji += skinTones.get(tone);
    }
    return emoji;
  };
});

// node_modules/has-flag/index.js
var require_has_flag2 = __commonJS((exports, module) => {
  module.exports = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS((exports, module) => {
  var translateLevel2 = function(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  };
  var supportsColor2 = function(haveStream, streamIsTTY) {
    if (forceColor === 0) {
      return 0;
    }
    if (hasFlag2("color=16m") || hasFlag2("color=full") || hasFlag2("color=truecolor")) {
      return 3;
    }
    if (hasFlag2("color=256")) {
      return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === undefined) {
      return 0;
    }
    const min = forceColor || 0;
    if (env2.TERM === "dumb") {
      return min;
    }
    if (process.platform === "win32") {
      const osRelease = os2.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env2) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => (sign in env2)) || env2.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env2) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env2.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env2) {
      const version2 = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env2.TERM_PROGRAM) {
        case "iTerm.app":
          return version2 >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env2.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env2) {
      return 1;
    }
    return min;
  };
  var getSupportLevel = function(stream) {
    const level = supportsColor2(stream, stream && stream.isTTY);
    return translateLevel2(level);
  };
  var os2 = __require("os");
  var tty2 = __require("tty");
  var hasFlag2 = require_has_flag2();
  var { env: env2 } = process;
  var forceColor;
  if (hasFlag2("no-color") || hasFlag2("no-colors") || hasFlag2("color=false") || hasFlag2("color=never")) {
    forceColor = 0;
  } else if (hasFlag2("color") || hasFlag2("colors") || hasFlag2("color=true") || hasFlag2("color=always")) {
    forceColor = 1;
  }
  if ("FORCE_COLOR" in env2) {
    if (env2.FORCE_COLOR === "true") {
      forceColor = 1;
    } else if (env2.FORCE_COLOR === "false") {
      forceColor = 0;
    } else {
      forceColor = env2.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env2.FORCE_COLOR, 10), 3);
    }
  }
  module.exports = {
    supportsColor: getSupportLevel,
    stdout: translateLevel2(supportsColor2(true, tty2.isatty(1))),
    stderr: translateLevel2(supportsColor2(true, tty2.isatty(2)))
  };
});

// node_modules/supports-hyperlinks/index.js
var require_supports_hyperlinks = __commonJS((exports, module) => {
  var parseVersion = function(versionString) {
    if (/^\d{3,4}$/.test(versionString)) {
      const m2 = /(\d{1,2})(\d{2})/.exec(versionString) || [];
      return {
        major: 0,
        minor: parseInt(m2[1], 10),
        patch: parseInt(m2[2], 10)
      };
    }
    const versions = (versionString || "").split(".").map((n2) => parseInt(n2, 10));
    return {
      major: versions[0],
      minor: versions[1],
      patch: versions[2]
    };
  };
  var supportsHyperlink = function(stream) {
    const {
      CI,
      FORCE_HYPERLINK,
      NETLIFY,
      TEAMCITY_VERSION,
      TERM_PROGRAM,
      TERM_PROGRAM_VERSION,
      VTE_VERSION
    } = process.env;
    if (FORCE_HYPERLINK) {
      return !(FORCE_HYPERLINK.length > 0 && parseInt(FORCE_HYPERLINK, 10) === 0);
    }
    if (hasFlag2("no-hyperlink") || hasFlag2("no-hyperlinks") || hasFlag2("hyperlink=false") || hasFlag2("hyperlink=never")) {
      return false;
    }
    if (hasFlag2("hyperlink=true") || hasFlag2("hyperlink=always")) {
      return true;
    }
    if (NETLIFY) {
      return true;
    }
    if (!supportsColor2.supportsColor(stream)) {
      return false;
    }
    if (stream && !stream.isTTY) {
      return false;
    }
    if (process.platform === "win32") {
      return false;
    }
    if (CI) {
      return false;
    }
    if (TEAMCITY_VERSION) {
      return false;
    }
    if (TERM_PROGRAM) {
      const version2 = parseVersion(TERM_PROGRAM_VERSION || "");
      switch (TERM_PROGRAM) {
        case "iTerm.app":
          if (version2.major === 3) {
            return version2.minor >= 1;
          }
          return version2.major > 3;
        case "WezTerm":
          return version2.major >= 20200620;
        case "vscode":
          return version2.major > 1 || version2.major === 1 && version2.minor >= 72;
      }
    }
    if (VTE_VERSION) {
      if (VTE_VERSION === "0.50.0") {
        return false;
      }
      const version2 = parseVersion(VTE_VERSION);
      return version2.major > 0 || version2.minor >= 50;
    }
    return false;
  };
  var supportsColor2 = require_supports_color();
  var hasFlag2 = require_has_flag2();
  module.exports = {
    supportsHyperlink,
    stdout: supportsHyperlink(process.stdout),
    stderr: supportsHyperlink(process.stderr)
  };
});

// src/index.ts
var import_node_cmd = __toESM(require_cmd(), 1);

// node_modules/marked/lib/marked.esm.js
var _getDefaults = function() {
  return {
    async: false,
    breaks: false,
    extensions: null,
    gfm: true,
    hooks: null,
    pedantic: false,
    renderer: null,
    silent: false,
    tokenizer: null,
    walkTokens: null
  };
};
var changeDefaults = function(newDefaults) {
  _defaults = newDefaults;
};
var escape = function(html, encode) {
  if (encode) {
    if (escapeTest.test(html)) {
      return html.replace(escapeReplace, getEscapeReplacement);
    }
  } else {
    if (escapeTestNoEncode.test(html)) {
      return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
    }
  }
  return html;
};
var unescape2 = function(html) {
  return html.replace(unescapeTest, (_, n) => {
    n = n.toLowerCase();
    if (n === "colon")
      return ":";
    if (n.charAt(0) === "#") {
      return n.charAt(1) === "x" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
    }
    return "";
  });
};
var edit = function(regex, opt) {
  regex = typeof regex === "string" ? regex : regex.source;
  opt = opt || "";
  const obj = {
    replace: (name, val) => {
      val = typeof val === "object" && ("source" in val) ? val.source : val;
      val = val.replace(caret, "$1");
      regex = regex.replace(name, val);
      return obj;
    },
    getRegex: () => {
      return new RegExp(regex, opt);
    }
  };
  return obj;
};
var cleanUrl = function(href) {
  try {
    href = encodeURI(href).replace(/%25/g, "%");
  } catch (e) {
    return null;
  }
  return href;
};
var splitCells = function(tableRow, count) {
  const row = tableRow.replace(/\|/g, (match, offset, str) => {
    let escaped = false;
    let curr = offset;
    while (--curr >= 0 && str[curr] === "\\")
      escaped = !escaped;
    if (escaped) {
      return "|";
    } else {
      return " |";
    }
  }), cells = row.split(/ \|/);
  let i = 0;
  if (!cells[0].trim()) {
    cells.shift();
  }
  if (cells.length > 0 && !cells[cells.length - 1].trim()) {
    cells.pop();
  }
  if (count) {
    if (cells.length > count) {
      cells.splice(count);
    } else {
      while (cells.length < count)
        cells.push("");
    }
  }
  for (;i < cells.length; i++) {
    cells[i] = cells[i].trim().replace(/\\\|/g, "|");
  }
  return cells;
};
var rtrim = function(str, c, invert) {
  const l = str.length;
  if (l === 0) {
    return "";
  }
  let suffLen = 0;
  while (suffLen < l) {
    const currChar = str.charAt(l - suffLen - 1);
    if (currChar === c && !invert) {
      suffLen++;
    } else if (currChar !== c && invert) {
      suffLen++;
    } else {
      break;
    }
  }
  return str.slice(0, l - suffLen);
};
var findClosingBracket = function(str, b) {
  if (str.indexOf(b[1]) === -1) {
    return -1;
  }
  let level = 0;
  for (let i = 0;i < str.length; i++) {
    if (str[i] === "\\") {
      i++;
    } else if (str[i] === b[0]) {
      level++;
    } else if (str[i] === b[1]) {
      level--;
      if (level < 0) {
        return i;
      }
    }
  }
  return -1;
};
var outputLink = function(cap, link, raw, lexer) {
  const href = link.href;
  const title = link.title ? escape(link.title) : null;
  const text = cap[1].replace(/\\([\[\]])/g, "$1");
  if (cap[0].charAt(0) !== "!") {
    lexer.state.inLink = true;
    const token = {
      type: "link",
      raw,
      href,
      title,
      text,
      tokens: lexer.inlineTokens(text)
    };
    lexer.state.inLink = false;
    return token;
  }
  return {
    type: "image",
    raw,
    href,
    title,
    text: escape(text)
  };
};
var indentCodeCompensation = function(raw, text) {
  const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
  if (matchIndentToCode === null) {
    return text;
  }
  const indentToCode = matchIndentToCode[1];
  return text.split("\n").map((node) => {
    const matchIndentInNode = node.match(/^\s+/);
    if (matchIndentInNode === null) {
      return node;
    }
    const [indentInNode] = matchIndentInNode;
    if (indentInNode.length >= indentToCode.length) {
      return node.slice(indentToCode.length);
    }
    return node;
  }).join("\n");
};
var marked = function(src, opt) {
  return markedInstance.parse(src, opt);
};
var _defaults = _getDefaults();
var escapeTest = /[&<>"']/;
var escapeReplace = new RegExp(escapeTest.source, "g");
var escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
var escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, "g");
var escapeReplacements = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
var getEscapeReplacement = (ch) => escapeReplacements[ch];
var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
var caret = /(^|[^\[])\^/g;
var noopTest = { exec: () => null };

class _Tokenizer {
  options;
  rules;
  lexer;
  constructor(options) {
    this.options = options || _defaults;
  }
  space(src) {
    const cap = this.rules.block.newline.exec(src);
    if (cap && cap[0].length > 0) {
      return {
        type: "space",
        raw: cap[0]
      };
    }
  }
  code(src) {
    const cap = this.rules.block.code.exec(src);
    if (cap) {
      const text = cap[0].replace(/^ {1,4}/gm, "");
      return {
        type: "code",
        raw: cap[0],
        codeBlockStyle: "indented",
        text: !this.options.pedantic ? rtrim(text, "\n") : text
      };
    }
  }
  fences(src) {
    const cap = this.rules.block.fences.exec(src);
    if (cap) {
      const raw = cap[0];
      const text = indentCodeCompensation(raw, cap[3] || "");
      return {
        type: "code",
        raw,
        lang: cap[2] ? cap[2].trim().replace(this.rules.inline._escapes, "$1") : cap[2],
        text
      };
    }
  }
  heading(src) {
    const cap = this.rules.block.heading.exec(src);
    if (cap) {
      let text = cap[2].trim();
      if (/#$/.test(text)) {
        const trimmed = rtrim(text, "#");
        if (this.options.pedantic) {
          text = trimmed.trim();
        } else if (!trimmed || / $/.test(trimmed)) {
          text = trimmed.trim();
        }
      }
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[1].length,
        text,
        tokens: this.lexer.inline(text)
      };
    }
  }
  hr(src) {
    const cap = this.rules.block.hr.exec(src);
    if (cap) {
      return {
        type: "hr",
        raw: cap[0]
      };
    }
  }
  blockquote(src) {
    const cap = this.rules.block.blockquote.exec(src);
    if (cap) {
      const text = rtrim(cap[0].replace(/^ *>[ \t]?/gm, ""), "\n");
      const top = this.lexer.state.top;
      this.lexer.state.top = true;
      const tokens = this.lexer.blockTokens(text);
      this.lexer.state.top = top;
      return {
        type: "blockquote",
        raw: cap[0],
        tokens,
        text
      };
    }
  }
  list(src) {
    let cap = this.rules.block.list.exec(src);
    if (cap) {
      let bull = cap[1].trim();
      const isordered = bull.length > 1;
      const list = {
        type: "list",
        raw: "",
        ordered: isordered,
        start: isordered ? +bull.slice(0, -1) : "",
        loose: false,
        items: []
      };
      bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
      if (this.options.pedantic) {
        bull = isordered ? bull : "[*+-]";
      }
      const itemRegex = new RegExp(`^( {0,3}${bull})((?:[\t ][^\\n]*)?(?:\\n|\$))`);
      let raw = "";
      let itemContents = "";
      let endsWithBlankLine = false;
      while (src) {
        let endEarly = false;
        if (!(cap = itemRegex.exec(src))) {
          break;
        }
        if (this.rules.block.hr.test(src)) {
          break;
        }
        raw = cap[0];
        src = src.substring(raw.length);
        let line = cap[2].split("\n", 1)[0].replace(/^\t+/, (t) => " ".repeat(3 * t.length));
        let nextLine = src.split("\n", 1)[0];
        let indent = 0;
        if (this.options.pedantic) {
          indent = 2;
          itemContents = line.trimStart();
        } else {
          indent = cap[2].search(/[^ ]/);
          indent = indent > 4 ? 1 : indent;
          itemContents = line.slice(indent);
          indent += cap[1].length;
        }
        let blankLine = false;
        if (!line && /^ *$/.test(nextLine)) {
          raw += nextLine + "\n";
          src = src.substring(nextLine.length + 1);
          endEarly = true;
        }
        if (!endEarly) {
          const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ \t][^\\n]*)?(?:\\n|\$))`);
          const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|\$)`);
          const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`);
          const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);
          while (src) {
            const rawLine = src.split("\n", 1)[0];
            nextLine = rawLine;
            if (this.options.pedantic) {
              nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
            }
            if (fencesBeginRegex.test(nextLine)) {
              break;
            }
            if (headingBeginRegex.test(nextLine)) {
              break;
            }
            if (nextBulletRegex.test(nextLine)) {
              break;
            }
            if (hrRegex.test(src)) {
              break;
            }
            if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) {
              itemContents += "\n" + nextLine.slice(indent);
            } else {
              if (blankLine) {
                break;
              }
              if (line.search(/[^ ]/) >= 4) {
                break;
              }
              if (fencesBeginRegex.test(line)) {
                break;
              }
              if (headingBeginRegex.test(line)) {
                break;
              }
              if (hrRegex.test(line)) {
                break;
              }
              itemContents += "\n" + nextLine;
            }
            if (!blankLine && !nextLine.trim()) {
              blankLine = true;
            }
            raw += rawLine + "\n";
            src = src.substring(rawLine.length + 1);
            line = nextLine.slice(indent);
          }
        }
        if (!list.loose) {
          if (endsWithBlankLine) {
            list.loose = true;
          } else if (/\n *\n *$/.test(raw)) {
            endsWithBlankLine = true;
          }
        }
        let istask = null;
        let ischecked;
        if (this.options.gfm) {
          istask = /^\[[ xX]\] /.exec(itemContents);
          if (istask) {
            ischecked = istask[0] !== "[ ] ";
            itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
          }
        }
        list.items.push({
          type: "list_item",
          raw,
          task: !!istask,
          checked: ischecked,
          loose: false,
          text: itemContents,
          tokens: []
        });
        list.raw += raw;
      }
      list.items[list.items.length - 1].raw = raw.trimEnd();
      list.items[list.items.length - 1].text = itemContents.trimEnd();
      list.raw = list.raw.trimEnd();
      for (let i = 0;i < list.items.length; i++) {
        this.lexer.state.top = false;
        list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);
        if (!list.loose) {
          const spacers = list.items[i].tokens.filter((t) => t.type === "space");
          const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t) => /\n.*\n/.test(t.raw));
          list.loose = hasMultipleLineBreaks;
        }
      }
      if (list.loose) {
        for (let i = 0;i < list.items.length; i++) {
          list.items[i].loose = true;
        }
      }
      return list;
    }
  }
  html(src) {
    const cap = this.rules.block.html.exec(src);
    if (cap) {
      const token = {
        type: "html",
        block: true,
        raw: cap[0],
        pre: cap[1] === "pre" || cap[1] === "script" || cap[1] === "style",
        text: cap[0]
      };
      return token;
    }
  }
  def(src) {
    const cap = this.rules.block.def.exec(src);
    if (cap) {
      const tag = cap[1].toLowerCase().replace(/\s+/g, " ");
      const href = cap[2] ? cap[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline._escapes, "$1") : "";
      const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline._escapes, "$1") : cap[3];
      return {
        type: "def",
        tag,
        raw: cap[0],
        href,
        title
      };
    }
  }
  table(src) {
    const cap = this.rules.block.table.exec(src);
    if (cap) {
      if (!/[:|]/.test(cap[2])) {
        return;
      }
      const item = {
        type: "table",
        raw: cap[0],
        header: splitCells(cap[1]).map((c) => {
          return { text: c, tokens: [] };
        }),
        align: cap[2].replace(/^\||\| *$/g, "").split("|"),
        rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : []
      };
      if (item.header.length === item.align.length) {
        let l = item.align.length;
        let i, j, k, row;
        for (i = 0;i < l; i++) {
          const align = item.align[i];
          if (align) {
            if (/^ *-+: *$/.test(align)) {
              item.align[i] = "right";
            } else if (/^ *:-+: *$/.test(align)) {
              item.align[i] = "center";
            } else if (/^ *:-+ *$/.test(align)) {
              item.align[i] = "left";
            } else {
              item.align[i] = null;
            }
          }
        }
        l = item.rows.length;
        for (i = 0;i < l; i++) {
          item.rows[i] = splitCells(item.rows[i], item.header.length).map((c) => {
            return { text: c, tokens: [] };
          });
        }
        l = item.header.length;
        for (j = 0;j < l; j++) {
          item.header[j].tokens = this.lexer.inline(item.header[j].text);
        }
        l = item.rows.length;
        for (j = 0;j < l; j++) {
          row = item.rows[j];
          for (k = 0;k < row.length; k++) {
            row[k].tokens = this.lexer.inline(row[k].text);
          }
        }
        return item;
      }
    }
  }
  lheading(src) {
    const cap = this.rules.block.lheading.exec(src);
    if (cap) {
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[2].charAt(0) === "=" ? 1 : 2,
        text: cap[1],
        tokens: this.lexer.inline(cap[1])
      };
    }
  }
  paragraph(src) {
    const cap = this.rules.block.paragraph.exec(src);
    if (cap) {
      const text = cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1];
      return {
        type: "paragraph",
        raw: cap[0],
        text,
        tokens: this.lexer.inline(text)
      };
    }
  }
  text(src) {
    const cap = this.rules.block.text.exec(src);
    if (cap) {
      return {
        type: "text",
        raw: cap[0],
        text: cap[0],
        tokens: this.lexer.inline(cap[0])
      };
    }
  }
  escape(src) {
    const cap = this.rules.inline.escape.exec(src);
    if (cap) {
      return {
        type: "escape",
        raw: cap[0],
        text: escape(cap[1])
      };
    }
  }
  tag(src) {
    const cap = this.rules.inline.tag.exec(src);
    if (cap) {
      if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
        this.lexer.state.inLink = true;
      } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
        this.lexer.state.inLink = false;
      }
      if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = true;
      } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = false;
      }
      return {
        type: "html",
        raw: cap[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        block: false,
        text: cap[0]
      };
    }
  }
  link(src) {
    const cap = this.rules.inline.link.exec(src);
    if (cap) {
      const trimmedUrl = cap[2].trim();
      if (!this.options.pedantic && /^</.test(trimmedUrl)) {
        if (!/>$/.test(trimmedUrl)) {
          return;
        }
        const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
        if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
          return;
        }
      } else {
        const lastParenIndex = findClosingBracket(cap[2], "()");
        if (lastParenIndex > -1) {
          const start = cap[0].indexOf("!") === 0 ? 5 : 4;
          const linkLen = start + cap[1].length + lastParenIndex;
          cap[2] = cap[2].substring(0, lastParenIndex);
          cap[0] = cap[0].substring(0, linkLen).trim();
          cap[3] = "";
        }
      }
      let href = cap[2];
      let title = "";
      if (this.options.pedantic) {
        const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
        if (link) {
          href = link[1];
          title = link[3];
        }
      } else {
        title = cap[3] ? cap[3].slice(1, -1) : "";
      }
      href = href.trim();
      if (/^</.test(href)) {
        if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
          href = href.slice(1);
        } else {
          href = href.slice(1, -1);
        }
      }
      return outputLink(cap, {
        href: href ? href.replace(this.rules.inline._escapes, "$1") : href,
        title: title ? title.replace(this.rules.inline._escapes, "$1") : title
      }, cap[0], this.lexer);
    }
  }
  reflink(src, links) {
    let cap;
    if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
      let link = (cap[2] || cap[1]).replace(/\s+/g, " ");
      link = links[link.toLowerCase()];
      if (!link) {
        const text = cap[0].charAt(0);
        return {
          type: "text",
          raw: text,
          text
        };
      }
      return outputLink(cap, link, cap[0], this.lexer);
    }
  }
  emStrong(src, maskedSrc, prevChar = "") {
    let match = this.rules.inline.emStrong.lDelim.exec(src);
    if (!match)
      return;
    if (match[3] && prevChar.match(/[\p{L}\p{N}]/u))
      return;
    const nextChar = match[1] || match[2] || "";
    if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {
      const lLength = [...match[0]].length - 1;
      let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
      const endReg = match[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
      endReg.lastIndex = 0;
      maskedSrc = maskedSrc.slice(-1 * src.length + match[0].length - 1);
      while ((match = endReg.exec(maskedSrc)) != null) {
        rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
        if (!rDelim)
          continue;
        rLength = [...rDelim].length;
        if (match[3] || match[4]) {
          delimTotal += rLength;
          continue;
        } else if (match[5] || match[6]) {
          if (lLength % 3 && !((lLength + rLength) % 3)) {
            midDelimTotal += rLength;
            continue;
          }
        }
        delimTotal -= rLength;
        if (delimTotal > 0)
          continue;
        rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
        const raw = [...src].slice(0, lLength + match.index + rLength + 1).join("");
        if (Math.min(lLength, rLength) % 2) {
          const text2 = raw.slice(1, -1);
          return {
            type: "em",
            raw,
            text: text2,
            tokens: this.lexer.inlineTokens(text2)
          };
        }
        const text = raw.slice(2, -2);
        return {
          type: "strong",
          raw,
          text,
          tokens: this.lexer.inlineTokens(text)
        };
      }
    }
  }
  codespan(src) {
    const cap = this.rules.inline.code.exec(src);
    if (cap) {
      let text = cap[2].replace(/\n/g, " ");
      const hasNonSpaceChars = /[^ ]/.test(text);
      const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
        text = text.substring(1, text.length - 1);
      }
      text = escape(text, true);
      return {
        type: "codespan",
        raw: cap[0],
        text
      };
    }
  }
  br(src) {
    const cap = this.rules.inline.br.exec(src);
    if (cap) {
      return {
        type: "br",
        raw: cap[0]
      };
    }
  }
  del(src) {
    const cap = this.rules.inline.del.exec(src);
    if (cap) {
      return {
        type: "del",
        raw: cap[0],
        text: cap[2],
        tokens: this.lexer.inlineTokens(cap[2])
      };
    }
  }
  autolink(src) {
    const cap = this.rules.inline.autolink.exec(src);
    if (cap) {
      let text, href;
      if (cap[2] === "@") {
        text = escape(cap[1]);
        href = "mailto:" + text;
      } else {
        text = escape(cap[1]);
        href = text;
      }
      return {
        type: "link",
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: "text",
            raw: text,
            text
          }
        ]
      };
    }
  }
  url(src) {
    let cap;
    if (cap = this.rules.inline.url.exec(src)) {
      let text, href;
      if (cap[2] === "@") {
        text = escape(cap[0]);
        href = "mailto:" + text;
      } else {
        let prevCapZero;
        do {
          prevCapZero = cap[0];
          cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
        } while (prevCapZero !== cap[0]);
        text = escape(cap[0]);
        if (cap[1] === "www.") {
          href = "http://" + cap[0];
        } else {
          href = cap[0];
        }
      }
      return {
        type: "link",
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: "text",
            raw: text,
            text
          }
        ]
      };
    }
  }
  inlineText(src) {
    const cap = this.rules.inline.text.exec(src);
    if (cap) {
      let text;
      if (this.lexer.state.inRawBlock) {
        text = cap[0];
      } else {
        text = escape(cap[0]);
      }
      return {
        type: "text",
        raw: cap[0],
        text
      };
    }
  }
}
var block = {
  newline: /^(?: *(?:\n|$))+/,
  code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
  fences: /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
  hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
  heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
  blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
  list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
  html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
  def: /^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
  table: noopTest,
  lheading: /^(?!bull )((?:.|\n(?!\s*?\n|bull ))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
  text: /^[^\n]+/
};
block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
block.def = edit(block.def).replace("label", block._label).replace("title", block._title).getRegex();
block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
block.listItemStart = edit(/^( *)(bull) */).replace("bull", block.bullet).getRegex();
block.list = edit(block.list).replace(/bull/g, block.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + block.def.source + ")").getRegex();
block._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
block.html = edit(block.html, "i").replace("comment", block._comment).replace("tag", block._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
block.lheading = edit(block.lheading).replace(/bull/g, block.bullet).getRegex();
block.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.blockquote = edit(block.blockquote).replace("paragraph", block.paragraph).getRegex();
block.normal = { ...block };
block.gfm = {
  ...block.normal,
  table: "^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
};
block.gfm.table = edit(block.gfm.table).replace("hr", block.hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.gfm.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", block.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.pedantic = {
  ...block.normal,
  html: edit('^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))').replace("comment", block._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: noopTest,
  lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  paragraph: edit(block.normal._paragraph).replace("hr", block.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
};
var inline = {
  escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
  autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
  url: noopTest,
  tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
  link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
  reflink: /^!?\[(label)\]\[(ref)\]/,
  nolink: /^!?\[(ref)\](?:\[\])?/,
  reflinkSearch: "reflink|nolink(?!\\()",
  emStrong: {
    lDelim: /^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/,
    rDelimAst: /^[^_*]*?__[^_*]*?\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\*)[punct](\*+)(?=[\s]|$)|[^punct\s](\*+)(?!\*)(?=[punct\s]|$)|(?!\*)[punct\s](\*+)(?=[^punct\s])|[\s](\*+)(?!\*)(?=[punct])|(?!\*)[punct](\*+)(?!\*)(?=[punct])|[^punct\s](\*+)(?=[^punct\s])/,
    rDelimUnd: /^[^_*]*?\*\*[^_*]*?_[^_*]*?(?=\*\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\s]|$)|[^punct\s](_+)(?!_)(?=[punct\s]|$)|(?!_)[punct\s](_+)(?=[^punct\s])|[\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])/
  },
  code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
  br: /^( {2,}|\\)\n(?!\s*$)/,
  del: noopTest,
  text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
  punctuation: /^((?![*_])[\spunctuation])/
};
inline._punctuation = "\\p{P}$+<=>`^|~";
inline.punctuation = edit(inline.punctuation, "u").replace(/punctuation/g, inline._punctuation).getRegex();
inline.blockSkip = /\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g;
inline.anyPunctuation = /\\[punct]/g;
inline._escapes = /\\([punct])/g;
inline._comment = edit(block._comment).replace("(?:-->|$)", "-->").getRegex();
inline.emStrong.lDelim = edit(inline.emStrong.lDelim, "u").replace(/punct/g, inline._punctuation).getRegex();
inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, "gu").replace(/punct/g, inline._punctuation).getRegex();
inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, "gu").replace(/punct/g, inline._punctuation).getRegex();
inline.anyPunctuation = edit(inline.anyPunctuation, "gu").replace(/punct/g, inline._punctuation).getRegex();
inline._escapes = edit(inline._escapes, "gu").replace(/punct/g, inline._punctuation).getRegex();
inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
inline.autolink = edit(inline.autolink).replace("scheme", inline._scheme).replace("email", inline._email).getRegex();
inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
inline.tag = edit(inline.tag).replace("comment", inline._comment).replace("attribute", inline._attribute).getRegex();
inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
inline.link = edit(inline.link).replace("label", inline._label).replace("href", inline._href).replace("title", inline._title).getRegex();
inline.reflink = edit(inline.reflink).replace("label", inline._label).replace("ref", block._label).getRegex();
inline.nolink = edit(inline.nolink).replace("ref", block._label).getRegex();
inline.reflinkSearch = edit(inline.reflinkSearch, "g").replace("reflink", inline.reflink).replace("nolink", inline.nolink).getRegex();
inline.normal = { ...inline };
inline.pedantic = {
  ...inline.normal,
  strong: {
    start: /^__|\*\*/,
    middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
    endAst: /\*\*(?!\*)/g,
    endUnd: /__(?!_)/g
  },
  em: {
    start: /^_|\*/,
    middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
    endAst: /\*(?!\*)/g,
    endUnd: /_(?!_)/g
  },
  link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", inline._label).getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline._label).getRegex()
};
inline.gfm = {
  ...inline.normal,
  escape: edit(inline.escape).replace("])", "~|])").getRegex(),
  _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
  url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
  _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
};
inline.gfm.url = edit(inline.gfm.url, "i").replace("email", inline.gfm._extended_email).getRegex();
inline.breaks = {
  ...inline.gfm,
  br: edit(inline.br).replace("{2,}", "*").getRegex(),
  text: edit(inline.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
};

class _Lexer {
  tokens;
  options;
  state;
  tokenizer;
  inlineQueue;
  constructor(options) {
    this.tokens = [];
    this.tokens.links = Object.create(null);
    this.options = options || _defaults;
    this.options.tokenizer = this.options.tokenizer || new _Tokenizer;
    this.tokenizer = this.options.tokenizer;
    this.tokenizer.options = this.options;
    this.tokenizer.lexer = this;
    this.inlineQueue = [];
    this.state = {
      inLink: false,
      inRawBlock: false,
      top: true
    };
    const rules = {
      block: block.normal,
      inline: inline.normal
    };
    if (this.options.pedantic) {
      rules.block = block.pedantic;
      rules.inline = inline.pedantic;
    } else if (this.options.gfm) {
      rules.block = block.gfm;
      if (this.options.breaks) {
        rules.inline = inline.breaks;
      } else {
        rules.inline = inline.gfm;
      }
    }
    this.tokenizer.rules = rules;
  }
  static get rules() {
    return {
      block,
      inline
    };
  }
  static lex(src, options) {
    const lexer = new _Lexer(options);
    return lexer.lex(src);
  }
  static lexInline(src, options) {
    const lexer = new _Lexer(options);
    return lexer.inlineTokens(src);
  }
  lex(src) {
    src = src.replace(/\r\n|\r/g, "\n");
    this.blockTokens(src, this.tokens);
    let next;
    while (next = this.inlineQueue.shift()) {
      this.inlineTokens(next.src, next.tokens);
    }
    return this.tokens;
  }
  blockTokens(src, tokens = []) {
    if (this.options.pedantic) {
      src = src.replace(/\t/g, "    ").replace(/^ +$/gm, "");
    } else {
      src = src.replace(/^( *)(\t+)/gm, (_, leading, tabs) => {
        return leading + "    ".repeat(tabs.length);
      });
    }
    let token;
    let lastToken;
    let cutSrc;
    let lastParagraphClipped;
    while (src) {
      if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.space(src)) {
        src = src.substring(token.raw.length);
        if (token.raw.length === 1 && tokens.length > 0) {
          tokens[tokens.length - 1].raw += "\n";
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.code(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.fences(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.heading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.hr(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.blockquote(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.list(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.html(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.def(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.raw;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else if (!this.tokens.links[token.tag]) {
          this.tokens.links[token.tag] = {
            href: token.href,
            title: token.title
          };
        }
        continue;
      }
      if (token = this.tokenizer.table(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.lheading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startBlock) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startBlock.forEach((getStartIndex) => {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
        lastToken = tokens[tokens.length - 1];
        if (lastParagraphClipped && lastToken.type === "paragraph") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        lastParagraphClipped = cutSrc.length !== src.length;
        src = src.substring(token.raw.length);
        continue;
      }
      if (token = this.tokenizer.text(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    this.state.top = true;
    return tokens;
  }
  inline(src, tokens = []) {
    this.inlineQueue.push({ src, tokens });
    return tokens;
  }
  inlineTokens(src, tokens = []) {
    let token, lastToken, cutSrc;
    let maskedSrc = src;
    let match;
    let keepPrevChar, prevChar;
    if (this.tokens.links) {
      const links = Object.keys(this.tokens.links);
      if (links.length > 0) {
        while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
          if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
            maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
          }
        }
      }
    }
    while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    }
    while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
    }
    while (src) {
      if (!keepPrevChar) {
        prevChar = "";
      }
      keepPrevChar = false;
      if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.escape(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.tag(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === "text" && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.link(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.reflink(src, this.tokens.links)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === "text" && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.codespan(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.br(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.del(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.autolink(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (!this.state.inLink && (token = this.tokenizer.url(src))) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startInline) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startInline.forEach((getStartIndex) => {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (token = this.tokenizer.inlineText(cutSrc)) {
        src = src.substring(token.raw.length);
        if (token.raw.slice(-1) !== "_") {
          prevChar = token.raw.slice(-1);
        }
        keepPrevChar = true;
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    return tokens;
  }
}

class _Renderer {
  options;
  constructor(options) {
    this.options = options || _defaults;
  }
  code(code, infostring, escaped) {
    const lang = (infostring || "").match(/^\S*/)?.[0];
    code = code.replace(/\n$/, "") + "\n";
    if (!lang) {
      return "<pre><code>" + (escaped ? code : escape(code, true)) + "</code></pre>\n";
    }
    return '<pre><code class="language-' + escape(lang) + '">' + (escaped ? code : escape(code, true)) + "</code></pre>\n";
  }
  blockquote(quote) {
    return `<blockquote>\n${quote}</blockquote>\n`;
  }
  html(html, block2) {
    return html;
  }
  heading(text, level, raw) {
    return `<h${level}>${text}</h${level}>\n`;
  }
  hr() {
    return "<hr>\n";
  }
  list(body, ordered, start) {
    const type = ordered ? "ol" : "ul";
    const startatt = ordered && start !== 1 ? ' start="' + start + '"' : "";
    return "<" + type + startatt + ">\n" + body + "</" + type + ">\n";
  }
  listitem(text, task, checked) {
    return `<li>${text}</li>\n`;
  }
  checkbox(checked) {
    return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
  }
  paragraph(text) {
    return `<p>${text}</p>\n`;
  }
  table(header, body) {
    if (body)
      body = `<tbody>${body}</tbody>`;
    return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
  }
  tablerow(content) {
    return `<tr>\n${content}</tr>\n`;
  }
  tablecell(content, flags) {
    const type = flags.header ? "th" : "td";
    const tag = flags.align ? `<${type} align="${flags.align}">` : `<${type}>`;
    return tag + content + `</${type}>\n`;
  }
  strong(text) {
    return `<strong>${text}</strong>`;
  }
  em(text) {
    return `<em>${text}</em>`;
  }
  codespan(text) {
    return `<code>${text}</code>`;
  }
  br() {
    return "<br>";
  }
  del(text) {
    return `<del>${text}</del>`;
  }
  link(href, title, text) {
    const cleanHref = cleanUrl(href);
    if (cleanHref === null) {
      return text;
    }
    href = cleanHref;
    let out = '<a href="' + href + '"';
    if (title) {
      out += ' title="' + title + '"';
    }
    out += ">" + text + "</a>";
    return out;
  }
  image(href, title, text) {
    const cleanHref = cleanUrl(href);
    if (cleanHref === null) {
      return text;
    }
    href = cleanHref;
    let out = `<img src="${href}" alt="${text}"`;
    if (title) {
      out += ` title="${title}"`;
    }
    out += ">";
    return out;
  }
  text(text) {
    return text;
  }
}

class _TextRenderer {
  strong(text) {
    return text;
  }
  em(text) {
    return text;
  }
  codespan(text) {
    return text;
  }
  del(text) {
    return text;
  }
  html(text) {
    return text;
  }
  text(text) {
    return text;
  }
  link(href, title, text) {
    return "" + text;
  }
  image(href, title, text) {
    return "" + text;
  }
  br() {
    return "";
  }
}

class _Parser {
  options;
  renderer;
  textRenderer;
  constructor(options) {
    this.options = options || _defaults;
    this.options.renderer = this.options.renderer || new _Renderer;
    this.renderer = this.options.renderer;
    this.renderer.options = this.options;
    this.textRenderer = new _TextRenderer;
  }
  static parse(tokens, options) {
    const parser = new _Parser(options);
    return parser.parse(tokens);
  }
  static parseInline(tokens, options) {
    const parser = new _Parser(options);
    return parser.parseInline(tokens);
  }
  parse(tokens, top = true) {
    let out = "";
    for (let i = 0;i < tokens.length; i++) {
      const token = tokens[i];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        const genericToken = token;
        const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);
        if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(genericToken.type)) {
          out += ret || "";
          continue;
        }
      }
      switch (token.type) {
        case "space": {
          continue;
        }
        case "hr": {
          out += this.renderer.hr();
          continue;
        }
        case "heading": {
          const headingToken = token;
          out += this.renderer.heading(this.parseInline(headingToken.tokens), headingToken.depth, unescape2(this.parseInline(headingToken.tokens, this.textRenderer)));
          continue;
        }
        case "code": {
          const codeToken = token;
          out += this.renderer.code(codeToken.text, codeToken.lang, !!codeToken.escaped);
          continue;
        }
        case "table": {
          const tableToken = token;
          let header = "";
          let cell = "";
          for (let j = 0;j < tableToken.header.length; j++) {
            cell += this.renderer.tablecell(this.parseInline(tableToken.header[j].tokens), { header: true, align: tableToken.align[j] });
          }
          header += this.renderer.tablerow(cell);
          let body = "";
          for (let j = 0;j < tableToken.rows.length; j++) {
            const row = tableToken.rows[j];
            cell = "";
            for (let k = 0;k < row.length; k++) {
              cell += this.renderer.tablecell(this.parseInline(row[k].tokens), { header: false, align: tableToken.align[k] });
            }
            body += this.renderer.tablerow(cell);
          }
          out += this.renderer.table(header, body);
          continue;
        }
        case "blockquote": {
          const blockquoteToken = token;
          const body = this.parse(blockquoteToken.tokens);
          out += this.renderer.blockquote(body);
          continue;
        }
        case "list": {
          const listToken = token;
          const ordered = listToken.ordered;
          const start = listToken.start;
          const loose = listToken.loose;
          let body = "";
          for (let j = 0;j < listToken.items.length; j++) {
            const item = listToken.items[j];
            const checked = item.checked;
            const task = item.task;
            let itemBody = "";
            if (item.task) {
              const checkbox = this.renderer.checkbox(!!checked);
              if (loose) {
                if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
                  item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                  if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                    item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
                  }
                } else {
                  item.tokens.unshift({
                    type: "text",
                    text: checkbox + " "
                  });
                }
              } else {
                itemBody += checkbox + " ";
              }
            }
            itemBody += this.parse(item.tokens, loose);
            body += this.renderer.listitem(itemBody, task, !!checked);
          }
          out += this.renderer.list(body, ordered, start);
          continue;
        }
        case "html": {
          const htmlToken = token;
          out += this.renderer.html(htmlToken.text, htmlToken.block);
          continue;
        }
        case "paragraph": {
          const paragraphToken = token;
          out += this.renderer.paragraph(this.parseInline(paragraphToken.tokens));
          continue;
        }
        case "text": {
          let textToken = token;
          let body = textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text;
          while (i + 1 < tokens.length && tokens[i + 1].type === "text") {
            textToken = tokens[++i];
            body += "\n" + (textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text);
          }
          out += top ? this.renderer.paragraph(body) : body;
          continue;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return "";
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
  parseInline(tokens, renderer) {
    renderer = renderer || this.renderer;
    let out = "";
    for (let i = 0;i < tokens.length; i++) {
      const token = tokens[i];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        const ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
        if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token.type)) {
          out += ret || "";
          continue;
        }
      }
      switch (token.type) {
        case "escape": {
          const escapeToken = token;
          out += renderer.text(escapeToken.text);
          break;
        }
        case "html": {
          const tagToken = token;
          out += renderer.html(tagToken.text);
          break;
        }
        case "link": {
          const linkToken = token;
          out += renderer.link(linkToken.href, linkToken.title, this.parseInline(linkToken.tokens, renderer));
          break;
        }
        case "image": {
          const imageToken = token;
          out += renderer.image(imageToken.href, imageToken.title, imageToken.text);
          break;
        }
        case "strong": {
          const strongToken = token;
          out += renderer.strong(this.parseInline(strongToken.tokens, renderer));
          break;
        }
        case "em": {
          const emToken = token;
          out += renderer.em(this.parseInline(emToken.tokens, renderer));
          break;
        }
        case "codespan": {
          const codespanToken = token;
          out += renderer.codespan(codespanToken.text);
          break;
        }
        case "br": {
          out += renderer.br();
          break;
        }
        case "del": {
          const delToken = token;
          out += renderer.del(this.parseInline(delToken.tokens, renderer));
          break;
        }
        case "text": {
          const textToken = token;
          out += renderer.text(textToken.text);
          break;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return "";
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
}

class _Hooks {
  options;
  constructor(options) {
    this.options = options || _defaults;
  }
  static passThroughHooks = new Set([
    "preprocess",
    "postprocess"
  ]);
  preprocess(markdown) {
    return markdown;
  }
  postprocess(html) {
    return html;
  }
}

class Marked {
  defaults = _getDefaults();
  options = this.setOptions;
  parse = this.#parseMarkdown(_Lexer.lex, _Parser.parse);
  parseInline = this.#parseMarkdown(_Lexer.lexInline, _Parser.parseInline);
  Parser = _Parser;
  parser = _Parser.parse;
  Renderer = _Renderer;
  TextRenderer = _TextRenderer;
  Lexer = _Lexer;
  lexer = _Lexer.lex;
  Tokenizer = _Tokenizer;
  Hooks = _Hooks;
  constructor(...args) {
    this.use(...args);
  }
  walkTokens(tokens, callback) {
    let values = [];
    for (const token of tokens) {
      values = values.concat(callback.call(this, token));
      switch (token.type) {
        case "table": {
          const tableToken = token;
          for (const cell of tableToken.header) {
            values = values.concat(this.walkTokens(cell.tokens, callback));
          }
          for (const row of tableToken.rows) {
            for (const cell of row) {
              values = values.concat(this.walkTokens(cell.tokens, callback));
            }
          }
          break;
        }
        case "list": {
          const listToken = token;
          values = values.concat(this.walkTokens(listToken.items, callback));
          break;
        }
        default: {
          const genericToken = token;
          if (this.defaults.extensions?.childTokens?.[genericToken.type]) {
            this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {
              values = values.concat(this.walkTokens(genericToken[childTokens], callback));
            });
          } else if (genericToken.tokens) {
            values = values.concat(this.walkTokens(genericToken.tokens, callback));
          }
        }
      }
    }
    return values;
  }
  use(...args) {
    const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };
    args.forEach((pack) => {
      const opts = { ...pack };
      opts.async = this.defaults.async || opts.async || false;
      if (pack.extensions) {
        pack.extensions.forEach((ext) => {
          if (!ext.name) {
            throw new Error("extension name required");
          }
          if ("renderer" in ext) {
            const prevRenderer = extensions.renderers[ext.name];
            if (prevRenderer) {
              extensions.renderers[ext.name] = function(...args2) {
                let ret = ext.renderer.apply(this, args2);
                if (ret === false) {
                  ret = prevRenderer.apply(this, args2);
                }
                return ret;
              };
            } else {
              extensions.renderers[ext.name] = ext.renderer;
            }
          }
          if ("tokenizer" in ext) {
            if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
              throw new Error("extension level must be 'block' or 'inline'");
            }
            const extLevel = extensions[ext.level];
            if (extLevel) {
              extLevel.unshift(ext.tokenizer);
            } else {
              extensions[ext.level] = [ext.tokenizer];
            }
            if (ext.start) {
              if (ext.level === "block") {
                if (extensions.startBlock) {
                  extensions.startBlock.push(ext.start);
                } else {
                  extensions.startBlock = [ext.start];
                }
              } else if (ext.level === "inline") {
                if (extensions.startInline) {
                  extensions.startInline.push(ext.start);
                } else {
                  extensions.startInline = [ext.start];
                }
              }
            }
          }
          if (("childTokens" in ext) && ext.childTokens) {
            extensions.childTokens[ext.name] = ext.childTokens;
          }
        });
        opts.extensions = extensions;
      }
      if (pack.renderer) {
        const renderer = this.defaults.renderer || new _Renderer(this.defaults);
        for (const prop in pack.renderer) {
          const rendererFunc = pack.renderer[prop];
          const rendererKey = prop;
          const prevRenderer = renderer[rendererKey];
          renderer[rendererKey] = (...args2) => {
            let ret = rendererFunc.apply(renderer, args2);
            if (ret === false) {
              ret = prevRenderer.apply(renderer, args2);
            }
            return ret || "";
          };
        }
        opts.renderer = renderer;
      }
      if (pack.tokenizer) {
        const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);
        for (const prop in pack.tokenizer) {
          const tokenizerFunc = pack.tokenizer[prop];
          const tokenizerKey = prop;
          const prevTokenizer = tokenizer[tokenizerKey];
          tokenizer[tokenizerKey] = (...args2) => {
            let ret = tokenizerFunc.apply(tokenizer, args2);
            if (ret === false) {
              ret = prevTokenizer.apply(tokenizer, args2);
            }
            return ret;
          };
        }
        opts.tokenizer = tokenizer;
      }
      if (pack.hooks) {
        const hooks = this.defaults.hooks || new _Hooks;
        for (const prop in pack.hooks) {
          const hooksFunc = pack.hooks[prop];
          const hooksKey = prop;
          const prevHook = hooks[hooksKey];
          if (_Hooks.passThroughHooks.has(prop)) {
            hooks[hooksKey] = (arg) => {
              if (this.defaults.async) {
                return Promise.resolve(hooksFunc.call(hooks, arg)).then((ret2) => {
                  return prevHook.call(hooks, ret2);
                });
              }
              const ret = hooksFunc.call(hooks, arg);
              return prevHook.call(hooks, ret);
            };
          } else {
            hooks[hooksKey] = (...args2) => {
              let ret = hooksFunc.apply(hooks, args2);
              if (ret === false) {
                ret = prevHook.apply(hooks, args2);
              }
              return ret;
            };
          }
        }
        opts.hooks = hooks;
      }
      if (pack.walkTokens) {
        const walkTokens = this.defaults.walkTokens;
        const packWalktokens = pack.walkTokens;
        opts.walkTokens = function(token) {
          let values = [];
          values.push(packWalktokens.call(this, token));
          if (walkTokens) {
            values = values.concat(walkTokens.call(this, token));
          }
          return values;
        };
      }
      this.defaults = { ...this.defaults, ...opts };
    });
    return this;
  }
  setOptions(opt) {
    this.defaults = { ...this.defaults, ...opt };
    return this;
  }
  #parseMarkdown(lexer, parser) {
    return (src, options) => {
      const origOpt = { ...options };
      const opt = { ...this.defaults, ...origOpt };
      if (this.defaults.async === true && origOpt.async === false) {
        if (!opt.silent) {
          console.warn("marked(): The async option was set to true by an extension. The async: false option sent to parse will be ignored.");
        }
        opt.async = true;
      }
      const throwError = this.#onError(!!opt.silent, !!opt.async);
      if (typeof src === "undefined" || src === null) {
        return throwError(new Error("marked(): input parameter is undefined or null"));
      }
      if (typeof src !== "string") {
        return throwError(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected"));
      }
      if (opt.hooks) {
        opt.hooks.options = opt;
      }
      if (opt.async) {
        return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src2) => lexer(src2, opt)).then((tokens) => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens).then((tokens) => parser(tokens, opt)).then((html) => opt.hooks ? opt.hooks.postprocess(html) : html).catch(throwError);
      }
      try {
        if (opt.hooks) {
          src = opt.hooks.preprocess(src);
        }
        const tokens = lexer(src, opt);
        if (opt.walkTokens) {
          this.walkTokens(tokens, opt.walkTokens);
        }
        let html = parser(tokens, opt);
        if (opt.hooks) {
          html = opt.hooks.postprocess(html);
        }
        return html;
      } catch (e) {
        return throwError(e);
      }
    };
  }
  #onError(silent, async) {
    return (e) => {
      e.message += "\nPlease report this to https://github.com/markedjs/marked.";
      if (silent) {
        const msg = "<p>An error occurred:</p><pre>" + escape(e.message + "", true) + "</pre>";
        if (async) {
          return Promise.resolve(msg);
        }
        return msg;
      }
      if (async) {
        return Promise.reject(e);
      }
      throw e;
    };
  }
}
var markedInstance = new Marked;
marked.options = marked.setOptions = function(options) {
  markedInstance.setOptions(options);
  marked.defaults = markedInstance.defaults;
  changeDefaults(marked.defaults);
  return marked;
};
marked.getDefaults = _getDefaults;
marked.defaults = _defaults;
marked.use = function(...args) {
  markedInstance.use(...args);
  marked.defaults = markedInstance.defaults;
  changeDefaults(marked.defaults);
  return marked;
};
marked.walkTokens = function(tokens, callback) {
  return markedInstance.walkTokens(tokens, callback);
};
marked.parseInline = markedInstance.parseInline;
marked.Parser = _Parser;
marked.parser = _Parser.parse;
marked.Renderer = _Renderer;
marked.TextRenderer = _TextRenderer;
marked.Lexer = _Lexer;
marked.lexer = _Lexer.lex;
marked.Tokenizer = _Tokenizer;
marked.Hooks = _Hooks;
marked.parse = marked;
var options = marked.options;
var setOptions = marked.setOptions;
var use = marked.use;
var walkTokens = marked.walkTokens;
var parseInline = marked.parseInline;
var parser = _Parser.parse;
var lexer = _Lexer.lex;

// src/index.ts
import readline from "readline";

// node_modules/openai/version.mjs
var VERSION = "4.14.1";

// node_modules/openai/_shims/registry.mjs
function setShims(shims, options2 = { auto: false }) {
  if (auto) {
    throw new Error(`you must \`import 'openai/shims/${shims.kind}'\` before importing anything else from openai`);
  }
  if (kind) {
    throw new Error(`can't \`import 'openai/shims/${shims.kind}'\` after \`import 'openai/shims/${kind}'\``);
  }
  auto = options2.auto;
  kind = shims.kind;
  fetch = shims.fetch;
  Request = shims.Request;
  Response = shims.Response;
  Headers = shims.Headers;
  FormData = shims.FormData;
  Blob = shims.Blob;
  File = shims.File;
  ReadableStream = shims.ReadableStream;
  getMultipartRequestOptions = shims.getMultipartRequestOptions;
  getDefaultAgent = shims.getDefaultAgent;
  fileFromPath = shims.fileFromPath;
  isFsReadStream = shims.isFsReadStream;
}
var auto = false;
var kind = undefined;
var fetch = undefined;
var Request = undefined;
var Response = undefined;
var Headers = undefined;
var FormData = undefined;
var Blob = undefined;
var File = undefined;
var ReadableStream = undefined;
var getMultipartRequestOptions = undefined;
var getDefaultAgent = undefined;
var fileFromPath = undefined;
var isFsReadStream = undefined;

// node_modules/openai/_shims/node-runtime.mjs
var nf = __toESM(require_lib2(), 1);

// node_modules/formdata-node/lib/esm/FormData.js
init_File();
init_isFile();
import {inspect} from "util";

// node_modules/formdata-node/lib/esm/isBlob.js
init_Blob();
var isBlob = (value) => value instanceof Blob2;

// node_modules/formdata-node/lib/esm/FormData.js
init_isFunction();

// node_modules/formdata-node/lib/esm/deprecateConstructorEntries.js
import {deprecate} from "util";
var deprecateConstructorEntries = deprecate(() => {
}, "Constructor \"entries\" argument is not spec-compliant and will be removed in next major release.");

// node_modules/formdata-node/lib/esm/FormData.js
var __classPrivateFieldGet3 = function(receiver, state, kind2, f2) {
  if (kind2 === "a" && !f2)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f2 : kind2 === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _FormData_instances;
var _FormData_entries;
var _FormData_setEntry;

class FormData2 {
  constructor(entries) {
    _FormData_instances.add(this);
    _FormData_entries.set(this, new Map);
    if (entries) {
      deprecateConstructorEntries();
      entries.forEach(({ name, value, fileName }) => this.append(name, value, fileName));
    }
  }
  static [(_FormData_entries = new WeakMap, _FormData_instances = new WeakSet, Symbol.hasInstance)](value) {
    return Boolean(value && isFunction(value.constructor) && value[Symbol.toStringTag] === "FormData" && isFunction(value.append) && isFunction(value.set) && isFunction(value.get) && isFunction(value.getAll) && isFunction(value.has) && isFunction(value.delete) && isFunction(value.entries) && isFunction(value.values) && isFunction(value.keys) && isFunction(value[Symbol.iterator]) && isFunction(value.forEach));
  }
  append(name, value, fileName) {
    __classPrivateFieldGet3(this, _FormData_instances, "m", _FormData_setEntry).call(this, {
      name,
      fileName,
      append: true,
      rawValue: value,
      argsLength: arguments.length
    });
  }
  set(name, value, fileName) {
    __classPrivateFieldGet3(this, _FormData_instances, "m", _FormData_setEntry).call(this, {
      name,
      fileName,
      append: false,
      rawValue: value,
      argsLength: arguments.length
    });
  }
  get(name) {
    const field = __classPrivateFieldGet3(this, _FormData_entries, "f").get(String(name));
    if (!field) {
      return null;
    }
    return field[0];
  }
  getAll(name) {
    const field = __classPrivateFieldGet3(this, _FormData_entries, "f").get(String(name));
    if (!field) {
      return [];
    }
    return field.slice();
  }
  has(name) {
    return __classPrivateFieldGet3(this, _FormData_entries, "f").has(String(name));
  }
  delete(name) {
    __classPrivateFieldGet3(this, _FormData_entries, "f").delete(String(name));
  }
  *keys() {
    for (const key of __classPrivateFieldGet3(this, _FormData_entries, "f").keys()) {
      yield key;
    }
  }
  *entries() {
    for (const name of this.keys()) {
      const values = this.getAll(name);
      for (const value of values) {
        yield [name, value];
      }
    }
  }
  *values() {
    for (const [, value] of this) {
      yield value;
    }
  }
  [(_FormData_setEntry = function _FormData_setEntry({ name, rawValue, append, fileName, argsLength }) {
    const methodName = append ? "append" : "set";
    if (argsLength < 2) {
      throw new TypeError(`Failed to execute '${methodName}' on 'FormData': ` + `2 arguments required, but only ${argsLength} present.`);
    }
    name = String(name);
    let value;
    if (isFile(rawValue)) {
      value = fileName === undefined ? rawValue : new File2([rawValue], fileName, {
        type: rawValue.type,
        lastModified: rawValue.lastModified
      });
    } else if (isBlob(rawValue)) {
      value = new File2([rawValue], fileName === undefined ? "blob" : fileName, {
        type: rawValue.type
      });
    } else if (fileName) {
      throw new TypeError(`Failed to execute '${methodName}' on 'FormData': ` + "parameter 2 is not of type 'Blob'.");
    } else {
      value = String(rawValue);
    }
    const values = __classPrivateFieldGet3(this, _FormData_entries, "f").get(name);
    if (!values) {
      return void __classPrivateFieldGet3(this, _FormData_entries, "f").set(name, [value]);
    }
    if (!append) {
      return void __classPrivateFieldGet3(this, _FormData_entries, "f").set(name, [value]);
    }
    values.push(value);
  }, Symbol.iterator)]() {
    return this.entries();
  }
  forEach(callback, thisArg) {
    for (const [name, value] of this) {
      callback.call(thisArg, value, name, this);
    }
  }
  get [Symbol.toStringTag]() {
    return "FormData";
  }
  [inspect.custom]() {
    return this[Symbol.toStringTag];
  }
}

// node_modules/openai/_shims/node-runtime.mjs
var import_agentkeepalive = __toESM(require_agentkeepalive(), 1);
var import_abort_controller = __toESM(require_abort_controller(), 1);
import {ReadStream as FsReadStream} from "node:fs";

// node_modules/form-data-encoder/lib/esm/util/createBoundary.js
var createBoundary = function() {
  let size = 16;
  let res = "";
  while (size--) {
    res += alphabet[Math.random() * alphabet.length << 0];
  }
  return res;
};
var alphabet = "abcdefghijklmnopqrstuvwxyz0123456789";
var createBoundary_default = createBoundary;

// node_modules/form-data-encoder/lib/esm/util/isPlainObject.js
var isPlainObject = function(value) {
  if (getType(value) !== "object") {
    return false;
  }
  const pp = Object.getPrototypeOf(value);
  if (pp === null || pp === undefined) {
    return true;
  }
  const Ctor = pp.constructor && pp.constructor.toString();
  return Ctor === Object.toString();
};
var getType = (value) => Object.prototype.toString.call(value).slice(8, -1).toLowerCase();
var isPlainObject_default = isPlainObject;

// node_modules/form-data-encoder/lib/esm/util/normalizeValue.js
var normalizeValue = (value) => String(value).replace(/\r|\n/g, (match, i2, str) => {
  if (match === "\r" && str[i2 + 1] !== "\n" || match === "\n" && str[i2 - 1] !== "\r") {
    return "\r\n";
  }
  return match;
});
var normalizeValue_default = normalizeValue;

// node_modules/form-data-encoder/lib/esm/util/escapeName.js
var escapeName = (name) => String(name).replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/"/g, "%22");
var escapeName_default = escapeName;

// node_modules/form-data-encoder/lib/esm/util/isFunction.js
var isFunction5 = (value) => typeof value === "function";
var isFunction_default = isFunction5;

// node_modules/form-data-encoder/lib/esm/util/isFileLike.js
var isFileLike = (value) => Boolean(value && typeof value === "object" && isFunction_default(value.constructor) && value[Symbol.toStringTag] === "File" && isFunction_default(value.stream) && value.name != null && value.size != null && value.lastModified != null);

// node_modules/form-data-encoder/lib/esm/util/isFormData.js
var isFormData = (value) => Boolean(value && isFunction_default(value.constructor) && value[Symbol.toStringTag] === "FormData" && isFunction_default(value.append) && isFunction_default(value.getAll) && isFunction_default(value.entries) && isFunction_default(value[Symbol.iterator]));

// node_modules/form-data-encoder/lib/esm/FormDataEncoder.js
var __classPrivateFieldSet3 = function(receiver, state, value, kind2, f2) {
  if (kind2 === "m")
    throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f2)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet4 = function(receiver, state, kind2, f2) {
  if (kind2 === "a" && !f2)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f2 : kind2 === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _FormDataEncoder_instances;
var _FormDataEncoder_CRLF;
var _FormDataEncoder_CRLF_BYTES;
var _FormDataEncoder_CRLF_BYTES_LENGTH;
var _FormDataEncoder_DASHES;
var _FormDataEncoder_encoder;
var _FormDataEncoder_footer;
var _FormDataEncoder_form;
var _FormDataEncoder_options;
var _FormDataEncoder_getFieldHeader;
var defaultOptions = {
  enableAdditionalHeaders: false
};

class FormDataEncoder {
  constructor(form, boundaryOrOptions, options2) {
    _FormDataEncoder_instances.add(this);
    _FormDataEncoder_CRLF.set(this, "\r\n");
    _FormDataEncoder_CRLF_BYTES.set(this, undefined);
    _FormDataEncoder_CRLF_BYTES_LENGTH.set(this, undefined);
    _FormDataEncoder_DASHES.set(this, "-".repeat(2));
    _FormDataEncoder_encoder.set(this, new TextEncoder);
    _FormDataEncoder_footer.set(this, undefined);
    _FormDataEncoder_form.set(this, undefined);
    _FormDataEncoder_options.set(this, undefined);
    if (!isFormData(form)) {
      throw new TypeError("Expected first argument to be a FormData instance.");
    }
    let boundary;
    if (isPlainObject_default(boundaryOrOptions)) {
      options2 = boundaryOrOptions;
    } else {
      boundary = boundaryOrOptions;
    }
    if (!boundary) {
      boundary = createBoundary_default();
    }
    if (typeof boundary !== "string") {
      throw new TypeError("Expected boundary argument to be a string.");
    }
    if (options2 && !isPlainObject_default(options2)) {
      throw new TypeError("Expected options argument to be an object.");
    }
    __classPrivateFieldSet3(this, _FormDataEncoder_form, form, "f");
    __classPrivateFieldSet3(this, _FormDataEncoder_options, { ...defaultOptions, ...options2 }, "f");
    __classPrivateFieldSet3(this, _FormDataEncoder_CRLF_BYTES, __classPrivateFieldGet4(this, _FormDataEncoder_encoder, "f").encode(__classPrivateFieldGet4(this, _FormDataEncoder_CRLF, "f")), "f");
    __classPrivateFieldSet3(this, _FormDataEncoder_CRLF_BYTES_LENGTH, __classPrivateFieldGet4(this, _FormDataEncoder_CRLF_BYTES, "f").byteLength, "f");
    this.boundary = `form-data-boundary-${boundary}`;
    this.contentType = `multipart/form-data; boundary=${this.boundary}`;
    __classPrivateFieldSet3(this, _FormDataEncoder_footer, __classPrivateFieldGet4(this, _FormDataEncoder_encoder, "f").encode(`${__classPrivateFieldGet4(this, _FormDataEncoder_DASHES, "f")}${this.boundary}${__classPrivateFieldGet4(this, _FormDataEncoder_DASHES, "f")}${__classPrivateFieldGet4(this, _FormDataEncoder_CRLF, "f").repeat(2)}`), "f");
    this.contentLength = String(this.getContentLength());
    this.headers = Object.freeze({
      "Content-Type": this.contentType,
      "Content-Length": this.contentLength
    });
    Object.defineProperties(this, {
      boundary: { writable: false, configurable: false },
      contentType: { writable: false, configurable: false },
      contentLength: { writable: false, configurable: false },
      headers: { writable: false, configurable: false }
    });
  }
  getContentLength() {
    let length = 0;
    for (const [name, raw] of __classPrivateFieldGet4(this, _FormDataEncoder_form, "f")) {
      const value = isFileLike(raw) ? raw : __classPrivateFieldGet4(this, _FormDataEncoder_encoder, "f").encode(normalizeValue_default(raw));
      length += __classPrivateFieldGet4(this, _FormDataEncoder_instances, "m", _FormDataEncoder_getFieldHeader).call(this, name, value).byteLength;
      length += isFileLike(value) ? value.size : value.byteLength;
      length += __classPrivateFieldGet4(this, _FormDataEncoder_CRLF_BYTES_LENGTH, "f");
    }
    return length + __classPrivateFieldGet4(this, _FormDataEncoder_footer, "f").byteLength;
  }
  *values() {
    for (const [name, raw] of __classPrivateFieldGet4(this, _FormDataEncoder_form, "f").entries()) {
      const value = isFileLike(raw) ? raw : __classPrivateFieldGet4(this, _FormDataEncoder_encoder, "f").encode(normalizeValue_default(raw));
      yield __classPrivateFieldGet4(this, _FormDataEncoder_instances, "m", _FormDataEncoder_getFieldHeader).call(this, name, value);
      yield value;
      yield __classPrivateFieldGet4(this, _FormDataEncoder_CRLF_BYTES, "f");
    }
    yield __classPrivateFieldGet4(this, _FormDataEncoder_footer, "f");
  }
  async* encode() {
    for (const part of this.values()) {
      if (isFileLike(part)) {
        yield* part.stream();
      } else {
        yield part;
      }
    }
  }
  [(_FormDataEncoder_CRLF = new WeakMap, _FormDataEncoder_CRLF_BYTES = new WeakMap, _FormDataEncoder_CRLF_BYTES_LENGTH = new WeakMap, _FormDataEncoder_DASHES = new WeakMap, _FormDataEncoder_encoder = new WeakMap, _FormDataEncoder_footer = new WeakMap, _FormDataEncoder_form = new WeakMap, _FormDataEncoder_options = new WeakMap, _FormDataEncoder_instances = new WeakSet, _FormDataEncoder_getFieldHeader = function _FormDataEncoder_getFieldHeader(name, value) {
    let header = "";
    header += `${__classPrivateFieldGet4(this, _FormDataEncoder_DASHES, "f")}${this.boundary}${__classPrivateFieldGet4(this, _FormDataEncoder_CRLF, "f")}`;
    header += `Content-Disposition: form-data; name="${escapeName_default(name)}"`;
    if (isFileLike(value)) {
      header += `; filename="${escapeName_default(value.name)}"${__classPrivateFieldGet4(this, _FormDataEncoder_CRLF, "f")}`;
      header += `Content-Type: ${value.type || "application/octet-stream"}`;
    }
    if (__classPrivateFieldGet4(this, _FormDataEncoder_options, "f").enableAdditionalHeaders === true) {
      header += `${__classPrivateFieldGet4(this, _FormDataEncoder_CRLF, "f")}Content-Length: ${isFileLike(value) ? value.size : value.byteLength}`;
    }
    return __classPrivateFieldGet4(this, _FormDataEncoder_encoder, "f").encode(`${header}${__classPrivateFieldGet4(this, _FormDataEncoder_CRLF, "f").repeat(2)}`);
  }, Symbol.iterator)]() {
    return this.values();
  }
  [Symbol.asyncIterator]() {
    return this.encode();
  }
}

// node_modules/openai/_shims/node-runtime.mjs
import {Readable} from "node:stream";

// node_modules/openai/_shims/MultipartBody.mjs
class MultipartBody {
  constructor(body) {
    this.body = body;
  }
  get [Symbol.toStringTag]() {
    return "MultipartBody";
  }
}

// node_modules/openai/_shims/node-runtime.mjs
var ponyfill_es2018 = __toESM(require_ponyfill_es2018(), 1);
async function fileFromPath3(path, ...args) {
  const { fileFromPath: _fileFromPath } = await Promise.resolve().then(() => (init_fileFromPath(), exports_fileFromPath));
  if (!fileFromPathWarned) {
    console.warn(`fileFromPath is deprecated; use fs.createReadStream(${JSON.stringify(path)}) instead`);
    fileFromPathWarned = true;
  }
  return await _fileFromPath(path, ...args);
}
async function getMultipartRequestOptions2(form, opts) {
  const encoder = new FormDataEncoder(form);
  const readable = Readable.from(encoder);
  const body = new MultipartBody(readable);
  const headers = {
    ...opts.headers,
    ...encoder.headers,
    "Content-Length": encoder.contentLength
  };
  return { ...opts, body, headers };
}
function getRuntime() {
  if (typeof AbortController === "undefined") {
    globalThis.AbortController = import_abort_controller.AbortController;
  }
  return {
    kind: "node",
    fetch: nf.default,
    Request: nf.Request,
    Response: nf.Response,
    Headers: nf.Headers,
    FormData: FormData2,
    Blob: Blob2,
    File: File2,
    ReadableStream: ponyfill_es2018.ReadableStream,
    getMultipartRequestOptions: getMultipartRequestOptions2,
    getDefaultAgent: (url) => url.startsWith("https") ? defaultHttpsAgent : defaultHttpAgent,
    fileFromPath: fileFromPath3,
    isFsReadStream: (value) => value instanceof FsReadStream
  };
}
var fileFromPathWarned = false;
var defaultHttpAgent = new import_agentkeepalive.default({ keepAlive: true, timeout: 5 * 60 * 1000 });
var defaultHttpsAgent = new import_agentkeepalive.default.HttpsAgent({ keepAlive: true, timeout: 5 * 60 * 1000 });

// node_modules/openai/_shims/index.mjs
if (!kind)
  setShims(getRuntime(), { auto: true });

// node_modules/openai/error.mjs
class OpenAIError extends Error {
}

class APIError extends OpenAIError {
  constructor(status, error, message, headers) {
    super(`${APIError.makeMessage(status, error, message)}`);
    this.status = status;
    this.headers = headers;
    const data = error;
    this.error = data;
    this.code = data?.["code"];
    this.param = data?.["param"];
    this.type = data?.["type"];
  }
  static makeMessage(status, error, message) {
    const msg = error?.message ? typeof error.message === "string" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message;
    if (status && msg) {
      return `${status} ${msg}`;
    }
    if (status) {
      return `${status} status code (no body)`;
    }
    if (msg) {
      return msg;
    }
    return "(no status code or body)";
  }
  static generate(status, errorResponse, message, headers) {
    if (!status) {
      return new APIConnectionError({ cause: castToError(errorResponse) });
    }
    const error = errorResponse?.["error"];
    if (status === 400) {
      return new BadRequestError(status, error, message, headers);
    }
    if (status === 401) {
      return new AuthenticationError(status, error, message, headers);
    }
    if (status === 403) {
      return new PermissionDeniedError(status, error, message, headers);
    }
    if (status === 404) {
      return new NotFoundError(status, error, message, headers);
    }
    if (status === 409) {
      return new ConflictError(status, error, message, headers);
    }
    if (status === 422) {
      return new UnprocessableEntityError(status, error, message, headers);
    }
    if (status === 429) {
      return new RateLimitError(status, error, message, headers);
    }
    if (status >= 500) {
      return new InternalServerError(status, error, message, headers);
    }
    return new APIError(status, error, message, headers);
  }
}

class APIUserAbortError extends APIError {
  constructor({ message } = {}) {
    super(undefined, undefined, message || "Request was aborted.", undefined);
    this.status = undefined;
  }
}

class APIConnectionError extends APIError {
  constructor({ message, cause }) {
    super(undefined, undefined, message || "Connection error.", undefined);
    this.status = undefined;
    if (cause)
      this.cause = cause;
  }
}

class APIConnectionTimeoutError extends APIConnectionError {
  constructor({ message } = {}) {
    super({ message: message ?? "Request timed out." });
  }
}

class BadRequestError extends APIError {
  constructor() {
    super(...arguments);
    this.status = 400;
  }
}

class AuthenticationError extends APIError {
  constructor() {
    super(...arguments);
    this.status = 401;
  }
}

class PermissionDeniedError extends APIError {
  constructor() {
    super(...arguments);
    this.status = 403;
  }
}

class NotFoundError extends APIError {
  constructor() {
    super(...arguments);
    this.status = 404;
  }
}

class ConflictError extends APIError {
  constructor() {
    super(...arguments);
    this.status = 409;
  }
}

class UnprocessableEntityError extends APIError {
  constructor() {
    super(...arguments);
    this.status = 422;
  }
}

class RateLimitError extends APIError {
  constructor() {
    super(...arguments);
    this.status = 429;
  }
}

class InternalServerError extends APIError {
}

// node_modules/openai/streaming.mjs
var partition = function(str, delimiter) {
  const index = str.indexOf(delimiter);
  if (index !== -1) {
    return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];
  }
  return [str, "", ""];
};
var readableStreamAsyncIterable = function(stream) {
  if (stream[Symbol.asyncIterator])
    return stream;
  const reader = stream.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result?.done)
          reader.releaseLock();
        return result;
      } catch (e2) {
        reader.releaseLock();
        throw e2;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: undefined };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
};

class Stream {
  constructor(iterator, controller) {
    this.iterator = iterator;
    this.controller = controller;
  }
  static fromSSEResponse(response, controller) {
    let consumed = false;
    const decoder = new SSEDecoder;
    async function* iterMessages() {
      if (!response.body) {
        controller.abort();
        throw new OpenAIError(`Attempted to iterate over a response with no body`);
      }
      const lineDecoder = new LineDecoder;
      const iter = readableStreamAsyncIterable(response.body);
      for await (const chunk of iter) {
        for (const line of lineDecoder.decode(chunk)) {
          const sse = decoder.decode(line);
          if (sse)
            yield sse;
        }
      }
      for (const line of lineDecoder.flush()) {
        const sse = decoder.decode(line);
        if (sse)
          yield sse;
      }
    }
    async function* iterator() {
      if (consumed) {
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const sse of iterMessages()) {
          if (done)
            continue;
          if (sse.data.startsWith("[DONE]")) {
            done = true;
            continue;
          }
          if (sse.event === null) {
            let data;
            try {
              data = JSON.parse(sse.data);
            } catch (e2) {
              console.error(`Could not parse message into JSON:`, sse.data);
              console.error(`From chunk:`, sse.raw);
              throw e2;
            }
            if (data && data.error) {
              throw new APIError(undefined, data.error, undefined, undefined);
            }
            yield data;
          }
        }
        done = true;
      } catch (e2) {
        if (e2 instanceof Error && e2.name === "AbortError")
          return;
        throw e2;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new Stream(iterator, controller);
  }
  static fromReadableStream(readableStream, controller) {
    let consumed = false;
    async function* iterLines() {
      const lineDecoder = new LineDecoder;
      const iter = readableStreamAsyncIterable(readableStream);
      for await (const chunk of iter) {
        for (const line of lineDecoder.decode(chunk)) {
          yield line;
        }
      }
      for (const line of lineDecoder.flush()) {
        yield line;
      }
    }
    async function* iterator() {
      if (consumed) {
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const line of iterLines()) {
          if (done)
            continue;
          if (line)
            yield JSON.parse(line);
        }
        done = true;
      } catch (e2) {
        if (e2 instanceof Error && e2.name === "AbortError")
          return;
        throw e2;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new Stream(iterator, controller);
  }
  [Symbol.asyncIterator]() {
    return this.iterator();
  }
  tee() {
    const left = [];
    const right = [];
    const iterator = this.iterator();
    const teeIterator = (queue) => {
      return {
        next: () => {
          if (queue.length === 0) {
            const result = iterator.next();
            left.push(result);
            right.push(result);
          }
          return queue.shift();
        }
      };
    };
    return [
      new Stream(() => teeIterator(left), this.controller),
      new Stream(() => teeIterator(right), this.controller)
    ];
  }
  toReadableStream() {
    const self2 = this;
    let iter;
    const encoder = new TextEncoder;
    return new ReadableStream({
      async start() {
        iter = self2[Symbol.asyncIterator]();
      },
      async pull(ctrl) {
        try {
          const { value, done } = await iter.next();
          if (done)
            return ctrl.close();
          const bytes = encoder.encode(JSON.stringify(value) + "\n");
          ctrl.enqueue(bytes);
        } catch (err) {
          ctrl.error(err);
        }
      },
      async cancel() {
        await iter.return?.();
      }
    });
  }
}

class SSEDecoder {
  constructor() {
    this.event = null;
    this.data = [];
    this.chunks = [];
  }
  decode(line) {
    if (line.endsWith("\r")) {
      line = line.substring(0, line.length - 1);
    }
    if (!line) {
      if (!this.event && !this.data.length)
        return null;
      const sse = {
        event: this.event,
        data: this.data.join("\n"),
        raw: this.chunks
      };
      this.event = null;
      this.data = [];
      this.chunks = [];
      return sse;
    }
    this.chunks.push(line);
    if (line.startsWith(":")) {
      return null;
    }
    let [fieldname, _2, value] = partition(line, ":");
    if (value.startsWith(" ")) {
      value = value.substring(1);
    }
    if (fieldname === "event") {
      this.event = value;
    } else if (fieldname === "data") {
      this.data.push(value);
    }
    return null;
  }
}

class LineDecoder {
  constructor() {
    this.buffer = [];
    this.trailingCR = false;
  }
  decode(chunk) {
    let text = this.decodeText(chunk);
    if (this.trailingCR) {
      text = "\r" + text;
      this.trailingCR = false;
    }
    if (text.endsWith("\r")) {
      this.trailingCR = true;
      text = text.slice(0, -1);
    }
    if (!text) {
      return [];
    }
    const trailingNewline = LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || "");
    let lines = text.split(LineDecoder.NEWLINE_REGEXP);
    if (lines.length === 1 && !trailingNewline) {
      this.buffer.push(lines[0]);
      return [];
    }
    if (this.buffer.length > 0) {
      lines = [this.buffer.join("") + lines[0], ...lines.slice(1)];
      this.buffer = [];
    }
    if (!trailingNewline) {
      this.buffer = [lines.pop() || ""];
    }
    return lines;
  }
  decodeText(bytes) {
    if (bytes == null)
      return "";
    if (typeof bytes === "string")
      return bytes;
    if (typeof Buffer !== "undefined") {
      if (bytes instanceof Buffer) {
        return bytes.toString();
      }
      if (bytes instanceof Uint8Array) {
        return Buffer.from(bytes).toString();
      }
      throw new OpenAIError(`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`);
    }
    if (typeof TextDecoder !== "undefined") {
      if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {
        this.textDecoder ?? (this.textDecoder = new TextDecoder("utf8"));
        return this.textDecoder.decode(bytes);
      }
      throw new OpenAIError(`Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`);
    }
    throw new OpenAIError(`Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`);
  }
  flush() {
    if (!this.buffer.length && !this.trailingCR) {
      return [];
    }
    const lines = [this.buffer.join("")];
    this.buffer = [];
    this.trailingCR = false;
    return lines;
  }
}
LineDecoder.NEWLINE_CHARS = new Set(["\n", "\r", "\v", "\f", "\x1C", "\x1D", "\x1E", "\x85", "\u2028", "\u2029"]);
LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r\x0b\x0c\x1c\x1d\x1e\x85\u2028\u2029]/g;

// node_modules/openai/uploads.mjs
async function toFile(value, name, options2 = {}) {
  value = await value;
  if (isResponseLike(value)) {
    const blob = await value.blob();
    name || (name = new URL(value.url).pathname.split(/[\\/]/).pop() ?? "unknown_file");
    return new File([blob], name, options2);
  }
  const bits = await getBytes(value);
  name || (name = getName(value) ?? "unknown_file");
  if (!options2.type) {
    const type = bits[0]?.type;
    if (typeof type === "string") {
      options2 = { ...options2, type };
    }
  }
  return new File(bits, name, options2);
}
async function getBytes(value) {
  let parts = [];
  if (typeof value === "string" || ArrayBuffer.isView(value) || value instanceof ArrayBuffer) {
    parts.push(value);
  } else if (isBlobLike(value)) {
    parts.push(await value.arrayBuffer());
  } else if (isAsyncIterableIterator(value)) {
    for await (const chunk of value) {
      parts.push(chunk);
    }
  } else {
    throw new Error(`Unexpected data type: ${typeof value}; constructor: ${value?.constructor?.name}; props: ${propsForError(value)}`);
  }
  return parts;
}
var propsForError = function(value) {
  const props = Object.getOwnPropertyNames(value);
  return `[${props.map((p2) => `"${p2}"`).join(", ")}]`;
};
var getName = function(value) {
  return getStringFromMaybeBuffer(value.name) || getStringFromMaybeBuffer(value.filename) || getStringFromMaybeBuffer(value.path)?.split(/[\\/]/).pop();
};
var isResponseLike = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
var isFileLike3 = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike(value);
var isBlobLike = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
var isUploadable = (value) => {
  return isFileLike3(value) || isResponseLike(value) || isFsReadStream(value);
};
var getStringFromMaybeBuffer = (x2) => {
  if (typeof x2 === "string")
    return x2;
  if (typeof Buffer !== "undefined" && x2 instanceof Buffer)
    return String(x2);
  return;
};
var isAsyncIterableIterator = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
var isMultipartBody = (body) => body && typeof body === "object" && body.body && body[Symbol.toStringTag] === "MultipartBody";
var multipartFormRequestOptions = async (opts) => {
  const form = await createForm(opts.body);
  return getMultipartRequestOptions(form, opts);
};
var createForm = async (body) => {
  const form = new FormData;
  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));
  return form;
};
var addFormValue = async (form, key, value) => {
  if (value === undefined)
    return;
  if (value == null) {
    throw new TypeError(`Received null for "${key}"; to pass null in FormData, you must use the string 'null'`);
  }
  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
    form.append(key, String(value));
  } else if (isUploadable(value)) {
    const file = await toFile(value);
    form.append(key, file);
  } else if (Array.isArray(value)) {
    await Promise.all(value.map((entry) => addFormValue(form, key + "[]", entry)));
  } else if (typeof value === "object") {
    await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)));
  } else {
    throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);
  }
};

// node_modules/openai/core.mjs
async function defaultParseResponse(props) {
  const { response } = props;
  if (props.options.stream) {
    debug("response", response.status, response.url, response.headers, response.body);
    return Stream.fromSSEResponse(response, props.controller);
  }
  if (response.status === 204) {
    return null;
  }
  const contentType = response.headers.get("content-type");
  if (contentType?.includes("application/json")) {
    const json = await response.json();
    debug("response", response.status, response.url, response.headers, json);
    return json;
  }
  const text = await response.text();
  debug("response", response.status, response.url, response.headers, text);
  return text;
}
var getBrowserInfo = function() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key, pattern } of browserPatterns) {
    const match = pattern.exec(navigator.userAgent);
    if (match) {
      const major = match[1] || 0;
      const minor = match[2] || 0;
      const patch = match[3] || 0;
      return { browser: key, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
};
function isEmptyObj(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}
function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function debug(action, ...args) {
  if (typeof process !== "undefined" && process.env["DEBUG"] === "true") {
    console.log(`OpenAI:DEBUG:${action}`, ...args);
  }
}
var __classPrivateFieldSet5 = function(receiver, state, value, kind2, f2) {
  if (kind2 === "m")
    throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f2)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet6 = function(receiver, state, kind2, f2) {
  if (kind2 === "a" && !f2)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f2 : kind2 === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _AbstractPage_client;

class APIPromise extends Promise {
  constructor(responsePromise, parseResponse = defaultParseResponse) {
    super((resolve) => {
      resolve(null);
    });
    this.responsePromise = responsePromise;
    this.parseResponse = parseResponse;
  }
  _thenUnwrap(transform) {
    return new APIPromise(this.responsePromise, async (props) => transform(await this.parseResponse(props)));
  }
  asResponse() {
    return this.responsePromise.then((p2) => p2.response);
  }
  async withResponse() {
    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
    return { data, response };
  }
  parse() {
    if (!this.parsedPromise) {
      this.parsedPromise = this.responsePromise.then(this.parseResponse);
    }
    return this.parsedPromise;
  }
  then(onfulfilled, onrejected) {
    return this.parse().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.parse().catch(onrejected);
  }
  finally(onfinally) {
    return this.parse().finally(onfinally);
  }
}

class APIClient {
  constructor({
    baseURL,
    maxRetries = 2,
    timeout = 600000,
    httpAgent,
    fetch: overridenFetch
  }) {
    this.baseURL = baseURL;
    this.maxRetries = validatePositiveInteger("maxRetries", maxRetries);
    this.timeout = validatePositiveInteger("timeout", timeout);
    this.httpAgent = httpAgent;
    this.fetch = overridenFetch ?? fetch;
  }
  authHeaders(opts) {
    return {};
  }
  defaultHeaders(opts) {
    return {
      Accept: "application/json",
      "Content-Type": "application/json",
      "User-Agent": this.getUserAgent(),
      ...getPlatformHeaders(),
      ...this.authHeaders(opts)
    };
  }
  validateHeaders(headers, customHeaders) {
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${uuid4()}`;
  }
  get(path, opts) {
    return this.methodRequest("get", path, opts);
  }
  post(path, opts) {
    return this.methodRequest("post", path, opts);
  }
  patch(path, opts) {
    return this.methodRequest("patch", path, opts);
  }
  put(path, opts) {
    return this.methodRequest("put", path, opts);
  }
  delete(path, opts) {
    return this.methodRequest("delete", path, opts);
  }
  methodRequest(method, path, opts) {
    return this.request(Promise.resolve(opts).then((opts2) => ({ method, path, ...opts2 })));
  }
  getAPIList(path, Page, opts) {
    return this.requestAPIList(Page, { method: "get", path, ...opts });
  }
  calculateContentLength(body) {
    if (typeof body === "string") {
      if (typeof Buffer !== "undefined") {
        return Buffer.byteLength(body, "utf8").toString();
      }
      if (typeof TextEncoder !== "undefined") {
        const encoder = new TextEncoder;
        const encoded = encoder.encode(body);
        return encoded.length.toString();
      }
    }
    return null;
  }
  buildRequest(options2) {
    const { method, path, query, headers = {} } = options2;
    const body = isMultipartBody(options2.body) ? options2.body.body : options2.body ? JSON.stringify(options2.body, null, 2) : null;
    const contentLength = this.calculateContentLength(body);
    const url = this.buildURL(path, query);
    if ("timeout" in options2)
      validatePositiveInteger("timeout", options2.timeout);
    const timeout = options2.timeout ?? this.timeout;
    const httpAgent = options2.httpAgent ?? this.httpAgent ?? getDefaultAgent(url);
    const minAgentTimeout = timeout + 1000;
    if (typeof httpAgent?.options?.timeout === "number" && minAgentTimeout > (httpAgent.options.timeout ?? 0)) {
      httpAgent.options.timeout = minAgentTimeout;
    }
    if (this.idempotencyHeader && method !== "get") {
      if (!options2.idempotencyKey)
        options2.idempotencyKey = this.defaultIdempotencyKey();
      headers[this.idempotencyHeader] = options2.idempotencyKey;
    }
    const reqHeaders = {
      ...contentLength && { "Content-Length": contentLength },
      ...this.defaultHeaders(options2),
      ...headers
    };
    if (isMultipartBody(options2.body) && kind !== "node") {
      delete reqHeaders["Content-Type"];
    }
    Object.keys(reqHeaders).forEach((key) => reqHeaders[key] === null && delete reqHeaders[key]);
    const req = {
      method,
      ...body && { body },
      headers: reqHeaders,
      ...httpAgent && { agent: httpAgent },
      signal: options2.signal ?? null
    };
    this.validateHeaders(reqHeaders, headers);
    return { req, url, timeout };
  }
  async prepareRequest(request, { url, options: options2 }) {
  }
  parseHeaders(headers) {
    return !headers ? {} : (Symbol.iterator in headers) ? Object.fromEntries(Array.from(headers).map((header) => [...header])) : { ...headers };
  }
  makeStatusError(status, error4, message, headers) {
    return APIError.generate(status, error4, message, headers);
  }
  request(options2, remainingRetries = null) {
    return new APIPromise(this.makeRequest(options2, remainingRetries));
  }
  async makeRequest(optionsInput, retriesRemaining) {
    const options2 = await optionsInput;
    if (retriesRemaining == null) {
      retriesRemaining = options2.maxRetries ?? this.maxRetries;
    }
    const { req, url, timeout } = this.buildRequest(options2);
    await this.prepareRequest(req, { url, options: options2 });
    debug("request", url, options2, req.headers);
    if (options2.signal?.aborted) {
      throw new APIUserAbortError;
    }
    const controller = new AbortController;
    const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);
    if (response instanceof Error) {
      if (options2.signal?.aborted) {
        throw new APIUserAbortError;
      }
      if (retriesRemaining) {
        return this.retryRequest(options2, retriesRemaining);
      }
      if (response.name === "AbortError") {
        throw new APIConnectionTimeoutError;
      }
      throw new APIConnectionError({ cause: response });
    }
    const responseHeaders = createResponseHeaders(response.headers);
    if (!response.ok) {
      if (retriesRemaining && this.shouldRetry(response)) {
        return this.retryRequest(options2, retriesRemaining, responseHeaders);
      }
      const errText = await response.text().catch((e2) => castToError(e2).message);
      const errJSON = safeJSON(errText);
      const errMessage = errJSON ? undefined : errText;
      debug("response", response.status, url, responseHeaders, errMessage);
      const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);
      throw err;
    }
    return { response, options: options2, controller };
  }
  requestAPIList(Page, options2) {
    const request = this.makeRequest(options2, null);
    return new PagePromise(this, request, Page);
  }
  buildURL(path, query) {
    const url = isAbsoluteURL(path) ? new URL(path) : new URL(this.baseURL + (this.baseURL.endsWith("/") && path.startsWith("/") ? path.slice(1) : path));
    const defaultQuery = this.defaultQuery();
    if (!isEmptyObj(defaultQuery)) {
      query = { ...defaultQuery, ...query };
    }
    if (query) {
      url.search = this.stringifyQuery(query);
    }
    return url.toString();
  }
  stringifyQuery(query) {
    return Object.entries(query).filter(([_2, value]) => typeof value !== "undefined").map(([key, value]) => {
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
      }
      if (value === null) {
        return `${encodeURIComponent(key)}=`;
      }
      throw new OpenAIError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
    }).join("&");
  }
  async fetchWithTimeout(url, init, ms, controller) {
    const { signal, ...options2 } = init || {};
    if (signal)
      signal.addEventListener("abort", () => controller.abort());
    const timeout = setTimeout(() => controller.abort(), ms);
    return this.getRequestClient().fetch.call(undefined, url, { signal: controller.signal, ...options2 }).finally(() => {
      clearTimeout(timeout);
    });
  }
  getRequestClient() {
    return { fetch: this.fetch };
  }
  shouldRetry(response) {
    const shouldRetryHeader = response.headers.get("x-should-retry");
    if (shouldRetryHeader === "true")
      return true;
    if (shouldRetryHeader === "false")
      return false;
    if (response.status === 408)
      return true;
    if (response.status === 409)
      return true;
    if (response.status === 429)
      return true;
    if (response.status >= 500)
      return true;
    return false;
  }
  async retryRequest(options2, retriesRemaining, responseHeaders) {
    let timeoutMillis;
    const retryAfterHeader = responseHeaders?.["retry-after"];
    if (retryAfterHeader) {
      const timeoutSeconds = parseInt(retryAfterHeader);
      if (!Number.isNaN(timeoutSeconds)) {
        timeoutMillis = timeoutSeconds * 1000;
      } else {
        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
      }
    }
    if (!timeoutMillis || !Number.isInteger(timeoutMillis) || timeoutMillis <= 0 || timeoutMillis > 60 * 1000) {
      const maxRetries = options2.maxRetries ?? this.maxRetries;
      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
    }
    await sleep(timeoutMillis);
    return this.makeRequest(options2, retriesRemaining - 1);
  }
  calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
    const initialRetryDelay = 0.5;
    const maxRetryDelay = 8;
    const numRetries = maxRetries - retriesRemaining;
    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
    const jitter = 1 - Math.random() * 0.25;
    return sleepSeconds * jitter * 1000;
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${VERSION}`;
  }
}
class AbstractPage {
  constructor(client, response, body, options2) {
    _AbstractPage_client.set(this, undefined);
    __classPrivateFieldSet5(this, _AbstractPage_client, client, "f");
    this.options = options2;
    this.response = response;
    this.body = body;
  }
  hasNextPage() {
    const items = this.getPaginatedItems();
    if (!items.length)
      return false;
    return this.nextPageInfo() != null;
  }
  async getNextPage() {
    const nextInfo = this.nextPageInfo();
    if (!nextInfo) {
      throw new OpenAIError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
    }
    const nextOptions = { ...this.options };
    if ("params" in nextInfo) {
      nextOptions.query = { ...nextOptions.query, ...nextInfo.params };
    } else if ("url" in nextInfo) {
      const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];
      for (const [key, value] of params) {
        nextInfo.url.searchParams.set(key, value);
      }
      nextOptions.query = undefined;
      nextOptions.path = nextInfo.url.toString();
    }
    return await __classPrivateFieldGet6(this, _AbstractPage_client, "f").requestAPIList(this.constructor, nextOptions);
  }
  async* iterPages() {
    let page = this;
    yield page;
    while (page.hasNextPage()) {
      page = await page.getNextPage();
      yield page;
    }
  }
  async* [(_AbstractPage_client = new WeakMap, Symbol.asyncIterator)]() {
    for await (const page of this.iterPages()) {
      for (const item of page.getPaginatedItems()) {
        yield item;
      }
    }
  }
}

class PagePromise extends APIPromise {
  constructor(client, request, Page) {
    super(request, async (props) => new Page(client, props.response, await defaultParseResponse(props), props.options));
  }
  async* [Symbol.asyncIterator]() {
    const page = await this;
    for await (const item of page) {
      yield item;
    }
  }
}
var createResponseHeaders = (headers) => {
  return new Proxy(Object.fromEntries(headers.entries()), {
    get(target, name) {
      const key = name.toString();
      return target[key.toLowerCase()] || target[key];
    }
  });
};
var requestOptionsKeys = {
  method: true,
  path: true,
  query: true,
  body: true,
  headers: true,
  maxRetries: true,
  stream: true,
  timeout: true,
  httpAgent: true,
  signal: true,
  idempotencyKey: true
};
var isRequestOptions = (obj) => {
  return typeof obj === "object" && obj !== null && !isEmptyObj(obj) && Object.keys(obj).every((k2) => hasOwn(requestOptionsKeys, k2));
};
var getPlatformProperties = () => {
  if (typeof Deno !== "undefined" && Deno.build != null) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(Deno.build.os),
      "X-Stainless-Arch": normalizeArch(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": Deno.version
    };
  }
  if (typeof EdgeRuntime !== "undefined") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": process.version
    };
  }
  if (Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(process.platform),
      "X-Stainless-Arch": normalizeArch(process.arch),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": process.version
    };
  }
  const browserInfo = getBrowserInfo();
  if (browserInfo) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
      "X-Stainless-Runtime-Version": browserInfo.version
    };
  }
  return {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": VERSION,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
var normalizeArch = (arch) => {
  if (arch === "x32")
    return "x32";
  if (arch === "x86_64" || arch === "x64")
    return "x64";
  if (arch === "arm")
    return "arm";
  if (arch === "aarch64" || arch === "arm64")
    return "arm64";
  if (arch)
    return `other:${arch}`;
  return "unknown";
};
var normalizePlatform = (platform) => {
  platform = platform.toLowerCase();
  if (platform.includes("ios"))
    return "iOS";
  if (platform === "android")
    return "Android";
  if (platform === "darwin")
    return "MacOS";
  if (platform === "win32")
    return "Windows";
  if (platform === "freebsd")
    return "FreeBSD";
  if (platform === "openbsd")
    return "OpenBSD";
  if (platform === "linux")
    return "Linux";
  if (platform)
    return `Other:${platform}`;
  return "Unknown";
};
var _platformHeaders;
var getPlatformHeaders = () => {
  return _platformHeaders ?? (_platformHeaders = getPlatformProperties());
};
var safeJSON = (text) => {
  try {
    return JSON.parse(text);
  } catch (err) {
    return;
  }
};
var startsWithSchemeRegexp = new RegExp("^(?:[a-z]+:)?//", "i");
var isAbsoluteURL = (url) => {
  return startsWithSchemeRegexp.test(url);
};
var sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
var validatePositiveInteger = (name, n2) => {
  if (typeof n2 !== "number" || !Number.isInteger(n2)) {
    throw new OpenAIError(`${name} must be an integer`);
  }
  if (n2 < 0) {
    throw new OpenAIError(`${name} must be a positive integer`);
  }
  return n2;
};
var castToError = (err) => {
  if (err instanceof Error)
    return err;
  return new Error(err);
};
var readEnv = (env) => {
  if (typeof process !== "undefined") {
    return process.env?.[env] ?? undefined;
  }
  if (typeof Deno !== "undefined") {
    return Deno.env?.get?.(env);
  }
  return;
};
var uuid4 = () => {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c2) => {
    const r2 = Math.random() * 16 | 0;
    const v2 = c2 === "x" ? r2 : r2 & 3 | 8;
    return v2.toString(16);
  });
};
var isRunningInBrowser = () => {
  return typeof window !== "undefined" && typeof window.document !== "undefined" && typeof navigator !== "undefined";
};

// node_modules/openai/pagination.mjs
class Page extends AbstractPage {
  constructor(client, response, body, options2) {
    super(client, response, body, options2);
    this.data = body.data;
    this.object = body.object;
  }
  getPaginatedItems() {
    return this.data;
  }
  nextPageParams() {
    return null;
  }
  nextPageInfo() {
    return null;
  }
}

class CursorPage extends AbstractPage {
  constructor(client, response, body, options2) {
    super(client, response, body, options2);
    this.data = body.data;
  }
  getPaginatedItems() {
    return this.data;
  }
  nextPageParams() {
    const info = this.nextPageInfo();
    if (!info)
      return null;
    if ("params" in info)
      return info.params;
    const params = Object.fromEntries(info.url.searchParams);
    if (!Object.keys(params).length)
      return null;
    return params;
  }
  nextPageInfo() {
    if (!this.data?.length) {
      return null;
    }
    const next = this.data[this.data.length - 1]?.id;
    if (!next)
      return null;
    return { params: { after: next } };
  }
}

// node_modules/openai/resource.mjs
class APIResource {
  constructor(client) {
    this.client = client;
    this.get = client.get.bind(client);
    this.post = client.post.bind(client);
    this.patch = client.patch.bind(client);
    this.put = client.put.bind(client);
    this.delete = client.delete.bind(client);
    this.getAPIList = client.getAPIList.bind(client);
  }
}

// node_modules/openai/resources/chat/completions.mjs
class Completions extends APIResource {
  create(body, options2) {
    return this.post("/chat/completions", { body, ...options2, stream: body.stream ?? false });
  }
}
(function(Completions2) {
})(Completions || (Completions = {}));

// node_modules/openai/resources/chat/chat.mjs
class Chat extends APIResource {
  constructor() {
    super(...arguments);
    this.completions = new Completions(this.client);
  }
}
(function(Chat2) {
  Chat2.Completions = Completions;
})(Chat || (Chat = {}));
// node_modules/openai/resources/audio/transcriptions.mjs
class Transcriptions extends APIResource {
  create(body, options2) {
    return this.post("/audio/transcriptions", multipartFormRequestOptions({ body, ...options2 }));
  }
}
(function(Transcriptions2) {
})(Transcriptions || (Transcriptions = {}));

// node_modules/openai/resources/audio/translations.mjs
class Translations extends APIResource {
  create(body, options2) {
    return this.post("/audio/translations", multipartFormRequestOptions({ body, ...options2 }));
  }
}
(function(Translations2) {
})(Translations || (Translations = {}));

// node_modules/openai/resources/audio/audio.mjs
class Audio extends APIResource {
  constructor() {
    super(...arguments);
    this.transcriptions = new Transcriptions(this.client);
    this.translations = new Translations(this.client);
  }
}
(function(Audio2) {
  Audio2.Transcriptions = Transcriptions;
  Audio2.Translations = Translations;
})(Audio || (Audio = {}));
// node_modules/openai/resources/completions.mjs
class Completions2 extends APIResource {
  create(body, options2) {
    return this.post("/completions", { body, ...options2, stream: body.stream ?? false });
  }
}
(function(Completions3) {
})(Completions2 || (Completions2 = {}));
// node_modules/openai/resources/embeddings.mjs
class Embeddings extends APIResource {
  create(body, options2) {
    return this.post("/embeddings", { body, ...options2 });
  }
}
(function(Embeddings2) {
})(Embeddings || (Embeddings = {}));
// node_modules/openai/resources/edits.mjs
class Edits extends APIResource {
  create(body, options2) {
    return this.post("/edits", { body, ...options2 });
  }
}
(function(Edits2) {
})(Edits || (Edits = {}));
// node_modules/openai/resources/files.mjs
class Files extends APIResource {
  create(body, options2) {
    return this.post("/files", multipartFormRequestOptions({ body, ...options2 }));
  }
  retrieve(fileId, options2) {
    return this.get(`/files/${fileId}`, options2);
  }
  list(options2) {
    return this.getAPIList("/files", FileObjectsPage, options2);
  }
  del(fileId, options2) {
    return this.delete(`/files/${fileId}`, options2);
  }
  retrieveContent(fileId, options2) {
    return this.get(`/files/${fileId}/content`, {
      ...options2,
      headers: { Accept: "application/json", ...options2?.headers }
    });
  }
  async waitForProcessing(id, { pollInterval = 5000, maxWait = 30 * 60 * 1000 } = {}) {
    const TERMINAL_STATES = new Set(["processed", "error", "deleted"]);
    const start = Date.now();
    let file = await this.retrieve(id);
    while (!file.status || !TERMINAL_STATES.has(file.status)) {
      await sleep(pollInterval);
      file = await this.retrieve(id);
      if (Date.now() - start > maxWait) {
        throw new APIConnectionTimeoutError({
          message: `Giving up on waiting for file ${id} to finish processing after ${maxWait} milliseconds.`
        });
      }
    }
    return file;
  }
}

class FileObjectsPage extends Page {
}
(function(Files2) {
  Files2.FileObjectsPage = FileObjectsPage;
})(Files || (Files = {}));
// node_modules/openai/resources/fine-tunes.mjs
class FineTunes extends APIResource {
  create(body, options2) {
    return this.post("/fine-tunes", { body, ...options2 });
  }
  retrieve(fineTuneId, options2) {
    return this.get(`/fine-tunes/${fineTuneId}`, options2);
  }
  list(options2) {
    return this.getAPIList("/fine-tunes", FineTunesPage, options2);
  }
  cancel(fineTuneId, options2) {
    return this.post(`/fine-tunes/${fineTuneId}/cancel`, options2);
  }
  listEvents(fineTuneId, query, options2) {
    return this.get(`/fine-tunes/${fineTuneId}/events`, {
      query,
      timeout: 86400000,
      ...options2,
      stream: query?.stream ?? false
    });
  }
}

class FineTunesPage extends Page {
}
(function(FineTunes2) {
  FineTunes2.FineTunesPage = FineTunesPage;
})(FineTunes || (FineTunes = {}));
// node_modules/openai/resources/fine-tuning/jobs.mjs
class Jobs extends APIResource {
  create(body, options2) {
    return this.post("/fine_tuning/jobs", { body, ...options2 });
  }
  retrieve(fineTuningJobId, options2) {
    return this.get(`/fine_tuning/jobs/${fineTuningJobId}`, options2);
  }
  list(query = {}, options2) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this.getAPIList("/fine_tuning/jobs", FineTuningJobsPage, { query, ...options2 });
  }
  cancel(fineTuningJobId, options2) {
    return this.post(`/fine_tuning/jobs/${fineTuningJobId}/cancel`, options2);
  }
  listEvents(fineTuningJobId, query = {}, options2) {
    if (isRequestOptions(query)) {
      return this.listEvents(fineTuningJobId, {}, query);
    }
    return this.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/events`, FineTuningJobEventsPage, {
      query,
      ...options2
    });
  }
}

class FineTuningJobsPage extends CursorPage {
}

class FineTuningJobEventsPage extends CursorPage {
}
(function(Jobs2) {
  Jobs2.FineTuningJobsPage = FineTuningJobsPage;
  Jobs2.FineTuningJobEventsPage = FineTuningJobEventsPage;
})(Jobs || (Jobs = {}));

// node_modules/openai/resources/fine-tuning/fine-tuning.mjs
class FineTuning extends APIResource {
  constructor() {
    super(...arguments);
    this.jobs = new Jobs(this.client);
  }
}
(function(FineTuning2) {
  FineTuning2.Jobs = Jobs;
  FineTuning2.FineTuningJobsPage = FineTuningJobsPage;
  FineTuning2.FineTuningJobEventsPage = FineTuningJobEventsPage;
})(FineTuning || (FineTuning = {}));
// node_modules/openai/resources/images.mjs
class Images extends APIResource {
  createVariation(body, options2) {
    return this.post("/images/variations", multipartFormRequestOptions({ body, ...options2 }));
  }
  edit(body, options2) {
    return this.post("/images/edits", multipartFormRequestOptions({ body, ...options2 }));
  }
  generate(body, options2) {
    return this.post("/images/generations", { body, ...options2 });
  }
}
(function(Images2) {
})(Images || (Images = {}));
// node_modules/openai/resources/models.mjs
class Models extends APIResource {
  retrieve(model, options2) {
    return this.get(`/models/${model}`, options2);
  }
  list(options2) {
    return this.getAPIList("/models", ModelsPage, options2);
  }
  del(model, options2) {
    return this.delete(`/models/${model}`, options2);
  }
}

class ModelsPage extends Page {
}
(function(Models2) {
  Models2.ModelsPage = ModelsPage;
})(Models || (Models = {}));
// node_modules/openai/resources/moderations.mjs
class Moderations extends APIResource {
  create(body, options2) {
    return this.post("/moderations", { body, ...options2 });
  }
}
(function(Moderations2) {
})(Moderations || (Moderations = {}));
// node_modules/openai/index.mjs
var _a;

class OpenAI extends APIClient {
  constructor({ apiKey = readEnv("OPENAI_API_KEY"), organization = readEnv("OPENAI_ORG_ID") ?? null, ...opts } = {}) {
    if (apiKey === undefined) {
      throw new OpenAIError("The OPENAI_API_KEY environment variable is missing or empty; either provide it, or instantiate the OpenAI client with an apiKey option, like new OpenAI({ apiKey: 'My API Key' }).");
    }
    const options2 = {
      apiKey,
      organization,
      ...opts,
      baseURL: opts.baseURL ?? `https://api.openai.com/v1`
    };
    if (!options2.dangerouslyAllowBrowser && isRunningInBrowser()) {
      throw new OpenAIError("It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\n\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\n");
    }
    super({
      baseURL: options2.baseURL,
      timeout: options2.timeout ?? 600000,
      httpAgent: options2.httpAgent,
      maxRetries: options2.maxRetries,
      fetch: options2.fetch
    });
    this.completions = new Completions2(this);
    this.chat = new Chat(this);
    this.edits = new Edits(this);
    this.embeddings = new Embeddings(this);
    this.files = new Files(this);
    this.images = new Images(this);
    this.audio = new Audio(this);
    this.moderations = new Moderations(this);
    this.models = new Models(this);
    this.fineTuning = new FineTuning(this);
    this.fineTunes = new FineTunes(this);
    this._options = options2;
    this.apiKey = apiKey;
    this.organization = organization;
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  defaultHeaders(opts) {
    return {
      ...super.defaultHeaders(opts),
      "OpenAI-Organization": this.organization,
      ...this._options.defaultHeaders
    };
  }
  authHeaders(opts) {
    return { Authorization: `Bearer ${this.apiKey}` };
  }
}
_a = OpenAI;
OpenAI.OpenAI = _a;
OpenAI.OpenAIError = OpenAIError;
OpenAI.APIError = APIError;
OpenAI.APIConnectionError = APIConnectionError;
OpenAI.APIConnectionTimeoutError = APIConnectionTimeoutError;
OpenAI.APIUserAbortError = APIUserAbortError;
OpenAI.NotFoundError = NotFoundError;
OpenAI.ConflictError = ConflictError;
OpenAI.RateLimitError = RateLimitError;
OpenAI.BadRequestError = BadRequestError;
OpenAI.AuthenticationError = AuthenticationError;
OpenAI.InternalServerError = InternalServerError;
OpenAI.PermissionDeniedError = PermissionDeniedError;
OpenAI.UnprocessableEntityError = UnprocessableEntityError;
(function(OpenAI2) {
  OpenAI2.toFile = toFile;
  OpenAI2.fileFromPath = fileFromPath;
  OpenAI2.Page = Page;
  OpenAI2.CursorPage = CursorPage;
  OpenAI2.Completions = Completions2;
  OpenAI2.Chat = Chat;
  OpenAI2.Edits = Edits;
  OpenAI2.Embeddings = Embeddings;
  OpenAI2.Files = Files;
  OpenAI2.FileObjectsPage = FileObjectsPage;
  OpenAI2.Images = Images;
  OpenAI2.Audio = Audio;
  OpenAI2.Moderations = Moderations;
  OpenAI2.Models = Models;
  OpenAI2.ModelsPage = ModelsPage;
  OpenAI2.FineTuning = FineTuning;
  OpenAI2.FineTunes = FineTunes;
  OpenAI2.FineTunesPage = FineTunesPage;
})(OpenAI || (OpenAI = {}));
var openai_default = OpenAI;

// src/api.ts
var openai = new openai_default({
  apiKey: process.env.OPEN_AI_API_TOKEN
});
var prompt = (command, error5) => `
  You're a programmer.
  You just encounter this ${error5} running this ${command}.
  Can you debug it to the best of your abilities?
  Be concise in your response. Return a command you think may fix it as a code snippet.
  If you can not, return "I can not debug this" as your response.
  If the command you return is a valid command and executable (does not need any additional information from the user) in shell return true in the json response as a boolean.
  Always return your response as json. In this fomat {"message": "<your response>", snippet: "<code snippet>", "commandExecutable": "<true or false>" }
  Omit anything but the json from your response.
`;
var openAiApi = {
  debug: async (command, error5) => {
    let chat2 = await openai.chat.completions.create({
      model: "gpt-4",
      messages: [{ role: "user", content: prompt(command, error5) }]
    });
    return { response: chat2.choices[0].message.content };
  }
};

// src/index.ts
var import_lodash = __toESM(require_lodash(), 1);

// node_modules/commander/esm.mjs
var import_ = __toESM(require_commander(), 1);
var {
  program,
  createCommand,
  createArgument,
  createOption,
  CommanderError,
  InvalidArgumentError,
  InvalidOptionArgumentError,
  Command,
  Argument,
  Option,
  Help
} = import_.default;

// node_modules/chalk/source/vendor/ansi-styles/index.js
var assembleStyles = function() {
  const codes = new Map;
  for (const [groupName, group] of Object.entries(styles)) {
    for (const [styleName, style] of Object.entries(group)) {
      styles[styleName] = {
        open: `\x1B[${style[0]}m`,
        close: `\x1B[${style[1]}m`
      };
      group[styleName] = styles[styleName];
      codes.set(style[0], style[1]);
    }
    Object.defineProperty(styles, groupName, {
      value: group,
      enumerable: false
    });
  }
  Object.defineProperty(styles, "codes", {
    value: codes,
    enumerable: false
  });
  styles.color.close = "\x1B[39m";
  styles.bgColor.close = "\x1B[49m";
  styles.color.ansi = wrapAnsi16();
  styles.color.ansi256 = wrapAnsi256();
  styles.color.ansi16m = wrapAnsi16m();
  styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
  Object.defineProperties(styles, {
    rgbToAnsi256: {
      value(red, green, blue) {
        if (red === green && green === blue) {
          if (red < 8) {
            return 16;
          }
          if (red > 248) {
            return 231;
          }
          return Math.round((red - 8) / 247 * 24) + 232;
        }
        return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
      },
      enumerable: false
    },
    hexToRgb: {
      value(hex) {
        const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
        if (!matches) {
          return [0, 0, 0];
        }
        let [colorString] = matches;
        if (colorString.length === 3) {
          colorString = [...colorString].map((character) => character + character).join("");
        }
        const integer = Number.parseInt(colorString, 16);
        return [
          integer >> 16 & 255,
          integer >> 8 & 255,
          integer & 255
        ];
      },
      enumerable: false
    },
    hexToAnsi256: {
      value: (hex) => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
      enumerable: false
    },
    ansi256ToAnsi: {
      value(code) {
        if (code < 8) {
          return 30 + code;
        }
        if (code < 16) {
          return 90 + (code - 8);
        }
        let red;
        let green;
        let blue;
        if (code >= 232) {
          red = ((code - 232) * 10 + 8) / 255;
          green = red;
          blue = red;
        } else {
          code -= 16;
          const remainder = code % 36;
          red = Math.floor(code / 36) / 5;
          green = Math.floor(remainder / 6) / 5;
          blue = remainder % 6 / 5;
        }
        const value = Math.max(red, green, blue) * 2;
        if (value === 0) {
          return 30;
        }
        let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
        if (value === 2) {
          result += 60;
        }
        return result;
      },
      enumerable: false
    },
    rgbToAnsi: {
      value: (red, green, blue) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
      enumerable: false
    },
    hexToAnsi: {
      value: (hex) => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
      enumerable: false
    }
  });
  return styles;
};
var ANSI_BACKGROUND_OFFSET = 10;
var wrapAnsi16 = (offset = 0) => (code) => `\x1B[${code + offset}m`;
var wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`;
var wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`;
var styles = {
  modifier: {
    reset: [0, 0],
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    blackBright: [90, 39],
    gray: [90, 39],
    grey: [90, 39],
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    bgGrey: [100, 49],
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
};
var modifierNames = Object.keys(styles.modifier);
var foregroundColorNames = Object.keys(styles.color);
var backgroundColorNames = Object.keys(styles.bgColor);
var colorNames = [...foregroundColorNames, ...backgroundColorNames];
var ansiStyles = assembleStyles();
var ansi_styles_default = ansiStyles;

// node_modules/chalk/source/vendor/supports-color/index.js
import process2 from "node:process";
import os from "node:os";
import tty from "node:tty";
var hasFlag = function(flag, argv = globalThis.Deno ? globalThis.Deno.args : process2.argv) {
  const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
  const position = argv.indexOf(prefix + flag);
  const terminatorPosition = argv.indexOf("--");
  return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};
var envForceColor = function() {
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      return 1;
    }
    if (env.FORCE_COLOR === "false") {
      return 0;
    }
    return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
  }
};
var translateLevel = function(level) {
  if (level === 0) {
    return false;
  }
  return {
    level,
    hasBasic: true,
    has256: level >= 2,
    has16m: level >= 3
  };
};
var _supportsColor = function(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
  const noFlagForceColor = envForceColor();
  if (noFlagForceColor !== undefined) {
    flagForceColor = noFlagForceColor;
  }
  const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
  if (forceColor === 0) {
    return 0;
  }
  if (sniffFlags) {
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
  }
  if (("TF_BUILD" in env) && ("AGENT_NAME" in env)) {
    return 1;
  }
  if (haveStream && !streamIsTTY && forceColor === undefined) {
    return 0;
  }
  const min = forceColor || 0;
  if (env.TERM === "dumb") {
    return min;
  }
  if (process2.platform === "win32") {
    const osRelease = os.release().split(".");
    if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
      return Number(osRelease[2]) >= 14931 ? 3 : 2;
    }
    return 1;
  }
  if ("CI" in env) {
    if (("GITHUB_ACTIONS" in env) || ("GITEA_ACTIONS" in env)) {
      return 3;
    }
    if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some((sign) => (sign in env)) || env.CI_NAME === "codeship") {
      return 1;
    }
    return min;
  }
  if ("TEAMCITY_VERSION" in env) {
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
  }
  if (env.COLORTERM === "truecolor") {
    return 3;
  }
  if (env.TERM === "xterm-kitty") {
    return 3;
  }
  if ("TERM_PROGRAM" in env) {
    const version2 = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (env.TERM_PROGRAM) {
      case "iTerm.app": {
        return version2 >= 3 ? 3 : 2;
      }
      case "Apple_Terminal": {
        return 2;
      }
    }
  }
  if (/-256(color)?$/i.test(env.TERM)) {
    return 2;
  }
  if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
    return 1;
  }
  if ("COLORTERM" in env) {
    return 1;
  }
  return min;
};
function createSupportsColor(stream, options2 = {}) {
  const level = _supportsColor(stream, {
    streamIsTTY: stream && stream.isTTY,
    ...options2
  });
  return translateLevel(level);
}
var { env } = process2;
var flagForceColor;
if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
  flagForceColor = 0;
} else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
  flagForceColor = 1;
}
var supportsColor = {
  stdout: createSupportsColor({ isTTY: tty.isatty(1) }),
  stderr: createSupportsColor({ isTTY: tty.isatty(2) })
};
var supports_color_default = supportsColor;

// node_modules/chalk/source/utilities.js
function stringReplaceAll(string, substring, replacer) {
  let index = string.indexOf(substring);
  if (index === -1) {
    return string;
  }
  const substringLength = substring.length;
  let endIndex = 0;
  let returnValue = "";
  do {
    returnValue += string.slice(endIndex, index) + substring + replacer;
    endIndex = index + substringLength;
    index = string.indexOf(substring, endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}
function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
  let endIndex = 0;
  let returnValue = "";
  do {
    const gotCR = string[index - 1] === "\r";
    returnValue += string.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
    endIndex = index + 1;
    index = string.indexOf("\n", endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}

// node_modules/chalk/source/index.js
var createChalk = function(options2) {
  return chalkFactory(options2);
};
var { stdout: stdoutColor, stderr: stderrColor } = supports_color_default;
var GENERATOR = Symbol("GENERATOR");
var STYLER = Symbol("STYLER");
var IS_EMPTY = Symbol("IS_EMPTY");
var levelMapping = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
];
var styles2 = Object.create(null);
var applyOptions = (object, options2 = {}) => {
  if (options2.level && !(Number.isInteger(options2.level) && options2.level >= 0 && options2.level <= 3)) {
    throw new Error("The `level` option should be an integer from 0 to 3");
  }
  const colorLevel = stdoutColor ? stdoutColor.level : 0;
  object.level = options2.level === undefined ? colorLevel : options2.level;
};
var chalkFactory = (options2) => {
  const chalk = (...strings) => strings.join(" ");
  applyOptions(chalk, options2);
  Object.setPrototypeOf(chalk, createChalk.prototype);
  return chalk;
};
Object.setPrototypeOf(createChalk.prototype, Function.prototype);
for (const [styleName, style] of Object.entries(ansi_styles_default)) {
  styles2[styleName] = {
    get() {
      const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
      Object.defineProperty(this, styleName, { value: builder });
      return builder;
    }
  };
}
styles2.visible = {
  get() {
    const builder = createBuilder(this, this[STYLER], true);
    Object.defineProperty(this, "visible", { value: builder });
    return builder;
  }
};
var getModelAnsi = (model, level, type, ...arguments_) => {
  if (model === "rgb") {
    if (level === "ansi16m") {
      return ansi_styles_default[type].ansi16m(...arguments_);
    }
    if (level === "ansi256") {
      return ansi_styles_default[type].ansi256(ansi_styles_default.rgbToAnsi256(...arguments_));
    }
    return ansi_styles_default[type].ansi(ansi_styles_default.rgbToAnsi(...arguments_));
  }
  if (model === "hex") {
    return getModelAnsi("rgb", level, type, ...ansi_styles_default.hexToRgb(...arguments_));
  }
  return ansi_styles_default[type][model](...arguments_);
};
var usedModels = ["rgb", "hex", "ansi256"];
for (const model of usedModels) {
  styles2[model] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level], "color", ...arguments_), ansi_styles_default.color.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
  const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
  styles2[bgModel] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level], "bgColor", ...arguments_), ansi_styles_default.bgColor.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
}
var proto = Object.defineProperties(() => {
}, {
  ...styles2,
  level: {
    enumerable: true,
    get() {
      return this[GENERATOR].level;
    },
    set(level) {
      this[GENERATOR].level = level;
    }
  }
});
var createStyler = (open, close, parent) => {
  let openAll;
  let closeAll;
  if (parent === undefined) {
    openAll = open;
    closeAll = close;
  } else {
    openAll = parent.openAll + open;
    closeAll = close + parent.closeAll;
  }
  return {
    open,
    close,
    openAll,
    closeAll,
    parent
  };
};
var createBuilder = (self2, _styler, _isEmpty) => {
  const builder = (...arguments_) => applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
  Object.setPrototypeOf(builder, proto);
  builder[GENERATOR] = self2;
  builder[STYLER] = _styler;
  builder[IS_EMPTY] = _isEmpty;
  return builder;
};
var applyStyle = (self2, string) => {
  if (self2.level <= 0 || !string) {
    return self2[IS_EMPTY] ? "" : string;
  }
  let styler = self2[STYLER];
  if (styler === undefined) {
    return string;
  }
  const { openAll, closeAll } = styler;
  if (string.includes("\x1B")) {
    while (styler !== undefined) {
      string = stringReplaceAll(string, styler.close, styler.open);
      styler = styler.parent;
    }
  }
  const lfIndex = string.indexOf("\n");
  if (lfIndex !== -1) {
    string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
  }
  return openAll + string + closeAll;
};
Object.defineProperties(createChalk.prototype, styles2);
var chalk = createChalk();
var chalkStderr = createChalk({ level: stderrColor ? stderrColor.level : 0 });
var source_default = chalk;

// node_modules/marked-terminal/index.js
var import_cli_table3 = __toESM(require_table(), 1);
var import_cardinal = __toESM(require_cardinal(), 1);

// node_modules/node-emoji/lib/index.js
var import_emojilib = __toESM(require_emojilib(), 1);
var import_char_regex = __toESM(require_char_regex(), 1);
var normalizeCode = function(code) {
  return code.replace(nonSpacingRegex, "");
};
var normalizeName = function(name) {
  return /:.+:/.test(name) ? name.slice(1, -1) : name;
};
var is = __toESM(require_dist(), 1);
var import_skin_tone = __toESM(require_skin_tone(), 1);
var charRegexMatcher = import_char_regex.default();
var NON_SPACING_MARK = String.fromCharCode(65039);
var nonSpacingRegex = new RegExp(NON_SPACING_MARK, "g");
var emojiData = Object.entries(import_emojilib.default.lib).map(([name, { char: emoji }]) => [name, emoji]);
var emojiCodesByName = new Map(emojiData);
var emojiNamesByCode = new Map(emojiData.map(([name, emoji]) => [normalizeCode(emoji), name]));
var get = (codeOrName) => {
  is.assert.string(codeOrName);
  return emojiCodesByName.get(normalizeName(codeOrName));
};

// node_modules/ansi-escapes/index.js
import process3 from "node:process";
var ESC = "\x1B[";
var OSC = "\x1B]";
var BEL = "\x07";
var SEP = ";";
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
var isTerminalApp = !isBrowser && process3.env.TERM_PROGRAM === "Apple_Terminal";
var isWindows = !isBrowser && process3.platform === "win32";
var cwdFunction = isBrowser ? () => {
  throw new Error("`process.cwd()` only works in Node.js, not the browser.");
} : process3.cwd;
var ansiEscapes = {};
ansiEscapes.cursorTo = (x2, y2) => {
  if (typeof x2 !== "number") {
    throw new TypeError("The `x` argument is required");
  }
  if (typeof y2 !== "number") {
    return ESC + (x2 + 1) + "G";
  }
  return ESC + (y2 + 1) + SEP + (x2 + 1) + "H";
};
ansiEscapes.cursorMove = (x2, y2) => {
  if (typeof x2 !== "number") {
    throw new TypeError("The `x` argument is required");
  }
  let returnValue = "";
  if (x2 < 0) {
    returnValue += ESC + -x2 + "D";
  } else if (x2 > 0) {
    returnValue += ESC + x2 + "C";
  }
  if (y2 < 0) {
    returnValue += ESC + -y2 + "A";
  } else if (y2 > 0) {
    returnValue += ESC + y2 + "B";
  }
  return returnValue;
};
ansiEscapes.cursorUp = (count = 1) => ESC + count + "A";
ansiEscapes.cursorDown = (count = 1) => ESC + count + "B";
ansiEscapes.cursorForward = (count = 1) => ESC + count + "C";
ansiEscapes.cursorBackward = (count = 1) => ESC + count + "D";
ansiEscapes.cursorLeft = ESC + "G";
ansiEscapes.cursorSavePosition = isTerminalApp ? "\x1B7" : ESC + "s";
ansiEscapes.cursorRestorePosition = isTerminalApp ? "\x1B8" : ESC + "u";
ansiEscapes.cursorGetPosition = ESC + "6n";
ansiEscapes.cursorNextLine = ESC + "E";
ansiEscapes.cursorPrevLine = ESC + "F";
ansiEscapes.cursorHide = ESC + "?25l";
ansiEscapes.cursorShow = ESC + "?25h";
ansiEscapes.eraseLines = (count) => {
  let clear = "";
  for (let i2 = 0;i2 < count; i2++) {
    clear += ansiEscapes.eraseLine + (i2 < count - 1 ? ansiEscapes.cursorUp() : "");
  }
  if (count) {
    clear += ansiEscapes.cursorLeft;
  }
  return clear;
};
ansiEscapes.eraseEndLine = ESC + "K";
ansiEscapes.eraseStartLine = ESC + "1K";
ansiEscapes.eraseLine = ESC + "2K";
ansiEscapes.eraseDown = ESC + "J";
ansiEscapes.eraseUp = ESC + "1J";
ansiEscapes.eraseScreen = ESC + "2J";
ansiEscapes.scrollUp = ESC + "S";
ansiEscapes.scrollDown = ESC + "T";
ansiEscapes.clearScreen = "\x1Bc";
ansiEscapes.clearTerminal = isWindows ? `${ansiEscapes.eraseScreen}${ESC}0f` : `${ansiEscapes.eraseScreen}${ESC}3J${ESC}H`;
ansiEscapes.enterAlternativeScreen = ESC + "?1049h";
ansiEscapes.exitAlternativeScreen = ESC + "?1049l";
ansiEscapes.beep = BEL;
ansiEscapes.link = (text, url) => [
  OSC,
  "8",
  SEP,
  SEP,
  url,
  BEL,
  text,
  OSC,
  "8",
  SEP,
  SEP,
  BEL
].join("");
ansiEscapes.image = (buffer, options2 = {}) => {
  let returnValue = `${OSC}1337;File=inline=1`;
  if (options2.width) {
    returnValue += `;width=${options2.width}`;
  }
  if (options2.height) {
    returnValue += `;height=${options2.height}`;
  }
  if (options2.preserveAspectRatio === false) {
    returnValue += ";preserveAspectRatio=0";
  }
  return returnValue + ":" + buffer.toString("base64") + BEL;
};
ansiEscapes.iTerm = {
  setCwd: (cwd = cwdFunction()) => `${OSC}50;CurrentDir=${cwd}${BEL}`,
  annotation(message, options2 = {}) {
    let returnValue = `${OSC}1337;`;
    const hasX = typeof options2.x !== "undefined";
    const hasY = typeof options2.y !== "undefined";
    if ((hasX || hasY) && !(hasX && hasY && typeof options2.length !== "undefined")) {
      throw new Error("`x`, `y` and `length` must be defined when `x` or `y` is defined");
    }
    message = message.replace(/\|/g, "");
    returnValue += options2.isHidden ? "AddHiddenAnnotation=" : "AddAnnotation=";
    if (options2.length > 0) {
      returnValue += (hasX ? [message, options2.length, options2.x, options2.y] : [options2.length, message]).join("|");
    } else {
      returnValue += message;
    }
    return returnValue + BEL;
  }
};
var ansi_escapes_default = ansiEscapes;

// node_modules/marked-terminal/index.js
var import_supports_hyperlinks = __toESM(require_supports_hyperlinks(), 1);
var Renderer = function(options2, highlightOptions) {
  this.o = Object.assign({}, defaultOptions2, options2);
  this.tab = sanitizeTab(this.o.tab, defaultOptions2.tab);
  this.tableSettings = this.o.tableOptions;
  this.emoji = this.o.emoji ? insertEmojis : identity;
  this.unescape = this.o.unescape ? unescapeEntities : identity;
  this.highlightOptions = highlightOptions || {};
  this.transform = compose(undoColon, this.unescape, this.emoji);
};
var textLength = function(str) {
  return str.replace(/\u001b\[(?:\d{1,3})(?:;\d{1,3})*m/g, "").length;
};
var fixHardReturn = function(text, reflow) {
  return reflow ? text.replace(HARD_RETURN, /\n/g) : text;
};
function markedTerminal(options2, highlightOptions) {
  const r2 = new Renderer(options2, highlightOptions);
  const funcs = [
    "text",
    "code",
    "blockquote",
    "html",
    "heading",
    "hr",
    "list",
    "listitem",
    "checkbox",
    "paragraph",
    "table",
    "tablerow",
    "tablecell",
    "strong",
    "em",
    "codespan",
    "br",
    "del",
    "link",
    "image"
  ];
  return funcs.reduce((extension, func) => {
    extension.renderer[func] = function(...args) {
      r2.options = this.options;
      return r2[func](...args);
    };
    return extension;
  }, { renderer: {} });
}
var reflowText = function(text, width, gfm) {
  var splitRe = gfm ? HARD_RETURN_GFM_RE : HARD_RETURN_RE, sections = text.split(splitRe), reflowed = [];
  sections.forEach(function(section) {
    var fragments = section.split(/(\u001b\[(?:\d{1,3})(?:;\d{1,3})*m)/g);
    var column = 0;
    var currentLine = "";
    var lastWasEscapeChar = false;
    while (fragments.length) {
      var fragment = fragments[0];
      if (fragment === "") {
        fragments.splice(0, 1);
        lastWasEscapeChar = false;
        continue;
      }
      if (!textLength(fragment)) {
        currentLine += fragment;
        fragments.splice(0, 1);
        lastWasEscapeChar = true;
        continue;
      }
      var words = fragment.split(/[ \t\n]+/);
      for (var i2 = 0;i2 < words.length; i2++) {
        var word = words[i2];
        var addSpace = column != 0;
        if (lastWasEscapeChar)
          addSpace = false;
        if (column + word.length + addSpace > width) {
          if (word.length <= width) {
            reflowed.push(currentLine);
            currentLine = word;
            column = word.length;
          } else {
            var w2 = word.substr(0, width - column - addSpace);
            if (addSpace)
              currentLine += " ";
            currentLine += w2;
            reflowed.push(currentLine);
            currentLine = "";
            column = 0;
            word = word.substr(w2.length);
            while (word.length) {
              var w2 = word.substr(0, width);
              if (!w2.length)
                break;
              if (w2.length < width) {
                currentLine = w2;
                column = w2.length;
                break;
              } else {
                reflowed.push(w2);
                word = word.substr(width);
              }
            }
          }
        } else {
          if (addSpace) {
            currentLine += " ";
            column++;
          }
          currentLine += word;
          column += word.length;
        }
        lastWasEscapeChar = false;
      }
      fragments.splice(0, 1);
    }
    if (textLength(currentLine))
      reflowed.push(currentLine);
  });
  return reflowed.join("\n");
};
var indentLines = function(indent, text) {
  return text.replace(/(^|\n)(.+)/g, "$1" + indent + "$2");
};
var indentify = function(indent, text) {
  if (!text)
    return text;
  return indent + text.split("\n").join("\n" + indent);
};
var fixNestedLists = function(body, indent) {
  var regex = new RegExp("(\\S(?: |  )?)((?:" + indent + ")+)(" + POINT_REGEX + "(?:.*)+)$", "gm");
  return body.replace(regex, "$1\n" + indent + "$2$3");
};
var toSpaces = function(str) {
  return " ".repeat(str.length);
};
var bulletPointLine = function(indent, line) {
  return isPointedLine(line, indent) ? line : toSpaces(BULLET_POINT) + line;
};
var bulletPointLines = function(lines, indent) {
  var transform = bulletPointLine.bind(null, indent);
  return lines.split("\n").filter(identity).map(transform).join("\n");
};
var numberedLine = function(indent, line, num) {
  return isPointedLine(line, indent) ? {
    num: num + 1,
    line: line.replace(BULLET_POINT, numberedPoint(num + 1))
  } : {
    num,
    line: toSpaces(numberedPoint(num)) + line
  };
};
var numberedLines = function(lines, indent) {
  var transform = numberedLine.bind(null, indent);
  let num = 0;
  return lines.split("\n").filter(identity).map((line) => {
    const numbered = transform(line, num);
    num = numbered.num;
    return numbered.line;
  }).join("\n");
};
var list = function(body, ordered, indent) {
  body = body.trim();
  body = ordered ? numberedLines(body, indent) : bulletPointLines(body, indent);
  return body;
};
var section = function(text) {
  return text + "\n\n";
};
var highlight = function(code, lang, opts, hightlightOpts) {
  if (source_default.level === 0)
    return code;
  var style = opts.code;
  code = fixHardReturn(code, opts.reflowText);
  if (lang !== "javascript" && lang !== "js") {
    return style(code);
  }
  try {
    return import_cardinal.default.highlight(code, hightlightOpts);
  } catch (e2) {
    return style(code);
  }
};
var insertEmojis = function(text) {
  return text.replace(/:([A-Za-z0-9_\-\+]+?):/g, function(emojiString) {
    var emojiSign = get(emojiString);
    if (!emojiSign)
      return emojiString;
    return emojiSign + " ";
  });
};
var hr2 = function(inputHrStr, length) {
  length = length || process.stdout.columns;
  return new Array(length).join(inputHrStr);
};
var undoColon = function(str) {
  return str.replace(COLON_REPLACER_REGEXP, ":");
};
var generateTableRow = function(text, escape2) {
  if (!text)
    return [];
  escape2 = escape2 || identity;
  var lines = escape2(text).split("\n");
  var data = [];
  lines.forEach(function(line) {
    if (!line)
      return;
    var parsed = line.replace(TABLE_ROW_WRAP_REGEXP, "").split(TABLE_CELL_SPLIT);
    data.push(parsed.splice(0, parsed.length - 1));
  });
  return data;
};
var escapeRegExp = function(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
};
var unescapeEntities = function(html) {
  return html.replace(/&amp;/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/&#39;/g, "'");
};
var identity = function(str) {
  return str;
};
var compose = function() {
  var funcs = arguments;
  return function() {
    var args = arguments;
    for (var i2 = funcs.length;i2-- > 0; ) {
      args = [funcs[i2].apply(this, args)];
    }
    return args[0];
  };
};
var isAllowedTabString = function(string) {
  return TAB_ALLOWED_CHARACTERS.some(function(char) {
    return string.match("^(" + char + ")+$");
  });
};
var sanitizeTab = function(tab, fallbackTab) {
  if (typeof tab === "number") {
    return new Array(tab + 1).join(" ");
  } else if (typeof tab === "string" && isAllowedTabString(tab)) {
    return tab;
  } else {
    return new Array(fallbackTab + 1).join(" ");
  }
};
var TABLE_CELL_SPLIT = "^*||*^";
var TABLE_ROW_WRAP = "*|*|*|*";
var TABLE_ROW_WRAP_REGEXP = new RegExp(escapeRegExp(TABLE_ROW_WRAP), "g");
var COLON_REPLACER = "*#COLON|*";
var COLON_REPLACER_REGEXP = new RegExp(escapeRegExp(COLON_REPLACER), "g");
var TAB_ALLOWED_CHARACTERS = ["\t"];
var HARD_RETURN = "\r";
var HARD_RETURN_RE = new RegExp(HARD_RETURN);
var HARD_RETURN_GFM_RE = new RegExp(HARD_RETURN + "|<br />");
var defaultOptions2 = {
  code: source_default.yellow,
  blockquote: source_default.gray.italic,
  html: source_default.gray,
  heading: source_default.green.bold,
  firstHeading: source_default.magenta.underline.bold,
  hr: source_default.reset,
  listitem: source_default.reset,
  list,
  table: source_default.reset,
  paragraph: source_default.reset,
  strong: source_default.bold,
  em: source_default.italic,
  codespan: source_default.yellow,
  del: source_default.dim.gray.strikethrough,
  link: source_default.blue,
  href: source_default.blue.underline,
  text: identity,
  unescape: true,
  emoji: true,
  width: 80,
  showSectionPrefix: true,
  reflowText: false,
  tab: 4,
  tableOptions: {}
};
Renderer.prototype.textLength = textLength;
Renderer.prototype.text = function(text) {
  return this.o.text(text);
};
Renderer.prototype.code = function(code, lang, escaped) {
  return section(indentify(this.tab, highlight(code, lang, this.o, this.highlightOptions)));
};
Renderer.prototype.blockquote = function(quote) {
  return section(this.o.blockquote(indentify(this.tab, quote.trim())));
};
Renderer.prototype.html = function(html) {
  return this.o.html(html);
};
Renderer.prototype.heading = function(text, level, raw) {
  text = this.transform(text);
  var prefix = this.o.showSectionPrefix ? new Array(level + 1).join("#") + " " : "";
  text = prefix + text;
  if (this.o.reflowText) {
    text = reflowText(text, this.o.width, this.options.gfm);
  }
  return section(level === 1 ? this.o.firstHeading(text) : this.o.heading(text));
};
Renderer.prototype.hr = function() {
  return section(this.o.hr(hr2("-", this.o.reflowText && this.o.width)));
};
Renderer.prototype.list = function(body, ordered) {
  body = this.o.list(body, ordered, this.tab);
  return section(fixNestedLists(indentLines(this.tab, body), this.tab));
};
Renderer.prototype.listitem = function(text) {
  var transform = compose(this.o.listitem, this.transform);
  var isNested = text.indexOf("\n") !== -1;
  if (isNested)
    text = text.trim();
  return "\n" + BULLET_POINT + transform(text);
};
Renderer.prototype.checkbox = function(checked) {
  return "[" + (checked ? "X" : " ") + "] ";
};
Renderer.prototype.paragraph = function(text) {
  var transform = compose(this.o.paragraph, this.transform);
  text = transform(text);
  if (this.o.reflowText) {
    text = reflowText(text, this.o.width, this.options.gfm);
  }
  return section(text);
};
Renderer.prototype.table = function(header, body) {
  var table = new import_cli_table3.default(Object.assign({}, {
    head: generateTableRow(header)[0]
  }, this.tableSettings));
  generateTableRow(body, this.transform).forEach(function(row) {
    table.push(row);
  });
  return section(this.o.table(table.toString()));
};
Renderer.prototype.tablerow = function(content) {
  return TABLE_ROW_WRAP + content + TABLE_ROW_WRAP + "\n";
};
Renderer.prototype.tablecell = function(content, flags) {
  return content + TABLE_CELL_SPLIT;
};
Renderer.prototype.strong = function(text) {
  return this.o.strong(text);
};
Renderer.prototype.em = function(text) {
  text = fixHardReturn(text, this.o.reflowText);
  return this.o.em(text);
};
Renderer.prototype.codespan = function(text) {
  text = fixHardReturn(text, this.o.reflowText);
  return this.o.codespan(text.replace(/:/g, COLON_REPLACER));
};
Renderer.prototype.br = function() {
  return this.o.reflowText ? HARD_RETURN : "\n";
};
Renderer.prototype.del = function(text) {
  return this.o.del(text);
};
Renderer.prototype.link = function(href, title, text) {
  if (this.options.sanitize) {
    try {
      var prot = decodeURIComponent(unescape(href)).replace(/[^\w:]/g, "").toLowerCase();
    } catch (e2) {
      return "";
    }
    if (prot.indexOf("javascript:") === 0) {
      return "";
    }
  }
  var hasText = text && text !== href;
  var out = "";
  if (import_supports_hyperlinks.default.stdout) {
    let link = "";
    if (text) {
      link = this.o.href(this.emoji(text));
    } else {
      link = this.o.href(href);
    }
    out = ansi_escapes_default.link(link, href);
  } else {
    if (hasText)
      out += this.emoji(text) + " (";
    out += this.o.href(href);
    if (hasText)
      out += ")";
  }
  return this.o.link(out);
};
Renderer.prototype.image = function(href, title, text) {
  if (typeof this.o.image === "function") {
    return this.o.image(href, title, text);
  }
  var out = "![" + text;
  if (title)
    out += " \u2013 " + title;
  return out + "](" + href + ")\n";
};
var BULLET_POINT_REGEX = "\\*";
var NUMBERED_POINT_REGEX = "\\d+\\.";
var POINT_REGEX = "(?:" + [BULLET_POINT_REGEX, NUMBERED_POINT_REGEX].join("|") + ")";
var isPointedLine = function(line, indent) {
  return line.match("^(?:" + indent + ")*" + POINT_REGEX);
};
var BULLET_POINT = "* ";
var numberedPoint = function(n2) {
  return n2 + ". ";
};

// src/index.ts
marked.use(markedTerminal());
program.option("--debug");
program.parse();
var options2 = program.opts();
var chat2;
var answer;
var executable;
var commandResult;
import_node_cmd.default.runSync("chmod 777./scripts/last_command.sh");
var command = import_node_cmd.default.runSync("sh ./scripts/last_command.sh").data.trim();
var lastCommdQuestion = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});
lastCommdQuestion.question(marked.parse(`The last command was: **${command}**. \n\n ## Are you sure that is the one you want to debug? (Y/n)`), async (debug2) => {
  lastCommdQuestion.close();
  if (debug2 !== "Y") {
    console.log(marked.parse(`# Exiting debugger..`));
  }
  if (debug2 == "Y") {
    console.log(marked.parse(`Debugging **${command}**`));
    commandResult = import_node_cmd.default.runSync(`${command}`);
    if (commandResult.stderr || commandResult.err) {
      chat2 = await openAiApi.debug(command, commandResult.stderr);
      answer = JSON.parse(chat2.response);
      executable = answer.commandExecutable;
      console.log(marked.parse(`# Debugger's response: \n\n ${answer.message}`));
      console.log(marked.parse(`# Code snippet: \n\n ${answer.snippet}`));
    }
    if (import_lodash.isEmpty(commandResult) || import_lodash.isEmpty(commandResult.stderr) && import_lodash.isEmpty(commandResult.err)) {
      console.log(`Did not encounter an error running ${command}. This is the output\n\n`, commandResult.data);
    }
  }
  if (executable == true || executable == "true") {
    const executeQuestion = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });
    executeQuestion.question(marked.parse(`Debugger marked **${answer.snippet}** as executable. Do you want to run it? (Y/n)`), async (commandAnswer) => {
      executeQuestion.close();
      if (commandAnswer == "Y") {
        commandResult = import_node_cmd.default.runSync(`${answer.snippet}`);
        console.log(marked.parse(`# Running command: \n\n ${answer.snippet}`));
        if (commandResult.stderr || commandResult.err) {
          console.log(marked.parse(`# Encounterd error when running command: \n\n ${commandResult.stderr}`));
        }
        if (import_lodash.isEmpty(commandResult) || import_lodash.isEmpty(commandResult.stderr) && import_lodash.isEmpty(commandResult.err)) {
          console.log(marked.parse(`# Command output: \n\n ${commandResult.data}`));
        }
        if (commandResult.data) {
          console.log(marked.parse(`# Command output: \n\n ${commandResult.data}`));
        }
      }
    });
  }
});
